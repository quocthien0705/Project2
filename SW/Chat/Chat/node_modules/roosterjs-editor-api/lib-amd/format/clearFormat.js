define(["require", "exports", "tslib", "../utils/applyListItemWrap", "../utils/blockFormat", "../utils/execCommand", "../utils/formatUndoSnapshot", "./setBackgroundColor", "./setFontName", "./setFontSize", "./setTextColor", "./toggleBold", "./toggleItalic", "./toggleUnderline", "roosterjs-editor-dom"], function (require, exports, tslib_1, applyListItemWrap_1, blockFormat_1, execCommand_1, formatUndoSnapshot_1, setBackgroundColor_1, setFontName_1, setFontSize_1, setTextColor_1, toggleBold_1, toggleItalic_1, toggleUnderline_1, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];
    var TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(',');
    var ATTRIBUTES_TO_PRESERVE = ['href', 'src', 'cellpadding', 'cellspacing'];
    var TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];
    /**
     * @param editor The editor instance
     * @returns if the current selection is composed of two or more block elements
     */
    function isMultiBlockSelection(editor) {
        var transverser = editor.getSelectionTraverser();
        var blockElement = transverser === null || transverser === void 0 ? void 0 : transverser.currentBlockElement;
        if (!blockElement) {
            return false;
        }
        var nextBlockElement = transverser === null || transverser === void 0 ? void 0 : transverser.getNextBlockElement();
        //At least two blocks are selected
        return !!nextBlockElement;
    }
    function clearNodeFormat(node) {
        // 1. Recursively clear format of all its child nodes
        var areBlockElements = (0, roosterjs_editor_dom_1.toArray)(node.childNodes).map(clearNodeFormat);
        var areAllChildrenBlock = areBlockElements.every(function (b) { return b; });
        var returnBlockElement = (0, roosterjs_editor_dom_1.isBlockElement)(node);
        // 2. Unwrap the tag if necessary
        var tag = (0, roosterjs_editor_dom_1.getTagOfNode)(node);
        if (tag) {
            if (TAGS_TO_UNWRAP.indexOf(tag) >= 0 ||
                (areAllChildrenBlock &&
                    !(0, roosterjs_editor_dom_1.isVoidHtmlElement)(node) &&
                    TAGS_TO_STOP_UNWRAP.indexOf(tag) < 0)) {
                if (returnBlockElement && !areAllChildrenBlock) {
                    (0, roosterjs_editor_dom_1.wrap)(node);
                }
                (0, roosterjs_editor_dom_1.unwrap)(node);
            }
            else {
                // 3. Otherwise, remove all attributes
                clearAttribute(node);
            }
        }
        return returnBlockElement;
    }
    function clearAttribute(element) {
        var e_1, _a;
        var isTableCell = (0, roosterjs_editor_dom_1.safeInstanceOf)(element, 'HTMLTableCellElement');
        var isTable = (0, roosterjs_editor_dom_1.safeInstanceOf)(element, 'HTMLTableElement');
        try {
            for (var _b = (0, tslib_1.__values)((0, roosterjs_editor_dom_1.toArray)(element.attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                if (isTableCell && attr.name == 'style') {
                    removeNonBorderStyles(element);
                }
                else if (isTable && attr.name == 'style') {
                    removeNotTableDefaultStyles(element);
                }
                else if (ATTRIBUTES_TO_PRESERVE.indexOf(attr.name.toLowerCase()) < 0 &&
                    attr.name.indexOf('data-') != 0) {
                    element.removeAttribute(attr.name);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    function updateStyles(element, callbackfn) {
        var styles = (0, roosterjs_editor_dom_1.getStyles)(element);
        var result = {};
        (0, roosterjs_editor_dom_1.getObjectKeys)(styles).forEach(function (style) { return callbackfn(style, styles, result); });
        (0, roosterjs_editor_dom_1.setStyles)(element, styles);
        return result;
    }
    function removeNonBorderStyles(element) {
        return updateStyles(element, function (name, styles, result) {
            if (name.indexOf('border') < 0) {
                result[name] = styles[name];
                delete styles[name];
            }
        });
    }
    function removeNotTableDefaultStyles(element) {
        return updateStyles(element, function (name, styles, result) {
            if (name != 'border-collapse') {
                result[name] = styles[name];
                delete styles[name];
            }
        });
    }
    /**
     * Verifies recursively if a node and its parents have any siblings with text content
     * Ignoring the children of contentDiv and returning true if any node is LI
     * @returns `true` if this node, and its parents (minus the children of the contentDiv) have no siblings with text content
     */
    function isNodeWholeBlock(node, editor) {
        var _a;
        var currentNode = node;
        var _loop_1 = function () {
            if (currentNode.nextSibling || currentNode.previousSibling) {
                if ((0, roosterjs_editor_dom_1.safeInstanceOf)(currentNode, 'HTMLLIElement')) {
                    return { value: true };
                }
                var isOnlySiblingWithContent_1 = true;
                (_a = currentNode.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes.forEach(function (node) {
                    var _a;
                    if (node != currentNode && ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length)) {
                        isOnlySiblingWithContent_1 = false;
                    }
                });
                return { value: isOnlySiblingWithContent_1 };
            }
            currentNode = currentNode.parentNode;
        };
        while (currentNode && editor.contains(currentNode.parentNode)) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return true;
    }
    /**
     * Clear the format of the selected text or list of blocks
     * If the current selection is compose of multiple block elements then remove the text and struture format for all the selected blocks
     * If the current selection is compose of a partial inline element then only the text format is removed from the current selection
     * @param editor The editor instance
     */
    function clearAutoDetectFormat(editor) {
        var isMultiBlock = isMultiBlockSelection(editor);
        if (!isMultiBlock) {
            var transverser = editor.getSelectionTraverser();
            var inlineElement = transverser === null || transverser === void 0 ? void 0 : transverser.currentInlineElement;
            var isPartial = inlineElement instanceof roosterjs_editor_dom_1.PartialInlineElement ||
                (inlineElement instanceof roosterjs_editor_dom_1.NodeInlineElement &&
                    !isNodeWholeBlock(inlineElement.getContainerNode(), editor));
            if (isPartial) {
                clearFormat(editor);
                return;
            }
        }
        clearBlockFormat(editor);
    }
    /**
     * Clear all formats of selected blocks.
     * When selection is collapsed, only clear format of current block.
     * @param editor The editor instance
     */
    function clearBlockFormat(editor) {
        (0, formatUndoSnapshot_1.default)(editor, function () {
            (0, blockFormat_1.default)(editor, function (region) {
                var blocks = (0, roosterjs_editor_dom_1.getSelectedBlockElementsInRegion)(region);
                var nodes = (0, roosterjs_editor_dom_1.collapseNodesInRegion)(region, blocks);
                if (editor.contains(region.rootNode)) {
                    // If there are styles on table cell, wrap all its children and move down all non-border styles.
                    // So that we can preserve styles for unselected blocks as well as border styles for table
                    var nonborderStyles = removeNonBorderStyles(region.rootNode);
                    if ((0, roosterjs_editor_dom_1.getObjectKeys)(nonborderStyles).length > 0) {
                        var wrapper = (0, roosterjs_editor_dom_1.wrap)((0, roosterjs_editor_dom_1.toArray)(region.rootNode.childNodes));
                        (0, roosterjs_editor_dom_1.setStyles)(wrapper, nonborderStyles);
                    }
                }
                while (nodes.length > 0 &&
                    nodes[0].parentNode &&
                    (0, roosterjs_editor_dom_1.isNodeInRegion)(region, nodes[0].parentNode)) {
                    var balancedNodes = (0, roosterjs_editor_dom_1.splitBalancedNodeRange)(nodes);
                    nodes = balancedNodes ? [balancedNodes] : [];
                }
                nodes.forEach(clearNodeFormat);
            });
            setDefaultFormat(editor);
        }, 'clearBlockFormat');
    }
    function clearInlineFormat(editor) {
        editor.focus();
        editor.addUndoSnapshot(function () {
            (0, execCommand_1.default)(editor, "removeFormat" /* RemoveFormat */);
            editor.queryElements('[class]', 1 /* OnSelection */, function (node) {
                return node.removeAttribute('class');
            });
            setDefaultFormat(editor);
            return 'clearInlineFormat';
        }, "Format" /* Format */);
    }
    function setDefaultFontWeight(editor, fontWeight) {
        if (fontWeight === void 0) { fontWeight = '400'; }
        (0, applyListItemWrap_1.default)(editor, 'font-weight', function (element) { return (element.style.fontWeight = fontWeight); }, 'setDefaultFontWeight');
    }
    function setDefaultFormat(editor) {
        var defaultFormat = editor.getDefaultFormat();
        var isDefaultFormatEmpty = (0, roosterjs_editor_dom_1.getObjectKeys)(defaultFormat).length === 0;
        editor.queryElements('[style]', 2 /* InSelection */, function (node) {
            var tag = (0, roosterjs_editor_dom_1.getTagOfNode)(node);
            if (TAGS_TO_STOP_UNWRAP.indexOf(tag) == -1) {
                removeStyles(tag, node, isDefaultFormatEmpty);
            }
            else {
                node.childNodes.forEach(function (node) {
                    node.childNodes.forEach(function (cNode) {
                        var tag = (0, roosterjs_editor_dom_1.getTagOfNode)(cNode);
                        if ((0, roosterjs_editor_dom_1.safeInstanceOf)(cNode, 'HTMLElement')) {
                            removeStyles(tag, cNode, isDefaultFormatEmpty);
                        }
                    });
                });
            }
        });
        if (!isDefaultFormatEmpty) {
            if (defaultFormat.fontFamily) {
                (0, setFontName_1.default)(editor, defaultFormat.fontFamily);
            }
            if (defaultFormat.fontSize) {
                (0, setFontSize_1.default)(editor, defaultFormat.fontSize);
            }
            if (defaultFormat.textColor) {
                var setColorIgnoredElements_1 = editor.queryElements('a *, a', 1 /* OnSelection */);
                var shouldApplyInlineStyle = setColorIgnoredElements_1.length > 0
                    ? function (element) { return setColorIgnoredElements_1.indexOf(element) == -1; }
                    : undefined;
                if (defaultFormat.textColors) {
                    (0, setTextColor_1.default)(editor, defaultFormat.textColors, shouldApplyInlineStyle);
                }
                else {
                    (0, setTextColor_1.default)(editor, defaultFormat.textColor, shouldApplyInlineStyle);
                }
            }
            if (defaultFormat.backgroundColor) {
                if (defaultFormat.backgroundColors) {
                    (0, setBackgroundColor_1.default)(editor, defaultFormat.backgroundColors);
                }
                else {
                    (0, setBackgroundColor_1.default)(editor, defaultFormat.backgroundColor);
                }
            }
            if (defaultFormat.bold) {
                (0, toggleBold_1.default)(editor);
            }
            else {
                setDefaultFontWeight(editor);
            }
            if (defaultFormat.italic) {
                (0, toggleItalic_1.default)(editor);
            }
            if (defaultFormat.underline) {
                (0, toggleUnderline_1.default)(editor);
            }
        }
    }
    function removeStyles(tag, node, isDefaultFormatEmpty) {
        if (TAGS_TO_STOP_UNWRAP.indexOf(tag) == -1) {
            STYLES_TO_REMOVE.forEach(function (style) { return node.style.removeProperty(style); });
            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style
            // (note: because default format is empty, we're not adding style back in)
            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {
                node.removeAttribute('style');
            }
        }
    }
    /**
     * Clear the format in current selection, after cleaning, the format will be
     * changed to default format. The format that get cleaned include B/I/U/font name/
     * font size/text color/background color/align left/align right/align center/superscript/subscript
     * @param editor The editor instance
     * @param formatType type of format to apply
     */
    function clearFormat(editor, formatType) {
        if (formatType === void 0) { formatType = 0 /* Inline */; }
        switch (formatType) {
            case 0 /* Inline */:
                clearInlineFormat(editor);
                break;
            case 1 /* Block */:
                clearBlockFormat(editor);
                break;
            default:
                clearAutoDetectFormat(editor);
        }
    }
    exports.default = clearFormat;
});
//# sourceMappingURL=clearFormat.js.map