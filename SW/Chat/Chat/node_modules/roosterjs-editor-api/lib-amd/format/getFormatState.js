define(["require", "exports", "tslib", "roosterjs-editor-dom"], function (require, exports, tslib_1, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementBasedFormatState = void 0;
    /**
     * Get element based Format State at cursor
     * @param editor The editor instance
     * @param event (Optional) The plugin event, it stores the event cached data for looking up.
     * In this function the event cache is used to get list state and heading level. If not passed,
     * it will query the node within selection to get the info
     * @returns An ElementBasedFormatState object
     */
    function getElementBasedFormatState(editor, event) {
        var listTag = (0, roosterjs_editor_dom_1.getTagOfNode)(editor.getElementAtCursor('OL,UL', undefined /*startFrom*/, event));
        // Check if selection is multiline, spans more than one block
        var range = editor.getSelectionRange();
        var multiline = false;
        if (range && !range.collapsed) {
            var startingBlock = editor.getBlockElementAtNode(range.startContainer);
            var endingBlock = editor.getBlockElementAtNode(range.endContainer);
            multiline = endingBlock && startingBlock ? !endingBlock.equals(startingBlock) : false;
        }
        var headingTag = (0, roosterjs_editor_dom_1.getTagOfNode)(editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', undefined /*startFrom*/, event));
        var table = editor.queryElements('table', 1 /* OnSelection */)[0];
        var tableFormat = table ? (0, roosterjs_editor_dom_1.getTableFormatInfo)(table) : undefined;
        var hasTableHeader = (table === null || table === void 0 ? void 0 : table.rows[0])
            ? (0, roosterjs_editor_dom_1.toArray)(table.rows[0].cells).every(function (cell) { return (0, roosterjs_editor_dom_1.getTagOfNode)(cell) == 'TH'; })
            : undefined;
        var headingLevel = (headingTag && parseInt(headingTag[1])) || 0;
        return {
            isBullet: listTag == 'UL',
            isNumbering: listTag == 'OL',
            isMultilineSelection: multiline,
            headingLevel: headingLevel,
            headerLevel: headingLevel,
            canUnlink: !!editor.queryElements('a[href]', 1 /* OnSelection */)[0],
            canAddImageAltText: !!editor.queryElements('img', 1 /* OnSelection */)[0],
            isBlockQuote: !!editor.queryElements('blockquote', 1 /* OnSelection */)[0],
            isCodeInline: !!editor.queryElements('code', 1 /* OnSelection */)[0],
            isCodeBlock: !!editor.queryElements('pre>code', 1 /* OnSelection */)[0],
            isInTable: !!table,
            tableFormat: tableFormat || {},
            tableHasHeader: hasTableHeader,
            canMergeTableCell: canMergeTableCell(editor),
        };
    }
    exports.getElementBasedFormatState = getElementBasedFormatState;
    /**
     * Get format state at cursor
     * A format state is a collection of all format related states, e.g.,
     * bold, italic, underline, font name, font size, etc.
     * @param editor The editor instance
     * @param event (Optional) The plugin event, it stores the event cached data for looking up.
     * In this function the event cache is used to get list state and heading level. If not passed,
     * it will query the node within selection to get the info
     * @returns The format state at cursor
     */
    function getFormatState(editor, event) {
        return (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, editor.getPendableFormatState(false /* forceGetStateFromDom */)), getElementBasedFormatState(editor, event)), editor.getStyleBasedFormatState()), editor.getUndoState()), { isDarkMode: editor.isDarkMode(), zoomScale: editor.getZoomScale() });
    }
    exports.default = getFormatState;
    /**
     * Checks whether the editor selection range is starting and ending at a table element.
     * @param editor Editor Instance
     * @returns
     */
    var canMergeTableCell = function (editor) {
        var selection = editor.getSelectionRangeEx();
        var isATable = selection && selection.type === 1 /* TableSelection */;
        if (isATable && selection.coordinates) {
            var _a = selection.coordinates, firstCell = _a.firstCell, lastCell = _a.lastCell;
            if (firstCell.x !== lastCell.x || firstCell.y !== lastCell.y) {
                return true;
            }
            return false;
        }
        return false;
    };
});
//# sourceMappingURL=getFormatState.js.map