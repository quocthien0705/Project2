{"version":3,"file":"insertEntity.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-api/lib/format/insertEntity.ts"],"names":[],"mappings":"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","sourcesContent":["import commitListChains from '../utils/commitListChains';\nimport {\n    addDelimiters,\n    applyFormat,\n    commitEntity,\n    createElement,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n    VListChain,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport type { Entity, IEditor, NodePosition } from 'roosterjs-editor-types';\nimport {\n    ChangeSource,\n    ContentPosition,\n    KnownCreateElementDataIndex,\n    PositionType,\n} from 'roosterjs-editor-types';\nimport type { CompatibleContentPosition } from 'roosterjs-editor-types/lib/compatibleTypes';\n\n/**\n * Insert an entity into editor.\n * @param editor The editor to insert entity into.\n * @param type Type of the entity\n * @param contentNode Root element of the entity\n * @param isBlock Whether the entity will be shown as a block\n * @param isReadonly Whether the entity will be a readonly entity\n * @param position @optional The position to insert into. If not specified, current position will be used.\n * If isBlock is true, entity will be insert below this position\n * @param insertToRegionRoot @optional When pass true, insert the entity at the root level of current region.\n * Parent nodes will be split if need\n * @param focusAfterEntity @optional When pass true, focus will be moved next to the entity. For inline entity,\n * focus will be after right after the entity (and the delimiter if exist). For block entity, focus will be in\n * the new empty line below the entity\n */\nexport default function insertEntity(\n    editor: IEditor,\n    type: string,\n    contentNode: Node,\n    isBlock: boolean,\n    isReadonly: boolean,\n    position?:\n        | NodePosition\n        | ContentPosition.Begin\n        | ContentPosition.End\n        | ContentPosition.DomEnd\n        | CompatibleContentPosition.Begin\n        | CompatibleContentPosition.End\n        | CompatibleContentPosition.DomEnd,\n    insertToRegionRoot?: boolean,\n    focusAfterEntity?: boolean\n): Entity {\n    const wrapper = wrap(contentNode, isBlock ? 'div' : 'span');\n\n    // For inline & readonly entity, we need to set display to \"inline-block\" otherwise\n    // there will be some weird behavior when move cursor around the entity node.\n    // And we should only do this for readonly entity since \"inline-block\" has some side effect\n    // in IE that there will be a resize border around the inline-block element. We made some\n    // workaround for readonly entity for this issue but for editable entity, keep it as \"inline\"\n    // will just work fine.\n    if (!isBlock && isReadonly) {\n        wrapper.style.display = 'inline-block';\n    }\n\n    commitEntity(wrapper, type, isReadonly);\n\n    if (!editor.contains(wrapper)) {\n        let currentRange: Range | null = null;\n        let contentPosition:\n            | ContentPosition.Begin\n            | ContentPosition.End\n            | ContentPosition.DomEnd\n            | ContentPosition.SelectionStart\n            | CompatibleContentPosition.Begin\n            | CompatibleContentPosition.End\n            | CompatibleContentPosition.DomEnd\n            | CompatibleContentPosition.SelectionStart;\n\n        if (typeof position == 'number') {\n            contentPosition = position;\n        } else if (position) {\n            currentRange = editor.getSelectionRange();\n            const node = position.normalize().node;\n            const existingEntity = node && editor.getElementAtCursor(getEntitySelector(), node);\n\n            // Do not insert entity into another entity\n            if (existingEntity) {\n                position = new Position(existingEntity, PositionType.After);\n            }\n\n            editor.select(position);\n            contentPosition = ContentPosition.SelectionStart;\n        } else {\n            editor.focus();\n            contentPosition = ContentPosition.SelectionStart;\n        }\n\n        const regions = insertToRegionRoot && editor.getSelectedRegions();\n        const chains = regions && VListChain.createListChains(regions);\n\n        editor.insertNode(wrapper, {\n            updateCursor: false,\n            insertOnNewLine: isBlock,\n            replaceSelection: true,\n            position: contentPosition,\n            insertToRegionRoot: insertToRegionRoot,\n        });\n\n        if (chains) {\n            commitListChains(editor, chains);\n        }\n\n        if (contentPosition == ContentPosition.SelectionStart) {\n            if (currentRange) {\n                editor.select(currentRange);\n            } else if (!isBlock) {\n                editor.select(wrapper, PositionType.After);\n            }\n        }\n    }\n\n    const entity = getEntityFromElement(wrapper)!;\n\n    if (isBlock) {\n        // Insert an extra empty line for block entity to make sure\n        // user can still put cursor below the entity.\n        const newLine = createElement(KnownCreateElementDataIndex.EmptyLine, editor.getDocument());\n\n        wrapper.parentNode?.insertBefore(newLine!, wrapper.nextSibling);\n\n        if (newLine) {\n            applyFormat(\n                newLine as HTMLElement,\n                editor.getDefaultFormat(),\n                editor.isDarkMode(),\n                editor.getDarkColorHandler()\n            );\n        }\n\n        if (focusAfterEntity) {\n            const br = newLine?.querySelector('br');\n            const pos = br && new Position(br, PositionType.Before);\n\n            if (pos) {\n                editor.select(pos);\n            }\n        }\n    } else if (isReadonly) {\n        addDelimiters(entity.wrapper);\n\n        if (entity.wrapper.nextElementSibling && editor.hasFocus()) {\n            editor.select(new Position(entity.wrapper.nextElementSibling, PositionType.After));\n        }\n    }\n\n    editor.triggerContentChangedEvent(ChangeSource.InsertEntity, entity);\n\n    return entity;\n}\n"]}