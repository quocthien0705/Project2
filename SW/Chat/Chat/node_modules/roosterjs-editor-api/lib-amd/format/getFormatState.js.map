{"version":3,"file":"getFormatState.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-api/lib/format/getFormatState.ts"],"names":[],"mappings":"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","sourcesContent":["import { getTableFormatInfo, getTagOfNode, toArray } from 'roosterjs-editor-dom';\r\nimport type {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    IEditor,\r\n    PluginEvent,\r\n} from 'roosterjs-editor-types';\r\nimport { QueryScope, SelectionRangeTypes } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and heading level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: IEditor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    const listTag = getTagOfNode(\r\n        editor.getElementAtCursor('OL,UL', undefined /*startFrom*/, event)\r\n    );\r\n\r\n    // Check if selection is multiline, spans more than one block\r\n    const range = editor.getSelectionRange();\r\n    let multiline = false;\r\n\r\n    if (range && !range.collapsed) {\r\n        const startingBlock = editor.getBlockElementAtNode(range.startContainer);\r\n        const endingBlock = editor.getBlockElementAtNode(range.endContainer);\r\n        multiline = endingBlock && startingBlock ? !endingBlock.equals(startingBlock) : false;\r\n    }\r\n\r\n    const headingTag = getTagOfNode(\r\n        editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', undefined /*startFrom*/, event)\r\n    );\r\n\r\n    const table = editor.queryElements('table', QueryScope.OnSelection)[0];\r\n    const tableFormat = table ? getTableFormatInfo(table) : undefined;\r\n    const hasTableHeader = table?.rows[0]\r\n        ? toArray(table.rows[0].cells).every(cell => getTagOfNode(cell) == 'TH')\r\n        : undefined;\r\n    const headingLevel = (headingTag && parseInt(headingTag[1])) || 0;\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        isMultilineSelection: multiline,\r\n        headingLevel: headingLevel,\r\n        headerLevel: headingLevel,\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n        isCodeInline: !!editor.queryElements('code', QueryScope.OnSelection)[0],\r\n        isCodeBlock: !!editor.queryElements('pre>code', QueryScope.OnSelection)[0],\r\n        isInTable: !!table,\r\n        tableFormat: tableFormat || {},\r\n        tableHasHeader: hasTableHeader,\r\n        canMergeTableCell: canMergeTableCell(editor),\r\n    };\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and heading level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: IEditor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...editor.getPendableFormatState(false /* forceGetStateFromDom */),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...editor.getStyleBasedFormatState(),\r\n        ...editor.getUndoState(),\r\n        isDarkMode: editor.isDarkMode(),\r\n        zoomScale: editor.getZoomScale(),\r\n    };\r\n}\r\n\r\n/**\r\n * Checks whether the editor selection range is starting and ending at a table element.\r\n * @param editor Editor Instance\r\n * @returns\r\n */\r\n\r\nconst canMergeTableCell = (editor: IEditor): boolean => {\r\n    const selection = editor.getSelectionRangeEx();\r\n    const isATable = selection && selection.type === SelectionRangeTypes.TableSelection;\r\n    if (isATable && selection.coordinates) {\r\n        const { firstCell, lastCell } = selection.coordinates;\r\n        if (firstCell.x !== lastCell.x || firstCell.y !== lastCell.y) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    return false;\r\n};\r\n"]}