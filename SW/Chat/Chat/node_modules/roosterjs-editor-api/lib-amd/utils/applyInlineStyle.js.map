{"version":3,"file":"applyInlineStyle.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts"],"names":[],"mappings":";;;IAUA;;;;;OAKG;IACH,SAAwB,gBAAgB,CACpC,MAAe,EACf,QAA8D,EAC9D,OAAe;QAEf,MAAM,CAAC,KAAK,EAAE,CAAC;QACf,IAAM,SAAS,GAAG,MAAM,CAAC,mBAAmB,EAAE,CAAC;QAE/C,IAAM,YAAY,GAAG,UAAC,OAAoB,EAAE,WAAqB;YAC7D,OAAA,OAAO,CAAC,iBAAiB,IAAI,QAAQ,CAAC,OAAO,EAAE,WAAW,CAAC;QAA3D,CAA2D,CAAC;QAEhE,IAAI,SAAS,IAAI,SAAS,CAAC,eAAe,EAAE;YACxC,IAAM,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAClC,IAAM,IAAI,GAAG,KAAK,CAAC,cAAc,CAAC;YAClC,IAAM,WAAW,GACb,IAAA,mCAAY,EAAC,IAAI,CAAC,IAAI,MAAM;gBAC5B,CAAC,CAAC,IAAI,CAAC,UAAU;oBACb,CAAC,IAAA,mCAAY,EAAC,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC;YACjF,IAAI,WAAW,EAAE;gBACb,MAAM,CAAC,eAAe,EAAE,CAAC;gBACzB,YAAY,CAAC,IAAmB,CAAC,CAAC;aACrC;iBAAM;gBACH,MAAM,CAAC,kBAAkB,qCAA4C;oBACjE,WAAW,EAAE,EAAE;oBACf,qFAAqF;oBACrF,kHAAkH;oBAClH,cAAc,EAAE,QAAQ;iBAC3B,CAAC,CAAC;gBACH,MAAM,CAAC,0BAA0B,uBAAqB,CAAC;aAC1D;SACJ;aAAM;YACH,0GAA0G;YAC1G,wCAAwC;YACxC,IAAA,4BAAkB,EACd,MAAM,EACN;gBACI,IAAI,SAA2B,CAAC;gBAChC,IAAI,QAA0B,CAAC;gBAC/B,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,UAAA,KAAK;oBAC1B,IAAM,gBAAgB,GAAG,MAAM,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;oBAC7D,IAAI,CAAC,gBAAgB,EAAE;wBACnB,OAAO;qBACV;oBACD,IAAI,aAAa,GAAG,gBAAgB,IAAI,gBAAgB,CAAC,oBAAoB,CAAC;oBAC9E,OAAO,aAAa,EAAE;wBAClB,IAAM,iBAAiB,GAAG,gBAAgB,CAAC,oBAAoB,EAAE,CAAC;wBAClE,aAAa,CAAC,UAAU,CAAC,UAAC,OAAO,EAAE,WAAW;4BAC1C,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;4BACnC,SAAS,GAAG,SAAS,IAAI,OAAO,CAAC;4BACjC,QAAQ,GAAG,OAAO,CAAC;wBACvB,CAAC,CAAC,CAAC;wBACH,aAAa,GAAG,iBAAiB,CAAC;qBACrC;gBACL,CAAC,CAAC,CAAC;gBAEH,IAAI,SAAS,IAAI,QAAQ,IAAI,SAAS,CAAC,IAAI,kBAA8B,EAAE;oBACvE,MAAM,CAAC,MAAM,CAAC,SAAS,mBAAuB,QAAQ,iBAAqB,CAAC;iBAC/E;YACL,CAAC,EACD,OAAO,CACV,CAAC;SACL;IACL,CAAC;IA9DD,mCA8DC","sourcesContent":["import formatUndoSnapshot from './formatUndoSnapshot';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\nimport type { IEditor } from 'roosterjs-editor-types';\r\nimport {\r\n    ChangeSource,\r\n    PluginEventType,\r\n    PositionType,\r\n    SelectionRangeTypes,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: IEditor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any,\r\n    apiName: string\r\n) {\r\n    editor.focus();\r\n    const selection = editor.getSelectionRangeEx();\r\n\r\n    const safeCallback = (element: HTMLElement, isInnerNode?: boolean) =>\r\n        element.isContentEditable && callback(element, isInnerNode);\r\n\r\n    if (selection && selection.areAllCollapsed) {\r\n        const range = selection.ranges[0];\r\n        const node = range.startContainer;\r\n        const isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            safeCallback(node as HTMLElement);\r\n        } else {\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: {},\r\n                // Here we use callback instead of safeCallback because we know it's contentEditable.\r\n                // In addition, for elements that are not added to the DOM tree, isContentEditable always returns false on Safari.\r\n                formatCallback: callback,\r\n            });\r\n            editor.triggerContentChangedEvent(ChangeSource.Format);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        formatUndoSnapshot(\r\n            editor,\r\n            () => {\r\n                let firstNode: Node | undefined;\r\n                let lastNode: Node | undefined;\r\n                selection.ranges.forEach(range => {\r\n                    const contentTraverser = editor.getSelectionTraverser(range);\r\n                    if (!contentTraverser) {\r\n                        return;\r\n                    }\r\n                    let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n                    while (inlineElement) {\r\n                        const nextInlineElement = contentTraverser.getNextInlineElement();\r\n                        inlineElement.applyStyle((element, isInnerNode) => {\r\n                            safeCallback(element, isInnerNode);\r\n                            firstNode = firstNode || element;\r\n                            lastNode = element;\r\n                        });\r\n                        inlineElement = nextInlineElement;\r\n                    }\r\n                });\r\n\r\n                if (firstNode && lastNode && selection.type == SelectionRangeTypes.Normal) {\r\n                    editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n                }\r\n            },\r\n            apiName\r\n        );\r\n    }\r\n}\r\n"]}