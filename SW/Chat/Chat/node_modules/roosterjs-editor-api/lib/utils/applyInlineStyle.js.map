{"version":3,"file":"applyInlineStyle.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts"],"names":[],"mappings":";;AAAA,2DAAsD;AACtD,6DAAoD;AASpD;;;;;GAKG;AACH,SAAwB,gBAAgB,CACpC,MAAe,EACf,QAA8D,EAC9D,OAAe;IAEf,MAAM,CAAC,KAAK,EAAE,CAAC;IACf,IAAM,SAAS,GAAG,MAAM,CAAC,mBAAmB,EAAE,CAAC;IAE/C,IAAM,YAAY,GAAG,UAAC,OAAoB,EAAE,WAAqB;QAC7D,OAAA,OAAO,CAAC,iBAAiB,IAAI,QAAQ,CAAC,OAAO,EAAE,WAAW,CAAC;IAA3D,CAA2D,CAAC;IAEhE,IAAI,SAAS,IAAI,SAAS,CAAC,eAAe,EAAE;QACxC,IAAM,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAClC,IAAM,IAAI,GAAG,KAAK,CAAC,cAAc,CAAC;QAClC,IAAM,WAAW,GACb,IAAA,mCAAY,EAAC,IAAI,CAAC,IAAI,MAAM;YAC5B,CAAC,CAAC,IAAI,CAAC,UAAU;gBACb,CAAC,IAAA,mCAAY,EAAC,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC;QACjF,IAAI,WAAW,EAAE;YACb,MAAM,CAAC,eAAe,EAAE,CAAC;YACzB,YAAY,CAAC,IAAmB,CAAC,CAAC;SACrC;aAAM;YACH,MAAM,CAAC,kBAAkB,qCAA4C;gBACjE,WAAW,EAAE,EAAE;gBACf,qFAAqF;gBACrF,kHAAkH;gBAClH,cAAc,EAAE,QAAQ;aAC3B,CAAC,CAAC;YACH,MAAM,CAAC,0BAA0B,uBAAqB,CAAC;SAC1D;KACJ;SAAM;QACH,0GAA0G;QAC1G,wCAAwC;QACxC,IAAA,4BAAkB,EACd,MAAM,EACN;YACI,IAAI,SAA2B,CAAC;YAChC,IAAI,QAA0B,CAAC;YAC/B,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,UAAA,KAAK;gBAC1B,IAAM,gBAAgB,GAAG,MAAM,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;gBAC7D,IAAI,CAAC,gBAAgB,EAAE;oBACnB,OAAO;iBACV;gBACD,IAAI,aAAa,GAAG,gBAAgB,IAAI,gBAAgB,CAAC,oBAAoB,CAAC;gBAC9E,OAAO,aAAa,EAAE;oBAClB,IAAM,iBAAiB,GAAG,gBAAgB,CAAC,oBAAoB,EAAE,CAAC;oBAClE,aAAa,CAAC,UAAU,CAAC,UAAC,OAAO,EAAE,WAAW;wBAC1C,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;wBACnC,SAAS,GAAG,SAAS,IAAI,OAAO,CAAC;wBACjC,QAAQ,GAAG,OAAO,CAAC;oBACvB,CAAC,CAAC,CAAC;oBACH,aAAa,GAAG,iBAAiB,CAAC;iBACrC;YACL,CAAC,CAAC,CAAC;YAEH,IAAI,SAAS,IAAI,QAAQ,IAAI,SAAS,CAAC,IAAI,kBAA8B,EAAE;gBACvE,MAAM,CAAC,MAAM,CAAC,SAAS,mBAAuB,QAAQ,iBAAqB,CAAC;aAC/E;QACL,CAAC,EACD,OAAO,CACV,CAAC;KACL;AACL,CAAC;AA9DD,mCA8DC","sourcesContent":["import formatUndoSnapshot from './formatUndoSnapshot';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\nimport type { IEditor } from 'roosterjs-editor-types';\r\nimport {\r\n    ChangeSource,\r\n    PluginEventType,\r\n    PositionType,\r\n    SelectionRangeTypes,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: IEditor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any,\r\n    apiName: string\r\n) {\r\n    editor.focus();\r\n    const selection = editor.getSelectionRangeEx();\r\n\r\n    const safeCallback = (element: HTMLElement, isInnerNode?: boolean) =>\r\n        element.isContentEditable && callback(element, isInnerNode);\r\n\r\n    if (selection && selection.areAllCollapsed) {\r\n        const range = selection.ranges[0];\r\n        const node = range.startContainer;\r\n        const isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            safeCallback(node as HTMLElement);\r\n        } else {\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: {},\r\n                // Here we use callback instead of safeCallback because we know it's contentEditable.\r\n                // In addition, for elements that are not added to the DOM tree, isContentEditable always returns false on Safari.\r\n                formatCallback: callback,\r\n            });\r\n            editor.triggerContentChangedEvent(ChangeSource.Format);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        formatUndoSnapshot(\r\n            editor,\r\n            () => {\r\n                let firstNode: Node | undefined;\r\n                let lastNode: Node | undefined;\r\n                selection.ranges.forEach(range => {\r\n                    const contentTraverser = editor.getSelectionTraverser(range);\r\n                    if (!contentTraverser) {\r\n                        return;\r\n                    }\r\n                    let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n                    while (inlineElement) {\r\n                        const nextInlineElement = contentTraverser.getNextInlineElement();\r\n                        inlineElement.applyStyle((element, isInnerNode) => {\r\n                            safeCallback(element, isInnerNode);\r\n                            firstNode = firstNode || element;\r\n                            lastNode = element;\r\n                        });\r\n                        inlineElement = nextInlineElement;\r\n                    }\r\n                });\r\n\r\n                if (firstNode && lastNode && selection.type == SelectionRangeTypes.Normal) {\r\n                    editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n                }\r\n            },\r\n            apiName\r\n        );\r\n    }\r\n}\r\n"]}