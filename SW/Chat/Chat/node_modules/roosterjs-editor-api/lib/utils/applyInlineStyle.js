"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var formatUndoSnapshot_1 = require("./formatUndoSnapshot");
var roosterjs_editor_dom_1 = require("roosterjs-editor-dom");
/**
 * @internal
 * Apply inline style to current selection
 * @param editor The editor instance
 * @param callback The callback function to apply style
 */
function applyInlineStyle(editor, callback, apiName) {
    editor.focus();
    var selection = editor.getSelectionRangeEx();
    var safeCallback = function (element, isInnerNode) {
        return element.isContentEditable && callback(element, isInnerNode);
    };
    if (selection && selection.areAllCollapsed) {
        var range = selection.ranges[0];
        var node = range.startContainer;
        var isEmptySpan = (0, roosterjs_editor_dom_1.getTagOfNode)(node) == 'SPAN' &&
            (!node.firstChild ||
                ((0, roosterjs_editor_dom_1.getTagOfNode)(node.firstChild) == 'BR' && !node.firstChild.nextSibling));
        if (isEmptySpan) {
            editor.addUndoSnapshot();
            safeCallback(node);
        }
        else {
            editor.triggerPluginEvent(13 /* PendingFormatStateChanged */, {
                formatState: {},
                // Here we use callback instead of safeCallback because we know it's contentEditable.
                // In addition, for elements that are not added to the DOM tree, isContentEditable always returns false on Safari.
                formatCallback: callback,
            });
            editor.triggerContentChangedEvent("Format" /* Format */);
        }
    }
    else {
        // This is start and end node that get the style. The start and end needs to be recorded so that selection
        // can be re-applied post-applying style
        (0, formatUndoSnapshot_1.default)(editor, function () {
            var firstNode;
            var lastNode;
            selection.ranges.forEach(function (range) {
                var contentTraverser = editor.getSelectionTraverser(range);
                if (!contentTraverser) {
                    return;
                }
                var inlineElement = contentTraverser && contentTraverser.currentInlineElement;
                while (inlineElement) {
                    var nextInlineElement = contentTraverser.getNextInlineElement();
                    inlineElement.applyStyle(function (element, isInnerNode) {
                        safeCallback(element, isInnerNode);
                        firstNode = firstNode || element;
                        lastNode = element;
                    });
                    inlineElement = nextInlineElement;
                }
            });
            if (firstNode && lastNode && selection.type == 0 /* Normal */) {
                editor.select(firstNode, -2 /* Before */, lastNode, -3 /* After */);
            }
        }, apiName);
    }
}
exports.default = applyInlineStyle;
//# sourceMappingURL=applyInlineStyle.js.map