"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = require("roosterjs-editor-dom");
/**
 * @internal
 * @param node start node to normalize
 * @param quotesHandled Optional parameter to prevent already modified quotes to be rechecked.
 * @returns
 */
function normalizeBlockquote(node, quotesHandled) {
    if ((0, roosterjs_editor_dom_1.safeInstanceOf)(node, 'HTMLElement')) {
        var alignment = node.style.textAlign;
        var quote = (0, roosterjs_editor_dom_1.findClosestElementAncestor)(node, undefined /* root */, 'blockquote');
        if (!quote) {
            return;
        }
        var isNodeRTL = isRTL(node);
        if (quotesHandled) {
            if (quotesHandled.indexOf(quote) > -1) {
                return;
            }
            quotesHandled.push(quote);
        }
        while (quote) {
            if (alignment == 'center') {
                if (isNodeRTL) {
                    quote.style.removeProperty('marginInlineEnd');
                    quote.style.marginInlineStart = 'auto';
                }
                else {
                    quote.style.removeProperty('marginInlineStart');
                    quote.style.marginInlineEnd = 'auto';
                }
            }
            else {
                quote.style.removeProperty('marginInlineEnd');
                quote.style.removeProperty('marginInlineStart');
            }
            quote = (0, roosterjs_editor_dom_1.findClosestElementAncestor)(quote.parentElement, undefined /* root */, 'blockquote');
        }
    }
}
exports.default = normalizeBlockquote;
function isRTL(el) {
    return (0, roosterjs_editor_dom_1.getComputedStyle)(el, 'direction') == 'rtl' || el.getAttribute('dir') == 'rtl';
}
//# sourceMappingURL=normalizeBlockquote.js.map