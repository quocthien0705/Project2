"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var commitListChains_1 = require("../utils/commitListChains");
var roosterjs_editor_dom_1 = require("roosterjs-editor-dom");
/**
 * Insert an entity into editor.
 * @param editor The editor to insert entity into.
 * @param type Type of the entity
 * @param contentNode Root element of the entity
 * @param isBlock Whether the entity will be shown as a block
 * @param isReadonly Whether the entity will be a readonly entity
 * @param position @optional The position to insert into. If not specified, current position will be used.
 * If isBlock is true, entity will be insert below this position
 * @param insertToRegionRoot @optional When pass true, insert the entity at the root level of current region.
 * Parent nodes will be split if need
 * @param focusAfterEntity @optional When pass true, focus will be moved next to the entity. For inline entity,
 * focus will be after right after the entity (and the delimiter if exist). For block entity, focus will be in
 * the new empty line below the entity
 */
function insertEntity(editor, type, contentNode, isBlock, isReadonly, position, insertToRegionRoot, focusAfterEntity) {
    var _a;
    var wrapper = (0, roosterjs_editor_dom_1.wrap)(contentNode, isBlock ? 'div' : 'span');
    // For inline & readonly entity, we need to set display to "inline-block" otherwise
    // there will be some weird behavior when move cursor around the entity node.
    // And we should only do this for readonly entity since "inline-block" has some side effect
    // in IE that there will be a resize border around the inline-block element. We made some
    // workaround for readonly entity for this issue but for editable entity, keep it as "inline"
    // will just work fine.
    if (!isBlock && isReadonly) {
        wrapper.style.display = 'inline-block';
    }
    (0, roosterjs_editor_dom_1.commitEntity)(wrapper, type, isReadonly);
    if (!editor.contains(wrapper)) {
        var currentRange = null;
        var contentPosition = void 0;
        if (typeof position == 'number') {
            contentPosition = position;
        }
        else if (position) {
            currentRange = editor.getSelectionRange();
            var node = position.normalize().node;
            var existingEntity = node && editor.getElementAtCursor((0, roosterjs_editor_dom_1.getEntitySelector)(), node);
            // Do not insert entity into another entity
            if (existingEntity) {
                position = new roosterjs_editor_dom_1.Position(existingEntity, -3 /* After */);
            }
            editor.select(position);
            contentPosition = 3 /* SelectionStart */;
        }
        else {
            editor.focus();
            contentPosition = 3 /* SelectionStart */;
        }
        var regions = insertToRegionRoot && editor.getSelectedRegions();
        var chains = regions && roosterjs_editor_dom_1.VListChain.createListChains(regions);
        editor.insertNode(wrapper, {
            updateCursor: false,
            insertOnNewLine: isBlock,
            replaceSelection: true,
            position: contentPosition,
            insertToRegionRoot: insertToRegionRoot,
        });
        if (chains) {
            (0, commitListChains_1.default)(editor, chains);
        }
        if (contentPosition == 3 /* SelectionStart */) {
            if (currentRange) {
                editor.select(currentRange);
            }
            else if (!isBlock) {
                editor.select(wrapper, -3 /* After */);
            }
        }
    }
    var entity = (0, roosterjs_editor_dom_1.getEntityFromElement)(wrapper);
    if (isBlock) {
        // Insert an extra empty line for block entity to make sure
        // user can still put cursor below the entity.
        var newLine = (0, roosterjs_editor_dom_1.createElement)(1 /* EmptyLine */, editor.getDocument());
        (_a = wrapper.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newLine, wrapper.nextSibling);
        if (newLine) {
            (0, roosterjs_editor_dom_1.applyFormat)(newLine, editor.getDefaultFormat(), editor.isDarkMode(), editor.getDarkColorHandler());
        }
        if (focusAfterEntity) {
            var br = newLine === null || newLine === void 0 ? void 0 : newLine.querySelector('br');
            var pos = br && new roosterjs_editor_dom_1.Position(br, -2 /* Before */);
            if (pos) {
                editor.select(pos);
            }
        }
    }
    else if (isReadonly) {
        (0, roosterjs_editor_dom_1.addDelimiters)(entity.wrapper);
        if (entity.wrapper.nextElementSibling && editor.hasFocus()) {
            editor.select(new roosterjs_editor_dom_1.Position(entity.wrapper.nextElementSibling, -3 /* After */));
        }
    }
    editor.triggerContentChangedEvent("InsertEntity" /* InsertEntity */, entity);
    return entity;
}
exports.default = insertEntity;
//# sourceMappingURL=insertEntity.js.map