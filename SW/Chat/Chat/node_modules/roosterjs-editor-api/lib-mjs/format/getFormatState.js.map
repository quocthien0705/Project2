{"version":3,"file":"getFormatState.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-api/lib/format/getFormatState.ts"],"names":[],"mappings":"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","sourcesContent":["import { getTableFormatInfo, getTagOfNode, toArray } from 'roosterjs-editor-dom';\r\nimport type {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    IEditor,\r\n    PluginEvent,\r\n} from 'roosterjs-editor-types';\r\nimport { QueryScope, SelectionRangeTypes } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and heading level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: IEditor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    const listTag = getTagOfNode(\r\n        editor.getElementAtCursor('OL,UL', undefined /*startFrom*/, event)\r\n    );\r\n\r\n    // Check if selection is multiline, spans more than one block\r\n    const range = editor.getSelectionRange();\r\n    let multiline = false;\r\n\r\n    if (range && !range.collapsed) {\r\n        const startingBlock = editor.getBlockElementAtNode(range.startContainer);\r\n        const endingBlock = editor.getBlockElementAtNode(range.endContainer);\r\n        multiline = endingBlock && startingBlock ? !endingBlock.equals(startingBlock) : false;\r\n    }\r\n\r\n    const headingTag = getTagOfNode(\r\n        editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', undefined /*startFrom*/, event)\r\n    );\r\n\r\n    const table = editor.queryElements('table', QueryScope.OnSelection)[0];\r\n    const tableFormat = table ? getTableFormatInfo(table) : undefined;\r\n    const hasTableHeader = table?.rows[0]\r\n        ? toArray(table.rows[0].cells).every(cell => getTagOfNode(cell) == 'TH')\r\n        : undefined;\r\n    const headingLevel = (headingTag && parseInt(headingTag[1])) || 0;\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        isMultilineSelection: multiline,\r\n        headingLevel: headingLevel,\r\n        headerLevel: headingLevel,\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n        isCodeInline: !!editor.queryElements('code', QueryScope.OnSelection)[0],\r\n        isCodeBlock: !!editor.queryElements('pre>code', QueryScope.OnSelection)[0],\r\n        isInTable: !!table,\r\n        tableFormat: tableFormat || {},\r\n        tableHasHeader: hasTableHeader,\r\n        canMergeTableCell: canMergeTableCell(editor),\r\n    };\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and heading level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: IEditor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...editor.getPendableFormatState(false /* forceGetStateFromDom */),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...editor.getStyleBasedFormatState(),\r\n        ...editor.getUndoState(),\r\n        isDarkMode: editor.isDarkMode(),\r\n        zoomScale: editor.getZoomScale(),\r\n    };\r\n}\r\n\r\n/**\r\n * Checks whether the editor selection range is starting and ending at a table element.\r\n * @param editor Editor Instance\r\n * @returns\r\n */\r\n\r\nconst canMergeTableCell = (editor: IEditor): boolean => {\r\n    const selection = editor.getSelectionRangeEx();\r\n    const isATable = selection && selection.type === SelectionRangeTypes.TableSelection;\r\n    if (isATable && selection.coordinates) {\r\n        const { firstCell, lastCell } = selection.coordinates;\r\n        if (firstCell.x !== lastCell.x || firstCell.y !== lastCell.y) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    return false;\r\n};\r\n"]}