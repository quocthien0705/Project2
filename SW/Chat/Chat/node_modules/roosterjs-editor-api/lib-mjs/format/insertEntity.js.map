{"version":3,"file":"insertEntity.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-api/lib/format/insertEntity.ts"],"names":[],"mappings":"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","sourcesContent":["import commitListChains from '../utils/commitListChains';\nimport {\n    addDelimiters,\n    applyFormat,\n    commitEntity,\n    createElement,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n    VListChain,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport type { Entity, IEditor, NodePosition } from 'roosterjs-editor-types';\nimport {\n    ChangeSource,\n    ContentPosition,\n    KnownCreateElementDataIndex,\n    PositionType,\n} from 'roosterjs-editor-types';\nimport type { CompatibleContentPosition } from 'roosterjs-editor-types/lib/compatibleTypes';\n\n/**\n * Insert an entity into editor.\n * @param editor The editor to insert entity into.\n * @param type Type of the entity\n * @param contentNode Root element of the entity\n * @param isBlock Whether the entity will be shown as a block\n * @param isReadonly Whether the entity will be a readonly entity\n * @param position @optional The position to insert into. If not specified, current position will be used.\n * If isBlock is true, entity will be insert below this position\n * @param insertToRegionRoot @optional When pass true, insert the entity at the root level of current region.\n * Parent nodes will be split if need\n * @param focusAfterEntity @optional When pass true, focus will be moved next to the entity. For inline entity,\n * focus will be after right after the entity (and the delimiter if exist). For block entity, focus will be in\n * the new empty line below the entity\n */\nexport default function insertEntity(\n    editor: IEditor,\n    type: string,\n    contentNode: Node,\n    isBlock: boolean,\n    isReadonly: boolean,\n    position?:\n        | NodePosition\n        | ContentPosition.Begin\n        | ContentPosition.End\n        | ContentPosition.DomEnd\n        | CompatibleContentPosition.Begin\n        | CompatibleContentPosition.End\n        | CompatibleContentPosition.DomEnd,\n    insertToRegionRoot?: boolean,\n    focusAfterEntity?: boolean\n): Entity {\n    const wrapper = wrap(contentNode, isBlock ? 'div' : 'span');\n\n    // For inline & readonly entity, we need to set display to \"inline-block\" otherwise\n    // there will be some weird behavior when move cursor around the entity node.\n    // And we should only do this for readonly entity since \"inline-block\" has some side effect\n    // in IE that there will be a resize border around the inline-block element. We made some\n    // workaround for readonly entity for this issue but for editable entity, keep it as \"inline\"\n    // will just work fine.\n    if (!isBlock && isReadonly) {\n        wrapper.style.display = 'inline-block';\n    }\n\n    commitEntity(wrapper, type, isReadonly);\n\n    if (!editor.contains(wrapper)) {\n        let currentRange: Range | null = null;\n        let contentPosition:\n            | ContentPosition.Begin\n            | ContentPosition.End\n            | ContentPosition.DomEnd\n            | ContentPosition.SelectionStart\n            | CompatibleContentPosition.Begin\n            | CompatibleContentPosition.End\n            | CompatibleContentPosition.DomEnd\n            | CompatibleContentPosition.SelectionStart;\n\n        if (typeof position == 'number') {\n            contentPosition = position;\n        } else if (position) {\n            currentRange = editor.getSelectionRange();\n            const node = position.normalize().node;\n            const existingEntity = node && editor.getElementAtCursor(getEntitySelector(), node);\n\n            // Do not insert entity into another entity\n            if (existingEntity) {\n                position = new Position(existingEntity, PositionType.After);\n            }\n\n            editor.select(position);\n            contentPosition = ContentPosition.SelectionStart;\n        } else {\n            editor.focus();\n            contentPosition = ContentPosition.SelectionStart;\n        }\n\n        const regions = insertToRegionRoot && editor.getSelectedRegions();\n        const chains = regions && VListChain.createListChains(regions);\n\n        editor.insertNode(wrapper, {\n            updateCursor: false,\n            insertOnNewLine: isBlock,\n            replaceSelection: true,\n            position: contentPosition,\n            insertToRegionRoot: insertToRegionRoot,\n        });\n\n        if (chains) {\n            commitListChains(editor, chains);\n        }\n\n        if (contentPosition == ContentPosition.SelectionStart) {\n            if (currentRange) {\n                editor.select(currentRange);\n            } else if (!isBlock) {\n                editor.select(wrapper, PositionType.After);\n            }\n        }\n    }\n\n    const entity = getEntityFromElement(wrapper)!;\n\n    if (isBlock) {\n        // Insert an extra empty line for block entity to make sure\n        // user can still put cursor below the entity.\n        const newLine = createElement(KnownCreateElementDataIndex.EmptyLine, editor.getDocument());\n\n        wrapper.parentNode?.insertBefore(newLine!, wrapper.nextSibling);\n\n        if (newLine) {\n            applyFormat(\n                newLine as HTMLElement,\n                editor.getDefaultFormat(),\n                editor.isDarkMode(),\n                editor.getDarkColorHandler()\n            );\n        }\n\n        if (focusAfterEntity) {\n            const br = newLine?.querySelector('br');\n            const pos = br && new Position(br, PositionType.Before);\n\n            if (pos) {\n                editor.select(pos);\n            }\n        }\n    } else if (isReadonly) {\n        addDelimiters(entity.wrapper);\n\n        if (entity.wrapper.nextElementSibling && editor.hasFocus()) {\n            editor.select(new Position(entity.wrapper.nextElementSibling, PositionType.After));\n        }\n    }\n\n    editor.triggerContentChangedEvent(ChangeSource.InsertEntity, entity);\n\n    return entity;\n}\n"]}