import blockFormat from '../utils/blockFormat';
import execCommand from '../utils/execCommand';
import formatUndoSnapshot from '../utils/formatUndoSnapshot';
import normalizeBlockquote from '../utils/normalizeBlockquote';
import { createVListFromRegion, findClosestElementAncestor, getSelectedBlockElementsInRegion, isWholeTableSelected, VTable, } from 'roosterjs-editor-dom';
/**
 * Set content alignment
 * @param editor The editor instance
 * @param alignment The alignment option:
 * Alignment.Center, Alignment.Left, Alignment.Right
 */
export default function setAlignment(editor, alignment) {
    formatUndoSnapshot(editor, function () {
        var selection = editor.getSelectionRangeEx();
        var isATable = selection && selection.type === 1 /* TableSelection */;
        var elementAtCursor = editor.getElementAtCursor();
        if (isATable &&
            selection.coordinates &&
            isWholeTableSelected(new VTable(selection.table), selection.coordinates)) {
            alignTable(selection, alignment);
        }
        else if (elementAtCursor && isList(elementAtCursor)) {
            alignList(editor, alignment);
        }
        else {
            alignText(editor, alignment);
        }
    }, 'setAlignment');
}
/**
 * Align text using the margins
 * @param editor
 * @param element
 * @param alignment
 * @param addUndoSnapshot
 * @returns
 */
function alignTable(selection, alignment) {
    var table = selection.table;
    if (alignment == 1 /* Center */) {
        table.style.marginLeft = 'auto';
        table.style.marginRight = 'auto';
    }
    else if (alignment == 2 /* Right */) {
        table.style.marginLeft = 'auto';
        table.style.marginRight = '';
    }
    else {
        table.style.marginLeft = '';
        table.style.marginRight = 'auto';
    }
}
/**
 * Align text using the text-align
 * @param editor
 * @param alignment
 * @returns
 */
function alignText(editor, alignment) {
    var align = 'left';
    var command = "justifyLeft" /* JustifyLeft */;
    if (alignment == 1 /* Center */) {
        command = "justifyCenter" /* JustifyCenter */;
        align = 'center';
    }
    else if (alignment == 2 /* Right */) {
        command = "justifyRight" /* JustifyRight */;
        align = 'right';
    }
    execCommand(editor, command);
    var elements = editor.queryElements('[align]', 1 /* OnSelection */, function (node) {
        node.style.textAlign = align;
        normalizeBlockquote(node);
    });
    if (elements.length == 0) {
        var node = editor.getElementAtCursor();
        if (node) {
            normalizeBlockquote(node);
        }
    }
}
function isList(element) {
    return findClosestElementAncestor(element, undefined /** root */, 'LI');
}
function alignList(editor, alignment) {
    blockFormat(editor, function (region, start, end) {
        var blocks = getSelectedBlockElementsInRegion(region);
        var startNode = blocks[0].getStartNode();
        var vList = createVListFromRegion(region, true /*includeSiblingLists*/, startNode);
        if (start && end) {
            vList === null || vList === void 0 ? void 0 : vList.setAlignment(start, end, alignment);
        }
    }, undefined /* beforeRunCallback */, 'alignList');
}
//# sourceMappingURL=setAlignment.js.map