import { __values } from "tslib";
import applyListItemStyleWrap from '../utils/applyListItemWrap';
import blockFormat from '../utils/blockFormat';
import execCommand from '../utils/execCommand';
import formatUndoSnapshot from '../utils/formatUndoSnapshot';
import setBackgroundColor from './setBackgroundColor';
import setFontName from './setFontName';
import setFontSize from './setFontSize';
import setTextColor from './setTextColor';
import toggleBold from './toggleBold';
import toggleItalic from './toggleItalic';
import toggleUnderline from './toggleUnderline';
import { collapseNodesInRegion, getObjectKeys, getSelectedBlockElementsInRegion, getStyles, getTagOfNode, isBlockElement, isNodeInRegion, isVoidHtmlElement, PartialInlineElement, NodeInlineElement, safeInstanceOf, setStyles, splitBalancedNodeRange, toArray, unwrap, wrap, } from 'roosterjs-editor-dom';
var STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];
var TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(',');
var ATTRIBUTES_TO_PRESERVE = ['href', 'src', 'cellpadding', 'cellspacing'];
var TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];
/**
 * @param editor The editor instance
 * @returns if the current selection is composed of two or more block elements
 */
function isMultiBlockSelection(editor) {
    var transverser = editor.getSelectionTraverser();
    var blockElement = transverser === null || transverser === void 0 ? void 0 : transverser.currentBlockElement;
    if (!blockElement) {
        return false;
    }
    var nextBlockElement = transverser === null || transverser === void 0 ? void 0 : transverser.getNextBlockElement();
    //At least two blocks are selected
    return !!nextBlockElement;
}
function clearNodeFormat(node) {
    // 1. Recursively clear format of all its child nodes
    var areBlockElements = toArray(node.childNodes).map(clearNodeFormat);
    var areAllChildrenBlock = areBlockElements.every(function (b) { return b; });
    var returnBlockElement = isBlockElement(node);
    // 2. Unwrap the tag if necessary
    var tag = getTagOfNode(node);
    if (tag) {
        if (TAGS_TO_UNWRAP.indexOf(tag) >= 0 ||
            (areAllChildrenBlock &&
                !isVoidHtmlElement(node) &&
                TAGS_TO_STOP_UNWRAP.indexOf(tag) < 0)) {
            if (returnBlockElement && !areAllChildrenBlock) {
                wrap(node);
            }
            unwrap(node);
        }
        else {
            // 3. Otherwise, remove all attributes
            clearAttribute(node);
        }
    }
    return returnBlockElement;
}
function clearAttribute(element) {
    var e_1, _a;
    var isTableCell = safeInstanceOf(element, 'HTMLTableCellElement');
    var isTable = safeInstanceOf(element, 'HTMLTableElement');
    try {
        for (var _b = __values(toArray(element.attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var attr = _c.value;
            if (isTableCell && attr.name == 'style') {
                removeNonBorderStyles(element);
            }
            else if (isTable && attr.name == 'style') {
                removeNotTableDefaultStyles(element);
            }
            else if (ATTRIBUTES_TO_PRESERVE.indexOf(attr.name.toLowerCase()) < 0 &&
                attr.name.indexOf('data-') != 0) {
                element.removeAttribute(attr.name);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
function updateStyles(element, callbackfn) {
    var styles = getStyles(element);
    var result = {};
    getObjectKeys(styles).forEach(function (style) { return callbackfn(style, styles, result); });
    setStyles(element, styles);
    return result;
}
function removeNonBorderStyles(element) {
    return updateStyles(element, function (name, styles, result) {
        if (name.indexOf('border') < 0) {
            result[name] = styles[name];
            delete styles[name];
        }
    });
}
function removeNotTableDefaultStyles(element) {
    return updateStyles(element, function (name, styles, result) {
        if (name != 'border-collapse') {
            result[name] = styles[name];
            delete styles[name];
        }
    });
}
/**
 * Verifies recursively if a node and its parents have any siblings with text content
 * Ignoring the children of contentDiv and returning true if any node is LI
 * @returns `true` if this node, and its parents (minus the children of the contentDiv) have no siblings with text content
 */
function isNodeWholeBlock(node, editor) {
    var _a;
    var currentNode = node;
    var _loop_1 = function () {
        if (currentNode.nextSibling || currentNode.previousSibling) {
            if (safeInstanceOf(currentNode, 'HTMLLIElement')) {
                return { value: true };
            }
            var isOnlySiblingWithContent_1 = true;
            (_a = currentNode.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes.forEach(function (node) {
                var _a;
                if (node != currentNode && ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length)) {
                    isOnlySiblingWithContent_1 = false;
                }
            });
            return { value: isOnlySiblingWithContent_1 };
        }
        currentNode = currentNode.parentNode;
    };
    while (currentNode && editor.contains(currentNode.parentNode)) {
        var state_1 = _loop_1();
        if (typeof state_1 === "object")
            return state_1.value;
    }
    return true;
}
/**
 * Clear the format of the selected text or list of blocks
 * If the current selection is compose of multiple block elements then remove the text and struture format for all the selected blocks
 * If the current selection is compose of a partial inline element then only the text format is removed from the current selection
 * @param editor The editor instance
 */
function clearAutoDetectFormat(editor) {
    var isMultiBlock = isMultiBlockSelection(editor);
    if (!isMultiBlock) {
        var transverser = editor.getSelectionTraverser();
        var inlineElement = transverser === null || transverser === void 0 ? void 0 : transverser.currentInlineElement;
        var isPartial = inlineElement instanceof PartialInlineElement ||
            (inlineElement instanceof NodeInlineElement &&
                !isNodeWholeBlock(inlineElement.getContainerNode(), editor));
        if (isPartial) {
            clearFormat(editor);
            return;
        }
    }
    clearBlockFormat(editor);
}
/**
 * Clear all formats of selected blocks.
 * When selection is collapsed, only clear format of current block.
 * @param editor The editor instance
 */
function clearBlockFormat(editor) {
    formatUndoSnapshot(editor, function () {
        blockFormat(editor, function (region) {
            var blocks = getSelectedBlockElementsInRegion(region);
            var nodes = collapseNodesInRegion(region, blocks);
            if (editor.contains(region.rootNode)) {
                // If there are styles on table cell, wrap all its children and move down all non-border styles.
                // So that we can preserve styles for unselected blocks as well as border styles for table
                var nonborderStyles = removeNonBorderStyles(region.rootNode);
                if (getObjectKeys(nonborderStyles).length > 0) {
                    var wrapper = wrap(toArray(region.rootNode.childNodes));
                    setStyles(wrapper, nonborderStyles);
                }
            }
            while (nodes.length > 0 &&
                nodes[0].parentNode &&
                isNodeInRegion(region, nodes[0].parentNode)) {
                var balancedNodes = splitBalancedNodeRange(nodes);
                nodes = balancedNodes ? [balancedNodes] : [];
            }
            nodes.forEach(clearNodeFormat);
        });
        setDefaultFormat(editor);
    }, 'clearBlockFormat');
}
function clearInlineFormat(editor) {
    editor.focus();
    editor.addUndoSnapshot(function () {
        execCommand(editor, "removeFormat" /* RemoveFormat */);
        editor.queryElements('[class]', 1 /* OnSelection */, function (node) {
            return node.removeAttribute('class');
        });
        setDefaultFormat(editor);
        return 'clearInlineFormat';
    }, "Format" /* Format */);
}
function setDefaultFontWeight(editor, fontWeight) {
    if (fontWeight === void 0) { fontWeight = '400'; }
    applyListItemStyleWrap(editor, 'font-weight', function (element) { return (element.style.fontWeight = fontWeight); }, 'setDefaultFontWeight');
}
function setDefaultFormat(editor) {
    var defaultFormat = editor.getDefaultFormat();
    var isDefaultFormatEmpty = getObjectKeys(defaultFormat).length === 0;
    editor.queryElements('[style]', 2 /* InSelection */, function (node) {
        var tag = getTagOfNode(node);
        if (TAGS_TO_STOP_UNWRAP.indexOf(tag) == -1) {
            removeStyles(tag, node, isDefaultFormatEmpty);
        }
        else {
            node.childNodes.forEach(function (node) {
                node.childNodes.forEach(function (cNode) {
                    var tag = getTagOfNode(cNode);
                    if (safeInstanceOf(cNode, 'HTMLElement')) {
                        removeStyles(tag, cNode, isDefaultFormatEmpty);
                    }
                });
            });
        }
    });
    if (!isDefaultFormatEmpty) {
        if (defaultFormat.fontFamily) {
            setFontName(editor, defaultFormat.fontFamily);
        }
        if (defaultFormat.fontSize) {
            setFontSize(editor, defaultFormat.fontSize);
        }
        if (defaultFormat.textColor) {
            var setColorIgnoredElements_1 = editor.queryElements('a *, a', 1 /* OnSelection */);
            var shouldApplyInlineStyle = setColorIgnoredElements_1.length > 0
                ? function (element) { return setColorIgnoredElements_1.indexOf(element) == -1; }
                : undefined;
            if (defaultFormat.textColors) {
                setTextColor(editor, defaultFormat.textColors, shouldApplyInlineStyle);
            }
            else {
                setTextColor(editor, defaultFormat.textColor, shouldApplyInlineStyle);
            }
        }
        if (defaultFormat.backgroundColor) {
            if (defaultFormat.backgroundColors) {
                setBackgroundColor(editor, defaultFormat.backgroundColors);
            }
            else {
                setBackgroundColor(editor, defaultFormat.backgroundColor);
            }
        }
        if (defaultFormat.bold) {
            toggleBold(editor);
        }
        else {
            setDefaultFontWeight(editor);
        }
        if (defaultFormat.italic) {
            toggleItalic(editor);
        }
        if (defaultFormat.underline) {
            toggleUnderline(editor);
        }
    }
}
function removeStyles(tag, node, isDefaultFormatEmpty) {
    if (TAGS_TO_STOP_UNWRAP.indexOf(tag) == -1) {
        STYLES_TO_REMOVE.forEach(function (style) { return node.style.removeProperty(style); });
        // when default format is empty, keep the HTML minimum by removing style attribute if there's no style
        // (note: because default format is empty, we're not adding style back in)
        if (isDefaultFormatEmpty && node.getAttribute('style') === '') {
            node.removeAttribute('style');
        }
    }
}
/**
 * Clear the format in current selection, after cleaning, the format will be
 * changed to default format. The format that get cleaned include B/I/U/font name/
 * font size/text color/background color/align left/align right/align center/superscript/subscript
 * @param editor The editor instance
 * @param formatType type of format to apply
 */
export default function clearFormat(editor, formatType) {
    if (formatType === void 0) { formatType = 0 /* Inline */; }
    switch (formatType) {
        case 0 /* Inline */:
            clearInlineFormat(editor);
            break;
        case 1 /* Block */:
            clearBlockFormat(editor);
            break;
        default:
            clearAutoDetectFormat(editor);
    }
}
//# sourceMappingURL=clearFormat.js.map