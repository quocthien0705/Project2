import { __assign } from "tslib";
import { getTableFormatInfo, getTagOfNode, toArray } from 'roosterjs-editor-dom';
/**
 * Get element based Format State at cursor
 * @param editor The editor instance
 * @param event (Optional) The plugin event, it stores the event cached data for looking up.
 * In this function the event cache is used to get list state and heading level. If not passed,
 * it will query the node within selection to get the info
 * @returns An ElementBasedFormatState object
 */
export function getElementBasedFormatState(editor, event) {
    var listTag = getTagOfNode(editor.getElementAtCursor('OL,UL', undefined /*startFrom*/, event));
    // Check if selection is multiline, spans more than one block
    var range = editor.getSelectionRange();
    var multiline = false;
    if (range && !range.collapsed) {
        var startingBlock = editor.getBlockElementAtNode(range.startContainer);
        var endingBlock = editor.getBlockElementAtNode(range.endContainer);
        multiline = endingBlock && startingBlock ? !endingBlock.equals(startingBlock) : false;
    }
    var headingTag = getTagOfNode(editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', undefined /*startFrom*/, event));
    var table = editor.queryElements('table', 1 /* OnSelection */)[0];
    var tableFormat = table ? getTableFormatInfo(table) : undefined;
    var hasTableHeader = (table === null || table === void 0 ? void 0 : table.rows[0])
        ? toArray(table.rows[0].cells).every(function (cell) { return getTagOfNode(cell) == 'TH'; })
        : undefined;
    var headingLevel = (headingTag && parseInt(headingTag[1])) || 0;
    return {
        isBullet: listTag == 'UL',
        isNumbering: listTag == 'OL',
        isMultilineSelection: multiline,
        headingLevel: headingLevel,
        headerLevel: headingLevel,
        canUnlink: !!editor.queryElements('a[href]', 1 /* OnSelection */)[0],
        canAddImageAltText: !!editor.queryElements('img', 1 /* OnSelection */)[0],
        isBlockQuote: !!editor.queryElements('blockquote', 1 /* OnSelection */)[0],
        isCodeInline: !!editor.queryElements('code', 1 /* OnSelection */)[0],
        isCodeBlock: !!editor.queryElements('pre>code', 1 /* OnSelection */)[0],
        isInTable: !!table,
        tableFormat: tableFormat || {},
        tableHasHeader: hasTableHeader,
        canMergeTableCell: canMergeTableCell(editor),
    };
}
/**
 * Get format state at cursor
 * A format state is a collection of all format related states, e.g.,
 * bold, italic, underline, font name, font size, etc.
 * @param editor The editor instance
 * @param event (Optional) The plugin event, it stores the event cached data for looking up.
 * In this function the event cache is used to get list state and heading level. If not passed,
 * it will query the node within selection to get the info
 * @returns The format state at cursor
 */
export default function getFormatState(editor, event) {
    return __assign(__assign(__assign(__assign(__assign({}, editor.getPendableFormatState(false /* forceGetStateFromDom */)), getElementBasedFormatState(editor, event)), editor.getStyleBasedFormatState()), editor.getUndoState()), { isDarkMode: editor.isDarkMode(), zoomScale: editor.getZoomScale() });
}
/**
 * Checks whether the editor selection range is starting and ending at a table element.
 * @param editor Editor Instance
 * @returns
 */
var canMergeTableCell = function (editor) {
    var selection = editor.getSelectionRangeEx();
    var isATable = selection && selection.type === 1 /* TableSelection */;
    if (isATable && selection.coordinates) {
        var _a = selection.coordinates, firstCell = _a.firstCell, lastCell = _a.lastCell;
        if (firstCell.x !== lastCell.x || firstCell.y !== lastCell.y) {
            return true;
        }
        return false;
    }
    return false;
};
//# sourceMappingURL=getFormatState.js.map