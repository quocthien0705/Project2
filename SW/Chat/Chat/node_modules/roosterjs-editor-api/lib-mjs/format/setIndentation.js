import blockFormat from '../utils/blockFormat';
import normalizeBlockquote from '../utils/normalizeBlockquote';
import { collapseNodesInRegion, createVListFromRegion, findClosestElementAncestor, getSelectedBlockElementsInRegion, getTagOfNode, isNodeInRegion, isWholeTableSelected, splitBalancedNodeRange, toArray, unwrap, VTable, wrap, } from 'roosterjs-editor-dom';
/**
 * Set indentation at selection
 * If selection contains bullet/numbering list, increase/decrease indentation will
 * increase/decrease the list level by one.
 * @param editor The editor instance
 * @param indentation The indentation option:
 * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation
 */
export default function setIndentation(editor, indentation) {
    var handler = indentation == 0 /* Increase */ ? indent : outdent;
    blockFormat(editor, function (region, start, end) {
        var blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);
        var blockGroups = [[]];
        for (var i = 0; i < blocks.length; i++) {
            var startNode = blocks[i].getStartNode();
            var vList = createVListFromRegion(region, true /*includeSiblingLists*/, startNode);
            if (vList) {
                while (blocks[i + 1] && vList.contains(blocks[i + 1].getStartNode())) {
                    i++;
                }
                var isTabKeyTextFeaturesEnabled = editor.isFeatureEnabled("TabKeyTextFeatures" /* TabKeyTextFeatures */);
                if (isTabKeyTextFeaturesEnabled &&
                    isFirstItem(vList, startNode) &&
                    shouldHandleWithBlockquotes(indentation, editor, startNode)) {
                    var block = editor.getBlockElementAtNode(vList.rootList);
                    if (block) {
                        blockGroups.push([block]);
                    }
                }
                else {
                    if (start && end) {
                        indentation == 1 /* Decrease */
                            ? vList.setIndentation(start, end, indentation, false /* softOutdent */, isTabKeyTextFeaturesEnabled /* preventItemRemoval */)
                            : vList.setIndentation(start, end, indentation);
                        vList.writeBack(editor.isFeatureEnabled("ReuseAllAncestorListElements" /* ReuseAllAncestorListElements */), editor.isFeatureEnabled("DisableListChain" /* DisableListChain */));
                        blockGroups.push([]);
                    }
                }
            }
            else {
                blockGroups[blockGroups.length - 1].push(blocks[i]);
            }
        }
        blockGroups.forEach(function (group) { return handler(region, group); });
    }, function () {
        var selection = editor.getSelectionRangeEx();
        if (selection.type == 1 /* TableSelection */ &&
            selection.coordinates &&
            isWholeTableSelected(new VTable(selection.table), selection.coordinates)) {
            if (indentation == 1 /* Decrease */) {
                var quote = editor.getElementAtCursor('blockquote', selection.table);
                if (quote) {
                    unwrap(quote);
                }
            }
            else if (indentation == 0 /* Increase */) {
                wrap(selection.table, 2 /* BlockquoteWrapper */);
            }
            return false;
        }
        return true;
    }, 'setIndentation');
    function indent(region, blocks) {
        var nodes = collapseNodesInRegion(region, blocks);
        wrap(nodes, 2 /* BlockquoteWrapper */);
        var quotesHandled = [];
        nodes.forEach(function (node) { return normalizeBlockquote(node, quotesHandled); });
    }
}
function outdent(region, blocks) {
    blocks.forEach(function (blockElement) {
        var node = blockElement.collapseToSingleElement();
        var quote = findClosestElementAncestor(node, region.rootNode, 'blockquote');
        if (quote) {
            if (node == quote) {
                node = wrap(toArray(node.childNodes));
            }
            while (node && isNodeInRegion(region, node) && getTagOfNode(node) != 'BLOCKQUOTE') {
                node = splitBalancedNodeRange(node);
            }
            if (node && isNodeInRegion(region, node)) {
                unwrap(node);
            }
        }
    });
}
function isFirstItem(vList, startNode) {
    var _a;
    return (((_a = vList.items[0]) === null || _a === void 0 ? void 0 : _a.getNode()) == startNode &&
        vList.getListItemIndex(startNode) == (vList.getStart() || 1));
}
function shouldHandleWithBlockquotes(indentation, editor, startNode) {
    return (indentation == 0 /* Increase */ || editor.getElementAtCursor('blockquote', startNode));
}
//# sourceMappingURL=setIndentation.js.map