{"version":3,"file":"insertNode.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-core/lib/coreApi/insertNode.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n    BlockElement,\n    EditorCore,\n    InsertNode,\n    InsertOption,\n    NodePosition,\n} from 'roosterjs-editor-types';\nimport {\n    ContentPosition,\n    ColorTransformDirection,\n    NodeType,\n    PositionType,\n    RegionType,\n} from 'roosterjs-editor-types';\nimport {\n    createRange,\n    getBlockElementAtNode,\n    getFirstLastBlockElement,\n    isBlockElement,\n    isVoidHtmlElement,\n    Position,\n    safeInstanceOf,\n    toArray,\n    wrap,\n    adjustInsertPosition,\n    getRegionsFromRange,\n    splitTextNode,\n    splitParentNode,\n} from 'roosterjs-editor-dom';\n\nfunction getInitialRange(\n    core: EditorCore,\n    option: InsertOption\n): { range: Range | null; rangeToRestore: Range | null } {\n    // Selection start replaces based on the current selection.\n    // Range inserts based on a provided range.\n    // Both have the potential to use the current selection to restore cursor position\n    // So in both cases we need to store the selection state.\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n    let rangeToRestore = null;\n    if (option.position == ContentPosition.Range) {\n        rangeToRestore = range;\n        range = option.range;\n    } else if (range) {\n        rangeToRestore = range.cloneRange();\n    }\n\n    return { range, rangeToRestore };\n}\n\n/**\n * @internal\n * Insert a DOM node into editor content\n * @param core The EditorCore object. No op if null.\n * @param option An insert option object to specify how to insert the node\n */\nexport const insertNode: InsertNode = (\n    core: EditorCore,\n    node: Node,\n    option: InsertOption | null\n) => {\n    option = option || {\n        position: ContentPosition.SelectionStart,\n        insertOnNewLine: false,\n        updateCursor: true,\n        replaceSelection: true,\n        insertToRegionRoot: false,\n    };\n    const contentDiv = core.contentDiv;\n\n    if (option.updateCursor) {\n        core.api.focus(core);\n    }\n\n    if (option.position == ContentPosition.Outside) {\n        contentDiv.parentNode?.insertBefore(node, contentDiv.nextSibling);\n        return true;\n    }\n\n    core.api.transformColor(\n        core,\n        node,\n        true /*includeSelf*/,\n        () => {\n            if (!option) {\n                return;\n            }\n            switch (option.position) {\n                case ContentPosition.Begin:\n                case ContentPosition.End: {\n                    const isBegin = option.position == ContentPosition.Begin;\n                    const block = getFirstLastBlockElement(contentDiv, isBegin);\n                    let insertedNode: Node | Node[] | undefined;\n                    if (block) {\n                        const refNode = isBegin ? block.getStartNode() : block.getEndNode();\n                        if (\n                            option.insertOnNewLine ||\n                            refNode.nodeType == NodeType.Text ||\n                            isVoidHtmlElement(refNode)\n                        ) {\n                            // For insert on new line, or refNode is text or void html element (HR, BR etc.)\n                            // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\n                            // first and last node. Insert before 'hello' or after 'world', but still inside DIV\n                            if (safeInstanceOf(node, 'DocumentFragment')) {\n                                // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode\n                                // because insertBefore() returns an empty DocumentFragment\n                                insertedNode = toArray(node.childNodes);\n                                refNode.parentNode?.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            } else {\n                                insertedNode = refNode.parentNode?.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            }\n                        } else {\n                            // if the refNode can have child, use appendChild (which is like to insert as first/last child)\n                            // i.e. <div>hello</div>, the content will be inserted before/after hello\n                            insertedNode = refNode.insertBefore(\n                                node,\n                                isBegin ? refNode.firstChild : null\n                            );\n                        }\n                    } else {\n                        // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\n                        insertedNode = contentDiv.appendChild(node);\n                    }\n\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine) {\n                        const nodes = Array.isArray(insertedNode) ? insertedNode : [insertedNode];\n                        if (!isBlockElement(nodes[0]) || !isBlockElement(nodes[nodes.length - 1])) {\n                            wrap(nodes);\n                        }\n                    }\n\n                    break;\n                }\n                case ContentPosition.DomEnd:\n                    // Use appendChild to insert the node at the end of the content div.\n                    const insertedNode = contentDiv.appendChild(node);\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\n                        wrap(insertedNode);\n                    }\n                    break;\n                case ContentPosition.Range:\n                case ContentPosition.SelectionStart:\n                    let { range, rangeToRestore } = getInitialRange(core, option);\n                    if (!range) {\n                        return;\n                    }\n\n                    // if to replace the selection and the selection is not collapsed, remove the the content at selection first\n                    if (option.replaceSelection && !range.collapsed) {\n                        range.deleteContents();\n                    }\n\n                    let pos: NodePosition = Position.getStart(range);\n                    let blockElement: BlockElement | null;\n\n                    if (option.insertOnNewLine && option.insertToRegionRoot) {\n                        pos = adjustInsertPositionRegionRoot(core, range, pos);\n                    } else if (\n                        option.insertOnNewLine &&\n                        (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\n                    ) {\n                        pos = adjustInsertPositionNewLine(blockElement, core, pos);\n                    } else {\n                        pos = adjustInsertPosition(contentDiv, node, pos, range);\n                    }\n\n                    const nodeForCursor =\n                        node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\n\n                    range = createRange(pos);\n                    range.insertNode(node);\n\n                    if (option.updateCursor && nodeForCursor) {\n                        rangeToRestore = createRange(\n                            new Position(nodeForCursor, PositionType.After).normalize()\n                        );\n                    }\n\n                    if (rangeToRestore) {\n                        core.api.selectRange(core, rangeToRestore);\n                    }\n\n                    break;\n            }\n        },\n        ColorTransformDirection.LightToDark\n    );\n\n    return true;\n};\n\nfunction adjustInsertPositionRegionRoot(core: EditorCore, range: Range, position: NodePosition) {\n    const region = getRegionsFromRange(core.contentDiv, range, RegionType.Table)[0];\n    let node: Node | null = position.node;\n\n    if (region) {\n        if (node.nodeType == NodeType.Text && !position.isAtEnd) {\n            node = splitTextNode(node as Text, position.offset, true /*returnFirstPart*/);\n        }\n\n        if (node != region.rootNode) {\n            while (node && node.parentNode != region.rootNode) {\n                splitParentNode(node, false /*splitBefore*/);\n                node = node.parentNode;\n            }\n        }\n\n        if (node) {\n            position = new Position(node, PositionType.After);\n        }\n    }\n\n    return position;\n}\n\nfunction adjustInsertPositionNewLine(blockElement: BlockElement, core: EditorCore, pos: Position) {\n    let tempPos = new Position(blockElement.getEndNode(), PositionType.After);\n    if (safeInstanceOf(tempPos.node, 'HTMLTableRowElement')) {\n        const div = core.contentDiv.ownerDocument.createElement('div');\n        const range = createRange(pos);\n        range.insertNode(div);\n        tempPos = new Position(div, PositionType.Begin);\n    }\n    return tempPos;\n}\n"]}