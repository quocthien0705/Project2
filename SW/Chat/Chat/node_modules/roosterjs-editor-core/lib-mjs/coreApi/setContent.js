import { createRange, extractContentMetadata, queryElements, restoreContentWithEntityPlaceholder, } from 'roosterjs-editor-dom';
/**
 * @internal
 * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered
 * if triggerContentChangedEvent is set to true
 * @param core The EditorCore object
 * @param content HTML content to set in
 * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true
 * @param metadata @optional Metadata of the content that helps editor know the selection and color mode.
 * If not passed, we will treat content as in light mode without selection
 */
export var setContent = function (core, content, triggerContentChangedEvent, metadata) {
    var _a, _b;
    var contentChanged = false;
    if (core.contentDiv.innerHTML != content) {
        core.api.triggerEvent(core, {
            eventType: 20 /* BeforeSetContent */,
            newContent: content,
        }, true /*broadcast*/);
        var entities = core.entity.entityMap;
        var html = content || '';
        var body = new DOMParser().parseFromString((_b = (_a = core.trustedHTMLHandler) === null || _a === void 0 ? void 0 : _a.call(core, html)) !== null && _b !== void 0 ? _b : html, 'text/html').body;
        restoreContentWithEntityPlaceholder(body, core.contentDiv, entities);
        var metadataFromContent = extractContentMetadata(core.contentDiv);
        metadata = metadata || metadataFromContent;
        selectContentMetadata(core, metadata);
        contentChanged = true;
    }
    var isDarkMode = core.lifecycle.isDarkMode;
    if ((!metadata && isDarkMode) || (metadata && !!metadata.isDarkMode != !!isDarkMode)) {
        core.api.transformColor(core, core.contentDiv, false /*includeSelf*/, null /*callback*/, isDarkMode ? 0 /* LightToDark */ : 1 /* DarkToLight */, true /*forceTransform*/, metadata === null || metadata === void 0 ? void 0 : metadata.isDarkMode);
        contentChanged = true;
    }
    if (triggerContentChangedEvent && contentChanged) {
        core.api.triggerEvent(core, {
            eventType: 7 /* ContentChanged */,
            source: "SetContent" /* SetContent */,
        }, false /*broadcast*/);
    }
};
function selectContentMetadata(core, metadata) {
    if (!core.lifecycle.shadowEditSelectionPath && metadata) {
        core.domEvent.tableSelectionRange = null;
        core.domEvent.imageSelectionRange = null;
        core.domEvent.selectionRange = null;
        switch (metadata.type) {
            case 0 /* Normal */:
                core.api.selectTable(core, null);
                core.api.selectImage(core, null);
                var range = createRange(core.contentDiv, metadata.start, metadata.end);
                core.api.selectRange(core, range);
                break;
            case 1 /* TableSelection */:
                var table = queryElements(core.contentDiv, '#' + metadata.tableId)[0];
                if (table) {
                    core.domEvent.tableSelectionRange = core.api.selectTable(core, table, metadata);
                }
                break;
            case 2 /* ImageSelection */:
                var image = queryElements(core.contentDiv, '#' + metadata.imageId)[0];
                if (image) {
                    core.domEvent.imageSelectionRange = core.api.selectImage(core, image);
                }
                break;
        }
    }
}
//# sourceMappingURL=setContent.js.map