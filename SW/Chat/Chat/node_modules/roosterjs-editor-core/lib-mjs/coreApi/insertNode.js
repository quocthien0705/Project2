import { createRange, getBlockElementAtNode, getFirstLastBlockElement, isBlockElement, isVoidHtmlElement, Position, safeInstanceOf, toArray, wrap, adjustInsertPosition, getRegionsFromRange, splitTextNode, splitParentNode, } from 'roosterjs-editor-dom';
function getInitialRange(core, option) {
    // Selection start replaces based on the current selection.
    // Range inserts based on a provided range.
    // Both have the potential to use the current selection to restore cursor position
    // So in both cases we need to store the selection state.
    var range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);
    var rangeToRestore = null;
    if (option.position == 5 /* Range */) {
        rangeToRestore = range;
        range = option.range;
    }
    else if (range) {
        rangeToRestore = range.cloneRange();
    }
    return { range: range, rangeToRestore: rangeToRestore };
}
/**
 * @internal
 * Insert a DOM node into editor content
 * @param core The EditorCore object. No op if null.
 * @param option An insert option object to specify how to insert the node
 */
export var insertNode = function (core, node, option) {
    var _a;
    option = option || {
        position: 3 /* SelectionStart */,
        insertOnNewLine: false,
        updateCursor: true,
        replaceSelection: true,
        insertToRegionRoot: false,
    };
    var contentDiv = core.contentDiv;
    if (option.updateCursor) {
        core.api.focus(core);
    }
    if (option.position == 4 /* Outside */) {
        (_a = contentDiv.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(node, contentDiv.nextSibling);
        return true;
    }
    core.api.transformColor(core, node, true /*includeSelf*/, function () {
        var _a, _b;
        if (!option) {
            return;
        }
        switch (option.position) {
            case 0 /* Begin */:
            case 1 /* End */: {
                var isBegin = option.position == 0 /* Begin */;
                var block = getFirstLastBlockElement(contentDiv, isBegin);
                var insertedNode_1;
                if (block) {
                    var refNode = isBegin ? block.getStartNode() : block.getEndNode();
                    if (option.insertOnNewLine ||
                        refNode.nodeType == 3 /* Text */ ||
                        isVoidHtmlElement(refNode)) {
                        // For insert on new line, or refNode is text or void html element (HR, BR etc.)
                        // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the
                        // first and last node. Insert before 'hello' or after 'world', but still inside DIV
                        if (safeInstanceOf(node, 'DocumentFragment')) {
                            // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode
                            // because insertBefore() returns an empty DocumentFragment
                            insertedNode_1 = toArray(node.childNodes);
                            (_a = refNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(node, isBegin ? refNode : refNode.nextSibling);
                        }
                        else {
                            insertedNode_1 = (_b = refNode.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(node, isBegin ? refNode : refNode.nextSibling);
                        }
                    }
                    else {
                        // if the refNode can have child, use appendChild (which is like to insert as first/last child)
                        // i.e. <div>hello</div>, the content will be inserted before/after hello
                        insertedNode_1 = refNode.insertBefore(node, isBegin ? refNode.firstChild : null);
                    }
                }
                else {
                    // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv
                    insertedNode_1 = contentDiv.appendChild(node);
                }
                // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,
                // add a DIV wrapping
                if (insertedNode_1 && option.insertOnNewLine) {
                    var nodes = Array.isArray(insertedNode_1) ? insertedNode_1 : [insertedNode_1];
                    if (!isBlockElement(nodes[0]) || !isBlockElement(nodes[nodes.length - 1])) {
                        wrap(nodes);
                    }
                }
                break;
            }
            case 2 /* DomEnd */:
                // Use appendChild to insert the node at the end of the content div.
                var insertedNode = contentDiv.appendChild(node);
                // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,
                // add a DIV wrapping
                if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {
                    wrap(insertedNode);
                }
                break;
            case 5 /* Range */:
            case 3 /* SelectionStart */:
                var _c = getInitialRange(core, option), range = _c.range, rangeToRestore = _c.rangeToRestore;
                if (!range) {
                    return;
                }
                // if to replace the selection and the selection is not collapsed, remove the the content at selection first
                if (option.replaceSelection && !range.collapsed) {
                    range.deleteContents();
                }
                var pos = Position.getStart(range);
                var blockElement = void 0;
                if (option.insertOnNewLine && option.insertToRegionRoot) {
                    pos = adjustInsertPositionRegionRoot(core, range, pos);
                }
                else if (option.insertOnNewLine &&
                    (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))) {
                    pos = adjustInsertPositionNewLine(blockElement, core, pos);
                }
                else {
                    pos = adjustInsertPosition(contentDiv, node, pos, range);
                }
                var nodeForCursor = node.nodeType == 11 /* DocumentFragment */ ? node.lastChild : node;
                range = createRange(pos);
                range.insertNode(node);
                if (option.updateCursor && nodeForCursor) {
                    rangeToRestore = createRange(new Position(nodeForCursor, -3 /* After */).normalize());
                }
                if (rangeToRestore) {
                    core.api.selectRange(core, rangeToRestore);
                }
                break;
        }
    }, 0 /* LightToDark */);
    return true;
};
function adjustInsertPositionRegionRoot(core, range, position) {
    var region = getRegionsFromRange(core.contentDiv, range, 0 /* Table */)[0];
    var node = position.node;
    if (region) {
        if (node.nodeType == 3 /* Text */ && !position.isAtEnd) {
            node = splitTextNode(node, position.offset, true /*returnFirstPart*/);
        }
        if (node != region.rootNode) {
            while (node && node.parentNode != region.rootNode) {
                splitParentNode(node, false /*splitBefore*/);
                node = node.parentNode;
            }
        }
        if (node) {
            position = new Position(node, -3 /* After */);
        }
    }
    return position;
}
function adjustInsertPositionNewLine(blockElement, core, pos) {
    var tempPos = new Position(blockElement.getEndNode(), -3 /* After */);
    if (safeInstanceOf(tempPos.node, 'HTMLTableRowElement')) {
        var div = core.contentDiv.ownerDocument.createElement('div');
        var range = createRange(pos);
        range.insertNode(div);
        tempPos = new Position(div, 0 /* Begin */);
    }
    return tempPos;
}
//# sourceMappingURL=insertNode.js.map