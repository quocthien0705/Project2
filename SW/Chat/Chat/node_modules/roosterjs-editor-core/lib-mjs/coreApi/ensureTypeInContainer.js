import { applyFormat, createElement, createRange, findClosestElementAncestor, getBlockElementAtNode, isNodeEmpty, Position, safeInstanceOf, } from 'roosterjs-editor-dom';
/**
 * @internal
 * When typing goes directly under content div, many things can go wrong
 * We fix it by wrapping it with a div and reposition cursor within the div
 */
export var ensureTypeInContainer = function (core, position, keyboardEvent) {
    var table = findClosestElementAncestor(position.node, core.contentDiv, 'table');
    var td;
    if (table && (td = table.querySelector('td,th'))) {
        position = new Position(td, 0 /* Begin */);
    }
    position = position.normalize();
    var block = getBlockElementAtNode(core.contentDiv, position.node);
    var formatNode;
    if (block) {
        formatNode = block.collapseToSingleElement();
        if (isNodeEmpty(formatNode, false /* trimContent */, true /* shouldCountBrAsVisible */)) {
            var brEl = formatNode.ownerDocument.createElement('br');
            formatNode.append(brEl);
        }
        // if the block is empty, apply default format
        // Otherwise, leave it as it is as we don't want to change the style for existing data
        // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)
        var shouldSetNodeStyles = isNodeEmpty(formatNode) ||
            (keyboardEvent && wasNodeJustCreatedByKeyboardEvent(keyboardEvent, formatNode));
        formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;
    }
    else {
        // Only reason we don't get the selection block is that we have an empty content div
        // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)
        // The fix is to add a DIV wrapping, apply default format and move cursor over
        formatNode = createElement(1 /* EmptyLine */, core.contentDiv.ownerDocument);
        core.api.insertNode(core, formatNode, {
            position: 1 /* End */,
            updateCursor: false,
            replaceSelection: false,
            insertOnNewLine: false,
        });
        // element points to a wrapping node we added "<div><br></div>". We should move the selection left to <br>
        position = new Position(formatNode, 0 /* Begin */);
    }
    if (formatNode && core.lifecycle.defaultFormat) {
        applyFormat(formatNode, core.lifecycle.defaultFormat, core.lifecycle.isDarkMode, core.darkColorHandler);
    }
    // If this is triggered by a keyboard event, let's select the new position
    if (keyboardEvent) {
        core.api.selectRange(core, createRange(new Position(position)));
    }
};
function wasNodeJustCreatedByKeyboardEvent(event, formatNode) {
    return (safeInstanceOf(event.target, 'Node') &&
        event.target.contains(formatNode) &&
        event.key === formatNode.innerText);
}
//# sourceMappingURL=ensureTypeInContainer.js.map