import { arrayPush, Browser, isCharacterValue } from 'roosterjs-editor-dom';
/**
 * @internal
 * DOMEventPlugin handles customized DOM events, including:
 * 1. Keyboard event
 * 2. Mouse event
 * 3. IME state
 * 4. Drop event
 * 5. Focus and blur event
 * 6. Input event
 * 7. Scroll event
 * It contains special handling for Safari since Safari cannot get correct selection when onBlur event is triggered in editor.
 */
var DOMEventPlugin = /** @class */ (function () {
    /**
     * Construct a new instance of DOMEventPlugin
     * @param options The editor options
     * @param contentDiv The editor content DIV
     */
    function DOMEventPlugin(options, contentDiv) {
        var _this = this;
        var _a;
        this.editor = null;
        this.disposer = null;
        this.onDragStart = function (e) {
            var _a;
            var dragEvent = e;
            var element = (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.getElementAtCursor('*', dragEvent.target);
            if (element && !element.isContentEditable) {
                dragEvent.preventDefault();
            }
        };
        this.onDrop = function () {
            var _a;
            (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.runAsync(function (editor) {
                editor.addUndoSnapshot(function () { }, "Drop" /* Drop */);
            });
        };
        this.onFocus = function () {
            var _a, _b, _c;
            if (!_this.state.skipReselectOnFocus) {
                var _d = _this.state.tableSelectionRange || {}, table = _d.table, coordinates = _d.coordinates;
                var image = (_this.state.imageSelectionRange || {}).image;
                if (table && coordinates) {
                    (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.select(table, coordinates);
                }
                else if (image) {
                    (_b = _this.editor) === null || _b === void 0 ? void 0 : _b.select(image);
                }
                else if (_this.state.selectionRange) {
                    (_c = _this.editor) === null || _c === void 0 ? void 0 : _c.select(_this.state.selectionRange);
                }
            }
            if (!Browser.isSafari) {
                _this.state.selectionRange = null;
            }
        };
        this.onSelectionChangeSafari = function () {
            var _a;
            // Safari has problem to handle onBlur event. When blur, we cannot get the original selection from editor.
            // So we always save a selection whenever editor has focus. Then after blur, we can still use this cached selection.
            if (((_a = _this.editor) === null || _a === void 0 ? void 0 : _a.hasFocus()) && !_this.editor.isInShadowEdit()) {
                _this.state.selectionRange = _this.editor.getSelectionRange(false /*tryGetFromCache*/);
            }
        };
        this.cacheSelection = function () {
            if (!_this.state.selectionRange && _this.editor) {
                _this.state.selectionRange = _this.editor.getSelectionRange(false /*tryGetFromCache*/);
            }
        };
        this.onScroll = function (e) {
            var _a;
            (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.triggerPluginEvent(14 /* Scroll */, {
                rawEvent: e,
                scrollContainer: _this.state.scrollContainer,
            });
        };
        this.onKeyboardEvent = function (event) {
            if (isCharacterValue(event) || (event.which >= 33 /* PAGEUP */ && event.which <= 40 /* DOWN */)) {
                // Stop propagation for Character keys and Up/Down/Left/Right/Home/End/PageUp/PageDown
                // since editor already handles these keys and no need to propagate to parents
                event.stopPropagation();
            }
        };
        this.onInputEvent = function (event) {
            event.stopPropagation();
        };
        this.onContextMenuEvent = function (event) {
            var _a, _b;
            var allItems = [];
            var searcher = (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.getContentSearcherOfCursor();
            var elementBeforeCursor = searcher === null || searcher === void 0 ? void 0 : searcher.getInlineElementBefore();
            var eventTargetNode = event.target;
            if (event.button != 2 && elementBeforeCursor) {
                eventTargetNode = elementBeforeCursor.getContainerNode();
            }
            _this.state.contextMenuProviders.forEach(function (provider) {
                var _a;
                var items = (_a = provider.getContextMenuItems(eventTargetNode)) !== null && _a !== void 0 ? _a : [];
                if ((items === null || items === void 0 ? void 0 : items.length) > 0) {
                    if (allItems.length > 0) {
                        allItems.push(null);
                    }
                    arrayPush(allItems, items);
                }
            });
            (_b = _this.editor) === null || _b === void 0 ? void 0 : _b.triggerPluginEvent(16 /* ContextMenu */, {
                rawEvent: event,
                items: allItems,
            });
        };
        this.state = {
            isInIME: false,
            scrollContainer: options.scrollContainer || contentDiv,
            selectionRange: null,
            stopPrintableKeyboardEventPropagation: !options.allowKeyboardEventPropagation,
            contextMenuProviders: ((_a = options.plugins) === null || _a === void 0 ? void 0 : _a.filter(isContextMenuProvider)) || [],
            tableSelectionRange: null,
            imageSelectionRange: null,
        };
    }
    /**
     * Get a friendly name of  this plugin
     */
    DOMEventPlugin.prototype.getName = function () {
        return 'DOMEvent';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    DOMEventPlugin.prototype.initialize = function (editor) {
        var _a;
        var _this = this;
        var _b, _c;
        this.editor = editor;
        var document = this.editor.getDocument();
        //Record<string, DOMEventHandler>
        var eventHandlers = (_a = {
                // 1. Keyboard event
                keypress: this.getEventHandler(1 /* KeyPress */),
                keydown: this.getEventHandler(0 /* KeyDown */),
                keyup: this.getEventHandler(2 /* KeyUp */),
                // 2. Mouse event
                mousedown: 5 /* MouseDown */,
                contextmenu: this.onContextMenuEvent,
                // 3. IME state management
                compositionstart: function () { return (_this.state.isInIME = true); },
                compositionend: function (rawEvent) {
                    _this.state.isInIME = false;
                    editor.triggerPluginEvent(4 /* CompositionEnd */, {
                        rawEvent: rawEvent,
                    });
                },
                // 4. Drag and Drop event
                dragstart: this.onDragStart,
                drop: this.onDrop,
                // 5. Focus management
                focus: this.onFocus
            },
            // 6. Input event
            _a[Browser.isIE ? 'textinput' : 'input'] = this.getEventHandler(3 /* Input */),
            _a);
        // 7. onBlur handlers
        if (Browser.isSafari) {
            document.addEventListener('selectionchange', this.onSelectionChangeSafari);
        }
        else if (Browser.isIEOrEdge) {
            eventHandlers.beforedeactivate = this.cacheSelection;
        }
        else {
            eventHandlers.blur = this.cacheSelection;
        }
        this.disposer = editor.addDomEventHandler(eventHandlers);
        // 8. Scroll event
        this.state.scrollContainer.addEventListener('scroll', this.onScroll);
        (_b = document.defaultView) === null || _b === void 0 ? void 0 : _b.addEventListener('scroll', this.onScroll);
        (_c = document.defaultView) === null || _c === void 0 ? void 0 : _c.addEventListener('resize', this.onScroll);
    };
    /**
     * Dispose this plugin
     */
    DOMEventPlugin.prototype.dispose = function () {
        var _a, _b, _c, _d;
        var document = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getDocument();
        if (document && Browser.isSafari) {
            document.removeEventListener('selectionchange', this.onSelectionChangeSafari);
        }
        (_b = document === null || document === void 0 ? void 0 : document.defaultView) === null || _b === void 0 ? void 0 : _b.removeEventListener('resize', this.onScroll);
        (_c = document === null || document === void 0 ? void 0 : document.defaultView) === null || _c === void 0 ? void 0 : _c.removeEventListener('scroll', this.onScroll);
        this.state.scrollContainer.removeEventListener('scroll', this.onScroll);
        (_d = this.disposer) === null || _d === void 0 ? void 0 : _d.call(this);
        this.disposer = null;
        this.editor = null;
    };
    /**
     * Get plugin state object
     */
    DOMEventPlugin.prototype.getState = function () {
        return this.state;
    };
    DOMEventPlugin.prototype.getEventHandler = function (eventType) {
        var _this = this;
        var beforeDispatch = function (event) {
            return eventType == 3 /* Input */
                ? _this.onInputEvent(event)
                : _this.onKeyboardEvent(event);
        };
        return this.state.stopPrintableKeyboardEventPropagation
            ? {
                pluginEventType: eventType,
                beforeDispatch: beforeDispatch,
            }
            : eventType;
    };
    return DOMEventPlugin;
}());
export default DOMEventPlugin;
function isContextMenuProvider(source) {
    var _a;
    return !!((_a = source) === null || _a === void 0 ? void 0 : _a.getContextMenuItems);
}
//# sourceMappingURL=DOMEventPlugin.js.map