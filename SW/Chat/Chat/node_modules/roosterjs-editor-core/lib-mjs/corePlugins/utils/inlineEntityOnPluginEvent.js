import { addDelimiters, arrayPush, createRange, getDelimiterFromElement, getEntityFromElement, getEntitySelector, isBlockElement, isCharacterValue, matchesSelector, Position, safeInstanceOf, splitTextNode, } from 'roosterjs-editor-dom';
var DELIMITER_SELECTOR = '.' + "entityDelimiterAfter" /* DELIMITER_AFTER */ + ',.' + "entityDelimiterBefore" /* DELIMITER_BEFORE */;
var ZERO_WIDTH_SPACE = '\u200B';
var INLINE_ENTITY_SELECTOR = 'span' + getEntitySelector();
/**
 * @internal
 */
export function inlineEntityOnPluginEvent(event, editor) {
    switch (event.eventType) {
        case 7 /* ContentChanged */:
            if (event.source === "SetContent" /* SetContent */) {
                normalizeDelimitersInEditor(editor);
            }
            break;
        case 11 /* EditorReady */:
            normalizeDelimitersInEditor(editor);
            break;
        case 10 /* BeforePaste */:
            var fragment = event.fragment, sanitizingOption = event.sanitizingOption;
            addDelimitersIfNeeded(fragment.querySelectorAll(INLINE_ENTITY_SELECTOR));
            if (sanitizingOption.additionalAllowedCssClasses) {
                arrayPush(sanitizingOption.additionalAllowedCssClasses, [
                    "entityDelimiterAfter" /* DELIMITER_AFTER */,
                    "entityDelimiterBefore" /* DELIMITER_BEFORE */,
                ]);
            }
            break;
        case 8 /* ExtractContentWithDom */:
        case 9 /* BeforeCutCopy */:
            event.clonedRoot.querySelectorAll(DELIMITER_SELECTOR).forEach(function (node) {
                if (getDelimiterFromElement(node)) {
                    removeNode(node);
                }
                else {
                    removeDelimiterAttr(node);
                }
            });
            break;
        case 0 /* KeyDown */:
            handleKeyDownEvent(editor, event);
            break;
    }
}
function preventTypeInDelimiter(delimiter) {
    var _a, _b, _c, _d;
    delimiter.normalize();
    var textNode = delimiter.firstChild;
    var index = (_b = (_a = textNode.nodeValue) === null || _a === void 0 ? void 0 : _a.indexOf(ZERO_WIDTH_SPACE)) !== null && _b !== void 0 ? _b : -1;
    if (index >= 0) {
        splitTextNode(textNode, index == 0 ? 1 : index, false /* returnFirstPart */);
        var nodeToMove_1;
        delimiter.childNodes.forEach(function (node) {
            if (node.nodeValue !== ZERO_WIDTH_SPACE) {
                nodeToMove_1 = node;
            }
        });
        if (nodeToMove_1) {
            (_c = delimiter.parentElement) === null || _c === void 0 ? void 0 : _c.insertBefore(nodeToMove_1, delimiter.className == "entityDelimiterBefore" /* DELIMITER_BEFORE */
                ? delimiter
                : delimiter.nextSibling);
            var selection = (_d = nodeToMove_1.ownerDocument) === null || _d === void 0 ? void 0 : _d.getSelection();
            if (selection) {
                selection.setPosition(nodeToMove_1, new Position(nodeToMove_1, -1 /* End */).offset);
            }
        }
    }
}
/**
 * @internal
 */
export function normalizeDelimitersInEditor(editor) {
    removeInvalidDelimiters(editor.queryElements(DELIMITER_SELECTOR));
    addDelimitersIfNeeded(editor.queryElements(INLINE_ENTITY_SELECTOR));
}
function addDelimitersIfNeeded(nodes) {
    nodes.forEach(function (node) {
        if (isEntityElement(node)) {
            addDelimiters(node);
        }
    });
}
function isEntityElement(node) {
    return !!(node &&
        safeInstanceOf(node, 'HTMLElement') &&
        isReadOnly(getEntityFromElement(node)));
}
function removeNode(el) {
    var _a;
    (_a = el === null || el === void 0 ? void 0 : el.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(el);
}
function isReadOnly(entity) {
    return ((entity === null || entity === void 0 ? void 0 : entity.isReadonly) &&
        !isBlockElement(entity.wrapper) &&
        safeInstanceOf(entity.wrapper, 'HTMLElement'));
}
function removeInvalidDelimiters(nodes) {
    nodes.forEach(function (node) {
        if (getDelimiterFromElement(node)) {
            var sibling = node.classList.contains("entityDelimiterBefore" /* DELIMITER_BEFORE */)
                ? node.nextElementSibling
                : node.previousElementSibling;
            if (!(safeInstanceOf(sibling, 'HTMLElement') && getEntityFromElement(sibling))) {
                removeNode(node);
            }
        }
        else {
            removeDelimiterAttr(node);
        }
    });
}
function removeDelimiterAttr(node, checkEntity) {
    if (checkEntity === void 0) { checkEntity = true; }
    if (!node) {
        return;
    }
    var isAfter = node.classList.contains("entityDelimiterAfter" /* DELIMITER_AFTER */);
    var entitySibling = isAfter ? node.previousElementSibling : node.nextElementSibling;
    if (checkEntity && entitySibling && isEntityElement(entitySibling)) {
        return;
    }
    node.classList.remove("entityDelimiterAfter" /* DELIMITER_AFTER */, "entityDelimiterBefore" /* DELIMITER_BEFORE */);
    node.normalize();
    node.childNodes.forEach(function (cn) {
        var _a, _b, _c;
        var index = (_b = (_a = cn.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(ZERO_WIDTH_SPACE)) !== null && _b !== void 0 ? _b : -1;
        if (index >= 0) {
            (_c = createRange(cn, index, cn, index + 1)) === null || _c === void 0 ? void 0 : _c.deleteContents();
        }
    });
}
function handleCollapsedEnter(editor, delimiter) {
    var isAfter = delimiter.classList.contains("entityDelimiterAfter" /* DELIMITER_AFTER */);
    var entity = !isAfter ? delimiter.nextSibling : delimiter.previousSibling;
    var block = getBlock(editor, delimiter);
    editor.runAsync(function () {
        if (!block) {
            return;
        }
        var blockToCheck = isAfter ? block.nextSibling : block.previousSibling;
        if (blockToCheck && safeInstanceOf(blockToCheck, 'HTMLElement')) {
            var delimiters = blockToCheck.querySelectorAll(DELIMITER_SELECTOR);
            // Check if the last or first delimiter still contain the delimiter class and remove it.
            var delimiterToCheck = delimiters.item(isAfter ? 0 : delimiters.length - 1);
            removeDelimiterAttr(delimiterToCheck);
        }
        if (isEntityElement(entity)) {
            var nextElementSibling = entity.nextElementSibling, previousElementSibling = entity.previousElementSibling;
            [nextElementSibling, previousElementSibling].forEach(function (el) {
                // Check if after Enter the ZWS got removed but we still have a element with the class
                // Remove the attributes of the element if it is invalid now.
                if (el && matchesSelector(el, DELIMITER_SELECTOR) && !getDelimiterFromElement(el)) {
                    removeDelimiterAttr(el, false /* checkEntity */);
                }
            });
            // Add delimiters to the entity if needed because on Enter we can sometimes lose the ZWS of the element.
            addDelimiters(entity);
        }
    });
}
var getPosition = function (container) {
    if (container && getDelimiterFromElement(container)) {
        var isAfter = container.classList.contains("entityDelimiterAfter" /* DELIMITER_AFTER */);
        return new Position(container, isAfter ? -3 /* After */ : -2 /* Before */);
    }
    return undefined;
};
function getBlock(editor, element) {
    var _a;
    if (!element) {
        return undefined;
    }
    var block = (_a = editor.getBlockElementAtNode(element)) === null || _a === void 0 ? void 0 : _a.getStartNode();
    while (block && !isBlockElement(block)) {
        block = editor.contains(block.parentElement) ? block.parentElement : undefined;
    }
    return block;
}
function handleSelectionNotCollapsed(editor, range, event) {
    var startContainer = range.startContainer, endContainer = range.endContainer, startOffset = range.startOffset, endOffset = range.endOffset;
    var startElement = editor.getElementAtCursor(DELIMITER_SELECTOR, startContainer);
    var endElement = editor.getElementAtCursor(DELIMITER_SELECTOR, endContainer);
    var startUpdate = getPosition(startElement);
    var endUpdate = getPosition(endElement);
    if (startUpdate || endUpdate) {
        editor.select(startUpdate !== null && startUpdate !== void 0 ? startUpdate : new Position(startContainer, startOffset), endUpdate !== null && endUpdate !== void 0 ? endUpdate : new Position(endContainer, endOffset));
    }
    editor.runAsync(function (aEditor) {
        var delimiter = aEditor.getElementAtCursor(DELIMITER_SELECTOR);
        if (delimiter) {
            preventTypeInDelimiter(delimiter);
            if (event.which === 13 /* ENTER */) {
                removeDelimiterAttr(delimiter);
            }
        }
    });
}
function handleKeyDownEvent(editor, event) {
    var _a, _b;
    var range = editor.getSelectionRangeEx();
    var rawEvent = event.rawEvent;
    if (range.type != 0 /* Normal */) {
        return;
    }
    if (range.areAllCollapsed && (isCharacterValue(rawEvent) || rawEvent.which === 13 /* ENTER */)) {
        var position = (_a = editor.getFocusedPosition()) === null || _a === void 0 ? void 0 : _a.normalize();
        if (!position) {
            return;
        }
        var element = position.element, node = position.node;
        var refNode = element == node ? element.childNodes.item(position.offset) : element;
        var delimiter_1 = editor.getElementAtCursor(DELIMITER_SELECTOR, refNode);
        if (!delimiter_1) {
            return;
        }
        if (rawEvent.which === 13 /* ENTER */) {
            handleCollapsedEnter(editor, delimiter_1);
        }
        else if (((_b = delimiter_1.firstChild) === null || _b === void 0 ? void 0 : _b.nodeType) == 3 /* Text */) {
            editor.runAsync(function () { return preventTypeInDelimiter(delimiter_1); });
        }
    }
    else if (!range.areAllCollapsed && !rawEvent.shiftKey && rawEvent.which != 16 /* SHIFT */) {
        var currentRange = range.ranges[0];
        if (!currentRange) {
            return;
        }
        handleSelectionNotCollapsed(editor, currentRange, rawEvent);
    }
}
//# sourceMappingURL=inlineEntityOnPluginEvent.js.map