import { inlineEntityOnPluginEvent, normalizeDelimitersInEditor, } from './utils/inlineEntityOnPluginEvent';
import { Browser, commitEntity, getEntityFromElement, getEntitySelector, isCharacterValue, toArray, arrayPush, createElement, addRangeToSelection, createRange, isBlockElement, getObjectKeys, } from 'roosterjs-editor-dom';
var ENTITY_ID_REGEX = /_(\d{1,8})$/;
var ENTITY_CSS_REGEX = '^' + "_Entity" /* ENTITY_INFO_NAME */ + '$';
var ENTITY_ID_CSS_REGEX = '^' + "_EId_" /* ENTITY_ID_PREFIX */;
var ENTITY_TYPE_CSS_REGEX = '^' + "_EType_" /* ENTITY_TYPE_PREFIX */;
var ENTITY_READONLY_CSS_REGEX = '^' + "_EReadonly_" /* ENTITY_READONLY_PREFIX */;
var ALLOWED_CSS_CLASSES = [
    ENTITY_CSS_REGEX,
    ENTITY_ID_CSS_REGEX,
    ENTITY_TYPE_CSS_REGEX,
    ENTITY_READONLY_CSS_REGEX,
];
var REMOVE_ENTITY_OPERATIONS = [
    6 /* Overwrite */,
    7 /* PartialOverwrite */,
    4 /* RemoveFromStart */,
    5 /* RemoveFromEnd */,
];
/**
 * @internal
 * Entity Plugin helps handle all operations related to an entity and generate entity specified events
 */
var EntityPlugin = /** @class */ (function () {
    /**
     * Construct a new instance of EntityPlugin
     */
    function EntityPlugin() {
        var _this = this;
        this.editor = null;
        this.handleCutEvent = function (event) {
            var _a;
            var range = (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
            if (range && !range.collapsed) {
                _this.checkRemoveEntityForRange(event);
            }
        };
        this.state = {
            entityMap: {},
        };
    }
    /**
     * Get a friendly name of  this plugin
     */
    EntityPlugin.prototype.getName = function () {
        return 'Entity';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    EntityPlugin.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    /**
     * Dispose this plugin
     */
    EntityPlugin.prototype.dispose = function () {
        this.editor = null;
        this.state.entityMap = {};
    };
    /**
     * Get plugin state object
     */
    EntityPlugin.prototype.getState = function () {
        return this.state;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    EntityPlugin.prototype.onPluginEvent = function (event) {
        switch (event.eventType) {
            case 6 /* MouseUp */:
                this.handleMouseUpEvent(event);
                break;
            case 0 /* KeyDown */:
                this.handleKeyDownEvent(event.rawEvent);
                break;
            case 9 /* BeforeCutCopy */:
                if (event.isCut) {
                    this.handleCutEvent(event.rawEvent);
                }
                break;
            case 10 /* BeforePaste */:
                this.handleBeforePasteEvent(event.sanitizingOption);
                break;
            case 7 /* ContentChanged */:
                this.handleContentChangedEvent(event);
                break;
            case 11 /* EditorReady */:
                this.handleContentChangedEvent();
                break;
            case 8 /* ExtractContentWithDom */:
                this.handleExtractContentWithDomEvent(event.clonedRoot);
                break;
            case 16 /* ContextMenu */:
                this.handleContextMenuEvent(event.rawEvent);
                break;
            case 15 /* EntityOperation */:
                this.handleEntityOperationEvent(event);
                break;
        }
        if (this.editor) {
            inlineEntityOnPluginEvent(event, this.editor);
        }
    };
    EntityPlugin.prototype.handleContextMenuEvent = function (event) {
        var _a;
        var node = event.target;
        var entityElement = node && ((_a = this.editor) === null || _a === void 0 ? void 0 : _a.getElementAtCursor(getEntitySelector(), node));
        if (entityElement) {
            event.preventDefault();
            this.triggerEvent(entityElement, 2 /* ContextMenu */, event);
        }
    };
    EntityPlugin.prototype.handleMouseUpEvent = function (event) {
        var rawEvent = event.rawEvent, isClicking = event.isClicking;
        var node = rawEvent.target;
        var entityElement;
        if (this.editor &&
            isClicking &&
            node &&
            !!(entityElement = this.editor.getElementAtCursor(getEntitySelector(), node))) {
            this.triggerEvent(entityElement, 1 /* Click */, rawEvent);
            workaroundSelectionIssueForIE(this.editor);
        }
    };
    EntityPlugin.prototype.handleKeyDownEvent = function (event) {
        var _a;
        if (isCharacterValue(event) ||
            event.which == 8 /* BACKSPACE */ ||
            event.which == 46 /* DELETE */ ||
            event.which == 13 /* ENTER */) {
            var range = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
            if (range && !range.collapsed) {
                this.checkRemoveEntityForRange(event);
            }
        }
    };
    EntityPlugin.prototype.handleBeforePasteEvent = function (sanitizingOption) {
        var _a;
        var range = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
        if (range && !range.collapsed) {
            this.checkRemoveEntityForRange(null /*rawEvent*/);
        }
        if (sanitizingOption.additionalAllowedCssClasses) {
            arrayPush(sanitizingOption.additionalAllowedCssClasses, ALLOWED_CSS_CLASSES);
        }
    };
    EntityPlugin.prototype.handleContentChangedEvent = function (event) {
        var _this = this;
        var shouldNormalizeDelimiters = false;
        // 1. find removed entities
        getObjectKeys(this.state.entityMap).forEach(function (id) {
            var item = _this.state.entityMap[id];
            var element = item.element;
            if (_this.editor && !item.isDeleted && !_this.editor.contains(element)) {
                item.isDeleted = true;
                _this.triggerEvent(element, 6 /* Overwrite */);
                if (!shouldNormalizeDelimiters &&
                    !element.isContentEditable &&
                    !isBlockElement(element)) {
                    shouldNormalizeDelimiters = true;
                }
            }
        });
        // 2. collect all new entities
        var newEntities = (event === null || event === void 0 ? void 0 : event.source) == "InsertEntity" /* InsertEntity */ && event.data
            ? [event.data]
            : this.getExistingEntities().filter(function (entity) {
                var item = _this.state.entityMap[entity.id];
                return !item || item.element != entity.wrapper || item.isDeleted;
            });
        // 3. Add new entities to known entity list, and hydrate
        newEntities.forEach(function (entity) {
            var wrapper = entity.wrapper, type = entity.type, id = entity.id, isReadonly = entity.isReadonly;
            entity.id = _this.ensureUniqueId(type, id, wrapper);
            commitEntity(wrapper, type, isReadonly, entity.id); // Use entity.id here because it is newly updated
            _this.handleNewEntity(entity);
        });
        if (shouldNormalizeDelimiters && this.editor) {
            normalizeDelimitersInEditor(this.editor);
        }
    };
    EntityPlugin.prototype.handleEntityOperationEvent = function (event) {
        if (this.editor && REMOVE_ENTITY_OPERATIONS.indexOf(event.operation) >= 0) {
            var item = this.state.entityMap[event.entity.id];
            if (item) {
                item.isDeleted = true;
            }
        }
    };
    EntityPlugin.prototype.handleExtractContentWithDomEvent = function (root) {
        var _this = this;
        toArray(root.querySelectorAll(getEntitySelector())).forEach(function (element) {
            element.removeAttribute('contentEditable');
            _this.triggerEvent(element, 8 /* ReplaceTemporaryContent */);
        });
    };
    EntityPlugin.prototype.checkRemoveEntityForRange = function (event) {
        var _this = this;
        var _a;
        var editableEntityElements = [];
        var selector = getEntitySelector();
        (_a = this.editor) === null || _a === void 0 ? void 0 : _a.queryElements(selector, 1 /* OnSelection */, function (element) {
            if (element.isContentEditable) {
                editableEntityElements.push(element);
            }
            else {
                _this.triggerEvent(element, 6 /* Overwrite */, event);
            }
        });
        // For editable entities, we need to check if it is fully or partially covered by current selection,
        // and trigger different events;
        if (this.editor && editableEntityElements.length > 0) {
            var inSelectionEntityElements_1 = this.editor.queryElements(selector, 2 /* InSelection */);
            editableEntityElements.forEach(function (element) {
                var isFullyCovered = inSelectionEntityElements_1.indexOf(element) >= 0;
                _this.triggerEvent(element, isFullyCovered ? 6 /* Overwrite */ : 7 /* PartialOverwrite */, event);
            });
        }
    };
    EntityPlugin.prototype.triggerEvent = function (element, operation, rawEvent) {
        var _a;
        var entity = element && getEntityFromElement(element);
        return entity
            ? (_a = this.editor) === null || _a === void 0 ? void 0 : _a.triggerPluginEvent(15 /* EntityOperation */, {
                operation: operation,
                rawEvent: rawEvent,
                entity: entity,
            })
            : null;
    };
    EntityPlugin.prototype.handleNewEntity = function (entity) {
        var wrapper = entity.wrapper;
        var event = this.triggerEvent(wrapper, 0 /* NewEntity */);
        var newItem = {
            element: entity.wrapper,
        };
        if (event === null || event === void 0 ? void 0 : event.shouldPersist) {
            newItem.canPersist = true;
        }
        this.state.entityMap[entity.id] = newItem;
    };
    EntityPlugin.prototype.getExistingEntities = function () {
        var _a, _b;
        return ((_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.queryElements(getEntitySelector()).map(getEntityFromElement).filter(function (x) { return !!x; })) !== null && _b !== void 0 ? _b : []);
    };
    EntityPlugin.prototype.ensureUniqueId = function (type, id, wrapper) {
        var match = ENTITY_ID_REGEX.exec(id);
        var baseId = (match ? id.substr(0, id.length - match[0].length) : id) || type;
        // Make sure entity id is unique
        var newId = '';
        for (var num = (match && parseInt(match[1])) || 0;; num++) {
            newId = num > 0 ? baseId + "_" + num : baseId;
            var item = this.state.entityMap[newId];
            if (!item || item.element == wrapper) {
                break;
            }
        }
        return newId;
    };
    return EntityPlugin;
}());
export default EntityPlugin;
/**
 * IE will show a resize border around the readonly content within content editable DIV
 * This is a workaround to remove it by temporarily move focus out of editor
 */
var workaroundSelectionIssueForIE = Browser.isIE
    ? function (editor) {
        editor.runAsync(function (editor) {
            var workaroundButton = editor.getCustomData('ENTITY_IE_FOCUS_BUTTON', function () {
                var button = createElement({
                    tag: 'button',
                    style: 'overflow:hidden;position:fixed;width:0;height:0;top:-1000px',
                }, editor.getDocument());
                button.onblur = function () {
                    button.style.display = 'none';
                };
                editor.insertNode(button, {
                    position: 4 /* Outside */,
                });
                return button;
            });
            workaroundButton.style.display = '';
            addRangeToSelection(createRange(workaroundButton, 0));
        });
    }
    : function () { };
//# sourceMappingURL=EntityPlugin.js.map