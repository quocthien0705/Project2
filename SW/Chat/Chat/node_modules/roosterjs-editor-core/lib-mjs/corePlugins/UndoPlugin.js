import { addSnapshotV2, canMoveCurrentSnapshot, clearProceedingSnapshotsV2, createSnapshots, isCtrlOrMetaPressed, moveCurrentSnapshot, canUndoAutoComplete, } from 'roosterjs-editor-dom';
// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped
// to keep size under limit. This is kept at 10MB
var MAX_SIZE_LIMIT = 1e7;
/**
 * @internal
 * Provides snapshot based undo service for Editor
 */
var UndoPlugin = /** @class */ (function () {
    /**
     * Construct a new instance of UndoPlugin
     * @param options The wrapper of the state object
     */
    function UndoPlugin(options) {
        this.editor = null;
        this.lastKeyPress = null;
        this.state = {
            snapshotsService: options.undoMetadataSnapshotService ||
                createUndoSnapshotServiceBridge(options.undoSnapshotService) ||
                createUndoSnapshots(),
            isRestoring: false,
            hasNewContent: false,
            isNested: false,
            autoCompletePosition: null,
        };
    }
    /**
     * Get a friendly name of  this plugin
     */
    UndoPlugin.prototype.getName = function () {
        return 'Undo';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    UndoPlugin.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    /**
     * Dispose this plugin
     */
    UndoPlugin.prototype.dispose = function () {
        this.editor = null;
    };
    /**
     * Get plugin state object
     */
    UndoPlugin.prototype.getState = function () {
        return this.state;
    };
    /**
     * Check if the plugin should handle the given event exclusively.
     * @param event The event to check
     */
    UndoPlugin.prototype.willHandleEventExclusively = function (event) {
        return (event.eventType == 0 /* KeyDown */ &&
            event.rawEvent.which == 8 /* BACKSPACE */ &&
            !event.rawEvent.ctrlKey &&
            this.canUndoAutoComplete());
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    UndoPlugin.prototype.onPluginEvent = function (event) {
        // if editor is in IME, don't do anything
        if (!this.editor || this.editor.isInIME()) {
            return;
        }
        switch (event.eventType) {
            case 11 /* EditorReady */:
                var undoState = this.editor.getUndoState();
                if (!undoState.canUndo && !undoState.canRedo) {
                    // Only add initial snapshot when there is no existing snapshot
                    // Otherwise preserved undo/redo state may be ruined
                    this.addUndoSnapshot();
                }
                break;
            case 0 /* KeyDown */:
                this.onKeyDown(event.rawEvent);
                break;
            case 1 /* KeyPress */:
                this.onKeyPress(event.rawEvent);
                break;
            case 4 /* CompositionEnd */:
                this.clearRedoForInput();
                this.addUndoSnapshot();
                break;
            case 7 /* ContentChanged */:
                this.onContentChanged(event);
                break;
            case 23 /* BeforeKeyboardEditing */:
                this.onBeforeKeyboardEditing(event.rawEvent);
                break;
        }
    };
    UndoPlugin.prototype.onKeyDown = function (evt) {
        var _a, _b;
        // Handle backspace/delete when there is a selection to take a snapshot
        // since we want the state prior to deletion restorable
        // Ignore if keycombo is ALT+BACKSPACE
        if ((evt.which == 8 /* BACKSPACE */ && !evt.altKey) || evt.which == 46 /* DELETE */) {
            if (evt.which == 8 /* BACKSPACE */ && !evt.ctrlKey && this.canUndoAutoComplete()) {
                evt.preventDefault();
                (_a = this.editor) === null || _a === void 0 ? void 0 : _a.undo();
                this.state.autoCompletePosition = null;
                this.lastKeyPress = evt.which;
            }
            else if (!evt.defaultPrevented) {
                var selectionRange = (_b = this.editor) === null || _b === void 0 ? void 0 : _b.getSelectionRange();
                // Add snapshot when
                // 1. Something has been selected (not collapsed), or
                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or
                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted
                if (selectionRange &&
                    (!selectionRange.collapsed ||
                        this.lastKeyPress != evt.which ||
                        isCtrlOrMetaPressed(evt))) {
                    this.addUndoSnapshot();
                }
                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time
                this.state.hasNewContent = true;
                this.lastKeyPress = evt.which;
            }
        }
        else if (evt.which >= 33 /* PAGEUP */ && evt.which <= 40 /* DOWN */) {
            // PageUp, PageDown, Home, End, Left, Right, Up, Down
            if (this.state.hasNewContent) {
                this.addUndoSnapshot();
            }
            this.lastKeyPress = 0;
        }
        else if (this.lastKeyPress == 8 /* BACKSPACE */ || this.lastKeyPress == 46 /* DELETE */) {
            if (this.state.hasNewContent) {
                this.addUndoSnapshot();
            }
        }
    };
    UndoPlugin.prototype.onKeyPress = function (evt) {
        var _a;
        if (evt.metaKey) {
            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.
            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.
            return;
        }
        var range = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
        if ((range && !range.collapsed) ||
            (evt.which == 32 /* SPACE */ && this.lastKeyPress != 32 /* SPACE */) ||
            evt.which == 13 /* ENTER */) {
            this.addUndoSnapshot();
            if (evt.which == 13 /* ENTER */) {
                // Treat ENTER as new content so if there is no input after ENTER and undo,
                // we restore the snapshot before ENTER
                this.state.hasNewContent = true;
            }
        }
        else {
            this.clearRedoForInput();
        }
        this.lastKeyPress = evt.which;
    };
    UndoPlugin.prototype.onBeforeKeyboardEditing = function (event) {
        // For keyboard event (triggered from Content Model), we can get its keycode from event.data
        // And when user is keep pressing the same key, mark editor with "hasNewContent" so that next time user
        // do some other action or press a different key, we will add undo snapshot
        if (event.which != this.lastKeyPress) {
            this.addUndoSnapshot();
        }
        this.lastKeyPress = event.which;
        this.state.hasNewContent = true;
    };
    UndoPlugin.prototype.onContentChanged = function (event) {
        if (!(this.state.isRestoring ||
            event.source == "SwitchToDarkMode" /* SwitchToDarkMode */ ||
            event.source == "SwitchToLightMode" /* SwitchToLightMode */ ||
            event.source == "Keyboard" /* Keyboard */)) {
            this.clearRedoForInput();
        }
    };
    UndoPlugin.prototype.clearRedoForInput = function () {
        this.state.snapshotsService.clearRedo();
        this.lastKeyPress = 0;
        this.state.hasNewContent = true;
    };
    UndoPlugin.prototype.canUndoAutoComplete = function () {
        var _a, _b;
        var focusedPosition = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getFocusedPosition();
        return (this.state.snapshotsService.canUndoAutoComplete() &&
            !!focusedPosition &&
            !!((_b = this.state.autoCompletePosition) === null || _b === void 0 ? void 0 : _b.equalTo(focusedPosition)));
    };
    UndoPlugin.prototype.addUndoSnapshot = function () {
        var _a;
        (_a = this.editor) === null || _a === void 0 ? void 0 : _a.addUndoSnapshot();
        this.state.autoCompletePosition = null;
    };
    return UndoPlugin;
}());
export default UndoPlugin;
function createUndoSnapshots() {
    var snapshots = createSnapshots(MAX_SIZE_LIMIT);
    return {
        canMove: function (delta) { return canMoveCurrentSnapshot(snapshots, delta); },
        move: function (delta) { return moveCurrentSnapshot(snapshots, delta); },
        addSnapshot: function (snapshot, isAutoCompleteSnapshot) {
            return addSnapshotV2(snapshots, snapshot, isAutoCompleteSnapshot);
        },
        clearRedo: function () { return clearProceedingSnapshotsV2(snapshots); },
        canUndoAutoComplete: function () { return canUndoAutoComplete(snapshots); },
    };
}
function createUndoSnapshotServiceBridge(service) {
    var html;
    return service
        ? {
            canMove: function (delta) { return service.canMove(delta); },
            move: function (delta) {
                return (html = service.move(delta)) ? { html: html, metadata: null, knownColors: [] } : null;
            },
            addSnapshot: function (snapshot, isAutoCompleteSnapshot) {
                return service.addSnapshot(snapshot.html +
                    (snapshot.metadata ? "<!--" + JSON.stringify(snapshot.metadata) + "-->" : ''), isAutoCompleteSnapshot);
            },
            clearRedo: function () { return service.clearRedo(); },
            canUndoAutoComplete: function () { return service.canUndoAutoComplete(); },
        }
        : undefined;
}
//# sourceMappingURL=UndoPlugin.js.map