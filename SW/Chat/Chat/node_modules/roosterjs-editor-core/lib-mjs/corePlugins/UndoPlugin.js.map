{"version":3,"file":"UndoPlugin.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-core/lib/corePlugins/UndoPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChangeSource, Keys, PluginEventType } from 'roosterjs-editor-types';\nimport type {\n    ContentChangedEvent,\n    EditorOptions,\n    IEditor,\n    PluginEvent,\n    PluginWithState,\n    Snapshot,\n    UndoPluginState,\n    UndoSnapshotsService,\n} from 'roosterjs-editor-types';\nimport {\n    addSnapshotV2,\n    canMoveCurrentSnapshot,\n    clearProceedingSnapshotsV2,\n    createSnapshots,\n    isCtrlOrMetaPressed,\n    moveCurrentSnapshot,\n    canUndoAutoComplete,\n} from 'roosterjs-editor-dom';\n\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\n// to keep size under limit. This is kept at 10MB\nconst MAX_SIZE_LIMIT = 1e7;\n\n/**\n * @internal\n * Provides snapshot based undo service for Editor\n */\nexport default class UndoPlugin implements PluginWithState<UndoPluginState> {\n    private editor: IEditor | null = null;\n    private lastKeyPress: number | null = null;\n    private state: UndoPluginState;\n\n    /**\n     * Construct a new instance of UndoPlugin\n     * @param options The wrapper of the state object\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            snapshotsService:\n                options.undoMetadataSnapshotService ||\n                createUndoSnapshotServiceBridge(options.undoSnapshotService) ||\n                createUndoSnapshots(),\n            isRestoring: false,\n            hasNewContent: false,\n            isNested: false,\n            autoCompletePosition: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Undo';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            event.eventType == PluginEventType.KeyDown &&\n            event.rawEvent.which == Keys.BACKSPACE &&\n            !event.rawEvent.ctrlKey &&\n            this.canUndoAutoComplete()\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent): void {\n        // if editor is in IME, don't do anything\n        if (!this.editor || this.editor.isInIME()) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n                const undoState = this.editor.getUndoState();\n                if (!undoState.canUndo && !undoState.canRedo) {\n                    // Only add initial snapshot when there is no existing snapshot\n                    // Otherwise preserved undo/redo state may be ruined\n                    this.addUndoSnapshot();\n                }\n                break;\n            case PluginEventType.KeyDown:\n                this.onKeyDown(event.rawEvent);\n                break;\n            case PluginEventType.KeyPress:\n                this.onKeyPress(event.rawEvent);\n                break;\n            case PluginEventType.CompositionEnd:\n                this.clearRedoForInput();\n                this.addUndoSnapshot();\n                break;\n            case PluginEventType.ContentChanged:\n                this.onContentChanged(event);\n                break;\n            case PluginEventType.BeforeKeyboardEditing:\n                this.onBeforeKeyboardEditing(event.rawEvent);\n                break;\n        }\n    }\n\n    private onKeyDown(evt: KeyboardEvent): void {\n        // Handle backspace/delete when there is a selection to take a snapshot\n        // since we want the state prior to deletion restorable\n        // Ignore if keycombo is ALT+BACKSPACE\n        if ((evt.which == Keys.BACKSPACE && !evt.altKey) || evt.which == Keys.DELETE) {\n            if (evt.which == Keys.BACKSPACE && !evt.ctrlKey && this.canUndoAutoComplete()) {\n                evt.preventDefault();\n                this.editor?.undo();\n                this.state.autoCompletePosition = null;\n                this.lastKeyPress = evt.which;\n            } else if (!evt.defaultPrevented) {\n                const selectionRange = this.editor?.getSelectionRange();\n\n                // Add snapshot when\n                // 1. Something has been selected (not collapsed), or\n                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\n                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\n                if (\n                    selectionRange &&\n                    (!selectionRange.collapsed ||\n                        this.lastKeyPress != evt.which ||\n                        isCtrlOrMetaPressed(evt))\n                ) {\n                    this.addUndoSnapshot();\n                }\n\n                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\n                this.state.hasNewContent = true;\n                this.lastKeyPress = evt.which;\n            }\n        } else if (evt.which >= Keys.PAGEUP && evt.which <= Keys.DOWN) {\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n            this.lastKeyPress = 0;\n        } else if (this.lastKeyPress == Keys.BACKSPACE || this.lastKeyPress == Keys.DELETE) {\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n        }\n    }\n\n    private onKeyPress(evt: KeyboardEvent): void {\n        if (evt.metaKey) {\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\n            return;\n        }\n\n        const range = this.editor?.getSelectionRange();\n        if (\n            (range && !range.collapsed) ||\n            (evt.which == Keys.SPACE && this.lastKeyPress != Keys.SPACE) ||\n            evt.which == Keys.ENTER\n        ) {\n            this.addUndoSnapshot();\n            if (evt.which == Keys.ENTER) {\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\n                // we restore the snapshot before ENTER\n                this.state.hasNewContent = true;\n            }\n        } else {\n            this.clearRedoForInput();\n        }\n\n        this.lastKeyPress = evt.which;\n    }\n\n    private onBeforeKeyboardEditing(event: KeyboardEvent) {\n        // For keyboard event (triggered from Content Model), we can get its keycode from event.data\n        // And when user is keep pressing the same key, mark editor with \"hasNewContent\" so that next time user\n        // do some other action or press a different key, we will add undo snapshot\n        if (event.which != this.lastKeyPress) {\n            this.addUndoSnapshot();\n        }\n\n        this.lastKeyPress = event.which;\n        this.state.hasNewContent = true;\n    }\n\n    private onContentChanged(event: ContentChangedEvent) {\n        if (\n            !(\n                this.state.isRestoring ||\n                event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode ||\n                event.source == ChangeSource.Keyboard\n            )\n        ) {\n            this.clearRedoForInput();\n        }\n    }\n\n    private clearRedoForInput() {\n        this.state.snapshotsService.clearRedo();\n        this.lastKeyPress = 0;\n        this.state.hasNewContent = true;\n    }\n\n    private canUndoAutoComplete() {\n        const focusedPosition = this.editor?.getFocusedPosition();\n        return (\n            this.state.snapshotsService.canUndoAutoComplete() &&\n            !!focusedPosition &&\n            !!this.state.autoCompletePosition?.equalTo(focusedPosition)\n        );\n    }\n\n    private addUndoSnapshot() {\n        this.editor?.addUndoSnapshot();\n        this.state.autoCompletePosition = null;\n    }\n}\n\nfunction createUndoSnapshots(): UndoSnapshotsService<Snapshot> {\n    const snapshots = createSnapshots<Snapshot>(MAX_SIZE_LIMIT);\n\n    return {\n        canMove: (delta: number): boolean => canMoveCurrentSnapshot(snapshots, delta),\n        move: (delta: number): Snapshot | null => moveCurrentSnapshot(snapshots, delta),\n        addSnapshot: (snapshot: Snapshot, isAutoCompleteSnapshot: boolean) =>\n            addSnapshotV2(snapshots, snapshot, isAutoCompleteSnapshot),\n        clearRedo: () => clearProceedingSnapshotsV2(snapshots),\n        canUndoAutoComplete: () => canUndoAutoComplete(snapshots),\n    };\n}\n\nfunction createUndoSnapshotServiceBridge(\n    service: UndoSnapshotsService<string> | undefined\n): UndoSnapshotsService<Snapshot> | undefined {\n    let html: string | null;\n    return service\n        ? {\n              canMove: (delta: number) => service.canMove(delta),\n              move: (delta: number): Snapshot | null =>\n                  (html = service.move(delta)) ? { html, metadata: null, knownColors: [] } : null,\n              addSnapshot: (snapshot: Snapshot, isAutoCompleteSnapshot: boolean) =>\n                  service.addSnapshot(\n                      snapshot.html +\n                          (snapshot.metadata ? `<!--${JSON.stringify(snapshot.metadata)}-->` : ''),\n                      isAutoCompleteSnapshot\n                  ),\n              clearRedo: () => service.clearRedo(),\n              canUndoAutoComplete: () => service.canUndoAutoComplete(),\n          }\n        : undefined;\n}\n"]}