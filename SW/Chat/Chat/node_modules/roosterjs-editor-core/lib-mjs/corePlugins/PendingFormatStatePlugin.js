import { isCharacterValue, Position, setColor } from 'roosterjs-editor-dom';
var ZERO_WIDTH_SPACE = '\u200B';
/**
 * @internal
 * PendingFormatStatePlugin handles pending format state management
 */
var PendingFormatStatePlugin = /** @class */ (function () {
    /**
     * Construct a new instance of PendingFormatStatePlugin
     * @param options The editor options
     * @param contentDiv The editor content DIV
     */
    function PendingFormatStatePlugin() {
        this.editor = null;
        this.state = {
            pendableFormatPosition: null,
            pendableFormatState: null,
            pendableFormatSpan: null,
        };
    }
    /**
     * Get a friendly name of  this plugin
     */
    PendingFormatStatePlugin.prototype.getName = function () {
        return 'PendingFormatState';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    PendingFormatStatePlugin.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    /**
     * Dispose this plugin
     */
    PendingFormatStatePlugin.prototype.dispose = function () {
        this.editor = null;
        this.clear();
    };
    /**
     * Get plugin state object
     */
    PendingFormatStatePlugin.prototype.getState = function () {
        return this.state;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    PendingFormatStatePlugin.prototype.onPluginEvent = function (event) {
        switch (event.eventType) {
            case 13 /* PendingFormatStateChanged */:
                // Got PendingFormatStateChanged event, cache current position and pending format if a format is passed in
                // otherwise clear existing pending format.
                if (event.formatState) {
                    this.state.pendableFormatPosition = this.getCurrentPosition();
                    this.state.pendableFormatState = event.formatState;
                    this.state.pendableFormatSpan = event.formatCallback
                        ? this.createPendingFormatSpan(event.formatCallback)
                        : null;
                }
                else {
                    this.clear();
                }
                break;
            case 0 /* KeyDown */:
            case 5 /* MouseDown */:
            case 7 /* ContentChanged */:
                var currentPosition = null;
                if (this.editor &&
                    event.eventType == 0 /* KeyDown */ &&
                    isCharacterValue(event.rawEvent) &&
                    this.state.pendableFormatSpan) {
                    this.state.pendableFormatSpan.removeAttribute('contentEditable');
                    this.editor.insertNode(this.state.pendableFormatSpan);
                    this.editor.select(this.state.pendableFormatSpan, 0 /* Begin */, this.state.pendableFormatSpan, -1 /* End */);
                    this.clear();
                }
                else if ((event.eventType == 0 /* KeyDown */ &&
                    event.rawEvent.which >= 33 /* PAGEUP */ &&
                    event.rawEvent.which <= 40 /* DOWN */) ||
                    (this.state.pendableFormatPosition &&
                        (currentPosition = this.getCurrentPosition()) &&
                        !this.state.pendableFormatPosition.equalTo(currentPosition)) ||
                    (event.eventType == 7 /* ContentChanged */ &&
                        (event.source == "SwitchToDarkMode" /* SwitchToDarkMode */ ||
                            event.source == "SwitchToLightMode" /* SwitchToLightMode */))) {
                    // If content or position is changed (by keyboard, mouse, or code),
                    // check if current position is still the same with the cached one (if exist),
                    // and clear cached format if position is changed since it is out-of-date now
                    this.clear();
                }
                break;
        }
    };
    PendingFormatStatePlugin.prototype.clear = function () {
        this.state.pendableFormatPosition = null;
        this.state.pendableFormatState = null;
        this.state.pendableFormatSpan = null;
    };
    PendingFormatStatePlugin.prototype.getCurrentPosition = function () {
        var _a, _b;
        var range = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getSelectionRange();
        return (_b = (range && Position.getStart(range).normalize())) !== null && _b !== void 0 ? _b : null;
    };
    PendingFormatStatePlugin.prototype.createPendingFormatSpan = function (callback) {
        var _a, _b;
        var span = this.state.pendableFormatSpan;
        if (!span && this.editor) {
            var currentStyle = this.editor.getStyleBasedFormatState();
            var doc = this.editor.getDocument();
            var isDarkMode = this.editor.isDarkMode();
            span = doc.createElement('span');
            span.contentEditable = 'true';
            span.appendChild(doc.createTextNode(ZERO_WIDTH_SPACE));
            span.style.setProperty('font-family', (_a = currentStyle.fontName) !== null && _a !== void 0 ? _a : null);
            span.style.setProperty('font-size', (_b = currentStyle.fontSize) !== null && _b !== void 0 ? _b : null);
            var darkColorHandler = this.editor.getDarkColorHandler();
            if (currentStyle.textColors || currentStyle.textColor) {
                setColor(span, (currentStyle.textColors || currentStyle.textColor), false /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
            }
            if (currentStyle.backgroundColors || currentStyle.backgroundColor) {
                setColor(span, (currentStyle.backgroundColors || currentStyle.backgroundColor), true /*isBackground*/, isDarkMode, false /*shouldAdaptFontColor*/, darkColorHandler);
            }
        }
        if (span) {
            callback(span);
        }
        return span;
    };
    return PendingFormatStatePlugin;
}());
export default PendingFormatStatePlugin;
//# sourceMappingURL=PendingFormatStatePlugin.js.map