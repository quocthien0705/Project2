{"version":3,"file":"UndoPlugin.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-core/lib/corePlugins/UndoPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChangeSource, Keys, PluginEventType } from 'roosterjs-editor-types';\nimport type {\n    ContentChangedEvent,\n    EditorOptions,\n    IEditor,\n    PluginEvent,\n    PluginWithState,\n    Snapshot,\n    UndoPluginState,\n    UndoSnapshotsService,\n} from 'roosterjs-editor-types';\nimport {\n    addSnapshotV2,\n    canMoveCurrentSnapshot,\n    clearProceedingSnapshotsV2,\n    createSnapshots,\n    isCtrlOrMetaPressed,\n    moveCurrentSnapshot,\n    canUndoAutoComplete,\n} from 'roosterjs-editor-dom';\n\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\n// to keep size under limit. This is kept at 10MB\nconst MAX_SIZE_LIMIT = 1e7;\n\n/**\n * @internal\n * Provides snapshot based undo service for Editor\n */\nexport default class UndoPlugin implements PluginWithState<UndoPluginState> {\n    private editor: IEditor | null = null;\n    private lastKeyPress: number | null = null;\n    private state: UndoPluginState;\n\n    /**\n     * Construct a new instance of UndoPlugin\n     * @param options The wrapper of the state object\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            snapshotsService:\n                options.undoMetadataSnapshotService ||\n                createUndoSnapshotServiceBridge(options.undoSnapshotService) ||\n                createUndoSnapshots(),\n            isRestoring: false,\n            hasNewContent: false,\n            isNested: false,\n            autoCompletePosition: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Undo';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            event.eventType == PluginEventType.KeyDown &&\n            event.rawEvent.which == Keys.BACKSPACE &&\n            !event.rawEvent.ctrlKey &&\n            this.canUndoAutoComplete()\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent): void {\n        // if editor is in IME, don't do anything\n        if (!this.editor || this.editor.isInIME()) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n                const undoState = this.editor.getUndoState();\n                if (!undoState.canUndo && !undoState.canRedo) {\n                    // Only add initial snapshot when there is no existing snapshot\n                    // Otherwise preserved undo/redo state may be ruined\n                    this.addUndoSnapshot();\n                }\n                break;\n            case PluginEventType.KeyDown:\n                this.onKeyDown(event.rawEvent);\n                break;\n            case PluginEventType.KeyPress:\n                this.onKeyPress(event.rawEvent);\n                break;\n            case PluginEventType.CompositionEnd:\n                this.clearRedoForInput();\n                this.addUndoSnapshot();\n                break;\n            case PluginEventType.ContentChanged:\n                this.onContentChanged(event);\n                break;\n            case PluginEventType.BeforeKeyboardEditing:\n                this.onBeforeKeyboardEditing(event.rawEvent);\n                break;\n        }\n    }\n\n    private onKeyDown(evt: KeyboardEvent): void {\n        // Handle backspace/delete when there is a selection to take a snapshot\n        // since we want the state prior to deletion restorable\n        // Ignore if keycombo is ALT+BACKSPACE\n        if ((evt.which == Keys.BACKSPACE && !evt.altKey) || evt.which == Keys.DELETE) {\n            if (evt.which == Keys.BACKSPACE && !evt.ctrlKey && this.canUndoAutoComplete()) {\n                evt.preventDefault();\n                this.editor?.undo();\n                this.state.autoCompletePosition = null;\n                this.lastKeyPress = evt.which;\n            } else if (!evt.defaultPrevented) {\n                const selectionRange = this.editor?.getSelectionRange();\n\n                // Add snapshot when\n                // 1. Something has been selected (not collapsed), or\n                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\n                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\n                if (\n                    selectionRange &&\n                    (!selectionRange.collapsed ||\n                        this.lastKeyPress != evt.which ||\n                        isCtrlOrMetaPressed(evt))\n                ) {\n                    this.addUndoSnapshot();\n                }\n\n                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\n                this.state.hasNewContent = true;\n                this.lastKeyPress = evt.which;\n            }\n        } else if (evt.which >= Keys.PAGEUP && evt.which <= Keys.DOWN) {\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n            this.lastKeyPress = 0;\n        } else if (this.lastKeyPress == Keys.BACKSPACE || this.lastKeyPress == Keys.DELETE) {\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n        }\n    }\n\n    private onKeyPress(evt: KeyboardEvent): void {\n        if (evt.metaKey) {\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\n            return;\n        }\n\n        const range = this.editor?.getSelectionRange();\n        if (\n            (range && !range.collapsed) ||\n            (evt.which == Keys.SPACE && this.lastKeyPress != Keys.SPACE) ||\n            evt.which == Keys.ENTER\n        ) {\n            this.addUndoSnapshot();\n            if (evt.which == Keys.ENTER) {\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\n                // we restore the snapshot before ENTER\n                this.state.hasNewContent = true;\n            }\n        } else {\n            this.clearRedoForInput();\n        }\n\n        this.lastKeyPress = evt.which;\n    }\n\n    private onBeforeKeyboardEditing(event: KeyboardEvent) {\n        // For keyboard event (triggered from Content Model), we can get its keycode from event.data\n        // And when user is keep pressing the same key, mark editor with \"hasNewContent\" so that next time user\n        // do some other action or press a different key, we will add undo snapshot\n        if (event.which != this.lastKeyPress) {\n            this.addUndoSnapshot();\n        }\n\n        this.lastKeyPress = event.which;\n        this.state.hasNewContent = true;\n    }\n\n    private onContentChanged(event: ContentChangedEvent) {\n        if (\n            !(\n                this.state.isRestoring ||\n                event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode ||\n                event.source == ChangeSource.Keyboard\n            )\n        ) {\n            this.clearRedoForInput();\n        }\n    }\n\n    private clearRedoForInput() {\n        this.state.snapshotsService.clearRedo();\n        this.lastKeyPress = 0;\n        this.state.hasNewContent = true;\n    }\n\n    private canUndoAutoComplete() {\n        const focusedPosition = this.editor?.getFocusedPosition();\n        return (\n            this.state.snapshotsService.canUndoAutoComplete() &&\n            !!focusedPosition &&\n            !!this.state.autoCompletePosition?.equalTo(focusedPosition)\n        );\n    }\n\n    private addUndoSnapshot() {\n        this.editor?.addUndoSnapshot();\n        this.state.autoCompletePosition = null;\n    }\n}\n\nfunction createUndoSnapshots(): UndoSnapshotsService<Snapshot> {\n    const snapshots = createSnapshots<Snapshot>(MAX_SIZE_LIMIT);\n\n    return {\n        canMove: (delta: number): boolean => canMoveCurrentSnapshot(snapshots, delta),\n        move: (delta: number): Snapshot | null => moveCurrentSnapshot(snapshots, delta),\n        addSnapshot: (snapshot: Snapshot, isAutoCompleteSnapshot: boolean) =>\n            addSnapshotV2(snapshots, snapshot, isAutoCompleteSnapshot),\n        clearRedo: () => clearProceedingSnapshotsV2(snapshots),\n        canUndoAutoComplete: () => canUndoAutoComplete(snapshots),\n    };\n}\n\nfunction createUndoSnapshotServiceBridge(\n    service: UndoSnapshotsService<string> | undefined\n): UndoSnapshotsService<Snapshot> | undefined {\n    let html: string | null;\n    return service\n        ? {\n              canMove: (delta: number) => service.canMove(delta),\n              move: (delta: number): Snapshot | null =>\n                  (html = service.move(delta)) ? { html, metadata: null, knownColors: [] } : null,\n              addSnapshot: (snapshot: Snapshot, isAutoCompleteSnapshot: boolean) =>\n                  service.addSnapshot(\n                      snapshot.html +\n                          (snapshot.metadata ? `<!--${JSON.stringify(snapshot.metadata)}-->` : ''),\n                      isAutoCompleteSnapshot\n                  ),\n              clearRedo: () => service.clearRedo(),\n              canUndoAutoComplete: () => service.canUndoAutoComplete(),\n          }\n        : undefined;\n}\n"]}