{"version":3,"file":"PendingFormatStatePlugin.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-core/lib/corePlugins/PendingFormatStatePlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChangeSource, Keys, PluginEventType, PositionType } from 'roosterjs-editor-types';\nimport { isCharacterValue, Position, setColor } from 'roosterjs-editor-dom';\nimport type {\n    IEditor,\n    NodePosition,\n    PendingFormatStatePluginState,\n    PluginEvent,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\nconst ZERO_WIDTH_SPACE = '\\u200B';\n\n/**\n * @internal\n * PendingFormatStatePlugin handles pending format state management\n */\nexport default class PendingFormatStatePlugin\n    implements PluginWithState<PendingFormatStatePluginState> {\n    private editor: IEditor | null = null;\n    private state: PendingFormatStatePluginState;\n\n    /**\n     * Construct a new instance of PendingFormatStatePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor() {\n        this.state = {\n            pendableFormatPosition: null,\n            pendableFormatState: null,\n            pendableFormatSpan: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'PendingFormatState';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.clear();\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.PendingFormatStateChanged:\n                // Got PendingFormatStateChanged event, cache current position and pending format if a format is passed in\n                // otherwise clear existing pending format.\n                if (event.formatState) {\n                    this.state.pendableFormatPosition = this.getCurrentPosition();\n                    this.state.pendableFormatState = event.formatState;\n                    this.state.pendableFormatSpan = event.formatCallback\n                        ? this.createPendingFormatSpan(event.formatCallback)\n                        : null;\n                } else {\n                    this.clear();\n                }\n\n                break;\n            case PluginEventType.KeyDown:\n            case PluginEventType.MouseDown:\n            case PluginEventType.ContentChanged:\n                let currentPosition: NodePosition | null = null;\n                if (\n                    this.editor &&\n                    event.eventType == PluginEventType.KeyDown &&\n                    isCharacterValue(event.rawEvent) &&\n                    this.state.pendableFormatSpan\n                ) {\n                    this.state.pendableFormatSpan.removeAttribute('contentEditable');\n                    this.editor.insertNode(this.state.pendableFormatSpan);\n                    this.editor.select(\n                        this.state.pendableFormatSpan,\n                        PositionType.Begin,\n                        this.state.pendableFormatSpan,\n                        PositionType.End\n                    );\n                    this.clear();\n                } else if (\n                    (event.eventType == PluginEventType.KeyDown &&\n                        event.rawEvent.which >= Keys.PAGEUP &&\n                        event.rawEvent.which <= Keys.DOWN) ||\n                    (this.state.pendableFormatPosition &&\n                        (currentPosition = this.getCurrentPosition()) &&\n                        !this.state.pendableFormatPosition.equalTo(currentPosition)) ||\n                    (event.eventType == PluginEventType.ContentChanged &&\n                        (event.source == ChangeSource.SwitchToDarkMode ||\n                            event.source == ChangeSource.SwitchToLightMode))\n                ) {\n                    // If content or position is changed (by keyboard, mouse, or code),\n                    // check if current position is still the same with the cached one (if exist),\n                    // and clear cached format if position is changed since it is out-of-date now\n                    this.clear();\n                }\n\n                break;\n        }\n    }\n\n    private clear() {\n        this.state.pendableFormatPosition = null;\n        this.state.pendableFormatState = null;\n        this.state.pendableFormatSpan = null;\n    }\n\n    private getCurrentPosition() {\n        const range = this.editor?.getSelectionRange();\n        return (range && Position.getStart(range).normalize()) ?? null;\n    }\n\n    private createPendingFormatSpan(\n        callback: (element: HTMLElement, isInnerNode?: boolean) => any\n    ) {\n        let span = this.state.pendableFormatSpan;\n\n        if (!span && this.editor) {\n            const currentStyle = this.editor.getStyleBasedFormatState();\n            const doc = this.editor.getDocument();\n            const isDarkMode = this.editor.isDarkMode();\n\n            span = doc.createElement('span');\n            span.contentEditable = 'true';\n            span.appendChild(doc.createTextNode(ZERO_WIDTH_SPACE));\n\n            span.style.setProperty('font-family', currentStyle.fontName ?? null);\n            span.style.setProperty('font-size', currentStyle.fontSize ?? null);\n\n            const darkColorHandler = this.editor.getDarkColorHandler();\n\n            if (currentStyle.textColors || currentStyle.textColor) {\n                setColor(\n                    span,\n                    (currentStyle.textColors || currentStyle.textColor)!,\n                    false /*isBackground*/,\n                    isDarkMode,\n                    false /*shouldAdaptFontColor*/,\n                    darkColorHandler\n                );\n            }\n\n            if (currentStyle.backgroundColors || currentStyle.backgroundColor) {\n                setColor(\n                    span,\n                    (currentStyle.backgroundColors || currentStyle.backgroundColor)!,\n                    true /*isBackground*/,\n                    isDarkMode,\n                    false /*shouldAdaptFontColor*/,\n                    darkColorHandler\n                );\n            }\n        }\n\n        if (span) {\n            callback(span);\n        }\n\n        return span;\n    }\n}\n"]}