define(["require", "exports", "roosterjs-editor-dom"], function (require, exports, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeDelimitersInEditor = exports.inlineEntityOnPluginEvent = void 0;
    var DELIMITER_SELECTOR = '.' + "entityDelimiterAfter" /* DELIMITER_AFTER */ + ',.' + "entityDelimiterBefore" /* DELIMITER_BEFORE */;
    var ZERO_WIDTH_SPACE = '\u200B';
    var INLINE_ENTITY_SELECTOR = 'span' + (0, roosterjs_editor_dom_1.getEntitySelector)();
    /**
     * @internal
     */
    function inlineEntityOnPluginEvent(event, editor) {
        switch (event.eventType) {
            case 7 /* ContentChanged */:
                if (event.source === "SetContent" /* SetContent */) {
                    normalizeDelimitersInEditor(editor);
                }
                break;
            case 11 /* EditorReady */:
                normalizeDelimitersInEditor(editor);
                break;
            case 10 /* BeforePaste */:
                var fragment = event.fragment, sanitizingOption = event.sanitizingOption;
                addDelimitersIfNeeded(fragment.querySelectorAll(INLINE_ENTITY_SELECTOR));
                if (sanitizingOption.additionalAllowedCssClasses) {
                    (0, roosterjs_editor_dom_1.arrayPush)(sanitizingOption.additionalAllowedCssClasses, [
                        "entityDelimiterAfter" /* DELIMITER_AFTER */,
                        "entityDelimiterBefore" /* DELIMITER_BEFORE */,
                    ]);
                }
                break;
            case 8 /* ExtractContentWithDom */:
            case 9 /* BeforeCutCopy */:
                event.clonedRoot.querySelectorAll(DELIMITER_SELECTOR).forEach(function (node) {
                    if ((0, roosterjs_editor_dom_1.getDelimiterFromElement)(node)) {
                        removeNode(node);
                    }
                    else {
                        removeDelimiterAttr(node);
                    }
                });
                break;
            case 0 /* KeyDown */:
                handleKeyDownEvent(editor, event);
                break;
        }
    }
    exports.inlineEntityOnPluginEvent = inlineEntityOnPluginEvent;
    function preventTypeInDelimiter(delimiter) {
        var _a, _b, _c, _d;
        delimiter.normalize();
        var textNode = delimiter.firstChild;
        var index = (_b = (_a = textNode.nodeValue) === null || _a === void 0 ? void 0 : _a.indexOf(ZERO_WIDTH_SPACE)) !== null && _b !== void 0 ? _b : -1;
        if (index >= 0) {
            (0, roosterjs_editor_dom_1.splitTextNode)(textNode, index == 0 ? 1 : index, false /* returnFirstPart */);
            var nodeToMove_1;
            delimiter.childNodes.forEach(function (node) {
                if (node.nodeValue !== ZERO_WIDTH_SPACE) {
                    nodeToMove_1 = node;
                }
            });
            if (nodeToMove_1) {
                (_c = delimiter.parentElement) === null || _c === void 0 ? void 0 : _c.insertBefore(nodeToMove_1, delimiter.className == "entityDelimiterBefore" /* DELIMITER_BEFORE */
                    ? delimiter
                    : delimiter.nextSibling);
                var selection = (_d = nodeToMove_1.ownerDocument) === null || _d === void 0 ? void 0 : _d.getSelection();
                if (selection) {
                    selection.setPosition(nodeToMove_1, new roosterjs_editor_dom_1.Position(nodeToMove_1, -1 /* End */).offset);
                }
            }
        }
    }
    /**
     * @internal
     */
    function normalizeDelimitersInEditor(editor) {
        removeInvalidDelimiters(editor.queryElements(DELIMITER_SELECTOR));
        addDelimitersIfNeeded(editor.queryElements(INLINE_ENTITY_SELECTOR));
    }
    exports.normalizeDelimitersInEditor = normalizeDelimitersInEditor;
    function addDelimitersIfNeeded(nodes) {
        nodes.forEach(function (node) {
            if (isEntityElement(node)) {
                (0, roosterjs_editor_dom_1.addDelimiters)(node);
            }
        });
    }
    function isEntityElement(node) {
        return !!(node &&
            (0, roosterjs_editor_dom_1.safeInstanceOf)(node, 'HTMLElement') &&
            isReadOnly((0, roosterjs_editor_dom_1.getEntityFromElement)(node)));
    }
    function removeNode(el) {
        var _a;
        (_a = el === null || el === void 0 ? void 0 : el.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(el);
    }
    function isReadOnly(entity) {
        return ((entity === null || entity === void 0 ? void 0 : entity.isReadonly) &&
            !(0, roosterjs_editor_dom_1.isBlockElement)(entity.wrapper) &&
            (0, roosterjs_editor_dom_1.safeInstanceOf)(entity.wrapper, 'HTMLElement'));
    }
    function removeInvalidDelimiters(nodes) {
        nodes.forEach(function (node) {
            if ((0, roosterjs_editor_dom_1.getDelimiterFromElement)(node)) {
                var sibling = node.classList.contains("entityDelimiterBefore" /* DELIMITER_BEFORE */)
                    ? node.nextElementSibling
                    : node.previousElementSibling;
                if (!((0, roosterjs_editor_dom_1.safeInstanceOf)(sibling, 'HTMLElement') && (0, roosterjs_editor_dom_1.getEntityFromElement)(sibling))) {
                    removeNode(node);
                }
            }
            else {
                removeDelimiterAttr(node);
            }
        });
    }
    function removeDelimiterAttr(node, checkEntity) {
        if (checkEntity === void 0) { checkEntity = true; }
        if (!node) {
            return;
        }
        var isAfter = node.classList.contains("entityDelimiterAfter" /* DELIMITER_AFTER */);
        var entitySibling = isAfter ? node.previousElementSibling : node.nextElementSibling;
        if (checkEntity && entitySibling && isEntityElement(entitySibling)) {
            return;
        }
        node.classList.remove("entityDelimiterAfter" /* DELIMITER_AFTER */, "entityDelimiterBefore" /* DELIMITER_BEFORE */);
        node.normalize();
        node.childNodes.forEach(function (cn) {
            var _a, _b, _c;
            var index = (_b = (_a = cn.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(ZERO_WIDTH_SPACE)) !== null && _b !== void 0 ? _b : -1;
            if (index >= 0) {
                (_c = (0, roosterjs_editor_dom_1.createRange)(cn, index, cn, index + 1)) === null || _c === void 0 ? void 0 : _c.deleteContents();
            }
        });
    }
    function handleCollapsedEnter(editor, delimiter) {
        var isAfter = delimiter.classList.contains("entityDelimiterAfter" /* DELIMITER_AFTER */);
        var entity = !isAfter ? delimiter.nextSibling : delimiter.previousSibling;
        var block = getBlock(editor, delimiter);
        editor.runAsync(function () {
            if (!block) {
                return;
            }
            var blockToCheck = isAfter ? block.nextSibling : block.previousSibling;
            if (blockToCheck && (0, roosterjs_editor_dom_1.safeInstanceOf)(blockToCheck, 'HTMLElement')) {
                var delimiters = blockToCheck.querySelectorAll(DELIMITER_SELECTOR);
                // Check if the last or first delimiter still contain the delimiter class and remove it.
                var delimiterToCheck = delimiters.item(isAfter ? 0 : delimiters.length - 1);
                removeDelimiterAttr(delimiterToCheck);
            }
            if (isEntityElement(entity)) {
                var nextElementSibling = entity.nextElementSibling, previousElementSibling = entity.previousElementSibling;
                [nextElementSibling, previousElementSibling].forEach(function (el) {
                    // Check if after Enter the ZWS got removed but we still have a element with the class
                    // Remove the attributes of the element if it is invalid now.
                    if (el && (0, roosterjs_editor_dom_1.matchesSelector)(el, DELIMITER_SELECTOR) && !(0, roosterjs_editor_dom_1.getDelimiterFromElement)(el)) {
                        removeDelimiterAttr(el, false /* checkEntity */);
                    }
                });
                // Add delimiters to the entity if needed because on Enter we can sometimes lose the ZWS of the element.
                (0, roosterjs_editor_dom_1.addDelimiters)(entity);
            }
        });
    }
    var getPosition = function (container) {
        if (container && (0, roosterjs_editor_dom_1.getDelimiterFromElement)(container)) {
            var isAfter = container.classList.contains("entityDelimiterAfter" /* DELIMITER_AFTER */);
            return new roosterjs_editor_dom_1.Position(container, isAfter ? -3 /* After */ : -2 /* Before */);
        }
        return undefined;
    };
    function getBlock(editor, element) {
        var _a;
        if (!element) {
            return undefined;
        }
        var block = (_a = editor.getBlockElementAtNode(element)) === null || _a === void 0 ? void 0 : _a.getStartNode();
        while (block && !(0, roosterjs_editor_dom_1.isBlockElement)(block)) {
            block = editor.contains(block.parentElement) ? block.parentElement : undefined;
        }
        return block;
    }
    function handleSelectionNotCollapsed(editor, range, event) {
        var startContainer = range.startContainer, endContainer = range.endContainer, startOffset = range.startOffset, endOffset = range.endOffset;
        var startElement = editor.getElementAtCursor(DELIMITER_SELECTOR, startContainer);
        var endElement = editor.getElementAtCursor(DELIMITER_SELECTOR, endContainer);
        var startUpdate = getPosition(startElement);
        var endUpdate = getPosition(endElement);
        if (startUpdate || endUpdate) {
            editor.select(startUpdate !== null && startUpdate !== void 0 ? startUpdate : new roosterjs_editor_dom_1.Position(startContainer, startOffset), endUpdate !== null && endUpdate !== void 0 ? endUpdate : new roosterjs_editor_dom_1.Position(endContainer, endOffset));
        }
        editor.runAsync(function (aEditor) {
            var delimiter = aEditor.getElementAtCursor(DELIMITER_SELECTOR);
            if (delimiter) {
                preventTypeInDelimiter(delimiter);
                if (event.which === 13 /* ENTER */) {
                    removeDelimiterAttr(delimiter);
                }
            }
        });
    }
    function handleKeyDownEvent(editor, event) {
        var _a, _b;
        var range = editor.getSelectionRangeEx();
        var rawEvent = event.rawEvent;
        if (range.type != 0 /* Normal */) {
            return;
        }
        if (range.areAllCollapsed && ((0, roosterjs_editor_dom_1.isCharacterValue)(rawEvent) || rawEvent.which === 13 /* ENTER */)) {
            var position = (_a = editor.getFocusedPosition()) === null || _a === void 0 ? void 0 : _a.normalize();
            if (!position) {
                return;
            }
            var element = position.element, node = position.node;
            var refNode = element == node ? element.childNodes.item(position.offset) : element;
            var delimiter_1 = editor.getElementAtCursor(DELIMITER_SELECTOR, refNode);
            if (!delimiter_1) {
                return;
            }
            if (rawEvent.which === 13 /* ENTER */) {
                handleCollapsedEnter(editor, delimiter_1);
            }
            else if (((_b = delimiter_1.firstChild) === null || _b === void 0 ? void 0 : _b.nodeType) == 3 /* Text */) {
                editor.runAsync(function () { return preventTypeInDelimiter(delimiter_1); });
            }
        }
        else if (!range.areAllCollapsed && !rawEvent.shiftKey && rawEvent.which != 16 /* SHIFT */) {
            var currentRange = range.ranges[0];
            if (!currentRange) {
                return;
            }
            handleSelectionNotCollapsed(editor, currentRange, rawEvent);
        }
    }
});
//# sourceMappingURL=inlineEntityOnPluginEvent.js.map