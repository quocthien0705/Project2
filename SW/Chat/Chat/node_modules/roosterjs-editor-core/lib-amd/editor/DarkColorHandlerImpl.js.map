{"version":3,"file":"DarkColorHandlerImpl.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-core/lib/editor/DarkColorHandlerImpl.ts"],"names":[],"mappings":"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","sourcesContent":["import { getObjectKeys, parseColor, setColor } from 'roosterjs-editor-dom';\nimport type {\n    ColorKeyAndValue,\n    DarkColorHandler,\n    ModeIndependentColor,\n} from 'roosterjs-editor-types';\n\nconst VARIABLE_REGEX = /^\\s*var\\(\\s*(\\-\\-[a-zA-Z0-9\\-_]+)\\s*(?:,\\s*(.*))?\\)\\s*$/;\nconst VARIABLE_PREFIX = 'var(';\nconst COLOR_VAR_PREFIX = 'darkColor';\nconst enum ColorAttributeEnum {\n    CssColor = 0,\n    HtmlColor = 1,\n}\nconst ColorAttributeName: { [key in ColorAttributeEnum]: string }[] = [\n    {\n        [ColorAttributeEnum.CssColor]: 'color',\n        [ColorAttributeEnum.HtmlColor]: 'color',\n    },\n    {\n        [ColorAttributeEnum.CssColor]: 'background-color',\n        [ColorAttributeEnum.HtmlColor]: 'bgcolor',\n    },\n];\n\n/**\n * @internal\n */\nexport default class DarkColorHandlerImpl implements DarkColorHandler {\n    private knownColors: Record<string, Readonly<ModeIndependentColor>> = {};\n\n    constructor(private contentDiv: HTMLElement, private getDarkColor: (color: string) => string) {}\n\n    /**\n     * Get a copy of known colors\n     * @returns\n     */\n    getKnownColorsCopy() {\n        return Object.values(this.knownColors);\n    }\n\n    /**\n     * Given a light mode color value and an optional dark mode color value, register this color\n     * so that editor can handle it, then return the CSS color value for current color mode.\n     * @param lightModeColor Light mode color value\n     * @param isDarkMode Whether current color mode is dark mode\n     * @param darkModeColor Optional dark mode color value. If not passed, we will calculate one.\n     */\n    registerColor(lightModeColor: string, isDarkMode: boolean, darkModeColor?: string): string {\n        const parsedColor = this.parseColorValue(lightModeColor);\n        let colorKey: string | undefined;\n\n        if (parsedColor) {\n            lightModeColor = parsedColor.lightModeColor;\n            darkModeColor = parsedColor.darkModeColor || darkModeColor;\n            colorKey = parsedColor.key;\n        }\n\n        if (isDarkMode && lightModeColor) {\n            colorKey =\n                colorKey || `--${COLOR_VAR_PREFIX}_${lightModeColor.replace(/[^\\d\\w]/g, '_')}`;\n\n            if (!this.knownColors[colorKey]) {\n                darkModeColor = darkModeColor || this.getDarkColor(lightModeColor);\n\n                this.knownColors[colorKey] = { lightModeColor, darkModeColor };\n                this.contentDiv.style.setProperty(colorKey, darkModeColor);\n            }\n\n            return `var(${colorKey}, ${lightModeColor})`;\n        } else {\n            return lightModeColor;\n        }\n    }\n\n    /**\n     * Reset known color record, clean up registered color variables.\n     */\n    reset(): void {\n        getObjectKeys(this.knownColors).forEach(key => this.contentDiv.style.removeProperty(key));\n        this.knownColors = {};\n    }\n\n    /**\n     * Parse an existing color value, if it is in variable-based color format, extract color key,\n     * light color and query related dark color if any\n     * @param color The color string to parse\n     * @param isInDarkMode Whether current content is in dark mode. When set to true, if the color value is not in dark var format,\n     * we will treat is as a dark mode color and try to find a matched dark mode color.\n     */\n    parseColorValue(color: string | undefined | null, isInDarkMode?: boolean): ColorKeyAndValue {\n        let key: string | undefined;\n        let lightModeColor = '';\n        let darkModeColor: string | undefined;\n\n        if (color) {\n            const match = color.startsWith(VARIABLE_PREFIX) ? VARIABLE_REGEX.exec(color) : null;\n\n            if (match) {\n                if (match[2]) {\n                    key = match[1];\n                    lightModeColor = match[2];\n                    darkModeColor = this.knownColors[key]?.darkModeColor;\n                } else {\n                    lightModeColor = '';\n                }\n            } else if (isInDarkMode) {\n                // If editor is in dark mode but the color is not in dark color format, it is possible the color was inserted from external code\n                // without any light color info. So we first try to see if there is a known dark color can match this color, and use its related\n                // light color as light mode color. Otherwise we need to drop this color to avoid show \"white on white\" content.\n                lightModeColor = this.findLightColorFromDarkColor(color) || '';\n\n                if (lightModeColor) {\n                    darkModeColor = color;\n                }\n            } else {\n                lightModeColor = color;\n            }\n        }\n\n        return { key, lightModeColor, darkModeColor };\n    }\n\n    /**\n     * Find related light mode color from dark mode color.\n     * @param darkColor The existing dark color\n     */\n    findLightColorFromDarkColor(darkColor: string): string | null {\n        const rgbSearch = parseColor(darkColor);\n\n        if (rgbSearch) {\n            const key = getObjectKeys(this.knownColors).find(key => {\n                const rgbCurrent = parseColor(this.knownColors[key].darkModeColor);\n\n                return (\n                    rgbCurrent &&\n                    rgbCurrent[0] == rgbSearch[0] &&\n                    rgbCurrent[1] == rgbSearch[1] &&\n                    rgbCurrent[2] == rgbSearch[2]\n                );\n            });\n\n            if (key) {\n                return this.knownColors[key].lightModeColor;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Transform element color, from dark to light or from light to dark\n     * @param element The element to transform color\n     * @param fromDarkMode Whether this is transforming color from dark mode\n     * @param toDarkMode Whether this is transforming color to dark mode\n     */\n    transformElementColor(element: HTMLElement, fromDarkMode: boolean, toDarkMode: boolean): void {\n        ColorAttributeName.forEach((names, i) => {\n            const color = this.parseColorValue(\n                element.style.getPropertyValue(names[ColorAttributeEnum.CssColor]) ||\n                    element.getAttribute(names[ColorAttributeEnum.HtmlColor]),\n                !!fromDarkMode\n            ).lightModeColor;\n\n            element.style.setProperty(names[ColorAttributeEnum.CssColor], null);\n            element.removeAttribute(names[ColorAttributeEnum.HtmlColor]);\n\n            if (color && color != 'inherit') {\n                setColor(element, color, i != 0, toDarkMode, false /*shouldAdaptFontColor*/, this);\n            }\n        });\n    }\n}\n"]}