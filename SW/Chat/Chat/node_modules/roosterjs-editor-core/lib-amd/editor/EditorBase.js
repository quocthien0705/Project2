define(["require", "exports", "tslib", "./isFeatureEnabled", "roosterjs-editor-dom"], function (require, exports, tslib_1, isFeatureEnabled_1, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EditorBase = void 0;
    /**
     * Base class of editor
     */
    var EditorBase = /** @class */ (function () {
        //#region Lifecycle
        /**
         * Creates an instance of EditorBase
         * @param contentDiv The DIV HTML element which will be the container element of editor
         * @param options An optional options object to customize the editor
         */
        function EditorBase(contentDiv, options, coreCreator) {
            var _this = this;
            this.core = null;
            // 1. Make sure all parameters are valid
            if ((0, roosterjs_editor_dom_1.getTagOfNode)(contentDiv) != 'DIV') {
                throw new Error('contentDiv must be an HTML DIV element');
            }
            // 2. Create editor core
            this.core = coreCreator(contentDiv, options);
            // 3. Initialize plugins
            this.core.plugins.forEach(function (plugin) { return plugin.initialize(_this); });
            // 4. Ensure user will type in a container node, not the editor content DIV
            this.ensureTypeInContainer(new roosterjs_editor_dom_1.Position(this.core.contentDiv, 0 /* Begin */).normalize());
        }
        /**
         * Dispose this editor, dispose all plugins and custom data
         */
        EditorBase.prototype.dispose = function () {
            var _a;
            var core = this.getCore();
            for (var i = core.plugins.length - 1; i >= 0; i--) {
                var plugin = core.plugins[i];
                try {
                    plugin.dispose();
                }
                catch (e) {
                    // Cache the error and pass it out, then keep going since dispose should always succeed
                    (_a = core.disposeErrorHandler) === null || _a === void 0 ? void 0 : _a.call(core, plugin, e);
                }
            }
            core.darkColorHandler.reset();
            this.core = null;
        };
        /**
         * Get whether this editor is disposed
         * @returns True if editor is disposed, otherwise false
         */
        EditorBase.prototype.isDisposed = function () {
            return !this.core;
        };
        //#endregion
        //#region Node API
        /**
         * Insert node into editor
         * @param node The node to insert
         * @param option Insert options. Default value is:
         *  position: ContentPosition.SelectionStart
         *  updateCursor: true
         *  replaceSelection: true
         *  insertOnNewLine: false
         * @returns true if node is inserted. Otherwise false
         */
        EditorBase.prototype.insertNode = function (node, option) {
            var core = this.getCore();
            return node ? core.api.insertNode(core, node, option !== null && option !== void 0 ? option : null) : false;
        };
        /**
         * Delete a node from editor content
         * @param node The node to delete
         * @returns true if node is deleted. Otherwise false
         */
        EditorBase.prototype.deleteNode = function (node) {
            // Only remove the node when it falls within editor
            if (node && this.contains(node) && node.parentNode) {
                node.parentNode.removeChild(node);
                return true;
            }
            return false;
        };
        /**
         * Replace a node in editor content with another node
         * @param existingNode The existing node to be replaced
         * @param toNode node to replace to
         * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false
         * @returns true if node is replaced. Otherwise false
         */
        EditorBase.prototype.replaceNode = function (existingNode, toNode, transformColorForDarkMode) {
            var core = this.getCore();
            // Only replace the node when it falls within editor
            if (this.contains(existingNode) && toNode) {
                core.api.transformColor(core, transformColorForDarkMode ? toNode : null, true /*includeSelf*/, function () { var _a; return (_a = existingNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(toNode, existingNode); }, 0 /* LightToDark */);
                return true;
            }
            return false;
        };
        /**
         * Get BlockElement at given node
         * @param node The node to create InlineElement
         * @returns The BlockElement result
         */
        EditorBase.prototype.getBlockElementAtNode = function (node) {
            return (0, roosterjs_editor_dom_1.getBlockElementAtNode)(this.getCore().contentDiv, node);
        };
        EditorBase.prototype.contains = function (arg) {
            if (!arg) {
                return false;
            }
            return (0, roosterjs_editor_dom_1.contains)(this.getCore().contentDiv, arg);
        };
        EditorBase.prototype.queryElements = function (selector, scopeOrCallback, callback) {
            if (scopeOrCallback === void 0) { scopeOrCallback = 0 /* Body */; }
            var core = this.getCore();
            var result = [];
            var scope = scopeOrCallback instanceof Function ? 0 /* Body */ : scopeOrCallback;
            callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;
            var selectionEx = scope == 0 /* Body */ ? null : this.getSelectionRangeEx();
            if (selectionEx) {
                selectionEx.ranges.forEach(function (range) {
                    result.push.apply(result, (0, tslib_1.__spreadArray)([], (0, tslib_1.__read)((0, roosterjs_editor_dom_1.queryElements)(core.contentDiv, selector, callback, scope, range)), false));
                });
            }
            else {
                return (0, roosterjs_editor_dom_1.queryElements)(core.contentDiv, selector, callback, scope, undefined /* range */);
            }
            return result;
        };
        /**
         * Collapse nodes within the given start and end nodes to their common ancestor node,
         * split parent nodes if necessary
         * @param start The start node
         * @param end The end node
         * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent
         * and the returned nodes will be all nodes from start through end after splitting
         * False to disallow split parent
         * @returns When canSplitParent is true, returns all node from start through end after splitting,
         * otherwise just return start and end
         */
        EditorBase.prototype.collapseNodes = function (start, end, canSplitParent) {
            return (0, roosterjs_editor_dom_1.collapseNodes)(this.getCore().contentDiv, start, end, canSplitParent);
        };
        //#endregion
        //#region Content API
        /**
         * Check whether the editor contains any visible content
         * @param trim Whether trim the content string before check. Default is false
         * @returns True if there's no visible content, otherwise false
         */
        EditorBase.prototype.isEmpty = function (trim) {
            return (0, roosterjs_editor_dom_1.isNodeEmpty)(this.getCore().contentDiv, trim);
        };
        /**
         * Get current editor content as HTML string
         * @param mode specify what kind of HTML content to retrieve
         * @returns HTML string representing current editor content
         */
        EditorBase.prototype.getContent = function (mode) {
            if (mode === void 0) { mode = 0 /* CleanHTML */; }
            var core = this.getCore();
            return core.api.getContent(core, mode);
        };
        /**
         * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered
         * @param content HTML content to set in
         * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true
         */
        EditorBase.prototype.setContent = function (content, triggerContentChangedEvent) {
            if (triggerContentChangedEvent === void 0) { triggerContentChangedEvent = true; }
            var core = this.getCore();
            core.api.setContent(core, content, triggerContentChangedEvent);
        };
        /**
         * Insert HTML content into editor
         * @param HTML content to insert
         * @param option Insert options. Default value is:
         *  position: ContentPosition.SelectionStart
         *  updateCursor: true
         *  replaceSelection: true
         *  insertOnNewLine: false
         */
        EditorBase.prototype.insertContent = function (content, option) {
            var _a;
            if (content) {
                var doc = this.getDocument();
                var body = (_a = new DOMParser().parseFromString(this.getCore().trustedHTMLHandler(content), 'text/html')) === null || _a === void 0 ? void 0 : _a.body;
                var allNodes = (body === null || body === void 0 ? void 0 : body.childNodes) ? (0, roosterjs_editor_dom_1.toArray)(body.childNodes) : [];
                // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with
                // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped
                // separately to show up on its own line
                if (option && option.insertOnNewLine && allNodes.length > 1) {
                    allNodes = [(0, roosterjs_editor_dom_1.wrap)(allNodes)];
                }
                var fragment_1 = doc.createDocumentFragment();
                allNodes.forEach(function (node) { return fragment_1.appendChild(node); });
                this.insertNode(fragment_1, option);
            }
        };
        /**
         * Delete selected content
         */
        EditorBase.prototype.deleteSelectedContent = function () {
            var range = this.getSelectionRange();
            if (range && !range.collapsed) {
                return (0, roosterjs_editor_dom_1.deleteSelectedContent)(this.getCore().contentDiv, range);
            }
            return null;
        };
        /**
         * Paste into editor using a clipboardData object
         * @param clipboardData Clipboard data retrieved from clipboard
         * @param pasteAsText Force pasting as plain text. Default value is false
         * @param applyCurrentStyle True if apply format of current selection to the pasted content,
         * false to keep original format.  Default value is false. When pasteAsText is true, this parameter is ignored
         * @param pasteAsImage: When set to true, if the clipboardData contains a imageDataUri will paste the image to the editor
         */
        EditorBase.prototype.paste = function (clipboardData, pasteAsText, applyCurrentFormat, pasteAsImage) {
            var _this = this;
            if (pasteAsText === void 0) { pasteAsText = false; }
            if (applyCurrentFormat === void 0) { applyCurrentFormat = false; }
            if (pasteAsImage === void 0) { pasteAsImage = false; }
            var core = this.getCore();
            if (!clipboardData) {
                return;
            }
            if (clipboardData.snapshotBeforePaste) {
                // Restore original content before paste a new one
                this.setContent(clipboardData.snapshotBeforePaste);
            }
            else {
                clipboardData.snapshotBeforePaste = this.getContent(2 /* RawHTMLWithSelection */);
            }
            var range = this.getSelectionRange();
            var pos = range && roosterjs_editor_dom_1.Position.getStart(range);
            var fragment = core.api.createPasteFragment(core, clipboardData, pos, pasteAsText, applyCurrentFormat, pasteAsImage);
            if (fragment) {
                this.addUndoSnapshot(function () {
                    _this.insertNode(fragment);
                    return clipboardData;
                }, "Paste" /* Paste */);
            }
        };
        //#endregion
        //#region Focus and Selection
        /**
         * Get current selection range from Editor.
         * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.
         * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.
         * Default value is true
         * @returns current selection range, or null if editor never got focus before
         */
        EditorBase.prototype.getSelectionRange = function (tryGetFromCache) {
            if (tryGetFromCache === void 0) { tryGetFromCache = true; }
            var core = this.getCore();
            return core.api.getSelectionRange(core, tryGetFromCache);
        };
        /**
         * Get current selection range from Editor.
         * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.
         * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.
         * Default value is true
         * @returns current selection range, or null if editor never got focus before
         */
        EditorBase.prototype.getSelectionRangeEx = function () {
            var core = this.getCore();
            return core.api.getSelectionRangeEx(core);
        };
        /**
         * Get current selection in a serializable format
         * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.
         * @returns current selection path, or null if editor never got focus before
         */
        EditorBase.prototype.getSelectionPath = function () {
            var range = this.getSelectionRange();
            return range && (0, roosterjs_editor_dom_1.getSelectionPath)(this.getCore().contentDiv, range);
        };
        /**
         * Check if focus is in editor now
         * @returns true if focus is in editor, otherwise false
         */
        EditorBase.prototype.hasFocus = function () {
            var core = this.getCore();
            return core.api.hasFocus(core);
        };
        /**
         * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.
         */
        EditorBase.prototype.focus = function () {
            var core = this.getCore();
            core.api.focus(core);
        };
        EditorBase.prototype.select = function (arg1, arg2, arg3, arg4) {
            var core = this.getCore();
            return core.api.select(core, arg1, arg2, arg3, arg4);
        };
        /**
         * Get current focused position. Return null if editor doesn't have focus at this time.
         */
        EditorBase.prototype.getFocusedPosition = function () {
            var _a;
            var sel = (_a = this.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
            if ((sel === null || sel === void 0 ? void 0 : sel.focusNode) && this.contains(sel.focusNode)) {
                return new roosterjs_editor_dom_1.Position(sel.focusNode, sel.focusOffset);
            }
            var range = this.getSelectionRange();
            if (range) {
                return roosterjs_editor_dom_1.Position.getStart(range);
            }
            return null;
        };
        /**
         * Get an HTML element from current cursor position.
         * When expectedTags is not specified, return value is the current node (if it is HTML element)
         * or its parent node (if current node is a Text node).
         * When expectedTags is specified, return value is the first ancestor of current node which has
         * one of the expected tags.
         * If no element found within editor by the given tag, return null.
         * @param selector Optional, an HTML selector to find HTML element with.
         * @param startFrom Start search from this node. If not specified, start from current focused position
         * @param event Optional, if specified, editor will try to get cached result from the event object first.
         * If it is not cached before, query from DOM and cache the result into the event object
         */
        EditorBase.prototype.getElementAtCursor = function (selector, startFrom, event) {
            var _this = this;
            var _a;
            event = startFrom ? undefined : event; // Only use cache when startFrom is not specified, for different start position can have different result
            return ((_a = (0, roosterjs_editor_dom_1.cacheGetEventData)(event !== null && event !== void 0 ? event : null, 'GET_ELEMENT_AT_CURSOR_' + selector, function () {
                if (!startFrom) {
                    var position = _this.getFocusedPosition();
                    startFrom = position === null || position === void 0 ? void 0 : position.node;
                }
                return (startFrom &&
                    (0, roosterjs_editor_dom_1.findClosestElementAncestor)(startFrom, _this.getCore().contentDiv, selector));
            })) !== null && _a !== void 0 ? _a : null);
        };
        /**
         * Check if this position is at beginning of the editor.
         * This will return true if all nodes between the beginning of target node and the position are empty.
         * @param position The position to check
         * @returns True if position is at beginning of the editor, otherwise false
         */
        EditorBase.prototype.isPositionAtBeginning = function (position) {
            return (0, roosterjs_editor_dom_1.isPositionAtBeginningOf)(position, this.getCore().contentDiv);
        };
        /**
         * Get impacted regions from selection
         */
        EditorBase.prototype.getSelectedRegions = function (type) {
            if (type === void 0) { type = 0 /* Table */; }
            var selection = this.getSelectionRangeEx();
            var result = [];
            var contentDiv = this.getCore().contentDiv;
            selection.ranges.forEach(function (range) {
                result.push.apply(result, (0, tslib_1.__spreadArray)([], (0, tslib_1.__read)((range ? (0, roosterjs_editor_dom_1.getRegionsFromRange)(contentDiv, range, type) : [])), false));
            });
            return result.filter(function (value, index, self) {
                return self.indexOf(value) === index;
            });
        };
        //#endregion
        //#region EVENT API
        EditorBase.prototype.addDomEventHandler = function (nameOrMap, handler) {
            var _a;
            var eventsToMap = typeof nameOrMap == 'string' ? (_a = {}, _a[nameOrMap] = handler, _a) : nameOrMap;
            var core = this.getCore();
            return core.api.attachDomEvent(core, eventsToMap);
        };
        /**
         * Trigger an event to be dispatched to all plugins
         * @param eventType Type of the event
         * @param data data of the event with given type, this is the rest part of PluginEvent with the given type
         * @param broadcast indicates if the event needs to be dispatched to all plugins
         * True means to all, false means to allow exclusive handling from one plugin unless no one wants that
         * @returns the event object which is really passed into plugins. Some plugin may modify the event object so
         * the result of this function provides a chance to read the modified result
         */
        EditorBase.prototype.triggerPluginEvent = function (eventType, data, broadcast) {
            if (broadcast === void 0) { broadcast = false; }
            var core = this.getCore();
            var event = (0, tslib_1.__assign)({ eventType: eventType }, data);
            core.api.triggerEvent(core, event, broadcast);
            return event;
        };
        /**
         * Trigger a ContentChangedEvent
         * @param source Source of this event, by default is 'SetContent'
         * @param data additional data for this event
         */
        EditorBase.prototype.triggerContentChangedEvent = function (source, data) {
            if (source === void 0) { source = "SetContent" /* SetContent */; }
            this.triggerPluginEvent(7 /* ContentChanged */, {
                source: source,
                data: data,
            });
        };
        //#endregion
        //#region Undo API
        /**
         * Undo last edit operation
         */
        EditorBase.prototype.undo = function () {
            this.focus();
            var core = this.getCore();
            core.api.restoreUndoSnapshot(core, -1 /*step*/);
        };
        /**
         * Redo next edit operation
         */
        EditorBase.prototype.redo = function () {
            this.focus();
            var core = this.getCore();
            core.api.restoreUndoSnapshot(core, 1 /*step*/);
        };
        /**
         * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger
         * ContentChangedEvent with given change source.
         * If this function is called nested, undo snapshot will only be added in the outside one
         * @param callback The callback function to perform formatting, returns a data object which will be used as
         * the data field in ContentChangedEvent if changeSource is not null.
         * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,
         * a ContentChangedEvent will be fired with change source equal to this value
         * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complete).
         */
        EditorBase.prototype.addUndoSnapshot = function (callback, changeSource, canUndoByBackspace, additionalData) {
            var core = this.getCore();
            core.api.addUndoSnapshot(core, callback !== null && callback !== void 0 ? callback : null, changeSource !== null && changeSource !== void 0 ? changeSource : null, canUndoByBackspace !== null && canUndoByBackspace !== void 0 ? canUndoByBackspace : false, additionalData);
        };
        /**
         * Whether there is an available undo/redo snapshot
         */
        EditorBase.prototype.getUndoState = function () {
            var _a = this.getCore().undo, hasNewContent = _a.hasNewContent, snapshotsService = _a.snapshotsService;
            return {
                canUndo: hasNewContent || snapshotsService.canMove(-1 /*previousSnapshot*/),
                canRedo: snapshotsService.canMove(1 /*nextSnapshot*/),
            };
        };
        //#endregion
        //#region Misc
        /**
         * Get document which contains this editor
         * @returns The HTML document which contains this editor
         */
        EditorBase.prototype.getDocument = function () {
            return this.getCore().contentDiv.ownerDocument;
        };
        /**
         * Get the scroll container of the editor
         */
        EditorBase.prototype.getScrollContainer = function () {
            return this.getCore().domEvent.scrollContainer;
        };
        /**
         * Get custom data related to this editor
         * @param key Key of the custom data
         * @param getter Getter function. If custom data for the given key doesn't exist,
         * call this function to get one and store it if it is specified. Otherwise return undefined
         * @param disposer An optional disposer function to dispose this custom data when
         * dispose editor.
         */
        EditorBase.prototype.getCustomData = function (key, getter, disposer) {
            var core = this.getCore();
            return (core.lifecycle.customData[key] = core.lifecycle.customData[key] || {
                value: getter ? getter() : undefined,
                disposer: disposer,
            }).value;
        };
        /**
         * Check if editor is in IME input sequence
         * @returns True if editor is in IME input sequence, otherwise false
         */
        EditorBase.prototype.isInIME = function () {
            return this.getCore().domEvent.isInIME;
        };
        /**
         * Get default format of this editor
         * @returns Default format object of this editor
         */
        EditorBase.prototype.getDefaultFormat = function () {
            var _a;
            return (_a = this.getCore().lifecycle.defaultFormat) !== null && _a !== void 0 ? _a : {};
        };
        /**
         * Get a content traverser for the whole editor
         * @param startNode The node to start from. If not passed, it will start from the beginning of the body
         */
        EditorBase.prototype.getBodyTraverser = function (startNode) {
            return roosterjs_editor_dom_1.ContentTraverser.createBodyTraverser(this.getCore().contentDiv, startNode);
        };
        /**
         * Get a content traverser for current selection
         * @returns A content traverser, or null if editor never got focus before
         */
        EditorBase.prototype.getSelectionTraverser = function (range) {
            var _a;
            range = (_a = range !== null && range !== void 0 ? range : this.getSelectionRange()) !== null && _a !== void 0 ? _a : undefined;
            return range
                ? roosterjs_editor_dom_1.ContentTraverser.createSelectionTraverser(this.getCore().contentDiv, range)
                : null;
        };
        /**
         * Get a content traverser for current block element start from specified position
         * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart
         * @returns A content traverser, or null if editor never got focus before
         */
        EditorBase.prototype.getBlockTraverser = function (startFrom) {
            if (startFrom === void 0) { startFrom = 3 /* SelectionStart */; }
            var range = this.getSelectionRange();
            return range
                ? roosterjs_editor_dom_1.ContentTraverser.createBlockTraverser(this.getCore().contentDiv, range, startFrom)
                : null;
        };
        /**
         * Get a text traverser of current selection
         * @param event Optional, if specified, editor will try to get cached result from the event object first.
         * If it is not cached before, query from DOM and cache the result into the event object
         * @returns A content traverser, or null if editor never got focus before
         */
        EditorBase.prototype.getContentSearcherOfCursor = function (event) {
            var _this = this;
            return (0, roosterjs_editor_dom_1.cacheGetEventData)(event !== null && event !== void 0 ? event : null, 'ContentSearcher', function () {
                var range = _this.getSelectionRange();
                return (range &&
                    new roosterjs_editor_dom_1.PositionContentSearcher(_this.getCore().contentDiv, roosterjs_editor_dom_1.Position.getStart(range)));
            });
        };
        /**
         * Run a callback function asynchronously
         * @param callback The callback function to run
         * @returns a function to cancel this async run
         */
        EditorBase.prototype.runAsync = function (callback) {
            var _this = this;
            var win = this.getCore().contentDiv.ownerDocument.defaultView || window;
            var handle = win.requestAnimationFrame(function () {
                if (!_this.isDisposed() && callback) {
                    callback(_this);
                }
            });
            return function () {
                win.cancelAnimationFrame(handle);
            };
        };
        /**
         * Set DOM attribute of editor content DIV
         * @param name Name of the attribute
         * @param value Value of the attribute
         */
        EditorBase.prototype.setEditorDomAttribute = function (name, value) {
            if (value === null) {
                this.getCore().contentDiv.removeAttribute(name);
            }
            else {
                this.getCore().contentDiv.setAttribute(name, value);
            }
        };
        /**
         * Get DOM attribute of editor content DIV, null if there is no such attribute.
         * @param name Name of the attribute
         */
        EditorBase.prototype.getEditorDomAttribute = function (name) {
            return this.getCore().contentDiv.getAttribute(name);
        };
        /**
         * @deprecated Use getVisibleViewport() instead.
         *
         * Get current relative distance from top-left corner of the given element to top-left corner of editor content DIV.
         * @param element The element to calculate from. If the given element is not in editor, return value will be null
         * @param addScroll When pass true, The return value will also add scrollLeft and scrollTop if any. So the value
         * may be different than what user is seeing from the view. When pass false, scroll position will be ignored.
         * @returns An [x, y] array which contains the left and top distances, or null if the given element is not in editor.
         */
        EditorBase.prototype.getRelativeDistanceToEditor = function (element, addScroll) {
            if (this.contains(element)) {
                var contentDiv = this.getCore().contentDiv;
                var editorRect = contentDiv.getBoundingClientRect();
                var elementRect = element.getBoundingClientRect();
                if (editorRect && elementRect) {
                    var x = elementRect.left - (editorRect === null || editorRect === void 0 ? void 0 : editorRect.left);
                    var y = elementRect.top - (editorRect === null || editorRect === void 0 ? void 0 : editorRect.top);
                    if (addScroll) {
                        x += contentDiv.scrollLeft;
                        y += contentDiv.scrollTop;
                    }
                    return [x, y];
                }
            }
            return null;
        };
        /**
         * Add a Content Edit feature.
         * @param feature The feature to add
         */
        EditorBase.prototype.addContentEditFeature = function (feature) {
            var core = this.getCore();
            feature === null || feature === void 0 ? void 0 : feature.keys.forEach(function (key) {
                var array = core.edit.features[key] || [];
                array.push(feature);
                core.edit.features[key] = array;
            });
        };
        /**
         * Remove a Content Edit feature.
         * @param feature The feature to remove
         */
        EditorBase.prototype.removeContentEditFeature = function (feature) {
            var core = this.getCore();
            feature === null || feature === void 0 ? void 0 : feature.keys.forEach(function (key) {
                var _a;
                var featureSet = core.edit.features[key];
                var index = (_a = featureSet === null || featureSet === void 0 ? void 0 : featureSet.indexOf(feature)) !== null && _a !== void 0 ? _a : -1;
                if (index >= 0) {
                    core.edit.features[key].splice(index, 1);
                    if (core.edit.features[key].length < 1) {
                        delete core.edit.features[key];
                    }
                }
            });
        };
        /**
         * Get style based format state from current selection, including font name/size and colors
         */
        EditorBase.prototype.getStyleBasedFormatState = function (node) {
            var _a;
            if (!node) {
                var range = this.getSelectionRange();
                node = (_a = (range && roosterjs_editor_dom_1.Position.getStart(range).normalize().node)) !== null && _a !== void 0 ? _a : undefined;
            }
            var core = this.getCore();
            return core.api.getStyleBasedFormatState(core, node !== null && node !== void 0 ? node : null);
        };
        /**
         * Get the pendable format such as underline and bold
         * @param forceGetStateFromDOM If set to true, will force get the format state from DOM tree.
         * @returns The pending format state
         */
        EditorBase.prototype.getPendableFormatState = function (forceGetStateFromDOM) {
            if (forceGetStateFromDOM === void 0) { forceGetStateFromDOM = false; }
            var core = this.getCore();
            return core.api.getPendableFormatState(core, forceGetStateFromDOM);
        };
        /**
         * Ensure user will type into a container element rather than into the editor content DIV directly
         * @param position The position that user is about to type to
         * @param keyboardEvent Optional keyboard event object
         */
        EditorBase.prototype.ensureTypeInContainer = function (position, keyboardEvent) {
            var core = this.getCore();
            core.api.ensureTypeInContainer(core, position, keyboardEvent);
        };
        //#endregion
        //#region Dark mode APIs
        /**
         * Set the dark mode state and transforms the content to match the new state.
         * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.
         */
        EditorBase.prototype.setDarkModeState = function (nextDarkMode) {
            var isDarkMode = this.isDarkMode();
            if (isDarkMode == !!nextDarkMode) {
                return;
            }
            var core = this.getCore();
            core.api.transformColor(core, core.contentDiv, false /*includeSelf*/, null /*callback*/, nextDarkMode
                ? 0 /* LightToDark */
                : 1 /* DarkToLight */, true /*forceTransform*/, isDarkMode);
            this.triggerContentChangedEvent(nextDarkMode ? "SwitchToDarkMode" /* SwitchToDarkMode */ : "SwitchToLightMode" /* SwitchToLightMode */);
        };
        /**
         * Check if the editor is in dark mode
         * @returns True if the editor is in dark mode, otherwise false
         */
        EditorBase.prototype.isDarkMode = function () {
            return this.getCore().lifecycle.isDarkMode;
        };
        /**
         * Transform the given node and all its child nodes to dark mode color if editor is in dark mode
         * @param node The node to transform
         * @param direction The transform direction. @default ColorTransformDirection.LightToDark
         */
        EditorBase.prototype.transformToDarkColor = function (node, direction) {
            if (direction === void 0) { direction = 0 /* LightToDark */; }
            var core = this.getCore();
            core.api.transformColor(core, node, true /*includeSelf*/, null /*callback*/, direction);
        };
        /**
         * Get a darkColorHandler object for this editor.
         */
        EditorBase.prototype.getDarkColorHandler = function () {
            return this.getCore().darkColorHandler;
        };
        /**
         * Make the editor in "Shadow Edit" mode.
         * In Shadow Edit mode, all format change will finally be ignored.
         * This can be used for building a live preview feature for format button, to allow user
         * see format result without really apply it.
         * This function can be called repeated. If editor is already in shadow edit mode, we can still
         * use this function to do more shadow edit operation.
         */
        EditorBase.prototype.startShadowEdit = function () {
            var core = this.getCore();
            core.api.switchShadowEdit(core, true /*isOn*/);
        };
        /**
         * Leave "Shadow Edit" mode, all changes made during shadow edit will be discarded
         */
        EditorBase.prototype.stopShadowEdit = function () {
            var core = this.getCore();
            core.api.switchShadowEdit(core, false /*isOn*/);
        };
        /**
         * Check if editor is in Shadow Edit mode
         */
        EditorBase.prototype.isInShadowEdit = function () {
            return !!this.getCore().lifecycle.shadowEditFragment;
        };
        /**
         * Check if the given experimental feature is enabled
         * @param feature The feature to check
         */
        EditorBase.prototype.isFeatureEnabled = function (feature) {
            return (0, isFeatureEnabled_1.isFeatureEnabled)(this.getCore().lifecycle.experimentalFeatures, feature);
        };
        /**
         * Get a function to convert HTML string to trusted HTML string.
         * By default it will just return the input HTML directly. To override this behavior,
         * pass your own trusted HTML handler to EditorOptions.trustedHTMLHandler
         * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types
         */
        EditorBase.prototype.getTrustedHTMLHandler = function () {
            return this.getCore().trustedHTMLHandler;
        };
        /**
         * @deprecated Use getZoomScale() instead
         */
        EditorBase.prototype.getSizeTransformer = function () {
            return this.getCore().sizeTransformer;
        };
        /**
         * Get current zoom scale, default value is 1
         * When editor is put under a zoomed container, need to pass the zoom scale number using EditorOptions.zoomScale
         * to let editor behave correctly especially for those mouse drag/drop behaviors
         * @returns current zoom scale number
         */
        EditorBase.prototype.getZoomScale = function () {
            return this.getCore().zoomScale;
        };
        /**
         * Set current zoom scale, default value is 1
         * When editor is put under a zoomed container, need to pass the zoom scale number using EditorOptions.zoomScale
         * to let editor behave correctly especially for those mouse drag/drop behaviors
         * @param scale The new scale number to set. It should be positive number and no greater than 10, otherwise it will be ignored.
         */
        EditorBase.prototype.setZoomScale = function (scale) {
            var core = this.getCore();
            if (scale > 0 && scale <= 10) {
                var oldValue = core.zoomScale;
                core.zoomScale = scale;
                if (oldValue != scale) {
                    this.triggerPluginEvent(21 /* ZoomChanged */, {
                        oldZoomScale: oldValue,
                        newZoomScale: scale,
                    }, true /*broadcast*/);
                }
            }
        };
        /**
         * Retrieves the rect of the visible viewport of the editor.
         */
        EditorBase.prototype.getVisibleViewport = function () {
            return this.getCore().getVisibleViewport();
        };
        /**
         * @returns the current EditorCore object
         * @throws a standard Error if there's no core object
         */
        EditorBase.prototype.getCore = function () {
            if (!this.core) {
                throw new Error('Editor is already disposed');
            }
            return this.core;
        };
        return EditorBase;
    }());
    exports.EditorBase = EditorBase;
});
//# sourceMappingURL=EditorBase.js.map