{"version":3,"file":"EditorBase.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-core/lib/editor/EditorBase.ts"],"names":[],"mappings":"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","sourcesContent":["import { isFeatureEnabled } from './isFeatureEnabled';\nimport {\n    ChangeSource,\n    ColorTransformDirection,\n    ContentPosition,\n    GetContentMode,\n    PluginEventType,\n    PositionType,\n    QueryScope,\n    RegionType,\n} from 'roosterjs-editor-types';\nimport type {\n    BlockElement,\n    ClipboardData,\n    ContentChangedData,\n    CoreCreator,\n    DarkColorHandler,\n    DefaultFormat,\n    DOMEventHandler,\n    EditorCore,\n    EditorOptions,\n    EditorUndoState,\n    ExperimentalFeatures,\n    GenericContentEditFeature,\n    IContentTraverser,\n    IEditor,\n    InsertOption,\n    IPositionContentSearcher,\n    NodePosition,\n    PendableFormatState,\n    PluginEvent,\n    PluginEventData,\n    PluginEventFromType,\n    Rect,\n    Region,\n    SelectionPath,\n    SelectionRangeEx,\n    SizeTransformer,\n    StyleBasedFormatState,\n    TableSelection,\n    TrustedHTMLHandler,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    collapseNodes,\n    contains,\n    ContentTraverser,\n    deleteSelectedContent,\n    getRegionsFromRange,\n    findClosestElementAncestor,\n    getBlockElementAtNode,\n    getSelectionPath,\n    getTagOfNode,\n    isNodeEmpty,\n    Position,\n    PositionContentSearcher,\n    queryElements,\n    wrap,\n    isPositionAtBeginningOf,\n    toArray,\n} from 'roosterjs-editor-dom';\nimport type {\n    CompatibleChangeSource,\n    CompatibleColorTransformDirection,\n    CompatibleContentPosition,\n    CompatibleExperimentalFeatures,\n    CompatibleGetContentMode,\n    CompatiblePluginEventType,\n    CompatibleQueryScope,\n    CompatibleRegionType,\n} from 'roosterjs-editor-types/lib/compatibleTypes';\n\n/**\n * Base class of editor\n */\nexport class EditorBase<TEditorCore extends EditorCore, TEditorOptions extends EditorOptions>\n    implements IEditor {\n    private core: TEditorCore | null = null;\n\n    //#region Lifecycle\n\n    /**\n     * Creates an instance of EditorBase\n     * @param contentDiv The DIV HTML element which will be the container element of editor\n     * @param options An optional options object to customize the editor\n     */\n    constructor(\n        contentDiv: HTMLDivElement,\n        options: TEditorOptions,\n        coreCreator: CoreCreator<TEditorCore, TEditorOptions>\n    ) {\n        // 1. Make sure all parameters are valid\n        if (getTagOfNode(contentDiv) != 'DIV') {\n            throw new Error('contentDiv must be an HTML DIV element');\n        }\n\n        // 2. Create editor core\n        this.core = coreCreator(contentDiv, options);\n\n        // 3. Initialize plugins\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\n\n        // 4. Ensure user will type in a container node, not the editor content DIV\n        this.ensureTypeInContainer(\n            new Position(this.core.contentDiv, PositionType.Begin).normalize()\n        );\n    }\n\n    /**\n     * Dispose this editor, dispose all plugins and custom data\n     */\n    public dispose(): void {\n        const core = this.getCore();\n\n        for (let i = core.plugins.length - 1; i >= 0; i--) {\n            const plugin = core.plugins[i];\n\n            try {\n                plugin.dispose();\n            } catch (e) {\n                // Cache the error and pass it out, then keep going since dispose should always succeed\n                core.disposeErrorHandler?.(plugin, e as Error);\n            }\n        }\n\n        core.darkColorHandler.reset();\n\n        this.core = null;\n    }\n\n    /**\n     * Get whether this editor is disposed\n     * @returns True if editor is disposed, otherwise false\n     */\n    public isDisposed(): boolean {\n        return !this.core;\n    }\n\n    //#endregion\n\n    //#region Node API\n\n    /**\n     * Insert node into editor\n     * @param node The node to insert\n     * @param option Insert options. Default value is:\n     *  position: ContentPosition.SelectionStart\n     *  updateCursor: true\n     *  replaceSelection: true\n     *  insertOnNewLine: false\n     * @returns true if node is inserted. Otherwise false\n     */\n    public insertNode(node: Node, option?: InsertOption): boolean {\n        const core = this.getCore();\n        return node ? core.api.insertNode(core, node, option ?? null) : false;\n    }\n\n    /**\n     * Delete a node from editor content\n     * @param node The node to delete\n     * @returns true if node is deleted. Otherwise false\n     */\n    public deleteNode(node: Node): boolean {\n        // Only remove the node when it falls within editor\n        if (node && this.contains(node) && node.parentNode) {\n            node.parentNode.removeChild(node);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Replace a node in editor content with another node\n     * @param existingNode The existing node to be replaced\n     * @param toNode node to replace to\n     * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false\n     * @returns true if node is replaced. Otherwise false\n     */\n    public replaceNode(\n        existingNode: Node,\n        toNode: Node,\n        transformColorForDarkMode?: boolean\n    ): boolean {\n        const core = this.getCore();\n        // Only replace the node when it falls within editor\n        if (this.contains(existingNode) && toNode) {\n            core.api.transformColor(\n                core,\n                transformColorForDarkMode ? toNode : null,\n                true /*includeSelf*/,\n                () => existingNode.parentNode?.replaceChild(toNode, existingNode),\n                ColorTransformDirection.LightToDark\n            );\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Get BlockElement at given node\n     * @param node The node to create InlineElement\n     * @returns The BlockElement result\n     */\n    public getBlockElementAtNode(node: Node): BlockElement | null {\n        return getBlockElementAtNode(this.getCore().contentDiv, node);\n    }\n\n    public contains(arg: Node | Range | null): boolean {\n        if (!arg) {\n            return false;\n        }\n        return contains(this.getCore().contentDiv, <Node>arg);\n    }\n\n    public queryElements(\n        selector: string,\n        scopeOrCallback:\n            | QueryScope\n            | CompatibleQueryScope\n            | ((node: Node) => any) = QueryScope.Body,\n        callback?: (node: Node) => any\n    ) {\n        const core = this.getCore();\n        const result: HTMLElement[] = [];\n        const scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\n\n        const selectionEx = scope == QueryScope.Body ? null : this.getSelectionRangeEx();\n        if (selectionEx) {\n            selectionEx.ranges.forEach(range => {\n                result.push(...queryElements(core.contentDiv, selector, callback, scope, range));\n            });\n        } else {\n            return queryElements(core.contentDiv, selector, callback, scope, undefined /* range */);\n        }\n\n        return result;\n    }\n\n    /**\n     * Collapse nodes within the given start and end nodes to their common ancestor node,\n     * split parent nodes if necessary\n     * @param start The start node\n     * @param end The end node\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\n     * and the returned nodes will be all nodes from start through end after splitting\n     * False to disallow split parent\n     * @returns When canSplitParent is true, returns all node from start through end after splitting,\n     * otherwise just return start and end\n     */\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\n        return collapseNodes(this.getCore().contentDiv, start, end, canSplitParent);\n    }\n\n    //#endregion\n\n    //#region Content API\n\n    /**\n     * Check whether the editor contains any visible content\n     * @param trim Whether trim the content string before check. Default is false\n     * @returns True if there's no visible content, otherwise false\n     */\n    public isEmpty(trim?: boolean): boolean {\n        return isNodeEmpty(this.getCore().contentDiv, trim);\n    }\n\n    /**\n     * Get current editor content as HTML string\n     * @param mode specify what kind of HTML content to retrieve\n     * @returns HTML string representing current editor content\n     */\n    public getContent(\n        mode: GetContentMode | CompatibleGetContentMode = GetContentMode.CleanHTML\n    ): string {\n        const core = this.getCore();\n        return core.api.getContent(core, mode);\n    }\n\n    /**\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\n     * @param content HTML content to set in\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\n     */\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\n        const core = this.getCore();\n        core.api.setContent(core, content, triggerContentChangedEvent);\n    }\n\n    /**\n     * Insert HTML content into editor\n     * @param HTML content to insert\n     * @param option Insert options. Default value is:\n     *  position: ContentPosition.SelectionStart\n     *  updateCursor: true\n     *  replaceSelection: true\n     *  insertOnNewLine: false\n     */\n    public insertContent(content: string, option?: InsertOption) {\n        if (content) {\n            const doc = this.getDocument();\n            const body = new DOMParser().parseFromString(\n                this.getCore().trustedHTMLHandler(content),\n                'text/html'\n            )?.body;\n            let allNodes = body?.childNodes ? toArray(body.childNodes) : [];\n\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\n            // separately to show up on its own line\n            if (option && option.insertOnNewLine && allNodes.length > 1) {\n                allNodes = [wrap(allNodes)];\n            }\n\n            const fragment = doc.createDocumentFragment();\n            allNodes.forEach(node => fragment.appendChild(node));\n\n            this.insertNode(fragment, option);\n        }\n    }\n\n    /**\n     * Delete selected content\n     */\n    public deleteSelectedContent(): NodePosition | null {\n        const range = this.getSelectionRange();\n        if (range && !range.collapsed) {\n            return deleteSelectedContent(this.getCore().contentDiv, range);\n        }\n        return null;\n    }\n\n    /**\n     * Paste into editor using a clipboardData object\n     * @param clipboardData Clipboard data retrieved from clipboard\n     * @param pasteAsText Force pasting as plain text. Default value is false\n     * @param applyCurrentStyle True if apply format of current selection to the pasted content,\n     * false to keep original format.  Default value is false. When pasteAsText is true, this parameter is ignored\n     * @param pasteAsImage: When set to true, if the clipboardData contains a imageDataUri will paste the image to the editor\n     */\n    public paste(\n        clipboardData: ClipboardData,\n        pasteAsText: boolean = false,\n        applyCurrentFormat: boolean = false,\n        pasteAsImage: boolean = false\n    ) {\n        const core = this.getCore();\n        if (!clipboardData) {\n            return;\n        }\n\n        if (clipboardData.snapshotBeforePaste) {\n            // Restore original content before paste a new one\n            this.setContent(clipboardData.snapshotBeforePaste);\n        } else {\n            clipboardData.snapshotBeforePaste = this.getContent(\n                GetContentMode.RawHTMLWithSelection\n            );\n        }\n\n        const range = this.getSelectionRange();\n        const pos = range && Position.getStart(range);\n        const fragment = core.api.createPasteFragment(\n            core,\n            clipboardData,\n            pos,\n            pasteAsText,\n            applyCurrentFormat,\n            pasteAsImage\n        );\n        if (fragment) {\n            this.addUndoSnapshot(() => {\n                this.insertNode(fragment);\n                return clipboardData;\n            }, ChangeSource.Paste);\n        }\n    }\n\n    //#endregion\n\n    //#region Focus and Selection\n\n    /**\n     * Get current selection range from Editor.\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\n     * Default value is true\n     * @returns current selection range, or null if editor never got focus before\n     */\n    public getSelectionRange(tryGetFromCache: boolean = true): Range | null {\n        const core = this.getCore();\n        return core.api.getSelectionRange(core, tryGetFromCache);\n    }\n\n    /**\n     * Get current selection range from Editor.\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\n     * Default value is true\n     * @returns current selection range, or null if editor never got focus before\n     */\n    public getSelectionRangeEx(): SelectionRangeEx {\n        const core = this.getCore();\n        return core.api.getSelectionRangeEx(core);\n    }\n\n    /**\n     * Get current selection in a serializable format\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\n     * @returns current selection path, or null if editor never got focus before\n     */\n    public getSelectionPath(): SelectionPath | null {\n        const range = this.getSelectionRange();\n        return range && getSelectionPath(this.getCore().contentDiv, range);\n    }\n\n    /**\n     * Check if focus is in editor now\n     * @returns true if focus is in editor, otherwise false\n     */\n    public hasFocus(): boolean {\n        const core = this.getCore();\n        return core.api.hasFocus(core);\n    }\n\n    /**\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\n     */\n    public focus() {\n        const core = this.getCore();\n        core.api.focus(core);\n    }\n\n    public select(\n        arg1: Range | SelectionRangeEx | NodePosition | Node | SelectionPath | null,\n        arg2?: NodePosition | number | PositionType | TableSelection | null,\n        arg3?: Node,\n        arg4?: number | PositionType\n    ): boolean {\n        const core = this.getCore();\n\n        return core.api.select(core, arg1, arg2, arg3, arg4);\n    }\n\n    /**\n     * Get current focused position. Return null if editor doesn't have focus at this time.\n     */\n    public getFocusedPosition(): NodePosition | null {\n        const sel = this.getDocument().defaultView?.getSelection();\n        if (sel?.focusNode && this.contains(sel.focusNode)) {\n            return new Position(sel.focusNode, sel.focusOffset);\n        }\n\n        const range = this.getSelectionRange();\n        if (range) {\n            return Position.getStart(range);\n        }\n\n        return null;\n    }\n\n    /**\n     * Get an HTML element from current cursor position.\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\n     * or its parent node (if current node is a Text node).\n     * When expectedTags is specified, return value is the first ancestor of current node which has\n     * one of the expected tags.\n     * If no element found within editor by the given tag, return null.\n     * @param selector Optional, an HTML selector to find HTML element with.\n     * @param startFrom Start search from this node. If not specified, start from current focused position\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\n     * If it is not cached before, query from DOM and cache the result into the event object\n     */\n    public getElementAtCursor(\n        selector?: string,\n        startFrom?: Node,\n        event?: PluginEvent\n    ): HTMLElement | null {\n        event = startFrom ? undefined : event; // Only use cache when startFrom is not specified, for different start position can have different result\n\n        return (\n            cacheGetEventData(event ?? null, 'GET_ELEMENT_AT_CURSOR_' + selector, () => {\n                if (!startFrom) {\n                    const position = this.getFocusedPosition();\n                    startFrom = position?.node;\n                }\n                return (\n                    startFrom &&\n                    findClosestElementAncestor(startFrom, this.getCore().contentDiv, selector)\n                );\n            }) ?? null\n        );\n    }\n\n    /**\n     * Check if this position is at beginning of the editor.\n     * This will return true if all nodes between the beginning of target node and the position are empty.\n     * @param position The position to check\n     * @returns True if position is at beginning of the editor, otherwise false\n     */\n    public isPositionAtBeginning(position: NodePosition): boolean {\n        return isPositionAtBeginningOf(position, this.getCore().contentDiv);\n    }\n\n    /**\n     * Get impacted regions from selection\n     */\n    public getSelectedRegions(\n        type: RegionType | CompatibleRegionType = RegionType.Table\n    ): Region[] {\n        const selection = this.getSelectionRangeEx();\n        const result: Region[] = [];\n        const contentDiv = this.getCore().contentDiv;\n        selection.ranges.forEach(range => {\n            result.push(...(range ? getRegionsFromRange(contentDiv, range, type) : []));\n        });\n        return result.filter((value, index, self) => {\n            return self.indexOf(value) === index;\n        });\n    }\n\n    //#endregion\n\n    //#region EVENT API\n\n    public addDomEventHandler(\n        nameOrMap: string | Record<string, DOMEventHandler>,\n        handler?: DOMEventHandler\n    ): () => void {\n        const eventsToMap = typeof nameOrMap == 'string' ? { [nameOrMap]: handler! } : nameOrMap;\n        const core = this.getCore();\n        return core.api.attachDomEvent(core, eventsToMap);\n    }\n\n    /**\n     * Trigger an event to be dispatched to all plugins\n     * @param eventType Type of the event\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\n     * the result of this function provides a chance to read the modified result\n     */\n    public triggerPluginEvent<T extends PluginEventType | CompatiblePluginEventType>(\n        eventType: T,\n        data: PluginEventData<T>,\n        broadcast: boolean = false\n    ): PluginEventFromType<T> {\n        const core = this.getCore();\n        const event = ({\n            eventType,\n            ...data,\n        } as any) as PluginEventFromType<T>;\n        core.api.triggerEvent(core, event, broadcast);\n\n        return event;\n    }\n\n    /**\n     * Trigger a ContentChangedEvent\n     * @param source Source of this event, by default is 'SetContent'\n     * @param data additional data for this event\n     */\n    public triggerContentChangedEvent(\n        source: ChangeSource | CompatibleChangeSource | string = ChangeSource.SetContent,\n        data?: any\n    ) {\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\n            source,\n            data,\n        });\n    }\n\n    //#endregion\n\n    //#region Undo API\n\n    /**\n     * Undo last edit operation\n     */\n    public undo() {\n        this.focus();\n        const core = this.getCore();\n        core.api.restoreUndoSnapshot(core, -1 /*step*/);\n    }\n\n    /**\n     * Redo next edit operation\n     */\n    public redo() {\n        this.focus();\n        const core = this.getCore();\n        core.api.restoreUndoSnapshot(core, 1 /*step*/);\n    }\n\n    /**\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\n     * ContentChangedEvent with given change source.\n     * If this function is called nested, undo snapshot will only be added in the outside one\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\n     * the data field in ContentChangedEvent if changeSource is not null.\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\n     * a ContentChangedEvent will be fired with change source equal to this value\n     * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complete).\n     */\n    public addUndoSnapshot(\n        callback?: (start: NodePosition | null, end: NodePosition | null) => any,\n        changeSource?: ChangeSource | CompatibleChangeSource | string,\n        canUndoByBackspace?: boolean,\n        additionalData?: ContentChangedData\n    ) {\n        const core = this.getCore();\n        core.api.addUndoSnapshot(\n            core,\n            callback ?? null,\n            changeSource ?? null,\n            canUndoByBackspace ?? false,\n            additionalData\n        );\n    }\n\n    /**\n     * Whether there is an available undo/redo snapshot\n     */\n    public getUndoState(): EditorUndoState {\n        const { hasNewContent, snapshotsService } = this.getCore().undo;\n        return {\n            canUndo: hasNewContent || snapshotsService.canMove(-1 /*previousSnapshot*/),\n            canRedo: snapshotsService.canMove(1 /*nextSnapshot*/),\n        };\n    }\n\n    //#endregion\n\n    //#region Misc\n\n    /**\n     * Get document which contains this editor\n     * @returns The HTML document which contains this editor\n     */\n    public getDocument(): Document {\n        return this.getCore().contentDiv.ownerDocument;\n    }\n\n    /**\n     * Get the scroll container of the editor\n     */\n    public getScrollContainer(): HTMLElement {\n        return this.getCore().domEvent.scrollContainer;\n    }\n\n    /**\n     * Get custom data related to this editor\n     * @param key Key of the custom data\n     * @param getter Getter function. If custom data for the given key doesn't exist,\n     * call this function to get one and store it if it is specified. Otherwise return undefined\n     * @param disposer An optional disposer function to dispose this custom data when\n     * dispose editor.\n     */\n    public getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\n        const core = this.getCore();\n        return (core.lifecycle.customData[key] = core.lifecycle.customData[key] || {\n            value: getter ? getter() : undefined,\n            disposer,\n        }).value as T;\n    }\n\n    /**\n     * Check if editor is in IME input sequence\n     * @returns True if editor is in IME input sequence, otherwise false\n     */\n    public isInIME(): boolean {\n        return this.getCore().domEvent.isInIME;\n    }\n\n    /**\n     * Get default format of this editor\n     * @returns Default format object of this editor\n     */\n    public getDefaultFormat(): DefaultFormat {\n        return this.getCore().lifecycle.defaultFormat ?? {};\n    }\n\n    /**\n     * Get a content traverser for the whole editor\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\n     */\n    public getBodyTraverser(startNode?: Node): IContentTraverser {\n        return ContentTraverser.createBodyTraverser(this.getCore().contentDiv, startNode);\n    }\n\n    /**\n     * Get a content traverser for current selection\n     * @returns A content traverser, or null if editor never got focus before\n     */\n    public getSelectionTraverser(range?: Range): IContentTraverser | null {\n        range = range ?? this.getSelectionRange() ?? undefined;\n        return range\n            ? ContentTraverser.createSelectionTraverser(this.getCore().contentDiv, range)\n            : null;\n    }\n\n    /**\n     * Get a content traverser for current block element start from specified position\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\n     * @returns A content traverser, or null if editor never got focus before\n     */\n    public getBlockTraverser(\n        startFrom: ContentPosition | CompatibleContentPosition = ContentPosition.SelectionStart\n    ): IContentTraverser | null {\n        const range = this.getSelectionRange();\n        return range\n            ? ContentTraverser.createBlockTraverser(this.getCore().contentDiv, range, startFrom)\n            : null;\n    }\n\n    /**\n     * Get a text traverser of current selection\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\n     * If it is not cached before, query from DOM and cache the result into the event object\n     * @returns A content traverser, or null if editor never got focus before\n     */\n    public getContentSearcherOfCursor(event?: PluginEvent): IPositionContentSearcher | null {\n        return cacheGetEventData(event ?? null, 'ContentSearcher', () => {\n            const range = this.getSelectionRange();\n            return (\n                range &&\n                new PositionContentSearcher(this.getCore().contentDiv, Position.getStart(range))\n            );\n        });\n    }\n\n    /**\n     * Run a callback function asynchronously\n     * @param callback The callback function to run\n     * @returns a function to cancel this async run\n     */\n    public runAsync(callback: (editor: IEditor) => void) {\n        const win = this.getCore().contentDiv.ownerDocument.defaultView || window;\n        const handle = win.requestAnimationFrame(() => {\n            if (!this.isDisposed() && callback) {\n                callback(this);\n            }\n        });\n\n        return () => {\n            win.cancelAnimationFrame(handle);\n        };\n    }\n\n    /**\n     * Set DOM attribute of editor content DIV\n     * @param name Name of the attribute\n     * @param value Value of the attribute\n     */\n    public setEditorDomAttribute(name: string, value: string | null) {\n        if (value === null) {\n            this.getCore().contentDiv.removeAttribute(name);\n        } else {\n            this.getCore().contentDiv.setAttribute(name, value);\n        }\n    }\n\n    /**\n     * Get DOM attribute of editor content DIV, null if there is no such attribute.\n     * @param name Name of the attribute\n     */\n    public getEditorDomAttribute(name: string): string | null {\n        return this.getCore().contentDiv.getAttribute(name);\n    }\n\n    /**\n     * @deprecated Use getVisibleViewport() instead.\n     *\n     * Get current relative distance from top-left corner of the given element to top-left corner of editor content DIV.\n     * @param element The element to calculate from. If the given element is not in editor, return value will be null\n     * @param addScroll When pass true, The return value will also add scrollLeft and scrollTop if any. So the value\n     * may be different than what user is seeing from the view. When pass false, scroll position will be ignored.\n     * @returns An [x, y] array which contains the left and top distances, or null if the given element is not in editor.\n     */\n    getRelativeDistanceToEditor(element: HTMLElement, addScroll?: boolean): number[] | null {\n        if (this.contains(element)) {\n            const contentDiv = this.getCore().contentDiv;\n            const editorRect = contentDiv.getBoundingClientRect();\n            const elementRect = element.getBoundingClientRect();\n\n            if (editorRect && elementRect) {\n                let x = elementRect.left - editorRect?.left;\n                let y = elementRect.top - editorRect?.top;\n\n                if (addScroll) {\n                    x += contentDiv.scrollLeft;\n                    y += contentDiv.scrollTop;\n                }\n\n                return [x, y];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Add a Content Edit feature.\n     * @param feature The feature to add\n     */\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\n        const core = this.getCore();\n        feature?.keys.forEach(key => {\n            const array = core.edit.features[key] || [];\n            array.push(feature);\n            core.edit.features[key] = array;\n        });\n    }\n\n    /**\n     * Remove a Content Edit feature.\n     * @param feature The feature to remove\n     */\n    public removeContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\n        const core = this.getCore();\n        feature?.keys.forEach(key => {\n            const featureSet = core.edit.features[key];\n            const index = featureSet?.indexOf(feature) ?? -1;\n            if (index >= 0) {\n                core.edit.features[key].splice(index, 1);\n                if (core.edit.features[key].length < 1) {\n                    delete core.edit.features[key];\n                }\n            }\n        });\n    }\n\n    /**\n     * Get style based format state from current selection, including font name/size and colors\n     */\n    public getStyleBasedFormatState(node?: Node): StyleBasedFormatState {\n        if (!node) {\n            const range = this.getSelectionRange();\n            node = (range && Position.getStart(range).normalize().node) ?? undefined;\n        }\n        const core = this.getCore();\n        return core.api.getStyleBasedFormatState(core, node ?? null);\n    }\n\n    /**\n     * Get the pendable format such as underline and bold\n     * @param forceGetStateFromDOM If set to true, will force get the format state from DOM tree.\n     * @returns The pending format state\n     */\n    public getPendableFormatState(forceGetStateFromDOM: boolean = false): PendableFormatState {\n        const core = this.getCore();\n        return core.api.getPendableFormatState(core, forceGetStateFromDOM);\n    }\n\n    /**\n     * Ensure user will type into a container element rather than into the editor content DIV directly\n     * @param position The position that user is about to type to\n     * @param keyboardEvent Optional keyboard event object\n     */\n    public ensureTypeInContainer(position: NodePosition, keyboardEvent?: KeyboardEvent) {\n        const core = this.getCore();\n        core.api.ensureTypeInContainer(core, position, keyboardEvent);\n    }\n\n    //#endregion\n\n    //#region Dark mode APIs\n\n    /**\n     * Set the dark mode state and transforms the content to match the new state.\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\n     */\n    public setDarkModeState(nextDarkMode?: boolean) {\n        const isDarkMode = this.isDarkMode();\n\n        if (isDarkMode == !!nextDarkMode) {\n            return;\n        }\n        const core = this.getCore();\n\n        core.api.transformColor(\n            core,\n            core.contentDiv,\n            false /*includeSelf*/,\n            null /*callback*/,\n            nextDarkMode\n                ? ColorTransformDirection.LightToDark\n                : ColorTransformDirection.DarkToLight,\n            true /*forceTransform*/,\n            isDarkMode\n        );\n\n        this.triggerContentChangedEvent(\n            nextDarkMode ? ChangeSource.SwitchToDarkMode : ChangeSource.SwitchToLightMode\n        );\n    }\n\n    /**\n     * Check if the editor is in dark mode\n     * @returns True if the editor is in dark mode, otherwise false\n     */\n    public isDarkMode(): boolean {\n        return this.getCore().lifecycle.isDarkMode;\n    }\n\n    /**\n     * Transform the given node and all its child nodes to dark mode color if editor is in dark mode\n     * @param node The node to transform\n     * @param direction The transform direction. @default ColorTransformDirection.LightToDark\n     */\n    public transformToDarkColor(\n        node: Node,\n        direction:\n            | ColorTransformDirection\n            | CompatibleColorTransformDirection = ColorTransformDirection.LightToDark\n    ) {\n        const core = this.getCore();\n        core.api.transformColor(core, node, true /*includeSelf*/, null /*callback*/, direction);\n    }\n\n    /**\n     * Get a darkColorHandler object for this editor.\n     */\n    public getDarkColorHandler(): DarkColorHandler {\n        return this.getCore().darkColorHandler;\n    }\n\n    /**\n     * Make the editor in \"Shadow Edit\" mode.\n     * In Shadow Edit mode, all format change will finally be ignored.\n     * This can be used for building a live preview feature for format button, to allow user\n     * see format result without really apply it.\n     * This function can be called repeated. If editor is already in shadow edit mode, we can still\n     * use this function to do more shadow edit operation.\n     */\n    public startShadowEdit() {\n        const core = this.getCore();\n        core.api.switchShadowEdit(core, true /*isOn*/);\n    }\n\n    /**\n     * Leave \"Shadow Edit\" mode, all changes made during shadow edit will be discarded\n     */\n    public stopShadowEdit() {\n        const core = this.getCore();\n        core.api.switchShadowEdit(core, false /*isOn*/);\n    }\n\n    /**\n     * Check if editor is in Shadow Edit mode\n     */\n    public isInShadowEdit() {\n        return !!this.getCore().lifecycle.shadowEditFragment;\n    }\n\n    /**\n     * Check if the given experimental feature is enabled\n     * @param feature The feature to check\n     */\n    public isFeatureEnabled(\n        feature: ExperimentalFeatures | CompatibleExperimentalFeatures\n    ): boolean {\n        return isFeatureEnabled(this.getCore().lifecycle.experimentalFeatures, feature);\n    }\n\n    /**\n     * Get a function to convert HTML string to trusted HTML string.\n     * By default it will just return the input HTML directly. To override this behavior,\n     * pass your own trusted HTML handler to EditorOptions.trustedHTMLHandler\n     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types\n     */\n    getTrustedHTMLHandler(): TrustedHTMLHandler {\n        return this.getCore().trustedHTMLHandler;\n    }\n\n    /**\n     * @deprecated Use getZoomScale() instead\n     */\n    getSizeTransformer(): SizeTransformer {\n        return this.getCore().sizeTransformer;\n    }\n\n    /**\n     * Get current zoom scale, default value is 1\n     * When editor is put under a zoomed container, need to pass the zoom scale number using EditorOptions.zoomScale\n     * to let editor behave correctly especially for those mouse drag/drop behaviors\n     * @returns current zoom scale number\n     */\n    getZoomScale(): number {\n        return this.getCore().zoomScale;\n    }\n\n    /**\n     * Set current zoom scale, default value is 1\n     * When editor is put under a zoomed container, need to pass the zoom scale number using EditorOptions.zoomScale\n     * to let editor behave correctly especially for those mouse drag/drop behaviors\n     * @param scale The new scale number to set. It should be positive number and no greater than 10, otherwise it will be ignored.\n     */\n    setZoomScale(scale: number): void {\n        const core = this.getCore();\n        if (scale > 0 && scale <= 10) {\n            const oldValue = core.zoomScale;\n            core.zoomScale = scale;\n\n            if (oldValue != scale) {\n                this.triggerPluginEvent(\n                    PluginEventType.ZoomChanged,\n                    {\n                        oldZoomScale: oldValue,\n                        newZoomScale: scale,\n                    },\n                    true /*broadcast*/\n                );\n            }\n        }\n    }\n\n    /**\n     * Retrieves the rect of the visible viewport of the editor.\n     */\n    getVisibleViewport(): Rect | null {\n        return this.getCore().getVisibleViewport();\n    }\n\n    /**\n     * @returns the current EditorCore object\n     * @throws a standard Error if there's no core object\n     */\n    protected getCore(): TEditorCore {\n        if (!this.core) {\n            throw new Error('Editor is already disposed');\n        }\n        return this.core;\n    }\n\n    //#endregion\n}\n"]}