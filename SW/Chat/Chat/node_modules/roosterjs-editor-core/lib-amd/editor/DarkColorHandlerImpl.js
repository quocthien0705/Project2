define(["require", "exports", "roosterjs-editor-dom"], function (require, exports, roosterjs_editor_dom_1) {
    "use strict";
    var _a, _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    var VARIABLE_REGEX = /^\s*var\(\s*(\-\-[a-zA-Z0-9\-_]+)\s*(?:,\s*(.*))?\)\s*$/;
    var VARIABLE_PREFIX = 'var(';
    var COLOR_VAR_PREFIX = 'darkColor';
    var ColorAttributeEnum;
    (function (ColorAttributeEnum) {
        ColorAttributeEnum[ColorAttributeEnum["CssColor"] = 0] = "CssColor";
        ColorAttributeEnum[ColorAttributeEnum["HtmlColor"] = 1] = "HtmlColor";
    })(ColorAttributeEnum || (ColorAttributeEnum = {}));
    var ColorAttributeName = [
        (_a = {},
            _a[0 /* CssColor */] = 'color',
            _a[1 /* HtmlColor */] = 'color',
            _a),
        (_b = {},
            _b[0 /* CssColor */] = 'background-color',
            _b[1 /* HtmlColor */] = 'bgcolor',
            _b),
    ];
    /**
     * @internal
     */
    var DarkColorHandlerImpl = /** @class */ (function () {
        function DarkColorHandlerImpl(contentDiv, getDarkColor) {
            this.contentDiv = contentDiv;
            this.getDarkColor = getDarkColor;
            this.knownColors = {};
        }
        /**
         * Get a copy of known colors
         * @returns
         */
        DarkColorHandlerImpl.prototype.getKnownColorsCopy = function () {
            return Object.values(this.knownColors);
        };
        /**
         * Given a light mode color value and an optional dark mode color value, register this color
         * so that editor can handle it, then return the CSS color value for current color mode.
         * @param lightModeColor Light mode color value
         * @param isDarkMode Whether current color mode is dark mode
         * @param darkModeColor Optional dark mode color value. If not passed, we will calculate one.
         */
        DarkColorHandlerImpl.prototype.registerColor = function (lightModeColor, isDarkMode, darkModeColor) {
            var parsedColor = this.parseColorValue(lightModeColor);
            var colorKey;
            if (parsedColor) {
                lightModeColor = parsedColor.lightModeColor;
                darkModeColor = parsedColor.darkModeColor || darkModeColor;
                colorKey = parsedColor.key;
            }
            if (isDarkMode && lightModeColor) {
                colorKey =
                    colorKey || "--" + COLOR_VAR_PREFIX + "_" + lightModeColor.replace(/[^\d\w]/g, '_');
                if (!this.knownColors[colorKey]) {
                    darkModeColor = darkModeColor || this.getDarkColor(lightModeColor);
                    this.knownColors[colorKey] = { lightModeColor: lightModeColor, darkModeColor: darkModeColor };
                    this.contentDiv.style.setProperty(colorKey, darkModeColor);
                }
                return "var(" + colorKey + ", " + lightModeColor + ")";
            }
            else {
                return lightModeColor;
            }
        };
        /**
         * Reset known color record, clean up registered color variables.
         */
        DarkColorHandlerImpl.prototype.reset = function () {
            var _this = this;
            (0, roosterjs_editor_dom_1.getObjectKeys)(this.knownColors).forEach(function (key) { return _this.contentDiv.style.removeProperty(key); });
            this.knownColors = {};
        };
        /**
         * Parse an existing color value, if it is in variable-based color format, extract color key,
         * light color and query related dark color if any
         * @param color The color string to parse
         * @param isInDarkMode Whether current content is in dark mode. When set to true, if the color value is not in dark var format,
         * we will treat is as a dark mode color and try to find a matched dark mode color.
         */
        DarkColorHandlerImpl.prototype.parseColorValue = function (color, isInDarkMode) {
            var _a;
            var key;
            var lightModeColor = '';
            var darkModeColor;
            if (color) {
                var match = color.startsWith(VARIABLE_PREFIX) ? VARIABLE_REGEX.exec(color) : null;
                if (match) {
                    if (match[2]) {
                        key = match[1];
                        lightModeColor = match[2];
                        darkModeColor = (_a = this.knownColors[key]) === null || _a === void 0 ? void 0 : _a.darkModeColor;
                    }
                    else {
                        lightModeColor = '';
                    }
                }
                else if (isInDarkMode) {
                    // If editor is in dark mode but the color is not in dark color format, it is possible the color was inserted from external code
                    // without any light color info. So we first try to see if there is a known dark color can match this color, and use its related
                    // light color as light mode color. Otherwise we need to drop this color to avoid show "white on white" content.
                    lightModeColor = this.findLightColorFromDarkColor(color) || '';
                    if (lightModeColor) {
                        darkModeColor = color;
                    }
                }
                else {
                    lightModeColor = color;
                }
            }
            return { key: key, lightModeColor: lightModeColor, darkModeColor: darkModeColor };
        };
        /**
         * Find related light mode color from dark mode color.
         * @param darkColor The existing dark color
         */
        DarkColorHandlerImpl.prototype.findLightColorFromDarkColor = function (darkColor) {
            var _this = this;
            var rgbSearch = (0, roosterjs_editor_dom_1.parseColor)(darkColor);
            if (rgbSearch) {
                var key = (0, roosterjs_editor_dom_1.getObjectKeys)(this.knownColors).find(function (key) {
                    var rgbCurrent = (0, roosterjs_editor_dom_1.parseColor)(_this.knownColors[key].darkModeColor);
                    return (rgbCurrent &&
                        rgbCurrent[0] == rgbSearch[0] &&
                        rgbCurrent[1] == rgbSearch[1] &&
                        rgbCurrent[2] == rgbSearch[2]);
                });
                if (key) {
                    return this.knownColors[key].lightModeColor;
                }
            }
            return null;
        };
        /**
         * Transform element color, from dark to light or from light to dark
         * @param element The element to transform color
         * @param fromDarkMode Whether this is transforming color from dark mode
         * @param toDarkMode Whether this is transforming color to dark mode
         */
        DarkColorHandlerImpl.prototype.transformElementColor = function (element, fromDarkMode, toDarkMode) {
            var _this = this;
            ColorAttributeName.forEach(function (names, i) {
                var color = _this.parseColorValue(element.style.getPropertyValue(names[0 /* CssColor */]) ||
                    element.getAttribute(names[1 /* HtmlColor */]), !!fromDarkMode).lightModeColor;
                element.style.setProperty(names[0 /* CssColor */], null);
                element.removeAttribute(names[1 /* HtmlColor */]);
                if (color && color != 'inherit') {
                    (0, roosterjs_editor_dom_1.setColor)(element, color, i != 0, toDarkMode, false /*shouldAdaptFontColor*/, _this);
                }
            });
        };
        return DarkColorHandlerImpl;
    }());
    exports.default = DarkColorHandlerImpl;
});
//# sourceMappingURL=DarkColorHandlerImpl.js.map