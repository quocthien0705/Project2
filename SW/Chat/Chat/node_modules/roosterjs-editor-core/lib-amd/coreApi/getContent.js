define(["require", "exports", "roosterjs-editor-dom"], function (require, exports, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContent = void 0;
    /**
     * @internal
     * Get current editor content as HTML string
     * @param core The EditorCore object
     * @param mode specify what kind of HTML content to retrieve
     * @returns HTML string representing current editor content
     */
    var getContent = function (core, mode) {
        var content = '';
        var triggerExtractContentEvent = mode == 0 /* CleanHTML */;
        var includeSelectionMarker = mode == 2 /* RawHTMLWithSelection */;
        // When there is fragment for shadow edit, always use the cached fragment as document since HTML node in editor
        // has been changed by uncommitted shadow edit which should be ignored.
        var root = core.lifecycle.shadowEditFragment || core.contentDiv;
        if (mode == 4 /* PlainTextFast */) {
            content = root.textContent;
        }
        else if (mode == 3 /* PlainText */) {
            content = (0, roosterjs_editor_dom_1.getTextContent)(root);
        }
        else {
            var clonedRoot = cloneNode(root);
            clonedRoot.normalize();
            var originalRange = core.api.getSelectionRange(core, true /*tryGetFromCache*/);
            var path = !includeSelectionMarker
                ? null
                : core.lifecycle.shadowEditFragment
                    ? core.lifecycle.shadowEditSelectionPath
                    : originalRange
                        ? (0, roosterjs_editor_dom_1.getSelectionPath)(core.contentDiv, originalRange)
                        : null;
            var range = path && (0, roosterjs_editor_dom_1.createRange)(clonedRoot, path.start, path.end);
            core.api.transformColor(core, clonedRoot, false /*includeSelf*/, null /*callback*/, 1 /* DarkToLight */, true /*forceTransform*/, core.lifecycle.isDarkMode);
            if (triggerExtractContentEvent) {
                core.api.triggerEvent(core, {
                    eventType: 8 /* ExtractContentWithDom */,
                    clonedRoot: clonedRoot,
                }, true /*broadcast*/);
                content = clonedRoot.innerHTML;
            }
            else if (range) {
                // range is not null, which means we want to include a selection path in the content
                content = (0, roosterjs_editor_dom_1.getHtmlWithSelectionPath)(clonedRoot, range);
            }
            else {
                content = clonedRoot.innerHTML;
            }
        }
        return content !== null && content !== void 0 ? content : '';
    };
    exports.getContent = getContent;
    function cloneNode(node) {
        var clonedNode;
        if ((0, roosterjs_editor_dom_1.safeInstanceOf)(node, 'DocumentFragment')) {
            clonedNode = node.ownerDocument.createElement('div');
            clonedNode.appendChild(node.cloneNode(true /*deep*/));
        }
        else {
            clonedNode = node.cloneNode(true /*deep*/);
        }
        return clonedNode;
    }
});
//# sourceMappingURL=getContent.js.map