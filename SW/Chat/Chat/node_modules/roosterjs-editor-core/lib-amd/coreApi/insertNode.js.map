{"version":3,"file":"insertNode.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-core/lib/coreApi/insertNode.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n    BlockElement,\n    EditorCore,\n    InsertNode,\n    InsertOption,\n    NodePosition,\n} from 'roosterjs-editor-types';\nimport {\n    ContentPosition,\n    ColorTransformDirection,\n    NodeType,\n    PositionType,\n    RegionType,\n} from 'roosterjs-editor-types';\nimport {\n    createRange,\n    getBlockElementAtNode,\n    getFirstLastBlockElement,\n    isBlockElement,\n    isVoidHtmlElement,\n    Position,\n    safeInstanceOf,\n    toArray,\n    wrap,\n    adjustInsertPosition,\n    getRegionsFromRange,\n    splitTextNode,\n    splitParentNode,\n} from 'roosterjs-editor-dom';\n\nfunction getInitialRange(\n    core: EditorCore,\n    option: InsertOption\n): { range: Range | null; rangeToRestore: Range | null } {\n    // Selection start replaces based on the current selection.\n    // Range inserts based on a provided range.\n    // Both have the potential to use the current selection to restore cursor position\n    // So in both cases we need to store the selection state.\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n    let rangeToRestore = null;\n    if (option.position == ContentPosition.Range) {\n        rangeToRestore = range;\n        range = option.range;\n    } else if (range) {\n        rangeToRestore = range.cloneRange();\n    }\n\n    return { range, rangeToRestore };\n}\n\n/**\n * @internal\n * Insert a DOM node into editor content\n * @param core The EditorCore object. No op if null.\n * @param option An insert option object to specify how to insert the node\n */\nexport const insertNode: InsertNode = (\n    core: EditorCore,\n    node: Node,\n    option: InsertOption | null\n) => {\n    option = option || {\n        position: ContentPosition.SelectionStart,\n        insertOnNewLine: false,\n        updateCursor: true,\n        replaceSelection: true,\n        insertToRegionRoot: false,\n    };\n    const contentDiv = core.contentDiv;\n\n    if (option.updateCursor) {\n        core.api.focus(core);\n    }\n\n    if (option.position == ContentPosition.Outside) {\n        contentDiv.parentNode?.insertBefore(node, contentDiv.nextSibling);\n        return true;\n    }\n\n    core.api.transformColor(\n        core,\n        node,\n        true /*includeSelf*/,\n        () => {\n            if (!option) {\n                return;\n            }\n            switch (option.position) {\n                case ContentPosition.Begin:\n                case ContentPosition.End: {\n                    const isBegin = option.position == ContentPosition.Begin;\n                    const block = getFirstLastBlockElement(contentDiv, isBegin);\n                    let insertedNode: Node | Node[] | undefined;\n                    if (block) {\n                        const refNode = isBegin ? block.getStartNode() : block.getEndNode();\n                        if (\n                            option.insertOnNewLine ||\n                            refNode.nodeType == NodeType.Text ||\n                            isVoidHtmlElement(refNode)\n                        ) {\n                            // For insert on new line, or refNode is text or void html element (HR, BR etc.)\n                            // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\n                            // first and last node. Insert before 'hello' or after 'world', but still inside DIV\n                            if (safeInstanceOf(node, 'DocumentFragment')) {\n                                // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode\n                                // because insertBefore() returns an empty DocumentFragment\n                                insertedNode = toArray(node.childNodes);\n                                refNode.parentNode?.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            } else {\n                                insertedNode = refNode.parentNode?.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            }\n                        } else {\n                            // if the refNode can have child, use appendChild (which is like to insert as first/last child)\n                            // i.e. <div>hello</div>, the content will be inserted before/after hello\n                            insertedNode = refNode.insertBefore(\n                                node,\n                                isBegin ? refNode.firstChild : null\n                            );\n                        }\n                    } else {\n                        // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\n                        insertedNode = contentDiv.appendChild(node);\n                    }\n\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine) {\n                        const nodes = Array.isArray(insertedNode) ? insertedNode : [insertedNode];\n                        if (!isBlockElement(nodes[0]) || !isBlockElement(nodes[nodes.length - 1])) {\n                            wrap(nodes);\n                        }\n                    }\n\n                    break;\n                }\n                case ContentPosition.DomEnd:\n                    // Use appendChild to insert the node at the end of the content div.\n                    const insertedNode = contentDiv.appendChild(node);\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\n                        wrap(insertedNode);\n                    }\n                    break;\n                case ContentPosition.Range:\n                case ContentPosition.SelectionStart:\n                    let { range, rangeToRestore } = getInitialRange(core, option);\n                    if (!range) {\n                        return;\n                    }\n\n                    // if to replace the selection and the selection is not collapsed, remove the the content at selection first\n                    if (option.replaceSelection && !range.collapsed) {\n                        range.deleteContents();\n                    }\n\n                    let pos: NodePosition = Position.getStart(range);\n                    let blockElement: BlockElement | null;\n\n                    if (option.insertOnNewLine && option.insertToRegionRoot) {\n                        pos = adjustInsertPositionRegionRoot(core, range, pos);\n                    } else if (\n                        option.insertOnNewLine &&\n                        (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\n                    ) {\n                        pos = adjustInsertPositionNewLine(blockElement, core, pos);\n                    } else {\n                        pos = adjustInsertPosition(contentDiv, node, pos, range);\n                    }\n\n                    const nodeForCursor =\n                        node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\n\n                    range = createRange(pos);\n                    range.insertNode(node);\n\n                    if (option.updateCursor && nodeForCursor) {\n                        rangeToRestore = createRange(\n                            new Position(nodeForCursor, PositionType.After).normalize()\n                        );\n                    }\n\n                    if (rangeToRestore) {\n                        core.api.selectRange(core, rangeToRestore);\n                    }\n\n                    break;\n            }\n        },\n        ColorTransformDirection.LightToDark\n    );\n\n    return true;\n};\n\nfunction adjustInsertPositionRegionRoot(core: EditorCore, range: Range, position: NodePosition) {\n    const region = getRegionsFromRange(core.contentDiv, range, RegionType.Table)[0];\n    let node: Node | null = position.node;\n\n    if (region) {\n        if (node.nodeType == NodeType.Text && !position.isAtEnd) {\n            node = splitTextNode(node as Text, position.offset, true /*returnFirstPart*/);\n        }\n\n        if (node != region.rootNode) {\n            while (node && node.parentNode != region.rootNode) {\n                splitParentNode(node, false /*splitBefore*/);\n                node = node.parentNode;\n            }\n        }\n\n        if (node) {\n            position = new Position(node, PositionType.After);\n        }\n    }\n\n    return position;\n}\n\nfunction adjustInsertPositionNewLine(blockElement: BlockElement, core: EditorCore, pos: Position) {\n    let tempPos = new Position(blockElement.getEndNode(), PositionType.After);\n    if (safeInstanceOf(tempPos.node, 'HTMLTableRowElement')) {\n        const div = core.contentDiv.ownerDocument.createElement('div');\n        const range = createRange(pos);\n        range.insertNode(div);\n        tempPos = new Position(div, PositionType.Begin);\n    }\n    return tempPos;\n}\n"]}