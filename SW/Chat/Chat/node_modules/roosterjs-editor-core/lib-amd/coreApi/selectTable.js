define(["require", "exports", "./utils/addUniqueId", "roosterjs-editor-dom"], function (require, exports, addUniqueId_1, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.selectTable = void 0;
    var TABLE_ID = 'tableSelected';
    var CONTENT_DIV_ID = 'contentDiv_';
    var STYLE_ID = 'tableStyle';
    var SELECTED_CSS_RULE = '{background-color: rgb(198,198,198) !important; caret-color: transparent}';
    var MAX_RULE_SELECTOR_LENGTH = 9000;
    /**
     * @internal
     * Select a table and save data of the selected range
     * @param core The EditorCore object
     * @param table table to select
     * @param coordinates first and last cell of the selection, if this parameter is null, instead of
     * selecting, will unselect the table.
     * @returns true if successful
     */
    var selectTable = function (core, table, coordinates) {
        var _a;
        unselect(core);
        if (areValidCoordinates(coordinates) && table) {
            (0, addUniqueId_1.default)(table, TABLE_ID);
            (0, addUniqueId_1.default)(core.contentDiv, CONTENT_DIV_ID);
            var _b = select(core, table, coordinates), ranges = _b.ranges, isWholeTableSelected_1 = _b.isWholeTableSelected;
            if (!isMergedCell(table, coordinates)) {
                var cellToSelect = (_a = table.rows
                    .item(coordinates.firstCell.y)) === null || _a === void 0 ? void 0 : _a.cells.item(coordinates.firstCell.x);
                if (cellToSelect) {
                    core.api.selectRange(core, (0, roosterjs_editor_dom_1.createRange)(new roosterjs_editor_dom_1.Position(cellToSelect, 0 /* Begin */)));
                }
            }
            return {
                type: 1 /* TableSelection */,
                ranges: ranges,
                table: table,
                areAllCollapsed: ranges.filter(function (range) { return range === null || range === void 0 ? void 0 : range.collapsed; }).length == ranges.length,
                coordinates: coordinates,
                isWholeTableSelected: isWholeTableSelected_1,
            };
        }
        return null;
    };
    exports.selectTable = selectTable;
    function buildCss(table, coordinates, contentDivSelector) {
        var _a;
        var ranges = [];
        var selectors = [];
        var vTable = new roosterjs_editor_dom_1.VTable(table);
        var isAllTableSelected = (0, roosterjs_editor_dom_1.isWholeTableSelected)(vTable, coordinates);
        if (isAllTableSelected) {
            handleAllTableSelected(contentDivSelector, vTable, selectors, ranges);
        }
        else {
            handleTableSelected(coordinates, vTable, contentDivSelector, selectors, ranges);
        }
        var cssRules = [];
        var currentRules = '';
        while (selectors.length > 0) {
            currentRules += (currentRules.length > 0 ? ',' : '') + selectors.shift() || '';
            if (currentRules.length + (((_a = selectors[0]) === null || _a === void 0 ? void 0 : _a.length) || 0) > MAX_RULE_SELECTOR_LENGTH ||
                selectors.length == 0) {
                cssRules.push(currentRules + ' ' + SELECTED_CSS_RULE);
                currentRules = '';
            }
        }
        return { cssRules: cssRules, ranges: ranges, isWholeTableSelected: isAllTableSelected };
    }
    function handleAllTableSelected(contentDivSelector, vTable, selectors, ranges) {
        var table = vTable.table;
        var tableSelector = contentDivSelector + ' #' + table.id;
        selectors.push(tableSelector, tableSelector + " *");
        var tableRange = new Range();
        tableRange.selectNode(table);
        ranges.push(tableRange);
    }
    function handleTableSelected(coordinates, vTable, contentDivSelector, selectors, ranges) {
        var _a;
        var tr1 = coordinates.firstCell.y;
        var td1 = coordinates.firstCell.x;
        var tr2 = coordinates.lastCell.y;
        var td2 = coordinates.lastCell.x;
        var table = vTable.table;
        var firstSelected = null;
        var lastSelected = null;
        // Get whether table has thead, tbody or tfoot.
        var tableChildren = (0, roosterjs_editor_dom_1.toArray)(table.childNodes).filter(function (node) { return ['THEAD', 'TBODY', 'TFOOT'].indexOf((0, roosterjs_editor_dom_1.getTagOfNode)(node)) > -1; });
        // Set the start and end of each of the table children, so we can build the selector according the element between the table and the row.
        var cont = 0;
        var indexes = tableChildren.map(function (node) {
            var result = {
                el: (0, roosterjs_editor_dom_1.getTagOfNode)(node),
                start: cont,
                end: node.childNodes.length + cont,
            };
            cont = result.end;
            return result;
        });
        (_a = vTable.cells) === null || _a === void 0 ? void 0 : _a.forEach(function (row, rowIndex) {
            var tdCount = 0;
            firstSelected = null;
            lastSelected = null;
            //Get current TBODY/THEAD/TFOOT
            var midElement = indexes.filter(function (ind) { return ind.start <= rowIndex && ind.end > rowIndex; })[0];
            var middleElSelector = midElement ? '>' + midElement.el + '>' : '>';
            var currentRow = midElement && rowIndex + 1 >= midElement.start
                ? rowIndex + 1 - midElement.start
                : rowIndex + 1;
            for (var cellIndex = 0; cellIndex < row.length; cellIndex++) {
                var cell = row[cellIndex].td;
                if (cell) {
                    tdCount++;
                    if (rowIndex >= tr1 && rowIndex <= tr2 && cellIndex >= td1 && cellIndex <= td2) {
                        removeImportant(cell);
                        var selector = generateCssFromCell(contentDivSelector, table.id, middleElSelector, currentRow, (0, roosterjs_editor_dom_1.getTagOfNode)(cell), tdCount);
                        var elementsSelector = selector + ' *';
                        selectors.push(selector, elementsSelector);
                        firstSelected = firstSelected || table.querySelector(selector);
                        lastSelected = table.querySelector(selector);
                    }
                }
            }
            if (firstSelected && lastSelected) {
                var rowRange = new Range();
                rowRange.setStartBefore(firstSelected);
                rowRange.setEndAfter(lastSelected);
                ranges.push(rowRange);
            }
        });
    }
    function select(core, table, coordinates) {
        var contentDivSelector = '#' + core.contentDiv.id;
        var _a = buildCss(table, coordinates, contentDivSelector), cssRules = _a.cssRules, ranges = _a.ranges, isWholeTableSelected = _a.isWholeTableSelected;
        cssRules.forEach(function (css) {
            return (0, roosterjs_editor_dom_1.setGlobalCssStyles)(core.contentDiv.ownerDocument, css, STYLE_ID + core.contentDiv.id);
        });
        return { ranges: ranges, isWholeTableSelected: isWholeTableSelected };
    }
    var unselect = function (core) {
        var doc = core.contentDiv.ownerDocument;
        (0, roosterjs_editor_dom_1.removeGlobalCssStyle)(doc, STYLE_ID + core.contentDiv.id);
    };
    function generateCssFromCell(contentDivSelector, tableId, middleElSelector, rowIndex, cellTag, index) {
        return (contentDivSelector +
            ' #' +
            tableId +
            middleElSelector +
            ' tr:nth-child(' +
            rowIndex +
            ')>' +
            cellTag +
            ':nth-child(' +
            index +
            ')');
    }
    function removeImportant(cell) {
        if (cell) {
            (0, roosterjs_editor_dom_1.removeImportantStyleRule)(cell, ['background-color', 'background']);
        }
    }
    function areValidCoordinates(input) {
        if (input) {
            var _a = input || {}, firstCell = _a.firstCell, lastCell = _a.lastCell;
            if (firstCell && lastCell) {
                var handler = function (coordinate) {
                    return isValidCoordinate(coordinate.x) && isValidCoordinate(coordinate.y);
                };
                return handler(firstCell) && handler(lastCell);
            }
        }
        return false;
    }
    function isValidCoordinate(input) {
        return (!!input || input == 0) && input > -1;
    }
    function isMergedCell(table, coordinates) {
        var _a;
        var firstCell = coordinates.firstCell;
        return !(table.rows.item(firstCell.y) && ((_a = table.rows.item(firstCell.y)) === null || _a === void 0 ? void 0 : _a.cells.item(firstCell.x)));
    }
});
//# sourceMappingURL=selectTable.js.map