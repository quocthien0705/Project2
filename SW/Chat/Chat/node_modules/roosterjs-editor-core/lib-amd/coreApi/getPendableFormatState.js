define(["require", "exports", "roosterjs-editor-dom"], function (require, exports, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPendableFormatState = void 0;
    /**
     * @internal
     * @param core The EditorCore object
     * @param forceGetStateFromDOM If set to true, will force get the format state from DOM tree.
     * @returns The cached format state if it exists. If the cached position do not exist, search for pendable elements in the DOM tree and return the pendable format state.
     */
    var getPendableFormatState = function (core, forceGetStateFromDOM) {
        var _a;
        var range = core.api.getSelectionRange(core, true /* tryGetFromCache*/);
        var cachedPendableFormatState = core.pendingFormatState.pendableFormatState;
        var cachedPosition = (_a = core.pendingFormatState.pendableFormatPosition) === null || _a === void 0 ? void 0 : _a.normalize();
        var currentPosition = range && roosterjs_editor_dom_1.Position.getStart(range).normalize();
        var isSamePosition = currentPosition &&
            cachedPosition &&
            range.collapsed &&
            currentPosition.equalTo(cachedPosition);
        if (range && cachedPendableFormatState && isSamePosition && !forceGetStateFromDOM) {
            return cachedPendableFormatState;
        }
        else {
            return currentPosition ? queryCommandStateFromDOM(core, currentPosition) : {};
        }
    };
    exports.getPendableFormatState = getPendableFormatState;
    var PendableStyleCheckers = {
        isBold: function (tag, style) {
            return tag == 'B' ||
                tag == 'STRONG' ||
                tag == 'H1' ||
                tag == 'H2' ||
                tag == 'H3' ||
                tag == 'H4' ||
                tag == 'H5' ||
                tag == 'H6' ||
                parseInt(style.fontWeight) >= 700 ||
                ['bold', 'bolder'].indexOf(style.fontWeight) >= 0;
        },
        isUnderline: function (tag, style) { return tag == 'U' || style.textDecoration.indexOf('underline') >= 0; },
        isItalic: function (tag, style) { return tag == 'I' || tag == 'EM' || style.fontStyle === 'italic'; },
        isSubscript: function (tag, style) { return tag == 'SUB' || style.verticalAlign === 'sub'; },
        isSuperscript: function (tag, style) { return tag == 'SUP' || style.verticalAlign === 'super'; },
        isStrikeThrough: function (tag, style) {
            return tag == 'S' || tag == 'STRIKE' || style.textDecoration.indexOf('line-through') >= 0;
        },
    };
    /**
     * CssFalsyCheckers checks for non pendable format that might overlay a pendable format, then it can prevent getPendableFormatState return falsy pendable format states.
     */
    var CssFalsyCheckers = {
        isBold: function (style) {
            return (style.fontWeight !== '' && parseInt(style.fontWeight) < 700) ||
                style.fontWeight === 'normal';
        },
        isUnderline: function (style) {
            return style.textDecoration !== '' && style.textDecoration.indexOf('underline') < 0;
        },
        isItalic: function (style) { return style.fontStyle !== '' && style.fontStyle !== 'italic'; },
        isSubscript: function (style) { return style.verticalAlign !== '' && style.verticalAlign !== 'sub'; },
        isSuperscript: function (style) { return style.verticalAlign !== '' && style.verticalAlign !== 'super'; },
        isStrikeThrough: function (style) {
            return style.textDecoration !== '' && style.textDecoration.indexOf('line-through') < 0;
        },
    };
    function queryCommandStateFromDOM(core, currentPosition) {
        var node = currentPosition.node;
        var formatState = {};
        var pendableKeys = [];
        var _loop_1 = function () {
            var tag = (0, roosterjs_editor_dom_1.getTagOfNode)(node);
            var style = node.nodeType == 1 /* Element */ && node.style;
            if (tag && style) {
                (0, roosterjs_editor_dom_1.getObjectKeys)(PendableStyleCheckers).forEach(function (key) {
                    if (!(pendableKeys.indexOf(key) >= 0)) {
                        formatState[key] = formatState[key] || PendableStyleCheckers[key](tag, style);
                        if (CssFalsyCheckers[key](style)) {
                            pendableKeys.push(key);
                        }
                    }
                });
            }
            node = node.parentNode;
        };
        while (node && (0, roosterjs_editor_dom_1.contains)(core.contentDiv, node)) {
            _loop_1();
        }
        return formatState;
    }
});
//# sourceMappingURL=getPendableFormatState.js.map