define(["require", "exports", "roosterjs-editor-dom"], function (require, exports, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setContent = void 0;
    /**
     * @internal
     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered
     * if triggerContentChangedEvent is set to true
     * @param core The EditorCore object
     * @param content HTML content to set in
     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true
     * @param metadata @optional Metadata of the content that helps editor know the selection and color mode.
     * If not passed, we will treat content as in light mode without selection
     */
    var setContent = function (core, content, triggerContentChangedEvent, metadata) {
        var _a, _b;
        var contentChanged = false;
        if (core.contentDiv.innerHTML != content) {
            core.api.triggerEvent(core, {
                eventType: 20 /* BeforeSetContent */,
                newContent: content,
            }, true /*broadcast*/);
            var entities = core.entity.entityMap;
            var html = content || '';
            var body = new DOMParser().parseFromString((_b = (_a = core.trustedHTMLHandler) === null || _a === void 0 ? void 0 : _a.call(core, html)) !== null && _b !== void 0 ? _b : html, 'text/html').body;
            (0, roosterjs_editor_dom_1.restoreContentWithEntityPlaceholder)(body, core.contentDiv, entities);
            var metadataFromContent = (0, roosterjs_editor_dom_1.extractContentMetadata)(core.contentDiv);
            metadata = metadata || metadataFromContent;
            selectContentMetadata(core, metadata);
            contentChanged = true;
        }
        var isDarkMode = core.lifecycle.isDarkMode;
        if ((!metadata && isDarkMode) || (metadata && !!metadata.isDarkMode != !!isDarkMode)) {
            core.api.transformColor(core, core.contentDiv, false /*includeSelf*/, null /*callback*/, isDarkMode ? 0 /* LightToDark */ : 1 /* DarkToLight */, true /*forceTransform*/, metadata === null || metadata === void 0 ? void 0 : metadata.isDarkMode);
            contentChanged = true;
        }
        if (triggerContentChangedEvent && contentChanged) {
            core.api.triggerEvent(core, {
                eventType: 7 /* ContentChanged */,
                source: "SetContent" /* SetContent */,
            }, false /*broadcast*/);
        }
    };
    exports.setContent = setContent;
    function selectContentMetadata(core, metadata) {
        if (!core.lifecycle.shadowEditSelectionPath && metadata) {
            core.domEvent.tableSelectionRange = null;
            core.domEvent.imageSelectionRange = null;
            core.domEvent.selectionRange = null;
            switch (metadata.type) {
                case 0 /* Normal */:
                    core.api.selectTable(core, null);
                    core.api.selectImage(core, null);
                    var range = (0, roosterjs_editor_dom_1.createRange)(core.contentDiv, metadata.start, metadata.end);
                    core.api.selectRange(core, range);
                    break;
                case 1 /* TableSelection */:
                    var table = (0, roosterjs_editor_dom_1.queryElements)(core.contentDiv, '#' + metadata.tableId)[0];
                    if (table) {
                        core.domEvent.tableSelectionRange = core.api.selectTable(core, table, metadata);
                    }
                    break;
                case 2 /* ImageSelection */:
                    var image = (0, roosterjs_editor_dom_1.queryElements)(core.contentDiv, '#' + metadata.imageId)[0];
                    if (image) {
                        core.domEvent.imageSelectionRange = core.api.selectImage(core, image);
                    }
                    break;
            }
        }
    }
});
//# sourceMappingURL=setContent.js.map