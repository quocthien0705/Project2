define(["require", "exports", "./hasFocus", "roosterjs-editor-dom"], function (require, exports, hasFocus_1, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.selectRange = void 0;
    /**
     * @internal
     * Change the editor selection to the given range
     * @param core The EditorCore object
     * @param range The range to select
     * @param skipSameRange When set to true, do nothing if the given range is the same with current selection
     * in editor, otherwise it will always remove current selection range and set to the given one.
     * This parameter is always treat as true in Edge to avoid some weird runtime exception.
     */
    var selectRange = function (core, range, skipSameRange) {
        if (!core.lifecycle.shadowEditSelectionPath && (0, roosterjs_editor_dom_1.contains)(core.contentDiv, range)) {
            (0, roosterjs_editor_dom_1.addRangeToSelection)(range, skipSameRange);
            if (!(0, hasFocus_1.hasFocus)(core)) {
                core.domEvent.selectionRange = range;
            }
            if (range.collapsed) {
                // If selected, and current selection is collapsed,
                // need to restore pending format state if exists.
                restorePendingFormatState(core);
            }
            return true;
        }
        else {
            return false;
        }
    };
    exports.selectRange = selectRange;
    /**
     * Restore cached pending format state (if exist) to current selection
     */
    function restorePendingFormatState(core) {
        var contentDiv = core.contentDiv, pendingFormatState = core.pendingFormatState, getSelectionRange = core.api.getSelectionRange;
        if (pendingFormatState.pendableFormatState) {
            var document_1 = contentDiv.ownerDocument;
            var formatState_1 = (0, roosterjs_editor_dom_1.getPendableFormatState)(document_1);
            (0, roosterjs_editor_dom_1.getObjectKeys)(roosterjs_editor_dom_1.PendableFormatCommandMap).forEach(function (key) {
                var _a;
                if (!!((_a = pendingFormatState.pendableFormatState) === null || _a === void 0 ? void 0 : _a[key]) != formatState_1[key]) {
                    document_1.execCommand(roosterjs_editor_dom_1.PendableFormatCommandMap[key], false /* showUI */, undefined /* value */);
                }
            });
            var range = getSelectionRange(core, true /*tryGetFromCache*/);
            var position = range && roosterjs_editor_dom_1.Position.getStart(range);
            if (position) {
                pendingFormatState.pendableFormatPosition = position;
            }
        }
    }
});
//# sourceMappingURL=selectRange.js.map