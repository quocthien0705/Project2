{"version":3,"file":"DarkColorHandlerImpl.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-core/lib/editor/DarkColorHandlerImpl.ts"],"names":[],"mappings":"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","sourcesContent":["import { getObjectKeys, parseColor, setColor } from 'roosterjs-editor-dom';\nimport type {\n    ColorKeyAndValue,\n    DarkColorHandler,\n    ModeIndependentColor,\n} from 'roosterjs-editor-types';\n\nconst VARIABLE_REGEX = /^\\s*var\\(\\s*(\\-\\-[a-zA-Z0-9\\-_]+)\\s*(?:,\\s*(.*))?\\)\\s*$/;\nconst VARIABLE_PREFIX = 'var(';\nconst COLOR_VAR_PREFIX = 'darkColor';\nconst enum ColorAttributeEnum {\n    CssColor = 0,\n    HtmlColor = 1,\n}\nconst ColorAttributeName: { [key in ColorAttributeEnum]: string }[] = [\n    {\n        [ColorAttributeEnum.CssColor]: 'color',\n        [ColorAttributeEnum.HtmlColor]: 'color',\n    },\n    {\n        [ColorAttributeEnum.CssColor]: 'background-color',\n        [ColorAttributeEnum.HtmlColor]: 'bgcolor',\n    },\n];\n\n/**\n * @internal\n */\nexport default class DarkColorHandlerImpl implements DarkColorHandler {\n    private knownColors: Record<string, Readonly<ModeIndependentColor>> = {};\n\n    constructor(private contentDiv: HTMLElement, private getDarkColor: (color: string) => string) {}\n\n    /**\n     * Get a copy of known colors\n     * @returns\n     */\n    getKnownColorsCopy() {\n        return Object.values(this.knownColors);\n    }\n\n    /**\n     * Given a light mode color value and an optional dark mode color value, register this color\n     * so that editor can handle it, then return the CSS color value for current color mode.\n     * @param lightModeColor Light mode color value\n     * @param isDarkMode Whether current color mode is dark mode\n     * @param darkModeColor Optional dark mode color value. If not passed, we will calculate one.\n     */\n    registerColor(lightModeColor: string, isDarkMode: boolean, darkModeColor?: string): string {\n        const parsedColor = this.parseColorValue(lightModeColor);\n        let colorKey: string | undefined;\n\n        if (parsedColor) {\n            lightModeColor = parsedColor.lightModeColor;\n            darkModeColor = parsedColor.darkModeColor || darkModeColor;\n            colorKey = parsedColor.key;\n        }\n\n        if (isDarkMode && lightModeColor) {\n            colorKey =\n                colorKey || `--${COLOR_VAR_PREFIX}_${lightModeColor.replace(/[^\\d\\w]/g, '_')}`;\n\n            if (!this.knownColors[colorKey]) {\n                darkModeColor = darkModeColor || this.getDarkColor(lightModeColor);\n\n                this.knownColors[colorKey] = { lightModeColor, darkModeColor };\n                this.contentDiv.style.setProperty(colorKey, darkModeColor);\n            }\n\n            return `var(${colorKey}, ${lightModeColor})`;\n        } else {\n            return lightModeColor;\n        }\n    }\n\n    /**\n     * Reset known color record, clean up registered color variables.\n     */\n    reset(): void {\n        getObjectKeys(this.knownColors).forEach(key => this.contentDiv.style.removeProperty(key));\n        this.knownColors = {};\n    }\n\n    /**\n     * Parse an existing color value, if it is in variable-based color format, extract color key,\n     * light color and query related dark color if any\n     * @param color The color string to parse\n     * @param isInDarkMode Whether current content is in dark mode. When set to true, if the color value is not in dark var format,\n     * we will treat is as a dark mode color and try to find a matched dark mode color.\n     */\n    parseColorValue(color: string | undefined | null, isInDarkMode?: boolean): ColorKeyAndValue {\n        let key: string | undefined;\n        let lightModeColor = '';\n        let darkModeColor: string | undefined;\n\n        if (color) {\n            const match = color.startsWith(VARIABLE_PREFIX) ? VARIABLE_REGEX.exec(color) : null;\n\n            if (match) {\n                if (match[2]) {\n                    key = match[1];\n                    lightModeColor = match[2];\n                    darkModeColor = this.knownColors[key]?.darkModeColor;\n                } else {\n                    lightModeColor = '';\n                }\n            } else if (isInDarkMode) {\n                // If editor is in dark mode but the color is not in dark color format, it is possible the color was inserted from external code\n                // without any light color info. So we first try to see if there is a known dark color can match this color, and use its related\n                // light color as light mode color. Otherwise we need to drop this color to avoid show \"white on white\" content.\n                lightModeColor = this.findLightColorFromDarkColor(color) || '';\n\n                if (lightModeColor) {\n                    darkModeColor = color;\n                }\n            } else {\n                lightModeColor = color;\n            }\n        }\n\n        return { key, lightModeColor, darkModeColor };\n    }\n\n    /**\n     * Find related light mode color from dark mode color.\n     * @param darkColor The existing dark color\n     */\n    findLightColorFromDarkColor(darkColor: string): string | null {\n        const rgbSearch = parseColor(darkColor);\n\n        if (rgbSearch) {\n            const key = getObjectKeys(this.knownColors).find(key => {\n                const rgbCurrent = parseColor(this.knownColors[key].darkModeColor);\n\n                return (\n                    rgbCurrent &&\n                    rgbCurrent[0] == rgbSearch[0] &&\n                    rgbCurrent[1] == rgbSearch[1] &&\n                    rgbCurrent[2] == rgbSearch[2]\n                );\n            });\n\n            if (key) {\n                return this.knownColors[key].lightModeColor;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Transform element color, from dark to light or from light to dark\n     * @param element The element to transform color\n     * @param fromDarkMode Whether this is transforming color from dark mode\n     * @param toDarkMode Whether this is transforming color to dark mode\n     */\n    transformElementColor(element: HTMLElement, fromDarkMode: boolean, toDarkMode: boolean): void {\n        ColorAttributeName.forEach((names, i) => {\n            const color = this.parseColorValue(\n                element.style.getPropertyValue(names[ColorAttributeEnum.CssColor]) ||\n                    element.getAttribute(names[ColorAttributeEnum.HtmlColor]),\n                !!fromDarkMode\n            ).lightModeColor;\n\n            element.style.setProperty(names[ColorAttributeEnum.CssColor], null);\n            element.removeAttribute(names[ColorAttributeEnum.HtmlColor]);\n\n            if (color && color != 'inherit') {\n                setColor(element, color, i != 0, toDarkMode, false /*shouldAdaptFontColor*/, this);\n            }\n        });\n    }\n}\n"]}