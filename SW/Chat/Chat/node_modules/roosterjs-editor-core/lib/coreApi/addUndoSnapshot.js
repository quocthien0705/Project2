"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addUndoSnapshot = void 0;
var tslib_1 = require("tslib");
var roosterjs_editor_dom_1 = require("roosterjs-editor-dom");
/**
 * @internal
 * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.
 * Undo snapshot will not be added if this call is nested inside another addUndoSnapshot() call.
 * @param core The EditorCore object
 * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.
 * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent
 * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complete).
 * @param additionalData @optional parameter to provide additional data related to the ContentChanged Event.
 */
var addUndoSnapshot = function (core, callback, changeSource, canUndoByBackspace, additionalData) {
    var _a, _b;
    var undoState = core.undo;
    var isNested = undoState.isNested;
    var data;
    if (!isNested) {
        undoState.isNested = true;
        // When there is getEntityState, it means this is triggered by an entity change.
        // So if HTML content is not changed (hasNewContent is false), no need to add another snapshot before change
        if (core.undo.hasNewContent || !(additionalData === null || additionalData === void 0 ? void 0 : additionalData.getEntityState) || !callback) {
            addUndoSnapshotInternal(core, canUndoByBackspace, (_a = additionalData === null || additionalData === void 0 ? void 0 : additionalData.getEntityState) === null || _a === void 0 ? void 0 : _a.call(additionalData));
        }
    }
    try {
        if (callback) {
            var range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);
            data = callback(range && roosterjs_editor_dom_1.Position.getStart(range).normalize(), range && roosterjs_editor_dom_1.Position.getEnd(range).normalize());
            if (!isNested) {
                var entityStates = (_b = additionalData === null || additionalData === void 0 ? void 0 : additionalData.getEntityState) === null || _b === void 0 ? void 0 : _b.call(additionalData);
                addUndoSnapshotInternal(core, false /*isAutoCompleteSnapshot*/, entityStates);
            }
        }
    }
    finally {
        if (!isNested) {
            undoState.isNested = false;
        }
    }
    if (callback && changeSource) {
        var event_1 = {
            eventType: 7 /* ContentChanged */,
            source: changeSource,
            data: data,
            additionalData: additionalData,
        };
        core.api.triggerEvent(core, event_1, true /*broadcast*/);
    }
    if (canUndoByBackspace) {
        var range = core.api.getSelectionRange(core, false /*tryGetFromCache*/);
        if (range) {
            core.undo.hasNewContent = false;
            core.undo.autoCompletePosition = roosterjs_editor_dom_1.Position.getStart(range);
        }
    }
};
exports.addUndoSnapshot = addUndoSnapshot;
function addUndoSnapshotInternal(core, canUndoByBackspace, entityStates) {
    var _a;
    if (!core.lifecycle.shadowEditFragment) {
        var rangeEx = core.api.getSelectionRangeEx(core);
        var isDarkMode = core.lifecycle.isDarkMode;
        var metadata = createContentMetadata(core.contentDiv, rangeEx, isDarkMode) || null;
        core.undo.snapshotsService.addSnapshot({
            html: core.contentDiv.innerHTML,
            metadata: metadata,
            knownColors: ((_a = core.darkColorHandler) === null || _a === void 0 ? void 0 : _a.getKnownColorsCopy()) || [],
            entityStates: entityStates,
        }, canUndoByBackspace);
        core.undo.hasNewContent = false;
    }
}
function createContentMetadata(root, rangeEx, isDarkMode) {
    switch (rangeEx === null || rangeEx === void 0 ? void 0 : rangeEx.type) {
        case 1 /* TableSelection */:
            return (0, tslib_1.__assign)({ type: 1 /* TableSelection */, tableId: rangeEx.table.id, isDarkMode: !!isDarkMode }, rangeEx.coordinates);
        case 2 /* ImageSelection */:
            return {
                type: 2 /* ImageSelection */,
                imageId: rangeEx.image.id,
                isDarkMode: !!isDarkMode,
            };
        case 0 /* Normal */:
            return (0, tslib_1.__assign)({ type: 0 /* Normal */, isDarkMode: !!isDarkMode, start: [], end: [] }, ((0, roosterjs_editor_dom_1.getSelectionPath)(root, rangeEx.ranges[0]) || {}));
    }
}
//# sourceMappingURL=addUndoSnapshot.js.map