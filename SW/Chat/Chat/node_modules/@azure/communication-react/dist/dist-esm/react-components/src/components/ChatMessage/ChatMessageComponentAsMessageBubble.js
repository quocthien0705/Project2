// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { Text, mergeStyles } from '@fluentui/react';
import { ChatMessage as FluentChatMessage, ChatMyMessage } from '@fluentui-contrib/react-chat';
import React, { useCallback, useRef, useState } from 'react';
import { chatMessageEditedTagStyle, chatMessageDateStyle, chatMessageFailedTagStyle, chatMessageAuthorStyle } from '../styles/ChatMessageComponent.styles';
import { formatTimeForChatMessage, formatTimestampForChatMessage } from '../utils/Datetime';
import { useIdentifiers } from '../../identifiers/IdentifierProvider';
import { useTheme } from '../../theming';
import { ChatMessageActionFlyout } from './ChatMessageActionsFlyout';
import { ChatMessageContent } from './ChatMessageContent';
import { chatMessageActionMenuProps } from './ChatMessageActionMenu';
import { useLocale } from '../../localization';
import { createStyleFromV8Style } from '../styles/v8StyleShim';
import { mergeClasses } from '@fluentui/react-components';
import { useChatMessageStyles, useChatMyMessageStyles, useChatMessageCommonStyles } from '../styles/MessageThread.styles';
const generateDefaultTimestamp = (createdOn, showDate, strings) => {
    const formattedTimestamp = showDate ? formatTimestampForChatMessage(createdOn, new Date(), strings) : formatTimeForChatMessage(createdOn);
    return formattedTimestamp;
};
// onDisplayDateTimeString from props overwrite onDisplayDateTimeString from locale
const generateCustomizedTimestamp = (props, createdOn, locale) => {
    return '';
};
/** @private */
const MessageBubble = (props) => {
    var _a;
    const ids = useIdentifiers();
    const theme = useTheme();
    const locale = useLocale();
    const { userId, message, onRemoveClick, onResendClick, disableEditing, showDate, messageContainerStyle, strings, onEditClick, remoteParticipantsCount = 0, onRenderAvatar, showMessageStatus, messageStatus, 
    /* @conditional-compile-remove(image-overlay) */
    inlineImageOptions, shouldOverlapAvatarAndMessage } = props;
    const defaultTimeStamp = message.createdOn ? generateDefaultTimestamp(message.createdOn, showDate, strings) : undefined;
    const customTimestamp = message.createdOn ? generateCustomizedTimestamp(props, message.createdOn, locale) : '';
    const formattedTimestamp = customTimestamp || defaultTimeStamp;
    // Track if the action menu was opened by touch - if so we increase the touch targets for the items
    const [wasInteractionByTouch, setWasInteractionByTouch] = useState(false);
    // `focused` state is used for show/hide actionMenu
    const [focused, setFocused] = React.useState(false);
    // The chat message action flyout should target the Chat.Message action menu if clicked,
    // or target the chat message if opened via touch press.
    // Undefined indicates the flyout menu should not be being shown.
    const messageRef = useRef(null);
    const messageActionButtonRef = useRef(null);
    const [chatMessageActionFlyoutTarget, setChatMessageActionFlyoutTarget] = useState(undefined);
    const chatActionsEnabled = !disableEditing && message.status !== 'sending' && !!message.mine;
    const [messageReadBy, setMessageReadBy] = useState([]);
    const actionMenuProps = chatMessageActionMenuProps({
        ariaLabel: (_a = strings.actionMenuMoreOptions) !== null && _a !== void 0 ? _a : '',
        enabled: chatActionsEnabled,
        menuButtonRef: messageActionButtonRef,
        menuExpanded: chatMessageActionFlyoutTarget === messageActionButtonRef,
        onActionButtonClick: () => {
            if (message.messageType === 'chat') {
                props.onActionButtonClick(message, setMessageReadBy);
                setChatMessageActionFlyoutTarget(messageActionButtonRef);
            }
        },
        theme
    });
    const onActionFlyoutDismiss = useCallback(() => {
        // When the flyout dismiss is called, since we control if the action flyout is visible
        // or not we need to set the target to undefined here to actually hide the action flyout
        setChatMessageActionFlyoutTarget(undefined);
    }, [setChatMessageActionFlyoutTarget]);
    const defaultOnRenderFileDownloads = useCallback(() => { }, [userId, message]);
    const editedOn = 'editedOn' in message ? message.editedOn : undefined;
    const getMessageDetails = useCallback(() => {
        if (messageStatus === 'failed') {
            return React.createElement("div", { className: chatMessageFailedTagStyle(theme) }, strings.failToSendTag);
        }
        else if (message.messageType === 'chat' && editedOn) {
            return React.createElement("div", { className: chatMessageEditedTagStyle(theme) }, strings.editedTag);
        }
        return undefined;
    }, [editedOn, message.messageType, messageStatus, strings.editedTag, strings.failToSendTag, theme]);
    const getContent = useCallback(() => {
        return React.createElement("div", { tabIndex: 0, className: "ui-chat__message__content" },
            React.createElement(ChatMessageContent, { message: message, strings: strings, inlineImageOptions: inlineImageOptions }));
    }, [defaultOnRenderFileDownloads, /* @conditional-compile-remove(image-overlay) */ inlineImageOptions, message, props, strings, userId]);
    const isBlockedMessage = false;
    const chatMyMessageStyles = useChatMyMessageStyles();
    const chatMessageCommonStyles = useChatMessageCommonStyles();
    const chatMessageStyles = useChatMessageStyles();
    const chatItemMessageContainerClassName = mergeClasses(
    // messageContainerStyle used in className and style prop as style prop can't handle CSS selectors
    chatMessageStyles.body, 
    // disable placeholder functionality for GA releases as it might confuse users
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    chatMessageStyles.bodyWithPlaceholderImage, isBlockedMessage ? chatMessageCommonStyles.blocked : props.message.status === 'failed' ? chatMessageCommonStyles.failed : undefined, shouldOverlapAvatarAndMessage ? chatMessageStyles.avatarOverlap : chatMessageStyles.avatarNoOverlap, message.attached === 'top' || message.attached === false ? chatMessageStyles.bodyWithAvatar : chatMessageStyles.bodyWithoutAvatar, mergeStyles(messageContainerStyle));
    const attached = message.attached === true ? 'center' : message.attached === 'bottom' ? 'bottom' : 'top';
    const chatMessage = React.createElement(React.Fragment, null,
        React.createElement("div", { key: props.message.messageId }, message.mine ? React.createElement(ChatMyMessage, { attached: attached, key: props.message.messageId, body: {
                // messageContainerStyle used in className and style prop as style prop can't handle CSS selectors
                className: mergeClasses(chatMyMessageStyles.body, isBlockedMessage ? chatMessageCommonStyles.blocked : props.message.status === 'failed' ? chatMessageCommonStyles.failed : undefined, attached !== 'top' ? chatMyMessageStyles.bodyAttached : undefined, mergeStyles(messageContainerStyle)),
                style: Object.assign({}, createStyleFromV8Style(messageContainerStyle)),
                ref: messageRef
            }, root: {
                className: chatMyMessageStyles.root,
                onBlur: e => {
                    // `focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
                    // with keyboard the focused element will be changed and there is no way to use `:focus` selector
                    if (chatMessageActionFlyoutTarget === null || chatMessageActionFlyoutTarget === void 0 ? void 0 : chatMessageActionFlyoutTarget.current) {
                        // doesn't dismiss action button if flyout is open, otherwise, narrator's focus will stay on the closed action menu
                        return;
                    }
                    const shouldPreserveFocusState = e.currentTarget.contains(e.relatedTarget);
                    setFocused(shouldPreserveFocusState);
                },
                onFocus: () => {
                    // react onFocus is called even when nested component receives focus (i.e. it bubbles)
                    // so when focus moves within actionMenu, the `focus` state in chatMessage remains true, and keeps actionMenu visible
                    setFocused(true);
                },
                // make body not focusable to remove repetitions from narrators.
                // inner components are already focusable
                role: 'none',
                tabIndex: -1
            }, "data-ui-id": "chat-composite-message", author: React.createElement(Text, { className: chatMessageDateStyle, tabIndex: 0 }, message.senderDisplayName), timestamp: React.createElement(Text, { className: chatMessageDateStyle, "data-ui-id": ids.messageTimestamp, tabIndex: 0 }, formattedTimestamp), details: getMessageDetails(), actions: {
                children: actionMenuProps === null || actionMenuProps === void 0 ? void 0 : actionMenuProps.children,
                className: mergeClasses(chatMyMessageStyles.menu, 
                // Make actions menu visible when the message is focused or the flyout is shown
                focused || (chatMessageActionFlyoutTarget === null || chatMessageActionFlyoutTarget === void 0 ? void 0 : chatMessageActionFlyoutTarget.current) ? chatMyMessageStyles.menuVisible : chatMyMessageStyles.menuHidden, attached !== 'top' ? chatMyMessageStyles.menuAttached : undefined)
            }, onTouchStart: () => setWasInteractionByTouch(true), onPointerDown: () => setWasInteractionByTouch(false), onKeyDown: () => setWasInteractionByTouch(false), onClick: () => {
                if (!wasInteractionByTouch) {
                    return;
                }
                // If the message was touched via touch we immediately open the menu
                // flyout (when using mouse the 3-dot menu that appears on hover
                // must be clicked to open the flyout).
                // In doing so here we set the target of the flyout to be the message and
                // not the 3-dot menu button to position the flyout correctly.
                setChatMessageActionFlyoutTarget(messageRef);
                if (message.messageType === 'chat') {
                    props.onActionButtonClick(message, setMessageReadBy);
                }
            } }, getContent()) : React.createElement(FluentChatMessage, { attached: attached, key: props.message.messageId, root: {
                className: chatMessageStyles.root,
                // make body not focusable to remove repetitions from narrators.
                // inner components are already focusable
                tabIndex: -1,
                role: 'none'
            }, author: React.createElement(Text, { className: chatMessageAuthorStyle }, message.senderDisplayName), body: {
                className: chatItemMessageContainerClassName,
                style: Object.assign({}, createStyleFromV8Style(messageContainerStyle))
            }, "data-ui-id": "chat-composite-message", timestamp: React.createElement(Text, { className: chatMessageDateStyle, "data-ui-id": ids.messageTimestamp }, formattedTimestamp), details: getMessageDetails() }, getContent())),
        chatActionsEnabled && React.createElement(ChatMessageActionFlyout, { hidden: !chatMessageActionFlyoutTarget, target: chatMessageActionFlyoutTarget, increaseFlyoutItemSize: wasInteractionByTouch, onDismiss: onActionFlyoutDismiss, onEditClick: onEditClick, onRemoveClick: onRemoveClick, onResendClick: onResendClick, strings: strings, messageReadBy: messageReadBy, messageStatus: messageStatus !== null && messageStatus !== void 0 ? messageStatus : 'failed', remoteParticipantsCount: remoteParticipantsCount, onRenderAvatar: onRenderAvatar, showMessageStatus: showMessageStatus }));
    return chatMessage;
};
/** @private */
export const ChatMessageComponentAsMessageBubble = React.memo(MessageBubble);
//# sourceMappingURL=ChatMessageComponentAsMessageBubble.js.map