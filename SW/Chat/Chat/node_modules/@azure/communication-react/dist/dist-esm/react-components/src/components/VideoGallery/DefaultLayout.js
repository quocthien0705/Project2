// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { Stack } from '@fluentui/react';
import React, { useMemo, useState, useRef } from 'react';
import { GridLayout } from '../GridLayout';
import { isNarrowWidth } from '../utils/responsive';
/* @conditional-compile-remove(vertical-gallery) */
import { isShortHeight } from '../utils/responsive';
import { rootLayoutStyle } from './styles/DefaultLayout.styles';
import { videoGalleryLayoutGap } from './styles/Layout.styles';
import { useOrganizedParticipants } from './utils/videoGalleryLayoutUtils';
import { OverflowGallery } from './OverflowGallery';
/**
 * DefaultLayout displays remote participants, local video component, and screen sharing component in
 * a grid an overflow gallery.
 *
 * @private
 */
export const DefaultLayout = (props) => {
    const { remoteParticipants = [], localParticipant, dominantSpeakers, localVideoComponent, screenShareComponent, onRenderRemoteParticipant, styles, maxRemoteVideoStreams, parentWidth, 
    /* @conditional-compile-remove(vertical-gallery) */
    parentHeight, pinnedParticipantUserIds = [], 
    /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition = 'horizontalBottom' } = props;
    const isNarrow = parentWidth ? isNarrowWidth(parentWidth) : false;
    /* @conditional-compile-remove(vertical-gallery) */
    const isShort = parentHeight ? isShortHeight(parentHeight) : false;
    // This is for tracking the number of children in the first page of overflow gallery.
    // This number will be used for the maxOverflowGalleryDominantSpeakers when organizing the remote participants.
    // We need to add the local participant to the pinned participant count so we are placing the speakers correctly.
    const childrenPerPage = useRef(4);
    const { gridParticipants, overflowGalleryParticipants } = useOrganizedParticipants({
        remoteParticipants,
        localParticipant,
        dominantSpeakers,
        maxRemoteVideoStreams,
        isScreenShareActive: !!screenShareComponent,
        maxOverflowGalleryDominantSpeakers: screenShareComponent ? childrenPerPage.current - (pinnedParticipantUserIds.length + 1) % childrenPerPage.current : childrenPerPage.current,
        pinnedParticipantUserIds,
        layout: 'default'
    });
    let activeVideoStreams = 0;
    let gridTiles = gridParticipants.map(p => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    /**
     * instantiate indexes available to render with indexes available that would be on first page
     *
     * For some components which do not strictly follow the order of the array, we might
     * re-render the initial tiles -> dispose them -> create new tiles, we need to take care of
     * this case when those components are here
     */
    const [indexesToRender, setIndexesToRender] = useState([]);
    let overflowGalleryTiles = overflowGalleryParticipants.map((p, i) => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && indexesToRender.includes(i) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    if (localVideoComponent) {
        if (screenShareComponent) {
            overflowGalleryTiles = [localVideoComponent].concat(overflowGalleryTiles);
        }
        else {
            gridTiles = [localVideoComponent].concat(gridTiles);
        }
    }
    const overflowGallery = useMemo(() => {
        if (overflowGalleryTiles.length === 0) {
            return null;
        }
        return React.createElement(OverflowGallery, { isNarrow: isNarrow, 
            /* @conditional-compile-remove(vertical-gallery) */ isShort: isShort, shouldFloatLocalVideo: false, overflowGalleryElements: overflowGalleryTiles, horizontalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, 
            /* @conditional-compile-remove(vertical-gallery) */ verticalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.verticalGallery, 
            /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition: overflowGalleryPosition, onFetchTilesToRender: setIndexesToRender, onChildrenPerPageChange: (n) => {
                childrenPerPage.current = n;
            }, parentWidth: parentWidth });
    }, [isNarrow, /* @conditional-compile-remove(vertical-gallery) */ isShort, overflowGalleryTiles, styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition, setIndexesToRender, /* @conditional-compile-remove(vertical-gallery) */ styles === null || styles === void 0 ? void 0 : styles.verticalGallery, parentWidth]);
    return React.createElement(Stack
    /* @conditional-compile-remove(vertical-gallery) */ , { 
        /* @conditional-compile-remove(vertical-gallery) */ horizontal: overflowGalleryPosition === 'verticalRight', styles: rootLayoutStyle, tokens: videoGalleryLayoutGap },
        props.overflowGalleryPosition === 'horizontalTop' ? overflowGallery : React.createElement(React.Fragment, null),
        screenShareComponent ? screenShareComponent : React.createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles),
        overflowGalleryTrampoline(overflowGallery, props.overflowGalleryPosition));
};
const overflowGalleryTrampoline = (gallery, galleryPosition) => {
    return galleryPosition !== 'horizontalTop' ? gallery : React.createElement(React.Fragment, null);
    return gallery;
};
//# sourceMappingURL=DefaultLayout.js.map