// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createClientLogger, getLogLevel } from '@azure/logger';
import EventEmitter from 'events';
import { enableMapSet, enablePatches, produce } from 'immer';
import { _safeJSONStringify, toFlatCommunicationIdentifier } from "../../acs-ui-common/src";
import { CallError } from './CallClientState';
import { callingStatefulLogger } from './Logger';
import { CallIdHistory } from './CallIdHistory';
/* @conditional-compile-remove(close-captions) */
import { convertFromSDKToCaptionInfoState } from './Converter';
/* @conditional-compile-remove(raise-hand) */
import { convertFromSDKToRaisedHandState } from './Converter';
enableMapSet();
// Needed to generate state diff for verbose logging.
enablePatches();
// TODO: How can we make this configurable?
/**
 * @private
 */
export const MAX_CALL_HISTORY_LENGTH = 10;
/**
 * @private
 */
export class CallContext {
    constructor(userId, maxListeners = 50) {
        this._callIdHistory = new CallIdHistory();
        /**
         * Tees direct errors to state.
         * @remarks
         * This is typically used for errors that are caught and intended to be shown to the user.
         *
         * @param error The raw error to report.
         * @param target The error target to tee error to.
         *
         * @private
         */
        this.teeErrorToState = (error, target) => {
            const callError = toCallError(target, error);
            this.setLatestError(target, callError);
        };
        this._logger = createClientLogger('communication-react:calling-context');
        this._state = {
            calls: {},
            callsEnded: {},
            incomingCalls: {},
            incomingCallsEnded: {},
            deviceManager: {
                isSpeakerSelectionAvailable: false,
                cameras: [],
                microphones: [],
                speakers: [],
                unparentedViews: []
            },
            callAgent: undefined,
            userId: userId,
            latestErrors: {}
        };
        this._emitter = new EventEmitter();
        this._emitter.setMaxListeners(maxListeners);
        this._atomicId = 0;
    }
    getState() {
        return this._state;
    }
    modifyState(modifier) {
        const priorState = this._state;
        this._state = produce(this._state, modifier, (patches) => {
            if (getLogLevel() === 'verbose') {
                // Log to `info` because AzureLogger.verbose() doesn't show up in console.
                this._logger.info(`State change: ${_safeJSONStringify(patches)}`);
            }
        });
        if (this._state !== priorState) {
            this._emitter.emit('stateChanged', this._state);
        }
    }
    onStateChange(handler) {
        this._emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this._emitter.off('stateChanged', handler);
    }
    // Disposing of the CallAgentDeclarative will not clear the state. If we create a new CallAgentDeclarative, we should
    // make sure the state is clean because any left over state (if previous CallAgentDeclarative was disposed) may be
    // invalid.
    clearCallRelatedState() {
        this.modifyState((draft) => {
            draft.calls = {};
            draft.incomingCalls = {};
            draft.callsEnded = {};
            draft.incomingCallsEnded = {};
        });
    }
    setCallAgent(callAgent) {
        this.modifyState((draft) => {
            draft.callAgent = callAgent;
        });
    }
    setCall(call) {
        this.modifyState((draft) => {
            const latestCallId = this._callIdHistory.latestCallId(call.id);
            const existingCall = draft.calls[latestCallId];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
                existingCall.state = call.state;
                existingCall.callEndReason = call.callEndReason;
                existingCall.direction = call.direction;
                existingCall.isMuted = call.isMuted;
                existingCall.isScreenSharingOn = call.isScreenSharingOn;
                existingCall.localVideoStreams = call.localVideoStreams;
                existingCall.remoteParticipants = call.remoteParticipants;
                existingCall.transcription.isTranscriptionActive = call.transcription.isTranscriptionActive;
                /* @conditional-compile-remove(optimal-video-count) */
                existingCall.optimalVideoCount.maxRemoteVideoStreams = call.optimalVideoCount.maxRemoteVideoStreams;
                existingCall.recording.isRecordingActive = call.recording.isRecordingActive;
                /* @conditional-compile-remove(raise-hand) */
                existingCall.raiseHand.raisedHands = call.raiseHand.raisedHands;
                /* @conditional-compile-remove(raise-hand) */
                existingCall.raiseHand.localParticipantRaisedHand = call.raiseHand.localParticipantRaisedHand;
                /* @conditional-compile-remove(rooms) */
                existingCall.role = call.role;
                // We don't update the startTime and endTime if we are updating an existing active call
                /* @conditional-compile-remove(close-captions) */
                existingCall.captionsFeature.currentSpokenLanguage = call.captionsFeature.currentSpokenLanguage;
                /* @conditional-compile-remove(close-captions) */
                existingCall.captionsFeature.currentCaptionLanguage = call.captionsFeature.currentCaptionLanguage;
            }
            else {
                draft.calls[latestCallId] = call;
            }
        });
    }
    removeCall(callId) {
        this.modifyState((draft) => {
            delete draft.calls[this._callIdHistory.latestCallId(callId)];
        });
    }
    setCallEnded(callId, callEndReason) {
        const latestCallId = this._callIdHistory.latestCallId(callId);
        this.modifyState((draft) => {
            const call = draft.calls[latestCallId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.calls[latestCallId];
                // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.callsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.callsEnded[findOldestCallEnded(draft.callsEnded)];
                }
                draft.callsEnded[latestCallId] = call;
            }
        });
    }
    setCallState(callId, state) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.state = state;
            }
        });
    }
    setCallId(newCallId, oldCallId) {
        this._callIdHistory.updateCallIdHistory(newCallId, oldCallId);
        this.modifyState((draft) => {
            const call = draft.calls[oldCallId];
            if (call) {
                call.id = newCallId;
                delete draft.calls[oldCallId];
                draft.calls[newCallId] = call;
            }
        });
    }
    setCallIsScreenSharingOn(callId, isScreenSharingOn) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.isScreenSharingOn = isScreenSharingOn;
            }
        });
    }
    setCallRemoteParticipants(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipants[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipants[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
                // TODO: need to remove after contentSharingRole avaible in WebCalling SDK.
            }
        });
    }
    setCallRemoteParticipantsEnded(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipantsEnded[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipantsEnded[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
            }
        });
    }
    setCallLocalVideoStream(callId, streamsAdded, streamsRemoved) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                for (const removedStream of streamsRemoved) {
                    const index = call.localVideoStreams.findIndex(i => i.mediaStreamType === removedStream.mediaStreamType);
                    if (index > -1) {
                        call.localVideoStreams.splice(index, 1);
                    }
                }
                for (const addedStream of streamsAdded) {
                    const index = call.localVideoStreams.findIndex(i => i.mediaStreamType === addedStream.mediaStreamType);
                    if (index > -1) {
                        call.localVideoStreams[index] = addedStream;
                    }
                    else {
                        call.localVideoStreams.push(addedStream);
                    }
                }
            }
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    setCallLocalVideoStreamVideoEffects(callId, videoEffects) {
        this.modifyState((draft) => {
            var _a;
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const stream = (_a = call.localVideoStreams) === null || _a === void 0 ? void 0 : _a.find(i => i.mediaStreamType === 'Video');
                if (stream) {
                    stream.videoEffects = videoEffects;
                }
            }
        });
    }
    setCallIsMicrophoneMuted(callId, isMicrophoneMuted) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.isMuted = isMicrophoneMuted;
            }
        });
    }
    /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(capabilities) */
    setRole(callId, role) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.role = role;
            }
        });
    }
    setCallDominantSpeakers(callId, dominantSpeakers) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.dominantSpeakers = dominantSpeakers;
            }
        });
    }
    setCallRecordingActive(callId, isRecordingActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.recording.isRecordingActive = isRecordingActive;
            }
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    setCallRaisedHands(callId, raisedHands) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.raiseHand.raisedHands = raisedHands.map(raisedHand => {
                    return convertFromSDKToRaisedHandState(raisedHand);
                });
                const raisedHand = raisedHands.find(raisedHand => toFlatCommunicationIdentifier(raisedHand.identifier) === toFlatCommunicationIdentifier(this._state.userId));
                if (raisedHand) {
                    call.raiseHand.localParticipantRaisedHand = convertFromSDKToRaisedHandState(raisedHand);
                }
                else {
                    call.raiseHand.localParticipantRaisedHand = undefined;
                }
            }
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    setParticipantIsRaisedHand(callId, participantKey, raisedHand) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.raisedHand = raisedHand ? convertFromSDKToRaisedHandState(raisedHand) : raisedHand;
                }
            }
        });
    }
    setCallTranscriptionActive(callId, isTranscriptionActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.transcription.isTranscriptionActive = isTranscriptionActive;
            }
        });
    }
    /* @conditional-compile-remove(capabilities) */
    setCapabilities(callId, capabilities, capabilitiesChangeInfo) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.capabilitiesFeature = {
                    capabilities,
                    latestCapabilitiesChangeInfo: capabilitiesChangeInfo
                };
            }
        });
    }
    setCallScreenShareParticipant(callId, participantKey) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.screenShareRemoteParticipant = participantKey;
            }
        });
    }
    setLocalVideoStreamRendererView(callId, localVideoMediaStreamType, view) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const localVideoStream = call.localVideoStreams.find(localVideoStream => localVideoStream.mediaStreamType === localVideoMediaStreamType);
                if (localVideoStream) {
                    localVideoStream.view = view;
                }
            }
        });
    }
    setParticipantState(callId, participantKey, state) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.state = state;
                }
            }
        });
    }
    setParticipantIsMuted(callId, participantKey, muted) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isMuted = muted;
                }
            }
        });
    }
    /* @conditional-compile-remove(optimal-video-count) */
    setOptimalVideoCount(callId, optimalVideoCount) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.optimalVideoCount.maxRemoteVideoStreams = optimalVideoCount;
            }
        });
    }
    /* @conditional-compile-remove(rooms) */
    setParticipantRole(callId, participantKey, role) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.role = role;
                }
            }
        });
    }
    setParticipantDisplayName(callId, participantKey, displayName) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.displayName = displayName;
                }
            }
        });
    }
    setParticipantIsSpeaking(callId, participantKey, isSpeaking) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isSpeaking = isSpeaking;
                }
            }
        });
    }
    setParticipantVideoStream(callId, participantKey, stream) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    // Set is called by subscriber will not modify any rendered stream so if there is existing stream only
                    // modify the values that subscriber has access to.
                    const existingStream = participant.videoStreams[stream.id];
                    if (existingStream) {
                        existingStream.isAvailable = stream.isAvailable;
                        existingStream.mediaStreamType = stream.mediaStreamType;
                    }
                    else {
                        participant.videoStreams[stream.id] = stream;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamIsAvailable(callId, participantKey, streamId, isAvailable) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.isAvailable = isAvailable;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamSize(callId, participantKey, streamId, size) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.streamSize = size;
                    }
                }
            }
        });
    }
    setRemoteVideoStreams(callId, participantKey, addRemoteVideoStream, removeRemoteVideoStream) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    for (const id of removeRemoteVideoStream) {
                        delete participant.videoStreams[id];
                    }
                    for (const newStream of addRemoteVideoStream) {
                        // This should only be called by the subscriber and some properties are add by other components so if the
                        // stream already exists, only update the values that subscriber knows about.
                        const stream = participant.videoStreams[newStream.id];
                        if (stream) {
                            stream.mediaStreamType = newStream.mediaStreamType;
                            stream.isAvailable = newStream.isAvailable;
                        }
                        else {
                            participant.videoStreams[newStream.id] = newStream;
                        }
                    }
                }
            }
        });
    }
    setRemoteVideoStreamRendererView(callId, participantKey, streamId, view) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.view = view;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamViewScalingMode(callId, participantKey, streamId, scalingMode) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream && stream.view) {
                        stream.view.scalingMode = scalingMode;
                    }
                }
            }
        });
    }
    setIncomingCall(call) {
        this.modifyState((draft) => {
            const existingCall = draft.incomingCalls[call.id];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
            }
            else {
                draft.incomingCalls[call.id] = call;
            }
        });
    }
    removeIncomingCall(callId) {
        this.modifyState((draft) => {
            delete draft.incomingCalls[callId];
        });
    }
    setIncomingCallEnded(callId, callEndReason) {
        this.modifyState((draft) => {
            const call = draft.incomingCalls[callId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.incomingCalls[callId];
                // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.incomingCallsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.incomingCallsEnded[findOldestCallEnded(draft.incomingCallsEnded)];
                }
                draft.incomingCallsEnded[callId] = call;
            }
        });
    }
    setDeviceManagerIsSpeakerSelectionAvailable(isSpeakerSelectionAvailable) {
        this.modifyState((draft) => {
            draft.deviceManager.isSpeakerSelectionAvailable = isSpeakerSelectionAvailable;
        });
    }
    setDeviceManagerSelectedMicrophone(selectedMicrophone) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedMicrophone = selectedMicrophone;
        });
    }
    setDeviceManagerSelectedSpeaker(selectedSpeaker) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedSpeaker = selectedSpeaker;
        });
    }
    setDeviceManagerSelectedCamera(selectedCamera) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedCamera = selectedCamera;
        });
    }
    setDeviceManagerCameras(cameras) {
        this.modifyState((draft) => {
            /**
             * SDK initializes cameras with one dummy camera with value { id: 'camera:id', name: '', deviceType: 'USBCamera' } immediately after
             * camera permissions are granted. So selectedCamera will have this value before the actual cameras are obtained. Therefore we should reset
             * selectedCamera to the first camera when there are cameras AND when current selectedCamera does not exist in the new array of cameras *
             */
            if (cameras.length > 0 && !cameras.some(camera => { var _a; return camera.id === ((_a = draft.deviceManager.selectedCamera) === null || _a === void 0 ? void 0 : _a.id); })) {
                draft.deviceManager.selectedCamera = cameras[0];
            }
            draft.deviceManager.cameras = cameras;
        });
    }
    setDeviceManagerMicrophones(microphones) {
        this.modifyState((draft) => {
            draft.deviceManager.microphones = microphones;
        });
    }
    setDeviceManagerSpeakers(speakers) {
        this.modifyState((draft) => {
            draft.deviceManager.speakers = speakers;
        });
    }
    setDeviceManagerDeviceAccess(deviceAccess) {
        this.modifyState((draft) => {
            draft.deviceManager.deviceAccess = deviceAccess;
        });
    }
    setDeviceManagerUnparentedView(localVideoStream, view) {
        this.modifyState((draft) => {
            draft.deviceManager.unparentedViews.push({
                source: localVideoStream.source,
                mediaStreamType: localVideoStream.mediaStreamType,
                view: view
            });
        });
    }
    deleteDeviceManagerUnparentedView(localVideoStream) {
        this.modifyState((draft) => {
            const foundIndex = draft.deviceManager.unparentedViews.findIndex(stream => stream.mediaStreamType === localVideoStream.mediaStreamType);
            if (foundIndex !== -1) {
                draft.deviceManager.unparentedViews.splice(foundIndex, 1);
            }
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    setDeviceManagerUnparentedViewVideoEffects(localVideoStream, videoEffects) {
        this.modifyState((draft) => {
            const foundIndex = draft.deviceManager.unparentedViews.findIndex(stream => stream.mediaStreamType === localVideoStream.mediaStreamType);
            if (foundIndex !== -1) {
                draft.deviceManager.unparentedViews[foundIndex].videoEffects = videoEffects;
            }
        });
    }
    getAndIncrementAtomicId() {
        const id = this._atomicId;
        this._atomicId++;
        return id;
    }
    /* @conditional-compile-remove(close-captions) */
    processNewCaption(captions, newCaption) {
        // going through current captions to find the last caption said by the same speaker, remove that caption if it's partial and replace with the new caption
        for (let index = captions.length - 1; index >= 0; index--) {
            const currentCaption = captions[index];
            if (currentCaption && currentCaption.resultType !== 'Final' && currentCaption.speaker.identifier && newCaption.speaker.identifier && toFlatCommunicationIdentifier(currentCaption.speaker.identifier) === toFlatCommunicationIdentifier(newCaption.speaker.identifier)) {
                captions.splice(index, 1);
                break;
            }
        }
        captions.push(newCaption);
        // If the array length exceeds 50, remove the oldest caption
        if (captions.length > 50) {
            captions.shift();
        }
    }
    /* @conditional-compile-remove(close-captions) */
    addCaption(callId, caption) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const currentCaptionLanguage = call.captionsFeature.currentCaptionLanguage;
                if (caption.captionLanguage.toUpperCase() === currentCaptionLanguage.toUpperCase() || currentCaptionLanguage === '' || currentCaptionLanguage === undefined) {
                    this.processNewCaption(call.captionsFeature.captions, convertFromSDKToCaptionInfoState(caption));
                }
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    clearCaptions(callId) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.captions = [];
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setIsCaptionActive(callId, isCaptionsActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.isCaptionsFeatureActive = isCaptionsActive;
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setStartCaptionsInProgress(callId, startCaptionsInProgress) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.startCaptionsInProgress = startCaptionsInProgress;
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setSelectedSpokenLanguage(callId, spokenLanguage) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.currentSpokenLanguage = spokenLanguage;
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setSelectedCaptionLanguage(callId, captionLanguage) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.currentCaptionLanguage = captionLanguage;
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setAvailableCaptionLanguages(callId, captionLanguages) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.supportedCaptionLanguages = captionLanguages;
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setAvailableSpokenLanguages(callId, spokenLanguages) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.supportedSpokenLanguages = spokenLanguages;
            }
        });
    }
    /* @conditional-compile-remove(call-transfer) */
    setAcceptedTransfer(callId, acceptedTransfer) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.transfer.acceptedTransfers[acceptedTransfer.callId] = acceptedTransfer;
            }
        });
    }
    /**
     * Tees any errors encountered in an async function to the state.
     *
     * @param action Async function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withAsyncErrorTeedToState(action, target) {
        return (...args) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        });
    }
    /**
     * Tees any errors encountered in an function to the state.
     *
     * @param action Function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withErrorTeedToState(action, target) {
        return (...args) => {
            try {
                callingStatefulLogger.info(`Calling stateful client target function called: ${target}`);
                return action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        };
    }
    setLatestError(target, error) {
        this.modifyState((draft) => {
            draft.latestErrors[target] = error;
        });
    }
}
const toCallError = (target, error) => {
    if (error instanceof Error) {
        return new CallError(target, error);
    }
    return new CallError(target, new Error(error));
};
const findOldestCallEnded = (calls) => {
    var _a, _b, _c, _d;
    const callEntries = Object.entries(calls);
    let [oldestCallId, oldestCall] = callEntries[0];
    if (oldestCall.endTime === undefined) {
        return oldestCallId;
    }
    for (const [callId, call] of callEntries.slice(1)) {
        if (call.endTime === undefined) {
            return callId;
        }
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) < ((_d = (_c = oldestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            [oldestCallId, oldestCall] = [callId, call];
        }
    }
    return oldestCallId;
};
//# sourceMappingURL=CallContext.js.map