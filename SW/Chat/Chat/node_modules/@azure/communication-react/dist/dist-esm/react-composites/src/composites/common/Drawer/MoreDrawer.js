// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import React, { useCallback } from 'react';
/* @conditional-compile-remove(close-captions) */
import { useState } from 'react';
/* @conditional-compile-remove(control-bar-button-injection) */
import { useMemo } from 'react';
import { _DrawerMenu as DrawerMenu } from "../../../../../react-components/src";
/* @conditional-compile-remove(close-captions) */
import { _StartCaptionsButton, _CaptionsSettingsModal } from "../../../../../react-components/src";
/* @conditional-compile-remove(raise-hand) */
import { RaiseHandButton } from "../../../../../react-components/src";
/* @conditional-compile-remove(control-bar-button-injection) */
import { CUSTOM_BUTTON_OPTIONS, generateCustomCallDrawerButtons, onFetchCustomButtonPropsTrampoline } from '../ControlBar/CustomButton';
/* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(raise-hand) */
import { usePropsFor } from '../../CallComposite/hooks/usePropsFor';
/* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */ /* @conditional-compile-remove(raise-hand) */
import { useLocale } from '../../localization';
import { isDisabled } from '../../CallComposite/utils';
/* @conditional-compile-remove(close-captions) */
import { Stack, Toggle, useTheme } from '@fluentui/react';
/* @conditional-compile-remove(close-captions) */
import { useAdaptedSelector } from '../../CallComposite/hooks/useAdaptedSelector';
/* @conditional-compile-remove(close-captions) */
import { _captionSettingsSelector } from "../../../../../calling-component-bindings/src";
/* @conditional-compile-remove(close-captions) */
import { useHandlers } from '../../CallComposite/hooks/useHandlers';
/* @conditional-compile-remove(close-captions) */
import { CaptionLanguageSettingsDrawer } from './CaptionLanguageSettingsDrawer';
/* @conditional-compile-remove(close-captions) */
import { themedToggleButtonStyle } from './MoreDrawer.styles';
/* @conditional-compile-remove(close-captions) */
import { _spokenLanguageToCaptionLanguage } from "../../../../../react-components/src";
/* @conditional-compile-remove(rooms) */
import { useAdapter } from '../../CallComposite/adapter/CallAdapterProvider';
import { useSelector } from '../../CallComposite/hooks/useSelector';
import { getTargetCallees } from '../../CallComposite/selectors/baseSelectors';
import { showDtmfDialer } from '../../CallComposite/utils/MediaGalleryUtils';
import { SpokenLanguageSettingsDrawer } from './SpokenLanguageSettingsDrawer';
const inferCallWithChatControlOptions = (callWithChatControls) => {
    if (callWithChatControls === false) {
        return false;
    }
    const options = callWithChatControls === true || callWithChatControls === undefined ? {} : callWithChatControls;
    return options;
};
/** @private */
export const MoreDrawer = (props) => {
    var _a, _b, _c, _d, _e, _f;
    /* @conditional-compile-remove(close-captions) */
    const theme = useTheme();
    /* @conditional-compile-remove(rooms) */
    const callAdapter = useAdapter();
    const drawerMenuItems = [];
    const { speakers, onSelectSpeaker, onLightDismiss } = props;
    /* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */ /* @conditional-compile-remove(raise-hand) */
    const localeStrings = useLocale();
    const callees = useSelector(getTargetCallees);
    const allowDtmfDialer = showDtmfDialer(callees);
    const [dtmfDialerChecked, setDtmfDialerChecked] = useState((_a = props.dtmfDialerPresent) !== null && _a !== void 0 ? _a : false);
    /* @conditional-compile-remove(raise-hand) */
    const raiseHandButtonProps = usePropsFor(RaiseHandButton);
    const onSpeakerItemClick = useCallback((_ev, itemKey) => {
        const selected = speakers === null || speakers === void 0 ? void 0 : speakers.find(speaker => speaker.id === itemKey);
        if (selected) {
            // This is unsafe - we're only passing in part of the argument to the handler.
            // But this is a known issue in our state.
            onSelectSpeaker(selected);
        }
        onLightDismiss();
    }, [speakers, onSelectSpeaker, onLightDismiss]);
    const drawerSelectionOptions = inferCallWithChatControlOptions(props.callControls);
    if (props.speakers && props.speakers.length > 0) {
        drawerMenuItems.push({
            itemKey: 'speakers',
            disabled: props.disableButtonsForHoldScreen,
            text: props.strings.speakerMenuTitle,
            iconProps: {
                iconName: 'MoreDrawerSpeakers'
            },
            subMenuProps: props.speakers.map(speaker => ({
                itemKey: speaker.id,
                iconProps: {
                    iconName: isDeviceSelected(speaker, props.selectedSpeaker) ? 'MoreDrawerSelectedSpeaker' : 'MoreDrawerSpeakers'
                },
                text: speaker.name,
                onItemClick: onSpeakerItemClick,
                secondaryIconProps: isDeviceSelected(speaker, props.selectedSpeaker) ? {
                    iconName: 'Accept'
                } : undefined
            })),
            secondaryText: (_b = props.selectedSpeaker) === null || _b === void 0 ? void 0 : _b.name
        });
    }
    const { microphones, onSelectMicrophone } = props;
    const onMicrophoneItemClick = useCallback((_ev, itemKey) => {
        const selected = microphones === null || microphones === void 0 ? void 0 : microphones.find(mic => mic.id === itemKey);
        if (selected) {
            // This is unsafe - we're only passing in part of the argument to the handler.
            // But this is a known issue in our state.
            onSelectMicrophone(selected);
        }
        onLightDismiss();
    }, [microphones, onSelectMicrophone, onLightDismiss]);
    if (props.microphones && props.microphones.length > 0) {
        // Set props as Microphone if speakers can be enumerated else set as Audio Device
        const speakersAvailable = props.speakers && props.speakers.length > 0;
        const itemKey = speakersAvailable ? 'microphones' : 'audioDevices';
        const text = speakersAvailable ? props.strings.microphoneMenuTitle : props.strings.audioDeviceMenuTitle;
        const iconName = speakersAvailable ? 'MoreDrawerMicrophones' : 'MoreDrawerSpeakers';
        const selectedIconName = speakersAvailable ? 'MoreDrawerSelectedMicrophone' : 'MoreDrawerSelectedSpeaker';
        drawerMenuItems.push({
            itemKey: itemKey,
            disabled: props.disableButtonsForHoldScreen,
            text: text,
            iconProps: {
                iconName: iconName
            },
            subMenuProps: props.microphones.map(mic => ({
                itemKey: mic.id,
                iconProps: {
                    iconName: isDeviceSelected(mic, props.selectedMicrophone) ? selectedIconName : iconName
                },
                text: mic.name,
                onItemClick: onMicrophoneItemClick,
                secondaryIconProps: isDeviceSelected(mic, props.selectedMicrophone) ? {
                    iconName: 'Accept'
                } : undefined,
                disabled: drawerSelectionOptions !== false ? isDisabled(drawerSelectionOptions.microphoneButton) : undefined
            })),
            secondaryText: (_c = props.selectedMicrophone) === null || _c === void 0 ? void 0 : _c.name
        });
    }
    const dtmfDialerScreenOption = {
        itemKey: 'dtmfDialerScreenKey',
        text: !dtmfDialerChecked ? localeStrings.strings.call.dtmfDialerMoreButtonLabelOn : localeStrings.strings.call.dtmfDialerMoreButtonLabelOff,
        onItemClick: () => {
            if (props.onSetDialpadPage) {
                props.onSetDialpadPage();
            }
            setDtmfDialerChecked(!dtmfDialerChecked);
            onLightDismiss();
        },
        iconProps: {
            iconName: 'DtmfDialpadButton',
            styles: {
                root: {
                    lineHeight: 0
                }
            }
        }
    };
    /**
     * Only render the dtmf dialer if the dialpad for PSTN calls is not present
     */
    if (props.onSetDialpadPage && allowDtmfDialer) {
        drawerMenuItems.push(dtmfDialerScreenOption);
    }
    const galleryLayoutOptions = {
        itemKey: 'galleryPositionKey',
        iconProps: {
            iconName: 'GalleryOptions',
            styles: {
                root: {
                    lineHeight: 0
                }
            }
        },
        disabled: props.disableButtonsForHoldScreen,
        text: localeStrings.strings.call.moreButtonGalleryControlLabel,
        subMenuProps: [{
                itemKey: 'dynamicSelectionKey',
                text: localeStrings.strings.call.moreButtonGalleryFloatingLocalLayoutLabel,
                onItemClick: () => {
                    props.onUserSetGalleryLayout && props.onUserSetGalleryLayout('floatingLocalVideo');
                    onLightDismiss();
                },
                iconProps: {
                    iconName: 'FloatingLocalVideoGalleryLayout',
                    styles: {
                        root: {
                            lineHeight: 0
                        }
                    }
                },
                secondaryIconProps: props.userSetGalleryLayout === 'floatingLocalVideo' ? {
                    iconName: 'Accept'
                } : undefined
            }, {
                itemKey: 'focusedContentSelectionKey',
                text: localeStrings.strings.call.moreButtonGalleryFocusedContentLayoutLabel,
                onItemClick: () => {
                    props.onUserSetGalleryLayout && props.onUserSetGalleryLayout('focusedContent');
                    onLightDismiss();
                },
                iconProps: {
                    iconName: 'FocusedContentGalleryLayout',
                    styles: {
                        root: {
                            lineHeight: 0
                        }
                    }
                },
                secondaryIconProps: props.userSetGalleryLayout === 'focusedContent' ? {
                    iconName: 'Accept'
                } : undefined
            }]
    };
    drawerMenuItems.push(galleryLayoutOptions);
    if (drawerSelectionOptions !== false && isEnabled(drawerSelectionOptions === null || drawerSelectionOptions === void 0 ? void 0 : drawerSelectionOptions.peopleButton)) {
        drawerMenuItems.push({
            itemKey: 'people',
            id: 'call-composite-drawer-people-button',
            text: props.strings.peopleButtonLabel,
            iconProps: {
                iconName: 'MoreDrawerPeople'
            },
            onItemClick: props.onPeopleButtonClicked,
            disabled: isDisabled(drawerSelectionOptions.peopleButton) || props.disableButtonsForHoldScreen
        });
    }
    /*@conditional-compile-remove(rooms) */
    const role = (_d = callAdapter.getState().call) === null || _d === void 0 ? void 0 : _d.role;
    /*@conditional-compile-remove(rooms) */
    const hideRaiseHandButtonInRoomsCall = callAdapter.getState().isRoomsCall && role && ['Consumer', 'Unknown'].includes(role);
    /* @conditional-compile-remove(raise-hand) */
    if (drawerSelectionOptions !== false && isEnabled(drawerSelectionOptions === null || drawerSelectionOptions === void 0 ? void 0 : drawerSelectionOptions.raiseHandButton) && /*@conditional-compile-remove(rooms) */ !hideRaiseHandButtonInRoomsCall) {
        const raiseHandIcon = raiseHandButtonProps.checked ? 'LowerHandContextualMenuItem' : 'RaiseHandContextualMenuItem';
        drawerMenuItems.push({
            itemKey: 'raiseHandButtonKey',
            disabled: props.disableButtonsForHoldScreen || isDisabled(drawerSelectionOptions.raiseHandButton),
            text: raiseHandButtonProps.checked ? localeStrings.component.strings.raiseHandButton.onLabel : localeStrings.component.strings.raiseHandButton.offLabel,
            onItemClick: () => {
                if (raiseHandButtonProps.onToggleRaiseHand) {
                    raiseHandButtonProps.onToggleRaiseHand();
                }
                onLightDismiss();
            },
            iconProps: {
                iconName: raiseHandIcon,
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    //Captions drawer menu
    const supportedSpokenLanguageStrings = useLocale().strings.call.spokenLanguageStrings;
    /* @conditional-compile-remove(close-captions) */
    //Captions drawer menu
    const supportedCaptionLanguageStrings = useLocale().strings.call.captionLanguageStrings;
    /* @conditional-compile-remove(close-captions) */
    const captionSettingsProp = useAdaptedSelector(_captionSettingsSelector);
    /* @conditional-compile-remove(close-captions) */
    const startCaptionsButtonHandlers = useHandlers(_StartCaptionsButton);
    /* @conditional-compile-remove(close-captions) */
    const captionSettingsHandlers = useHandlers(_CaptionsSettingsModal);
    /* @conditional-compile-remove(close-captions) */
    const [isSpokenLanguageDrawerOpen, setIsSpokenLanguageDrawerOpen] = useState(false);
    /* @conditional-compile-remove(close-captions) */
    const [isCaptionLanguageDrawerOpen, setIsCaptionLanguageDrawerOpen] = useState(false);
    /* @conditional-compile-remove(close-captions) */
    const [currentSpokenLanguage, setCurrentSpokenLanguage] = useState((_e = captionSettingsProp.currentSpokenLanguage) !== null && _e !== void 0 ? _e : 'en-us');
    /* @conditional-compile-remove(close-captions) */
    const [currentCaptionLanguage, setCurrentCaptionLanguage] = useState((_f = captionSettingsProp.currentCaptionLanguage) !== null && _f !== void 0 ? _f : _spokenLanguageToCaptionLanguage[currentSpokenLanguage]);
    /* @conditional-compile-remove(close-captions) */
    const onToggleChange = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        if (!captionSettingsProp.isCaptionsFeatureActive) {
            yield startCaptionsButtonHandlers.onStartCaptions({
                spokenLanguage: currentSpokenLanguage
            });
        }
        else {
            startCaptionsButtonHandlers.onStopCaptions();
        }
    }), [captionSettingsProp.isCaptionsFeatureActive, startCaptionsButtonHandlers, currentSpokenLanguage]);
    /* @conditional-compile-remove(close-captions) */
    if (props.isCaptionsSupported) {
        const captionsDrawerItems = [];
        const spokenLanguageString = supportedSpokenLanguageStrings ? supportedSpokenLanguageStrings[currentSpokenLanguage] : currentSpokenLanguage;
        const captionLanguageString = supportedCaptionLanguageStrings ? supportedCaptionLanguageStrings[currentCaptionLanguage] : currentCaptionLanguage;
        drawerMenuItems.push({
            itemKey: 'captions',
            id: 'common-call-composite-captions-button',
            disabled: props.disableButtonsForHoldScreen,
            text: props.strings.captionsMenuTitle,
            iconProps: {
                iconName: 'CaptionsIcon'
            },
            subMenuProps: captionsDrawerItems
        });
        captionsDrawerItems.push({
            itemKey: 'ToggleCaptionsKey',
            text: captionSettingsProp.isCaptionsFeatureActive ? localeStrings.strings.call.startCaptionsButtonTooltipOnContent : localeStrings.strings.call.startCaptionsButtonTooltipOffContent,
            iconProps: {
                iconName: captionSettingsProp.isCaptionsFeatureActive ? 'CaptionsOffIcon' : 'CaptionsIcon',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            onItemClick: onToggleChange,
            disabled: props.disableButtonsForHoldScreen,
            secondaryComponent: React.createElement(Stack, { verticalFill: true, verticalAlign: "center" },
                React.createElement(Toggle, { id: "common-call-composite-captions-toggle-button", checked: captionSettingsProp.isCaptionsFeatureActive, styles: themedToggleButtonStyle(theme, captionSettingsProp.isCaptionsFeatureActive), onChange: onToggleChange }))
        });
        captionsDrawerItems.push({
            itemKey: 'ChangeSpokenLanguage',
            text: props.strings.spokenLanguageMenuTitle,
            id: 'common-call-composite-captions-spoken-settings-button',
            secondaryText: spokenLanguageString,
            iconProps: {
                iconName: 'ChangeSpokenLanguageIcon',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            disabled: props.disableButtonsForHoldScreen || !captionSettingsProp.isCaptionsFeatureActive,
            onItemClick: () => {
                setIsSpokenLanguageDrawerOpen(true);
            },
            secondaryIconProps: {
                iconName: 'ChevronRight',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            }
        });
        captionsDrawerItems.push({
            itemKey: 'ChangeCaptionLanguage',
            text: props.strings.captionLanguageMenuTitle,
            id: 'common-call-composite-captions-subtitle-settings-button',
            secondaryText: captionLanguageString,
            iconProps: {
                iconName: 'ChangeCaptionLanguageIcon',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            disabled: props.disableButtonsForHoldScreen || !captionSettingsProp.isCaptionsFeatureActive,
            onItemClick: () => {
                setIsCaptionLanguageDrawerOpen(true);
            },
            secondaryIconProps: {
                iconName: 'ChevronRight',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            }
        });
    }
    /* @conditional-compile-remove(control-bar-button-injection) */
    const customDrawerButtons = useMemo(() => generateCustomCallDrawerButtons(onFetchCustomButtonPropsTrampoline(drawerSelectionOptions !== false ? drawerSelectionOptions : undefined), drawerSelectionOptions !== false ? drawerSelectionOptions === null || drawerSelectionOptions === void 0 ? void 0 : drawerSelectionOptions.displayType : undefined), [drawerSelectionOptions]);
    /* @conditional-compile-remove(control-bar-button-injection) */
    customDrawerButtons['primary'].slice(CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_MOBILE_CUSTOM_BUTTONS).forEach(element => {
        drawerMenuItems.push(element);
    });
    /* @conditional-compile-remove(control-bar-button-injection) */
    customDrawerButtons['secondary'].forEach(element => {
        drawerMenuItems.push(element);
    });
    /* @conditional-compile-remove(control-bar-button-injection) */
    customDrawerButtons['overflow'].forEach(element => {
        drawerMenuItems.push(element);
    });
    /* @conditional-compile-remove(close-captions) */
    return React.createElement(React.Fragment, null,
        isSpokenLanguageDrawerOpen && props.isCaptionsSupported && React.createElement(SpokenLanguageSettingsDrawer, { onLightDismiss: props.onLightDismiss, selectLanguage: setCurrentSpokenLanguage, setCurrentLanguage: captionSettingsHandlers.onSetSpokenLanguage, currentLanguage: currentSpokenLanguage, strings: {
                menuTitle: props.strings.spokenLanguageMenuTitle
            }, supportedLanguageStrings: supportedSpokenLanguageStrings }),
        isCaptionLanguageDrawerOpen && props.isCaptionsSupported && React.createElement(CaptionLanguageSettingsDrawer, { onLightDismiss: props.onLightDismiss, selectLanguage: setCurrentCaptionLanguage, setCurrentLanguage: captionSettingsHandlers.onSetCaptionLanguage, currentLanguage: currentCaptionLanguage, strings: {
                menuTitle: props.strings.captionLanguageMenuTitle
            }, supportedLanguageStrings: supportedCaptionLanguageStrings }),
        !isSpokenLanguageDrawerOpen && !isCaptionLanguageDrawerOpen && React.createElement(DrawerMenu, { items: drawerMenuItems, onLightDismiss: props.onLightDismiss }));
    return React.createElement(DrawerMenu, { items: drawerMenuItems, onLightDismiss: props.onLightDismiss });
};
const isDeviceSelected = (speaker, selectedSpeaker) => !!selectedSpeaker && speaker.id === selectedSpeaker.id;
const isEnabled = (option) => option !== false;
//# sourceMappingURL=MoreDrawer.js.map