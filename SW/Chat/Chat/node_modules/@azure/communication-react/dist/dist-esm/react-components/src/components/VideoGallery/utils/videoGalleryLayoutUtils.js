// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { useCallback, useRef } from 'react';
import { smartDominantSpeakerParticipants } from '../../../gallery';
const DEFAULT_MAX_OVERFLOW_GALLERY_DOMINANT_SPEAKERS = 6;
const DEFAULT_MAX_VIDEO_SREAMS = 4;
const MAX_GRID_PARTICIPANTS_NOT_LARGE_GALLERY = 9;
const _useOrganizedParticipants = (props) => {
    const visibleGridParticipants = useRef([]);
    const visibleOverflowGalleryParticipants = useRef([]);
    const { remoteParticipants = [], dominantSpeakers = [], maxRemoteVideoStreams = DEFAULT_MAX_VIDEO_SREAMS, maxOverflowGalleryDominantSpeakers = DEFAULT_MAX_OVERFLOW_GALLERY_DOMINANT_SPEAKERS, isScreenShareActive = false, pinnedParticipantUserIds = [], layout } = props;
    const calculateMaxRemoteVideoStreams = () => {
        if (maxRemoteVideoStreams > MAX_GRID_PARTICIPANTS_NOT_LARGE_GALLERY) {
            return MAX_GRID_PARTICIPANTS_NOT_LARGE_GALLERY;
        }
        else {
            return maxRemoteVideoStreams;
        }
        return maxRemoteVideoStreams;
    };
    const maxRemoteVideoStreamsToUse = calculateMaxRemoteVideoStreams();
    const videoParticipants = remoteParticipants.filter(p => { var _a; return (_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable; });
    const participantsToSortTrampoline = () => {
        return layout !== 'floatingLocalVideo' ? putVideoParticipantsFirst(remoteParticipants) : videoParticipants;
        return videoParticipants;
    };
    visibleGridParticipants.current = pinnedParticipantUserIds.length > 0 || isScreenShareActive ? [] : smartDominantSpeakerParticipants({
        participants: participantsToSortTrampoline(),
        dominantSpeakers,
        lastVisibleParticipants: visibleGridParticipants.current,
        maxDominantSpeakers: maxRemoteVideoStreamsToUse
    }).slice(0, maxRemoteVideoStreamsToUse);
    const dominantSpeakerToGrid = layout === 'speaker' ? dominantSpeakers && dominantSpeakers[0] ? visibleGridParticipants.current.filter(p => p.userId === dominantSpeakers[0]) : [visibleGridParticipants.current[0]] : [];
    if (dominantSpeakerToGrid[0]) {
        visibleGridParticipants.current = dominantSpeakerToGrid;
    }
    const visibleGridParticipantsSet = new Set(visibleGridParticipants.current.map(p => p.userId));
    const remoteParticipantsOrdered = putVideoParticipantsFirst(remoteParticipants);
    visibleOverflowGalleryParticipants.current = smartDominantSpeakerParticipants({
        participants: remoteParticipantsOrdered.filter(p => !visibleGridParticipantsSet.has(p.userId)),
        dominantSpeakers: dominantSpeakers,
        lastVisibleParticipants: visibleOverflowGalleryParticipants.current,
        maxDominantSpeakers: maxOverflowGalleryDominantSpeakers
    });
    const getGridParticipants = useCallback(() => {
        if (isScreenShareActive) {
            return [];
        }
        // if we have no grid participants we need to cap the max number of overflowGallery participants in the grid
        // we will use the max streams provided to the function to find the max participants that can go in the grid
        // if there are less participants than max streams then we will use all participants including joining in the grid
        return visibleGridParticipants.current.length > 0 ? visibleGridParticipants.current : visibleOverflowGalleryParticipants.current.slice(0, maxRemoteVideoStreamsToUse);
    }, [isScreenShareActive, maxRemoteVideoStreamsToUse]);
    const gridParticipants = getGridParticipants();
    const getOverflowGalleryRemoteParticipants = useCallback(() => {
        if (isScreenShareActive) {
            // If screen sharing is active, assign video and audio participants as overflow gallery participants
            return visibleGridParticipants.current.concat(visibleOverflowGalleryParticipants.current);
        }
        else {
            // If screen sharing is not active, then assign all video tiles as grid tiles.
            // If there are no video tiles, then assign audio tiles as grid tiles.
            // if there are more overflow tiles than max streams then find the tiles that don't fit in the grid and put them in overflow
            // overflow should be empty if total participants including calling participants is less than max streams
            return visibleGridParticipants.current.length > 0 ? visibleOverflowGalleryParticipants.current : visibleOverflowGalleryParticipants.current.slice(maxRemoteVideoStreamsToUse);
        }
    }, [isScreenShareActive, maxRemoteVideoStreamsToUse]);
    const overflowGalleryParticipants = getOverflowGalleryRemoteParticipants();
    return {
        gridParticipants,
        overflowGalleryParticipants: overflowGalleryParticipants
    };
};
const _useOrganizedParticipantsWithFocusedParticipants = (props) => {
    var _a, _b;
    // map remote participants by userId
    const remoteParticipantMap = props.remoteParticipants.reduce((map, remoteParticipant) => {
        map[remoteParticipant.userId] = remoteParticipant;
        return map;
    }, {});
    const spotlightedParticipantUserIds = (_a = props.spotlightedParticipantUserIds) !== null && _a !== void 0 ? _a : [];
    // declare focused participant user ids as spotlighted participants user ids followed by
    // pinned participants user ids
    const focusedParticipantUserIds = [...new Set(spotlightedParticipantUserIds.concat((_b = props.pinnedParticipantUserIds) !== null && _b !== void 0 ? _b : []))];
    // get focused participants from map of remote participants in the order of the user ids
    const focusedParticipants = [];
    focusedParticipantUserIds.forEach(id => {
        const pinnedParticipant = remoteParticipantMap[id];
        if (pinnedParticipant) {
            focusedParticipants.push(pinnedParticipant);
        }
    });
    // get unfocused participants by filtering out set of focused participant user ids from all remote participants
    const focusedParticipantUserIdSet = new Set(focusedParticipantUserIds);
    const unfocusedParticipants = props.remoteParticipants.filter(p => !focusedParticipantUserIdSet.has(p.userId));
    const useOrganizedParticipantsProps = Object.assign(Object.assign({}, props), { 
        // if there are pinned participants then we should only consider unpinned participants
        remoteParticipants: unfocusedParticipants });
    const useOrganizedParticipantsResult = _useOrganizedParticipants(useOrganizedParticipantsProps);
    if (focusedParticipants.length === 0) {
        return useOrganizedParticipantsResult;
    }
    return {
        gridParticipants: props.isScreenShareActive ? [] : focusedParticipants,
        overflowGalleryParticipants: props.isScreenShareActive ? focusedParticipants.concat(useOrganizedParticipantsResult.overflowGalleryParticipants) : useOrganizedParticipantsResult.gridParticipants.concat(useOrganizedParticipantsResult.overflowGalleryParticipants)
    };
};
const putVideoParticipantsFirst = (remoteParticipants) => {
    const videoParticipants = [];
    const audioParticipants = [];
    remoteParticipants.forEach(p => {
        var _a;
        if ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) {
            videoParticipants.push(p);
        }
        else {
            audioParticipants.push(p);
        }
    });
    const remoteParticipantSortedByVideo = videoParticipants.concat(audioParticipants);
    return remoteParticipantSortedByVideo;
};
/**
 * Hook to determine which participants should be in grid and overflow gallery and their order respectively
 * @private
 */
export const useOrganizedParticipants = (args) => {
    return _useOrganizedParticipantsWithFocusedParticipants(args);
};
//# sourceMappingURL=videoGalleryLayoutUtils.js.map