// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { Features } from '@azure/communication-calling';
import { toFlatCommunicationIdentifier } from "../../acs-ui-common/src";
/* @conditional-compile-remove(close-captions) */
import { CaptionsSubscriber } from './CaptionsSubscriber';
import { convertSdkLocalStreamToDeclarativeLocalStream, convertSdkParticipantToDeclarativeParticipant } from './Converter';
/* @conditional-compile-remove(video-background-effects) */
import { LocalVideoStreamVideoEffectsSubscriber } from './LocalVideoStreamVideoEffectsSubscriber';
import { ParticipantSubscriber } from './ParticipantSubscriber';
import { RecordingSubscriber } from './RecordingSubscriber';
import { disposeView } from './StreamUtils';
import { TranscriptionSubscriber } from './TranscriptionSubscriber';
import { UserFacingDiagnosticsSubscriber } from './UserFacingDiagnosticsSubscriber';
/* @conditional-compile-remove(raise-hand) */
import { RaiseHandSubscriber } from './RaiseHandSubscriber';
/* @conditional-compile-remove(optimal-video-count) */
import { OptimalVideoCountSubscriber } from './OptimalVideoCountSubscriber';
/* @conditional-compile-remove(capabilities) */
import { CapabilitiesSubscriber } from './CapabilitiesSubscriber';
/**
 * Keeps track of the listeners assigned to a particular call because when we get an event from SDK, it doesn't tell us
 * which call it is for. If we keep track of this then we know which call in the state that needs an update and also
 * which property of that call. Also we can use this when unregistering to a call.
 */
export class CallSubscriber {
    constructor(call, context, internalContext) {
        this.subscribe = () => {
            this._call.on('stateChanged', this.stateChanged);
            /* @conditional-compile-remove(close-captions) */
            this._call.on('stateChanged', this.initCaptionSubscriber);
            this._call.on('idChanged', this.idChanged);
            this._call.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged);
            this._call.on('remoteParticipantsUpdated', this.remoteParticipantsUpdated);
            this._call.on('localVideoStreamsUpdated', this.localVideoStreamsUpdated);
            this._call.on('isMutedChanged', this.isMuteChanged);
            /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(capabilities) */
            this._call.on('roleChanged', this.callRoleChangedHandler);
            this._call.feature(Features.DominantSpeakers).on('dominantSpeakersChanged', this.dominantSpeakersChanged);
            for (const localVideoStream of this._call.localVideoStreams) {
                this._internalContext.setLocalRenderInfo(this._callIdRef.callId, localVideoStream.mediaStreamType, localVideoStream, 'NotRendered', undefined);
            }
            if (this._call.remoteParticipants.length > 0) {
                this._call.remoteParticipants.forEach((participant) => {
                    this.addParticipantListener(participant);
                });
                this._context.setCallRemoteParticipants(this._callIdRef.callId, this._call.remoteParticipants.map(convertSdkParticipantToDeclarativeParticipant), []);
            }
        };
        this.unsubscribe = () => {
            var _a, _b;
            this._call.off('stateChanged', this.stateChanged);
            /* @conditional-compile-remove(close-captions) */
            this._call.off('stateChanged', this.initCaptionSubscriber);
            this._call.off('idChanged', this.idChanged);
            this._call.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged);
            this._call.off('remoteParticipantsUpdated', this.remoteParticipantsUpdated);
            this._call.off('localVideoStreamsUpdated', this.localVideoStreamsUpdated);
            this._call.off('isMutedChanged', this.isMuteChanged);
            /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(capabilities) */
            this._call.off('roleChanged', this.callRoleChangedHandler);
            this._participantSubscribers.forEach((participantSubscriber) => {
                participantSubscriber.unsubscribe();
            });
            this._participantSubscribers.clear();
            // If we are unsubscribing that means we no longer want to display any video for this call (callEnded or callAgent
            // disposed) and we should not be updating it any more. So if video is rendering we stop rendering.
            for (const localVideoStream of this._call.localVideoStreams) {
                const mediaStreamType = localVideoStream.mediaStreamType;
                disposeView(this._context, this._internalContext, this._callIdRef.callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(localVideoStream));
                this._internalContext.deleteLocalRenderInfo(this._callIdRef.callId, mediaStreamType);
            }
            this._diagnosticsSubscriber.unsubscribe();
            this._recordingSubscriber.unsubscribe();
            this._transcriptionSubscriber.unsubscribe();
            /* @conditional-compile-remove(optimal-video-count) */
            this._optimalVideoCountSubscriber.unsubscribe();
            /* @conditional-compile-remove(close-captions) */
            (_a = this._captionsSubscriber) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            /* @conditional-compile-remove(raise-hand) */
            (_b = this._raiseHandSubscriber) === null || _b === void 0 ? void 0 : _b.unsubscribe();
            /* @conditional-compile-remove(capabilities) */
            this._capabilitiesSubscriber.unsubscribe();
        };
        this.stateChanged = () => {
            this._context.setCallState(this._callIdRef.callId, this._call.state);
        };
        /* @conditional-compile-remove(close-captions) */
        this.initCaptionSubscriber = () => {
            // subscribe to captions here so that we don't call captions when call is not initialized
            if (this._call.state === 'Connected' && !this._captionsSubscriber) {
                if (this._call.feature(Features.Captions).captions.kind === 'TeamsCaptions') {
                    this._captionsSubscriber = new CaptionsSubscriber(this._callIdRef, this._context, this._call.feature(Features.Captions).captions);
                    this._call.off('stateChanged', this.initCaptionSubscriber);
                }
            }
        };
        this.idChanged = () => {
            this._internalContext.setCallId(this._call.id, this._callIdRef.callId);
            this._context.setCallId(this._call.id, this._callIdRef.callId);
            this._callIdRef.callId = this._call.id;
        };
        this.isScreenSharingOnChanged = () => {
            this._context.setCallIsScreenSharingOn(this._callIdRef.callId, this._call.isScreenSharingOn);
        };
        this.isMuteChanged = () => {
            this._context.setCallIsMicrophoneMuted(this._callIdRef.callId, this._call.isMuted);
        };
        /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(capabilities) */
        this.callRoleChangedHandler = () => {
            this._context.setRole(this._callIdRef.callId, this._call.role);
        };
        this.remoteParticipantsUpdated = (event) => {
            event.added.forEach((participant) => {
                this.addParticipantListener(participant);
            });
            event.removed.forEach((participant) => {
                this.removeParticipantListener(participant);
            });
            // Remove any added participants from remoteParticipantsEnded if they are there and add any removed participants to
            // remoteParticipantsEnded.
            this._context.setCallRemoteParticipantsEnded(this._callIdRef.callId, event.removed.map(convertSdkParticipantToDeclarativeParticipant), event.added.map((participant) => {
                return toFlatCommunicationIdentifier(participant.identifier);
            }));
            // Add added participants to remoteParticipants and remove removed participants from remoteParticipants.
            this._context.setCallRemoteParticipants(this._callIdRef.callId, event.added.map(convertSdkParticipantToDeclarativeParticipant), event.removed.map((participant) => {
                return toFlatCommunicationIdentifier(participant.identifier);
            }));
        };
        this.localVideoStreamsUpdated = (event) => {
            var _a, _b;
            for (const localVideoStream of event.added) {
                const mediaStreamType = localVideoStream.mediaStreamType;
                // IMPORTANT: The internalContext should be set before context. This is done to ensure that the internal context
                // has the required data when component re-renders due to external state changes.
                this._internalContext.setLocalRenderInfo(this._callIdRef.callId, mediaStreamType, localVideoStream, 'NotRendered', undefined);
                // Subscribe to video effect changes
                (_a = this._localVideoStreamVideoEffectsSubscribers.get(mediaStreamType)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                this._localVideoStreamVideoEffectsSubscribers.set(mediaStreamType, new LocalVideoStreamVideoEffectsSubscriber({
                    parent: this._callIdRef,
                    context: this._context,
                    localVideoStream: localVideoStream,
                    localVideoStreamEffectsAPI: localVideoStream.feature(Features.VideoEffects)
                }));
            }
            for (const localVideoStream of event.removed) {
                const mediaStreamType = localVideoStream.mediaStreamType;
                (_b = this._localVideoStreamVideoEffectsSubscribers.get(mediaStreamType)) === null || _b === void 0 ? void 0 : _b.unsubscribe();
                disposeView(this._context, this._internalContext, this._callIdRef.callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(localVideoStream));
                this._internalContext.deleteLocalRenderInfo(this._callIdRef.callId, mediaStreamType);
            }
            this._context.setCallLocalVideoStream(this._callIdRef.callId, event.added.map(convertSdkLocalStreamToDeclarativeLocalStream), event.removed.map(convertSdkLocalStreamToDeclarativeLocalStream));
        };
        this.dominantSpeakersChanged = () => {
            const dominantSpeakers = this._call.feature(Features.DominantSpeakers).dominantSpeakers;
            this._context.setCallDominantSpeakers(this._callIdRef.callId, dominantSpeakers);
        };
        this._call = call;
        this._callIdRef = {
            callId: call.id
        };
        this._context = context;
        this._internalContext = internalContext;
        this._diagnosticsSubscriber = new UserFacingDiagnosticsSubscriber(this._callIdRef, this._context, this._call.feature(Features.UserFacingDiagnostics));
        this._participantSubscribers = new Map();
        this._recordingSubscriber = new RecordingSubscriber(this._callIdRef, this._context, this._call.feature(Features.Recording));
        this._transcriptionSubscriber = new TranscriptionSubscriber(this._callIdRef, this._context, this._call.feature(Features.Transcription));
        /* @conditional-compile-remove(raise-hand) */
        this._raiseHandSubscriber = new RaiseHandSubscriber(this._callIdRef, this._context, this._call.feature(Features.RaiseHand));
        /* @conditional-compile-remove(optimal-video-count) */
        this._optimalVideoCountSubscriber = new OptimalVideoCountSubscriber({
            callIdRef: this._callIdRef,
            context: this._context,
            localOptimalVideoCountFeature: this._call.feature(Features.OptimalVideoCount)
        });
        /* @conditional-compile-remove(video-background-effects) */
        this._localVideoStreamVideoEffectsSubscribers = new Map();
        /* @conditional-compile-remove(capabilities) */
        this._capabilitiesSubscriber = new CapabilitiesSubscriber(this._callIdRef, this._context, this._call.feature(Features.Capabilities));
        this.subscribe();
    }
    addParticipantListener(participant) {
        var _a;
        const participantKey = toFlatCommunicationIdentifier(participant.identifier);
        (_a = this._participantSubscribers.get(participantKey)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this._participantSubscribers.set(participantKey, new ParticipantSubscriber(this._callIdRef, participant, this._context, this._internalContext));
    }
    removeParticipantListener(participant) {
        const participantKey = toFlatCommunicationIdentifier(participant.identifier);
        const participantSubscriber = this._participantSubscribers.get(participantKey);
        if (participantSubscriber) {
            participantSubscriber.unsubscribe();
            this._participantSubscribers.delete(participantKey);
        }
    }
}
//# sourceMappingURL=CallSubscriber.js.map