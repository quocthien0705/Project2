// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { compositeLogger } from '../../../Logger';
import { _isInCall, _isInLobbyOrConnecting } from "../../../../../calling-component-bindings/src";
import { _createStatefulCallClientInner } from "../../../../../calling-stateful-client/src";
import { LocalVideoStream as SDKLocalVideoStream } from '@azure/communication-calling';
/* @conditional-compile-remove(unsupported-browser) */ /* @conditional-compile-remove(video-background-effects) */ /* @conditional-compile-remove(close-captions) */ /* @conditional-compile-remove(capabilities) */
import { Features } from '@azure/communication-calling';
import { EventEmitter } from 'events';
import { getCallCompositePage, getLocatorOrTargetCallees, IsCallEndedPage, isCameraOn } from '../utils';
import { toFlatCommunicationIdentifier, _toCommunicationIdentifier, _isValidIdentifier } from "../../../../../acs-ui-common/src";
import { isMicrosoftTeamsUserIdentifier } from '@azure/communication-common';
import { ParticipantSubscriber } from './ParticipantSubcriber';
import { DiagnosticsForwarder } from './DiagnosticsForwarder';
import { useEffect, useRef, useState } from 'react';
import { createHandlers } from './createHandlers';
import { createProfileStateModifier } from './OnFetchProfileCallback';
/* @conditional-compile-remove(video-background-effects) */
import { getBackgroundEffectFromSelectedEffect } from '../utils';
import { getSelectedCameraFromAdapterState } from '../utils';
/* @conditional-compile-remove(calling-sounds) */
import { CallingSoundSubscriber } from './CallingSoundSubscriber';
/** Context of call, which is a centralized context for all state updates */
class CallContext {
    constructor(clientState, isTeamsCall, /* @conditional-compile-remove(rooms) */ isRoomsCall, options, targetCallees) {
        var _a, _b, _c, _d;
        this.emitter = new EventEmitter();
        this.state = {
            isLocalPreviewMicrophoneEnabled: false,
            userId: clientState.userId,
            displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName,
            devices: clientState.deviceManager,
            call: undefined,
            /* @conditional-compile-remove(calling-sounds) */ targetCallees: targetCallees,
            page: 'configuration',
            latestErrors: clientState.latestErrors,
            isTeamsCall,
            /* @conditional-compile-remove(rooms) */ isRoomsCall,
            /* @conditional-compile-remove(video-background-effects) */ videoBackgroundImages: (_b = options === null || options === void 0 ? void 0 : options.videoBackgroundOptions) === null || _b === void 0 ? void 0 : _b.videoBackgroundImages,
            /* @conditional-compile-remove(video-background-effects) */
            onResolveVideoEffectDependency: (_c = options === null || options === void 0 ? void 0 : options.videoBackgroundOptions) === null || _c === void 0 ? void 0 : _c.onResolveDependency,
            /* @conditional-compile-remove(video-background-effects) */ selectedVideoBackgroundEffect: undefined,
            cameraStatus: undefined,
            /* @conditional-compile-remove(calling-sounds) */ sounds: options === null || options === void 0 ? void 0 : options.callingSounds
        };
        this.emitter.setMaxListeners((_d = options === null || options === void 0 ? void 0 : options.maxListeners) !== null && _d !== void 0 ? _d : 50);
        this.bindPublicMethods();
        this.displayNameModifier = (options === null || options === void 0 ? void 0 : options.onFetchProfile) ? createProfileStateModifier(options.onFetchProfile, () => {
            this.setState(this.getState());
        }) : undefined;
    }
    bindPublicMethods() { }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = this.displayNameModifier ? this.displayNameModifier(state) : state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    setIsLocalMicrophoneEnabled(isLocalPreviewMicrophoneEnabled) {
        this.setState(Object.assign(Object.assign({}, this.state), { isLocalPreviewMicrophoneEnabled }));
    }
    // This is the key to find current call object in client state
    setCurrentCallId(callId) {
        this.callId = callId;
    }
    /* @conditional-compile-remove(calling-sounds) */
    setTargetCallee(targetCallees) {
        this.setState(Object.assign(Object.assign({}, this.state), { targetCallees }));
    }
    onCallEnded(handler) {
        this.emitter.on('callEnded', handler);
    }
    offCallEnded(handler) {
        this.emitter.off('callEnded', handler);
    }
    updateClientState(clientState) {
        var _a;
        let call = this.callId ? clientState.calls[this.callId] : undefined;
        const latestEndedCall = clientState.callsEnded ? findLatestEndedCall(clientState.callsEnded) : undefined;
        // As the state is transitioning to a new state, trigger appropriate callback events.
        const oldPage = this.state.page;
        /* @conditional-compile-remove(call-transfer) */
        const latestAcceptedTransfer = (call === null || call === void 0 ? void 0 : call.transfer.acceptedTransfers) ? findLatestAcceptedTransfer(call.transfer.acceptedTransfers) : undefined;
        /* @conditional-compile-remove(call-transfer) */
        const transferCall = latestAcceptedTransfer ? clientState.calls[latestAcceptedTransfer.callId] : undefined;
        const newPage = getCallCompositePage(call, latestEndedCall, /* @conditional-compile-remove(call-transfer) */ transferCall);
        if (!IsCallEndedPage(oldPage) && IsCallEndedPage(newPage)) {
            this.emitter.emit('callEnded', {
                callId: this.callId
            });
            // Reset the callId to undefined as the call has ended.
            this.setCurrentCallId(undefined);
            // Make sure that the call is set to undefined in the state.
            call = undefined;
        }
        if (this.state.page) {
            this.setState(Object.assign(Object.assign({}, this.state), { userId: clientState.userId, displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName, call, page: newPage, endedCall: latestEndedCall, devices: clientState.deviceManager, latestErrors: clientState.latestErrors, cameraStatus: (call === null || call === void 0 ? void 0 : call.localVideoStreams.find(s => s.mediaStreamType === 'Video')) || clientState.deviceManager.unparentedViews.find(s => s.mediaStreamType === 'Video') ? 'On' : 'Off', 
                /* @conditional-compile-remove(call-transfer) */ acceptedTransferCallState: transferCall }));
        }
    }
    /* @conditional-compile-remove(video-background-effects) */
    setBackroundPickerImages(videoBackgroundImages) {
        this.setState(Object.assign(Object.assign({}, this.state), { videoBackgroundImages }));
    }
    /* @conditional-compile-remove(video-background-effects) */
    setSelectedVideoBackgroundEffect(selectedVideoBackgroundEffect) {
        this.setState(Object.assign(Object.assign({}, this.state), { selectedVideoBackgroundEffect }));
    }
    /* @conditional-compile-remove(call-transfer) */
    setAcceptedTransferCall(call) {
        this.setState(Object.assign(Object.assign({}, this.state), { acceptedTransferCallState: call }));
    }
}
const findLatestEndedCall = (calls) => {
    var _a, _b, _c, _d;
    const callStates = Object.values(calls);
    if (callStates.length === 0) {
        return undefined;
    }
    let latestCall = callStates[0];
    for (const call of callStates.slice(1)) {
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) > ((_d = (_c = latestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            latestCall = call;
        }
    }
    return latestCall;
};
/* @conditional-compile-remove(call-transfer) */
const findLatestAcceptedTransfer = (acceptedTransfers) => {
    var _a, _b, _c, _d;
    const acceptedTransferValues = Object.values(acceptedTransfers);
    if (acceptedTransferValues.length === 0) {
        return undefined;
    }
    let latestAcceptedTransfer = acceptedTransferValues[0];
    for (const acceptedTransfer of acceptedTransferValues.slice(1)) {
        if (((_b = (_a = acceptedTransfer.timestamp) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) > ((_d = (_c = latestAcceptedTransfer.timestamp) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            latestAcceptedTransfer = acceptedTransfer;
        }
    }
    return latestAcceptedTransfer;
};
/**
 * @private
 */
export class AzureCommunicationCallAdapter {
    get call() {
        return this._call;
    }
    set call(newCall) {
        this.resetDiagnosticsForwarder(newCall);
        this._call = newCall;
    }
    constructor(callClient, locatorOrTargetCalless, callAgent, deviceManager, options) {
        var _a;
        this.participantSubscribers = new Map();
        this.emitter = new EventEmitter();
        this.isMyMutedChanged = () => {
            var _a;
            this.emitter.emit('isMutedChanged', {
                participantId: this.getState().userId,
                isMuted: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isMuted
            });
        };
        this.bindPublicMethods();
        this.callClient = callClient;
        this.callAgent = callAgent;
        this.targetCallees = getLocatorOrTargetCallees(locatorOrTargetCalless) === true ? locatorOrTargetCalless : undefined;
        this.locator = getLocatorOrTargetCallees(locatorOrTargetCalless) === false ? locatorOrTargetCalless : undefined;
        this.deviceManager = deviceManager;
        const isTeamsMeeting = this.locator ? 'meetingLink' in this.locator : false;
        /* @conditional-compile-remove(rooms) */
        const isRoomsCall = this.locator ? 'roomId' in this.locator : false;
        /* @conditional-compile-remove(video-background-effects) */
        this.onResolveVideoBackgroundEffectsDependency = (_a = options === null || options === void 0 ? void 0 : options.videoBackgroundOptions) === null || _a === void 0 ? void 0 : _a.onResolveDependency;
        this.context = new CallContext(callClient.getState(), isTeamsMeeting, /* @conditional-compile-remove(rooms) */ isRoomsCall, /* @conditional-compile-remove(video-background-effects) */ options, this.targetCallees);
        this.context.onCallEnded(endCallData => this.emitter.emit('callEnded', endCallData));
        const onStateChange = (clientState) => {
            var _a, _b, _c;
            // unsubscribe when the instance gets disposed
            if (!this) {
                callClient.offStateChange(onStateChange);
                return;
            }
            // `updateClientState` searches for the current call from all the calls in the state using a cached `call.id`
            // from the call object. `call.id` can change during a call. We must update the cached `call.id` before
            // calling `updateClientState` so that we find the correct state object for the call even when `call.id`
            // has changed.
            // https://github.com/Azure/communication-ui-library/pull/1820
            if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id) {
                this.context.setCurrentCallId(this.call.id);
            }
            // If the call connects we need to clean up any previous unparentedViews
            if ((((_b = this.call) === null || _b === void 0 ? void 0 : _b.state) === 'InLobby' || ((_c = this.call) === null || _c === void 0 ? void 0 : _c.state) === 'Connected') && this.callClient.getState().deviceManager.unparentedViews.length > 0) {
                this.callClient.getState().deviceManager.unparentedViews.forEach(view => {
                    this.callClient.disposeView(undefined, undefined, view);
                });
            }
            this.context.updateClientState(clientState);
        };
        this.handlers = createHandlers(callClient, callAgent, deviceManager, undefined, /* @conditional-compile-remove(video-background-effects) */ {
            onResolveVideoBackgroundEffectsDependency: this.onResolveVideoBackgroundEffectsDependency
        });
        this.onClientStateChange = onStateChange;
        this.subscribeDeviceManagerEvents();
        this.callClient.onStateChange(onStateChange);
        /* @conditional-compile-remove(call-transfer) */
        if (this.callAgent.kind === 'CallAgent') {
            const onCallsUpdated = (args) => {
                var _a;
                if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id) {
                    const removedCall = args.removed.find(call => { var _a; return call.id === ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id); });
                    if (removedCall) {
                        const removedCallState = this.callClient.getState().callsEnded[removedCall.id];
                        const latestAcceptedTransfer = findLatestAcceptedTransfer(removedCallState.transfer.acceptedTransfers);
                        const _callAgent = callAgent;
                        const transferCall = _callAgent.calls.find((call) => call.id === (latestAcceptedTransfer === null || latestAcceptedTransfer === void 0 ? void 0 : latestAcceptedTransfer.callId));
                        if (transferCall) {
                            this.processNewCall(transferCall);
                        }
                    }
                }
            };
            this.callAgent.on('callsUpdated', onCallsUpdated);
        }
    }
    // TODO: update this to include the 'selectedCameraChanged' when calling adds it to the device manager
    subscribeDeviceManagerEvents() {
        this.deviceManager.on('selectedMicrophoneChanged', () => {
            this.emitter.emit('selectedMicrophoneChanged');
        });
        this.deviceManager.on('selectedSpeakerChanged', () => {
            this.emitter.emit('selectedSpeakerChanged');
        });
    }
    bindPublicMethods() {
        this.onStateChange.bind(this);
        this.offStateChange.bind(this);
        this.getState.bind(this);
        this.dispose.bind(this);
        this.joinCall.bind(this);
        this.leaveCall.bind(this);
        this.setCamera.bind(this);
        this.setMicrophone.bind(this);
        this.setSpeaker.bind(this);
        this.askDevicePermission.bind(this);
        this.queryCameras.bind(this);
        this.queryMicrophones.bind(this);
        this.querySpeakers.bind(this);
        this.startCamera.bind(this);
        this.stopCamera.bind(this);
        this.mute.bind(this);
        this.unmute.bind(this);
        this.startCall.bind(this);
        this.startScreenShare.bind(this);
        this.stopScreenShare.bind(this);
        /* @conditional-compile-remove(raise-hand) */
        this.raiseHand.bind(this);
        this.lowerHand.bind(this);
        this.removeParticipant.bind(this);
        this.createStreamView.bind(this);
        this.disposeStreamView.bind(this);
        this.disposeScreenShareStreamView.bind(this);
        this.disposeRemoteVideoStreamView.bind(this);
        this.disposeLocalVideoStreamView.bind(this);
        this.on.bind(this);
        this.off.bind(this);
        this.processNewCall.bind(this);
        this.sendDtmfTone.bind(this);
        /* @conditional-compile-remove(close-captions) */
        {
            this.startCaptions.bind(this);
            this.stopCaptions.bind(this);
            this.setSpokenLanguage.bind(this);
            this.setCaptionLanguage.bind(this);
        }
        /* @conditional-compile-remove(video-background-effects) */
        this.startVideoBackgroundEffect.bind(this);
        /* @conditional-compile-remove(video-background-effects) */
        this.stopVideoBackgroundEffects.bind(this);
        /* @conditional-compile-remove(video-background-effects) */
        this.updateBackgroundPickerImages.bind(this);
    }
    dispose() {
        this.resetDiagnosticsForwarder();
        this.callClient.offStateChange(this.onClientStateChange);
        this.callAgent.dispose();
    }
    queryCameras() {
        return __awaiter(this, void 0, void 0, function* () {
            const startTime = new Date().getTime();
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                const cameras = yield this.deviceManager.getCameras();
                const endTime = new Date().getTime();
                compositeLogger.info('time to query cameras', endTime - startTime, 'ms');
                return cameras;
            }));
        });
    }
    queryMicrophones() {
        return __awaiter(this, void 0, void 0, function* () {
            const startTime = new Date().getTime();
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                const microphones = yield this.deviceManager.getMicrophones();
                const endTime = new Date().getTime();
                compositeLogger.info('time to query microphones', endTime - startTime, 'ms');
                return microphones;
            }));
        });
    }
    querySpeakers() {
        return __awaiter(this, void 0, void 0, function* () {
            const startTime = new Date().getTime();
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                const speakers = (yield this.deviceManager.isSpeakerSelectionAvailable) ? this.deviceManager.getSpeakers() : [];
                const endTime = new Date().getTime();
                compositeLogger.info('time to query speakers', endTime - startTime, 'ms');
                return speakers;
            }));
        });
    }
    askDevicePermission(constrain) {
        return __awaiter(this, void 0, void 0, function* () {
            const startTime = new Date().getTime();
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.deviceManager.askDevicePermission(constrain);
                const endTime = new Date().getTime();
                compositeLogger.info('time to query askDevicePermissions', endTime - startTime, 'ms');
            }));
        });
    }
    joinCall(options) {
        var _a, _b;
        if (_isInCall((_b = (_a = this.getState().call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None')) {
            throw new Error('You are already in the call!');
        }
        else if (this.locator === undefined) {
            throw new Error('Locator is not defined!');
        }
        return this.teeErrorToEventEmitter(() => {
            // Default to keeping camera/mic on if no override argument specified
            let shouldCameraBeOnInCall = this.getState().cameraStatus === 'On';
            let shouldMicrophoneBeOnInCall = this.getState().isLocalPreviewMicrophoneEnabled;
            // Apply override arguments
            if (typeof options === 'boolean') {
                // Deprecated joinCall API (boolen)
                shouldMicrophoneBeOnInCall = options;
            }
            else if (typeof options === 'object') {
                // Options bag API
                if (options.microphoneOn && options.microphoneOn !== 'keep') {
                    shouldMicrophoneBeOnInCall = options.microphoneOn;
                }
                if (options.cameraOn && options.cameraOn !== 'keep') {
                    shouldCameraBeOnInCall = options.cameraOn;
                }
            }
            const audioOptions = {
                muted: !shouldMicrophoneBeOnInCall
            };
            const selectedCamera = getSelectedCameraFromAdapterState(this.getState());
            const videoOptions = selectedCamera && shouldCameraBeOnInCall ? {
                localVideoStreams: [new SDKLocalVideoStream(selectedCamera)]
            } : {};
            const call = this._joinCall(audioOptions, videoOptions);
            this.processNewCall(call);
            return call;
        });
    }
    _joinCall(audioOptions, videoOptions) {
        const isTeamsMeeting = this.locator ? 'meetingLink' in this.locator : false;
        /* @conditional-compile-remove(rooms) */
        const isRoomsCall = this.locator ? 'roomId' in this.locator : false;
        if (isTeamsMeeting) {
            return this.callAgent.join(this.locator, {
                audioOptions,
                videoOptions
            });
        }
        /* @conditional-compile-remove(rooms) */
        if (isRoomsCall) {
            return this.callAgent.join(this.locator, {
                audioOptions,
                videoOptions
            });
        }
        return this.callAgent.join(this.locator, {
            audioOptions,
            videoOptions
        });
    }
    createStreamView(remoteUserId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                return yield this.handlers.onCreateLocalStreamView(options);
            }
            else {
                return yield this.handlers.onCreateRemoteStreamView(remoteUserId, options);
            }
        });
    }
    disposeStreamView(remoteUserId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                yield this.handlers.onDisposeLocalStreamView();
            }
            else {
                yield this.handlers.onDisposeRemoteStreamView(remoteUserId);
            }
        });
    }
    disposeScreenShareStreamView(remoteUserId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handlers.onDisposeRemoteScreenShareStreamView(remoteUserId);
        });
    }
    disposeRemoteVideoStreamView(remoteUserId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handlers.onDisposeRemoteVideoStreamView(remoteUserId);
        });
    }
    disposeLocalVideoStreamView() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handlers.onDisposeLocalStreamView();
        });
    }
    leaveCall(forEveryone) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.getState().page === 'transferring') {
                const transferCall = this.callAgent.calls.filter(call => { var _a; return call.id === ((_a = this.getState().acceptedTransferCallState) === null || _a === void 0 ? void 0 : _a.id); })[0];
                transferCall === null || transferCall === void 0 ? void 0 : transferCall.hangUp();
            }
            yield this.handlers.onHangUp(forEveryone);
            this.unsubscribeCallEvents();
            this.handlers = createHandlers(this.callClient, this.callAgent, this.deviceManager, this.call, /* @conditional-compile-remove(video-background-effects) */ {
                onResolveVideoBackgroundEffectsDependency: this.onResolveVideoBackgroundEffectsDependency
            });
            // We set the adapter.call object to undefined immediately when a call is ended.
            // We do not set the context.callId to undefined because it is a part of the immutable data flow loop.
            this.call = undefined;
            this.stopCamera();
            this.mute();
        });
    }
    setCamera(device, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onSelectCamera(device, options);
            }));
        });
    }
    setMicrophone(device) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onSelectMicrophone(device);
            }));
        });
    }
    setSpeaker(device) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onSelectSpeaker(device);
            }));
        });
    }
    startCamera(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                if (!isCameraOn(this.getState())) {
                    // First kick off the effect on the local device before starting the camera in the call.
                    // This prevents the effect not being applied for a brief moment when the camera is started.
                    /* @conditional-compile-remove(video-background-effects) */
                    {
                        const selectedEffect = this.getState().selectedVideoBackgroundEffect;
                        const selectedCamera = getSelectedCameraFromAdapterState(this.getState());
                        if (selectedEffect && selectedCamera && this.onResolveVideoBackgroundEffectsDependency) {
                            const stream = new SDKLocalVideoStream(selectedCamera);
                            const effect = getBackgroundEffectFromSelectedEffect(selectedEffect, yield this.onResolveVideoBackgroundEffectsDependency());
                            if (effect) {
                                yield stream.feature(Features.VideoEffects).startEffects(effect);
                            }
                            else {
                                yield stream.feature(Features.VideoEffects).stopEffects();
                            }
                        }
                    }
                    yield this.handlers.onToggleCamera(options);
                }
            }));
        });
    }
    stopCamera() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                if (isCameraOn(this.getState())) {
                    yield this.handlers.onToggleCamera();
                }
            }));
        });
    }
    mute() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                this.context.setIsLocalMicrophoneEnabled(false);
                if (_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) && !((_b = this.call) === null || _b === void 0 ? void 0 : _b.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    unmute() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                this.context.setIsLocalMicrophoneEnabled(true);
                if ((_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) || _isInLobbyOrConnecting((_b = this.call) === null || _b === void 0 ? void 0 : _b.state)) && ((_c = this.call) === null || _c === void 0 ? void 0 : _c.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    startScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (!((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn)) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    stopScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    raiseHand() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onToggleRaiseHand();
            }));
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    lowerHand() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onToggleRaiseHand();
            }));
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    startVideoBackgroundEffect(videoBackgroundEffect) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isBlurEffect(videoBackgroundEffect)) {
                const blurConfig = videoBackgroundEffect;
                yield this.handlers.onBlurVideoBackground(blurConfig);
            }
            else if (this.isReplacementEffect(videoBackgroundEffect)) {
                const replaceConfig = videoBackgroundEffect;
                yield this.handlers.onReplaceVideoBackground(replaceConfig);
            }
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    stopVideoBackgroundEffects() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handlers.onRemoveVideoBackgroundEffects();
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    updateBackgroundPickerImages(backgroundImages) {
        this.context.setBackroundPickerImages(backgroundImages);
    }
    /* @conditional-compile-remove(video-background-effects) */
    updateSelectedVideoBackgroundEffect(selectedVideoBackground) {
        this.context.setSelectedVideoBackgroundEffect(selectedVideoBackground);
    }
    startCall(participants, options) {
        var _a, _b;
        if (_isInCall((_b = (_a = this.getState().call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None')) {
            throw new Error('You are already in the call.');
        }
        const isCameraOn = this.getState().cameraStatus === 'On';
        const selectedCamera = getSelectedCameraFromAdapterState(this.getState());
        /* we only configure the video options here since the Calling SDK always unmutes the participant when starting a call */
        const startCallVideoOptions = selectedCamera ? {
            videoOptions: isCameraOn ? {
                localVideoStreams: [new SDKLocalVideoStream(selectedCamera)]
            } : undefined
        } : {};
        const combinedCallOptions = Object.assign(Object.assign({}, startCallVideoOptions), options);
        const idsToAdd = participants.map(participant => {
            const backendId = _toCommunicationIdentifier(participant);
            if ('phoneNumber' in backendId) {
                if ((options === null || options === void 0 ? void 0 : options.alternateCallerId) === undefined) {
                    throw new Error('Unable to start call, PSTN user present with no alternateCallerId.');
                }
            }
            return backendId;
        });
        /* @conditional-compile-remove(calling-sounds) */
        this.context.setTargetCallee(idsToAdd);
        const call = this.handlers.onStartCall(idsToAdd, combinedCallOptions);
        if (!call) {
            throw new Error('Unable to start call.');
        }
        this.processNewCall(call);
        return call;
    }
    processNewCall(call) {
        this.call = call;
        this.context.setCurrentCallId(call.id);
        // Resync state after callId is set
        this.context.updateClientState(this.callClient.getState());
        this.handlers = createHandlers(this.callClient, this.callAgent, this.deviceManager, this.call, /* @conditional-compile-remove(video-background-effects) */ {
            onResolveVideoBackgroundEffectsDependency: this.onResolveVideoBackgroundEffectsDependency
        });
        this.subscribeCallEvents();
    }
    /* @conditional-compile-remove(video-background-effects) */
    isBlurEffect(effect) {
        return effect.effectName === 'blur';
    }
    /* @conditional-compile-remove(video-background-effects) */
    isReplacementEffect(effect) {
        return effect.effectName === 'replacement';
    }
    removeParticipant(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            let participant = userId;
            this.handlers.onRemoveParticipant(participant);
        });
    }
    sendDtmfTone(dtmfTone) {
        return __awaiter(this, void 0, void 0, function* () {
            this.handlers.onSendDtmfTone(dtmfTone);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    startCaptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.handlers.onStartCaptions(options);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    stopCaptions() {
        return __awaiter(this, void 0, void 0, function* () {
            this.handlers.onStopCaptions();
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setCaptionLanguage(language) {
        return __awaiter(this, void 0, void 0, function* () {
            this.handlers.onSetCaptionLanguage(language);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setSpokenLanguage(language) {
        return __awaiter(this, void 0, void 0, function* () {
            this.handlers.onSetSpokenLanguage(language);
        });
    }
    getState() {
        return this.context.getState();
    }
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    /* @conditional-compile-remove(close-captions) */
    subscribeToCaptionEvents() {
        var _a;
        if (this.call && this.call.state === 'Connected' && this.context.getState().isTeamsCall) {
            const captionsFeature = (_a = this.call) === null || _a === void 0 ? void 0 : _a.feature(Features.Captions).captions;
            captionsFeature.on('CaptionsReceived', this.captionsReceived.bind(this));
            captionsFeature.on('CaptionsActiveChanged', this.isCaptionsActiveChanged.bind(this));
            captionsFeature.on('CaptionLanguageChanged', this.isCaptionLanguageChanged.bind(this));
            captionsFeature.on('SpokenLanguageChanged', this.isSpokenLanguageChanged.bind(this));
        }
    }
    /* @conditional-compile-remove(close-captions) */
    unsubscribeFromCaptionEvents() {
        var _a, _b;
        if (this.call && this.call.state === 'Connected' && this.context.getState().isTeamsCall) {
            const captionsFeature = (_a = this.call) === null || _a === void 0 ? void 0 : _a.feature(Features.Captions).captions;
            captionsFeature.off('CaptionsReceived', this.captionsReceived.bind(this));
            captionsFeature.off('CaptionsActiveChanged', this.isCaptionsActiveChanged.bind(this));
            captionsFeature.off('CaptionLanguageChanged', this.isCaptionLanguageChanged.bind(this));
            captionsFeature.off('SpokenLanguageChanged', this.isSpokenLanguageChanged.bind(this));
            (_b = this.call) === null || _b === void 0 ? void 0 : _b.off('stateChanged', this.subscribeToCaptionEvents.bind(this));
        }
    }
    subscribeCallEvents() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        /* @conditional-compile-remove(calling-sounds) */
        if (this.call) {
            this.callingSoundSubscriber = new CallingSoundSubscriber(this.call, this.getState().targetCallees, this.getState().sounds);
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.on('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.on('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.on('idChanged', this.callIdChanged.bind(this));
        /* @conditional-compile-remove(close-captions) */
        (_e = this.call) === null || _e === void 0 ? void 0 : _e.on('stateChanged', this.subscribeToCaptionEvents.bind(this));
        /* @conditional-compile-remove(rooms) */
        (_f = this.call) === null || _f === void 0 ? void 0 : _f.on('roleChanged', this.roleChanged.bind(this));
        /* @conditional-compile-remove(call-transfer) */
        (_g = this.call) === null || _g === void 0 ? void 0 : _g.feature(Features.Transfer).on('transferAccepted', this.transferAccepted.bind(this));
        /* @conditional-compile-remove(capabilities) */
        (_h = this.call) === null || _h === void 0 ? void 0 : _h.feature(Features.Capabilities).on('capabilitiesChanged', this.capabilitiesChanged.bind(this));
    }
    unsubscribeCallEvents() {
        var _a, _b, _c, _d, _e;
        for (const subscriber of this.participantSubscribers.values()) {
            subscriber.unsubscribeAll();
        }
        this.participantSubscribers.clear();
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.off('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.off('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.off('idChanged', this.callIdChanged.bind(this));
        /* @conditional-compile-remove(rooms) */
        (_e = this.call) === null || _e === void 0 ? void 0 : _e.off('roleChanged', this.roleChanged.bind(this));
        /* @conditional-compile-remove(close-captions) */
        this.unsubscribeFromCaptionEvents();
        /* @conditional-compile-remove(calling-sounds) */
        if (this.callingSoundSubscriber) {
            this.callingSoundSubscriber.unsubscribeAll();
        }
    }
    onRemoteParticipantsUpdated({ added, removed }) {
        if (added && added.length > 0) {
            this.emitter.emit('participantsJoined', {
                joined: added
            });
        }
        if (removed && removed.length > 0) {
            this.emitter.emit('participantsLeft', {
                removed: removed
            });
        }
        added.forEach(participant => {
            this.participantSubscribers.set(toFlatCommunicationIdentifier(participant.identifier), new ParticipantSubscriber(participant, this.emitter));
        });
        removed.forEach(participant => {
            const subscriber = this.participantSubscribers.get(toFlatCommunicationIdentifier(participant.identifier));
            subscriber && subscriber.unsubscribeAll();
            this.participantSubscribers.delete(toFlatCommunicationIdentifier(participant.identifier));
        });
    }
    isScreenSharingOnChanged() {
        var _a;
        this.emitter.emit('isLocalScreenSharingActiveChanged', {
            isScreenSharingOn: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn
        });
    }
    /* @conditional-compile-remove(close-captions) */
    captionsReceived(captionsInfo) {
        this.emitter.emit('captionsReceived', {
            captionsInfo
        });
    }
    /* @conditional-compile-remove(close-captions) */
    isCaptionsActiveChanged() {
        var _a;
        const captionsFeature = (_a = this.call) === null || _a === void 0 ? void 0 : _a.feature(Features.Captions).captions;
        this.emitter.emit('isCaptionsActiveChanged', {
            isActive: captionsFeature.isCaptionsFeatureActive
        });
    }
    /* @conditional-compile-remove(close-captions) */
    isSpokenLanguageChanged() {
        var _a;
        const captionsFeature = (_a = this.call) === null || _a === void 0 ? void 0 : _a.feature(Features.Captions).captions;
        this.emitter.emit('isSpokenLanguageChanged', {
            activeSpokenLanguage: captionsFeature.activeSpokenLanguage
        });
    }
    /* @conditional-compile-remove(close-captions) */
    isCaptionLanguageChanged() {
        var _a;
        const captionsFeature = (_a = this.call) === null || _a === void 0 ? void 0 : _a.feature(Features.Captions).captions;
        this.emitter.emit('isCaptionLanguageChanged', {
            activeCaptionLanguage: captionsFeature.activeCaptionLanguage
        });
    }
    /* @conditional-compile-remove(call-transfer) */
    transferAccepted(args) {
        this.emitter.emit('transferAccepted', args);
    }
    /* @conditional-compile-remove(capabilities) */
    capabilitiesChanged(data) {
        var _a, _b, _c, _d, _e;
        if (((_a = data.newValue.turnVideoOn) === null || _a === void 0 ? void 0 : _a.isPresent) === false) {
            // Only stop camera when the call state is not on hold. The Calling SDK does not allow us to stop camera when
            // the call state is on hold.
            if (((_b = this.call) === null || _b === void 0 ? void 0 : _b.state) !== 'LocalHold' && ((_c = this.call) === null || _c === void 0 ? void 0 : _c.state) !== 'RemoteHold') {
                this.stopCamera();
            }
            this.disposeLocalVideoStreamView();
        }
        if (((_d = data.newValue.unmuteMic) === null || _d === void 0 ? void 0 : _d.isPresent) === false) {
            this.mute();
        }
        if (((_e = data.newValue.shareScreen) === null || _e === void 0 ? void 0 : _e.isPresent) === false) {
            this.stopScreenShare();
        }
        this.emitter.emit('capabilitiesChanged', data);
    }
    /* @conditional-compile-remove(rooms) */
    roleChanged() {
        var _a, _b;
        if (((_a = this.call) === null || _a === void 0 ? void 0 : _a.role) === 'Consumer') {
            (_b = this.call) === null || _b === void 0 ? void 0 : _b.feature(Features.RaiseHand).lowerHand();
        }
        this.emitter.emit('roleChanged');
    }
    callIdChanged() {
        var _a;
        ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id) && this.emitter.emit('callIdChanged', {
            callId: this.call.id
        });
    }
    resetDiagnosticsForwarder(newCall) {
        if (this.diagnosticsForwarder) {
            this.diagnosticsForwarder.unsubscribe();
        }
        if (newCall) {
            this.diagnosticsForwarder = new DiagnosticsForwarder(this.emitter, newCall);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    asyncTeeErrorToEventEmitter(f) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield f();
            }
            catch (error) {
                if (isCallError(error)) {
                    this.emitter.emit('error', error);
                }
                throw error;
            }
        });
    }
    teeErrorToEventEmitter(f) {
        try {
            return f();
        }
        catch (error) {
            if (isCallError(error)) {
                this.emitter.emit('error', error);
            }
            throw error;
        }
    }
}
/**
 * @public
 */
/**
 * Create a {@link CallAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link CallAdapter} provided by this library.
 *
 * Note: `displayName` can be a maximum of 256 characters.
 *
 * @public
 */
export function createAzureCommunicationCallAdapter(args) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isMicrosoftTeamsUserIdentifier(args.userId)) {
            throw new Error('Microsoft Teams user identifier is not supported by AzureCommunicationCallAdapter. Instead use TeamsCallAdapter.');
        }
        return _createAzureCommunicationCallAdapterInner({
            userId: args.userId,
            displayName: args.displayName,
            credential: args.credential,
            locator: args.locator,
            targetCallees: args.targetCallees,
            /* @conditional-compile-remove(video-background-effects) */
            options: args.options
        });
    });
}
/**
 * This inner function is used to allow injection of TelemetryImplementationHint without changing the public API.
 *
 * @internal
 */
export const _createAzureCommunicationCallAdapterInner = ({ userId, displayName, credential, locator, targetCallees, 
/* @conditional-compile-remove(video-background-effects) */ options, telemetryImplementationHint = 'Call' }) => __awaiter(void 0, void 0, void 0, function* () {
    if (!_isValidIdentifier(userId)) {
        throw new Error('Invalid identifier. Please provide valid identifier object.');
    }
    const callClient = _createStatefulCallClientInner({
        userId
    }, undefined, telemetryImplementationHint);
    const callAgent = yield callClient.createCallAgent(credential, {
        displayName
    });
    let adapter;
    if (locator) {
        adapter = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, locator, /* @conditional-compile-remove(video-background-effects) */ options);
    }
    else {
        adapter = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, targetCallees, /* @conditional-compile-remove(video-background-effects) */ options);
    }
    return adapter;
});
/**
 * @private
 */
function useAzureCommunicationCallAdapterGeneric(args, adapterKind = 'AzureCommunication', afterCreate, beforeDispose) {
    const { credential, userId } = args;
    const locator = 'locator' in args ? args.locator : undefined;
    const targetCallees = 'targetCallees' in args ? args.targetCallees : undefined;
    const displayName = 'displayName' in args ? args.displayName : undefined;
    /* @conditional-compile-remove(video-background-effects) */
    const options = 'options' in args ? args.options : undefined;
    // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = useState(undefined);
    // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = useRef(undefined);
    const creatingAdapterRef = useRef(false);
    const afterCreateRef = useRef(undefined);
    const beforeDisposeRef = useRef(undefined);
    // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    useEffect(() => {
        if (!credential || !locator && !targetCallees || !userId) {
            return;
        }
        if (adapterKind === 'AzureCommunication' && !displayName) {
            return;
        }
        (() => __awaiter(this, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            let newAdapter = undefined;
            if (adapterKind === 'AzureCommunication') {
                // This is just the type check to ensure that displayName is defined.
                if (!displayName) {
                    throw new Error('Unreachable code, displayName already checked above.');
                }
                if (creatingAdapterRef.current) {
                    console.warn('Adapter is already being created, please see storybook for more information: https://azure.github.io/communication-ui-library/?path=/story/troubleshooting--page');
                    return;
                }
                creatingAdapterRef.current = true;
                if (locator) {
                    newAdapter = (yield createAzureCommunicationCallAdapter({
                        credential,
                        displayName: displayName,
                        locator,
                        userId: userId,
                        /* @conditional-compile-remove(video-background-effects) */ options
                    }));
                }
                else if (targetCallees) {
                    newAdapter = (yield createAzureCommunicationCallAdapter({
                        credential,
                        displayName: displayName,
                        targetCallees,
                        userId: userId,
                        /* @conditional-compile-remove(video-background-effects) */ options
                    }));
                }
            }
            else if (adapterKind === 'Teams') {
                if (creatingAdapterRef.current) {
                    console.warn('Adapter is already being created, skipping creation.');
                    return;
                }
                creatingAdapterRef.current = true;
            }
            else {
                throw new Error('Unreachable code, unknown adapterKind');
            }
            if (!newAdapter) {
                throw Error('Unreachable code! Get undefined adapter');
            }
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            creatingAdapterRef.current = false;
            setAdapter(newAdapter);
        }))();
    }, 
    // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, adapterKind, credential, locator, userId, displayName, options, targetCallees]);
    // Dispose any existing adapter when the component unmounts.
    useEffect(() => {
        return () => {
            (() => __awaiter(this, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
}
/**
 * A custom React hook to simplify the creation of {@link CallAdapter}.
 *
 * Similar to {@link createAzureCommunicationCallAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
export const useAzureCommunicationCallAdapter = (args, afterCreate, beforeDispose) => {
    return useAzureCommunicationCallAdapterGeneric(args, 'AzureCommunication', afterCreate, beforeDispose);
};
/**
 * Create a {@link CallAdapter} using the provided {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallAdapter} for a simpler API.
 *
 * @public
 */
export function createAzureCommunicationCallAdapterFromClient(callClient, callAgent, locatorOrtargetCallees, /* @conditional-compile-remove(video-background-effects) */ options) {
    return __awaiter(this, void 0, void 0, function* () {
        const deviceManager = yield callClient.getDeviceManager();
        yield Promise.all([deviceManager.getCameras(), deviceManager.getMicrophones()]);
        if (deviceManager.isSpeakerSelectionAvailable) {
            yield deviceManager.getSpeakers();
        }
        if (getLocatorOrTargetCallees(locatorOrtargetCallees)) {
            return new AzureCommunicationCallAdapter(callClient, locatorOrtargetCallees, callAgent, deviceManager, /* @conditional-compile-remove(video-background-effects) */ options);
        }
        else {
            return new AzureCommunicationCallAdapter(callClient, locatorOrtargetCallees, callAgent, deviceManager, /* @conditional-compile-remove(video-background-effects) */ options);
        }
    });
}
const isCallError = (e) => {
    return 'target' in e && 'innerError' in e;
};
//# sourceMappingURL=AzureCommunicationCallAdapter.js.map