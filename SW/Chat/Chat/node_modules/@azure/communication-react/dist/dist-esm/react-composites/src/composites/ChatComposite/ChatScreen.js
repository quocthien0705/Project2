// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* @conditional-compile-remove(image-overlay) */
import { isIOS } from '@fluentui/react';
import { mergeStyles, Stack } from '@fluentui/react';
/* @conditional-compile-remove(image-overlay) */
import { PersonaSize } from '@fluentui/react';
import { ErrorBar, MessageThread, TypingIndicator, useTheme } from "../../../../react-components/src";
import React, { useCallback, useEffect, useMemo } from 'react';
/* @conditional-compile-remove(image-overlay) */
import { useState } from 'react';
import { AvatarPersona } from '../common/AvatarPersona';
import { useAdapter } from './adapter/ChatAdapterProvider';
import { ChatHeader, getHeaderProps } from './ChatHeader';
import { FileUploadButtonWrapper as FileUploadButton } from './file-sharing';
import { useAdaptedSelector } from './hooks/useAdaptedSelector';
import { usePropsFor } from './hooks/usePropsFor';
import { chatArea, chatContainer, chatWrapper, messageThreadChatCompositeStyles, sendboxContainerStyles, typingIndicatorContainerStyles } from './styles/Chat.styles';
import { participantListContainerPadding } from '../common/styles/ParticipantContainer.styles';
import { toFlatCommunicationIdentifier } from "../../../../acs-ui-common/src";
/* @conditional-compile-remove(image-overlay) */
import { ImageOverlay } from "../../../../react-components/src";
import { SendBox } from '../common/SendBox';
/**
 * @private
 */
export const ChatScreen = (props) => {
    const { onFetchAvatarPersonaData, onRenderMessage, onRenderTypingIndicator, options, styles, fileSharing, formFactor } = props;
    const defaultNumberOfChatMessagesToReload = 5;
    /* @conditional-compile-remove(image-overlay) */
    const [overlayImageItem, setOverlayImageItem] = useState();
    /* @conditional-compile-remove(image-overlay) */
    const [isImageOverlayOpen, setIsImageOverlayOpen] = useState(false);
    const adapter = useAdapter();
    const theme = useTheme();
    useEffect(() => {
        // Initial data should be always fetched by the composite(or external caller) instead of the adapter
        const fetchData = () => __awaiter(void 0, void 0, void 0, function* () {
            // Fetch initial data for adapter
            yield adapter.fetchInitialData();
            // Fetch initial set of messages. Without fetching messages here, if the Composite's adapter is changed the message thread does not load new messages.
            yield adapter.loadPreviousChatMessages(defaultNumberOfChatMessagesToReload);
        });
        fetchData();
    }, [adapter]);
    const messageThreadProps = usePropsFor(MessageThread);
    const typingIndicatorProps = usePropsFor(TypingIndicator);
    const headerProps = useAdaptedSelector(getHeaderProps);
    const errorBarProps = usePropsFor(ErrorBar);
    /* @conditional-compile-remove(image-overlay) */
    useEffect(() => {
        if (overlayImageItem === undefined) {
            return;
        }
        const message = adapter.getState().thread.chatMessages[overlayImageItem.messageId];
        if (message === undefined) {
            return;
        }
        const resourceCache = message.resourceCache;
        if (overlayImageItem.imageSrc === '' && resourceCache && resourceCache[overlayImageItem.imageUrl]) {
            const fullSizeImageSrc = getResourceSourceUrl(resourceCache[overlayImageItem.imageUrl]);
            if (fullSizeImageSrc === undefined || fullSizeImageSrc === '' || overlayImageItem.imageSrc === fullSizeImageSrc) {
                return;
            }
            setOverlayImageItem(Object.assign(Object.assign({}, overlayImageItem), { imageSrc: fullSizeImageSrc }));
        }
        // Disable eslint because we are using the overlayImageItem in this effect but don't want to have it as a dependency, as it will cause an infinite loop.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [messageThreadProps.messages]);
    const getResourceSourceUrl = (result) => {
        let src = '';
        if (result.error || !result.sourceUrl) {
            src = 'blob://';
        }
        else {
            src = result.sourceUrl;
        }
        return src;
    };
    const onRenderAvatarCallback = useCallback((userId, defaultOptions) => {
        return React.createElement(AvatarPersona, Object.assign({ userId: userId, hidePersonaDetails: true }, defaultOptions, { dataProvider: onFetchAvatarPersonaData }));
    }, [onFetchAvatarPersonaData]);
    const messageThreadStyles = useMemo(() => {
        return Object.assign({}, messageThreadChatCompositeStyles(theme.semanticColors.bodyBackground), styles === null || styles === void 0 ? void 0 : styles.messageThread);
    }, [styles === null || styles === void 0 ? void 0 : styles.messageThread, theme.semanticColors.bodyBackground]);
    const typingIndicatorStyles = useMemo(() => {
        return Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.typingIndicator);
    }, [styles === null || styles === void 0 ? void 0 : styles.typingIndicator]);
    const userId = toFlatCommunicationIdentifier(adapter.getState().userId);
    const fileUploadButtonOnChange = useCallback((files) => {
        if (!files) {
            return;
        }
    }, [adapter, fileSharing, userId]);
    /* @conditional-compile-remove(image-overlay) */
    const onInlineImageClicked = useCallback((attachmentId, messageId) => {
        var _a, _b;
        const message = adapter.getState().thread.chatMessages[messageId];
        const inlinedImages = (_b = (_a = message.content) === null || _a === void 0 ? void 0 : _a.attachments) === null || _b === void 0 ? void 0 : _b.filter(attachment => {
            return attachment.attachmentType === 'image' && attachment.id === attachmentId;
        });
        if (!inlinedImages || inlinedImages.length <= 0) {
            return;
        }
        const attachment = inlinedImages[0];
        const resourceCache = message.resourceCache;
        let imageSrc = '';
        if (attachment.url) {
            if (resourceCache && resourceCache[attachment.url]) {
                imageSrc = getResourceSourceUrl(resourceCache[attachment.url]);
            }
            else {
                adapter.downloadResourceToCache({
                    threadId: adapter.getState().thread.threadId,
                    messageId: messageId,
                    resourceUrl: attachment.url
                });
            }
        }
        const titleIconRenderOptions = {
            text: message.senderDisplayName,
            size: PersonaSize.size32,
            showOverflowTooltip: false,
            imageAlt: message.senderDisplayName
        };
        const messageSenderId = message.sender !== undefined ? toFlatCommunicationIdentifier(message.sender) : userId;
        const titleIcon = onRenderAvatarCallback && onRenderAvatarCallback(messageSenderId, titleIconRenderOptions);
        const overlayImage = {
            title: message.senderDisplayName || '',
            titleIcon: titleIcon,
            attachmentId: attachment.id,
            imageSrc: imageSrc,
            messageId: messageId,
            imageUrl: attachment.url || ''
        };
        setIsImageOverlayOpen(true);
        setOverlayImageItem(overlayImage);
    }, [adapter, onRenderAvatarCallback, userId]);
    /* @conditional-compile-remove(image-overlay) */
    const inlineImageOptions = {
        onRenderInlineImage: (inlineImage, defaultOnRender) => {
            var _a, _b;
            const message = adapter.getState().thread.chatMessages[inlineImage.messageId];
            const attachment = (_b = (_a = message === null || message === void 0 ? void 0 : message.content) === null || _a === void 0 ? void 0 : _a.attachments) === null || _b === void 0 ? void 0 : _b.find(attachment => attachment.id === inlineImage.imageAttributes.id);
            if (attachment === undefined) {
                return defaultOnRender(inlineImage);
            }
            let pointerEvents = inlineImage.imageAttributes.src === '' ? 'none' : 'auto';
            const resourceCache = message.resourceCache;
            if (resourceCache && attachment.previewUrl && resourceCache[attachment.previewUrl] && resourceCache[attachment.previewUrl].error) {
                pointerEvents = 'none';
            }
            return React.createElement("span", { key: inlineImage.imageAttributes.id, onClick: () => onInlineImageClicked(inlineImage.imageAttributes.id || '', inlineImage.messageId), tabIndex: 0, role: "button", onKeyDown: e => {
                    if (e.key === 'Enter') {
                        onInlineImageClicked(inlineImage.imageAttributes.id || '', inlineImage.messageId);
                    }
                }, style: {
                    cursor: 'pointer',
                    pointerEvents
                } }, defaultOnRender(inlineImage));
        }
    };
    /* @conditional-compile-remove(image-overlay) */
    const onDownloadButtonClicked = useCallback((imageSrc) => {
        if (imageSrc === '') {
            return;
        }
        if (isIOS()) {
            window.open(imageSrc, '_blank');
        }
        else {
            // Create a new anchor element
            const a = document.createElement('a');
            // Set the href and download attributes for the anchor element
            a.href = imageSrc;
            a.download = (overlayImageItem === null || overlayImageItem === void 0 ? void 0 : overlayImageItem.attachmentId) || '';
            a.rel = 'noopener noreferrer';
            a.target = '_blank';
            // Programmatically click the anchor element to trigger the download
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    }, [overlayImageItem === null || overlayImageItem === void 0 ? void 0 : overlayImageItem.attachmentId]);
    const AttachFileButton = useCallback(() => {
        if (!(fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.uploadHandler)) {
            return null;
        }
        return React.createElement(FileUploadButton, { accept: fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.accept, multiple: fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.multiple, onChange: fileUploadButtonOnChange });
    }, [fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.accept, fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.multiple, fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.uploadHandler, fileUploadButtonOnChange]);
    return React.createElement(Stack, { className: chatContainer, grow: true },
        (options === null || options === void 0 ? void 0 : options.topic) !== false && React.createElement(ChatHeader, Object.assign({}, headerProps)),
        React.createElement(Stack, { className: chatArea, tokens: participantListContainerPadding, horizontal: true, grow: true },
            React.createElement(Stack, { className: chatWrapper, grow: true },
                (options === null || options === void 0 ? void 0 : options.errorBar) !== false && React.createElement(ErrorBar, Object.assign({}, errorBarProps)),
                React.createElement(MessageThread, Object.assign({}, messageThreadProps, { onRenderAvatar: onRenderAvatarCallback, onRenderMessage: onRenderMessage, inlineImageOptions: inlineImageOptions, numberOfChatMessagesToReload: defaultNumberOfChatMessagesToReload, styles: messageThreadStyles })),
                React.createElement(Stack, { className: mergeStyles(sendboxContainerStyles) },
                    React.createElement("div", { className: mergeStyles(typingIndicatorContainerStyles) }, onRenderTypingIndicator ? onRenderTypingIndicator(typingIndicatorProps.typingUsers) : React.createElement(TypingIndicator, Object.assign({}, typingIndicatorProps, { styles: typingIndicatorStyles }))),
                    React.createElement(Stack, { horizontal: formFactor === 'mobile' },
                        formFactor === 'mobile' && React.createElement(Stack, { verticalAlign: "center" },
                            React.createElement(AttachFileButton, null)),
                        React.createElement(Stack, { grow: true },
                            React.createElement(SendBox, { options: options, styles: styles === null || styles === void 0 ? void 0 : styles.sendBox })),
                        formFactor !== 'mobile' && React.createElement(AttachFileButton, null))))), /* @conditional-compile-remove(image-overlay) */
        overlayImageItem && React.createElement(ImageOverlay, Object.assign({}, overlayImageItem, { isOpen: isImageOverlayOpen, onDismiss: () => {
                setOverlayImageItem(undefined);
                setIsImageOverlayOpen(false);
                adapter.removeResourceFromCache({
                    threadId: adapter.getState().thread.threadId,
                    messageId: overlayImageItem.messageId,
                    resourceUrl: overlayImageItem.imageUrl
                });
            }, onDownloadButtonClicked: onDownloadButtonClicked })));
};
//# sourceMappingURL=ChatScreen.js.map