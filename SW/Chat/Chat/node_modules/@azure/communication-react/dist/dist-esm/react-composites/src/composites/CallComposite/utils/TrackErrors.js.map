{"version":3,"file":"TrackErrors.js","sourceRoot":"","sources":["../../../../../../../preprocess-dist/react-composites/src/composites/CallComposite/utils/TrackErrors.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAKlC;;;;GAIG;AACH,MAAM,CAAC,MAAM,kBAAkB,GAAG,CAAC,YAAkC,EAAE,aAA4B,EAAwB,EAAE;IAC3H,MAAM,cAAc,GAAG,YAAY,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE;QACvD,MAAM,YAAY,GAAG,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACrD,OAAO,CAAC,YAAY,IAAI,CAAC,YAAY,CAAC,eAAe,IAAI,YAAY,CAAC,eAAe,GAAG,YAAY,CAAC,kBAAkB,CAAC;IAC1H,CAAC,CAAC,CAAC;IACH,OAAO,cAAc,CAAC;AACxB,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,CAAC,MAAM,mCAAmC,GAAG,CAAC,qBAAoC,EAAE,YAAkC,EAAiB,EAAE;;IAC7I,MAAM,aAAa,GAAkB,EAAE,CAAC;IAExC,0HAA0H;IAC1H,KAAK,MAAM,WAAW,IAAI,YAAY,EAAE,CAAC;QACvC,MAAM,oBAAoB,GAAG,qBAAqB,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACrE,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG;YAChC,kBAAkB,EAAE,MAAA,MAAA,WAAW,CAAC,SAAS,mCAAI,oBAAoB,aAApB,oBAAoB,uBAApB,oBAAoB,CAAE,kBAAkB,mCAAI,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;YAC7G,eAAe,EAAE,oBAAoB,aAApB,oBAAoB,uBAApB,oBAAoB,CAAE,eAAe;SACvD,CAAC;IACJ,CAAC;IACD,OAAO,aAAa,CAAC;AACvB,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,CAAC,MAAM,qBAAqB,GAAG,CAAC,SAAoB,EAAE,aAA4B,EAAiB,EAAE;IACzG,MAAM,GAAG,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;IACjC,MAAM,aAAa,GAAG,aAAa,CAAC,SAAS,CAAC,CAAC;IAC/C,uCACK,aAAa,KAChB,CAAC,SAAS,CAAC,kCACN,CAAC,aAAa,IAAI,EAAE,CAAC,KACxB,eAAe,EAAE,GAAG,OAEtB;AACJ,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { ActiveErrorMessage, ErrorType } from '@internal/react-components';\nimport { TrackedErrors } from '../types/ErrorTracking';\n\n/**\n * Take the set of active errors, and filter to only those that are newer than previously dismissed errors or have never been dismissed.\n *\n * @private\n */\nexport const filterLatestErrors = (activeErrors: ActiveErrorMessage[], trackedErrors: TrackedErrors): ActiveErrorMessage[] => {\n  const filteredErrors = activeErrors.filter(activeError => {\n    const trackedError = trackedErrors[activeError.type];\n    return !trackedError || !trackedError.lastDismissedAt || trackedError.lastDismissedAt < trackedError.mostRecentlyActive;\n  });\n  return filteredErrors;\n};\n\n/**\n * Maintain a record of the most recently active error for each error type.\n *\n * @private\n */\nexport const updateTrackedErrorsWithActiveErrors = (existingTrackedErrors: TrackedErrors, activeErrors: ActiveErrorMessage[]): TrackedErrors => {\n  const trackedErrors: TrackedErrors = {};\n\n  // Only care about active errors. If errors are no longer active we do not track that they have been previously dismissed.\n  for (const activeError of activeErrors) {\n    const existingTrackedError = existingTrackedErrors[activeError.type];\n    trackedErrors[activeError.type] = {\n      mostRecentlyActive: activeError.timestamp ?? existingTrackedError?.mostRecentlyActive ?? new Date(Date.now()),\n      lastDismissedAt: existingTrackedError?.lastDismissedAt\n    };\n  }\n  return trackedErrors;\n};\n\n/**\n * Create a record for when the error was most recently dismissed for tracking dismissed errors.\n *\n * @private\n */\nexport const trackErrorAsDismissed = (errorType: ErrorType, trackedErrors: TrackedErrors): TrackedErrors => {\n  const now = new Date(Date.now());\n  const existingError = trackedErrors[errorType];\n  return {\n    ...trackedErrors,\n    [errorType]: {\n      ...(existingError || {}),\n      lastDismissedAt: now\n    }\n  };\n};"]}