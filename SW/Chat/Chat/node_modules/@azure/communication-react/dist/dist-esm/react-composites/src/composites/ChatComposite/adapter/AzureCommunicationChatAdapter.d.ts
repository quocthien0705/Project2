import { ChatClientState, StatefulChatClient } from "../../../../../chat-stateful-client/src";
import { ChatThreadClient, SendMessageOptions } from '@azure/communication-chat';
import { CommunicationTokenCredential, CommunicationUserIdentifier } from '@azure/communication-common';
import { _TelemetryImplementationHint } from "../../../../../acs-ui-common/src";
import { ChatAdapter, ChatAdapterState, MessageDeletedListener, MessageEditedListener, MessageReadListener, MessageReceivedListener, ParticipantsAddedListener, ParticipantsRemovedListener, TopicChangedListener } from './ChatAdapter';
import { ResourceDetails } from './ChatAdapter';
import { AdapterError } from '../../common/adapters';
/**
 * Context of Chat, which is a centralized context for all state updates
 * @private
 */
export declare class ChatContext {
    private emitter;
    private state;
    private threadId;
    constructor(clientState: ChatClientState, threadId: string);
    onStateChange(handler: (_uiState: ChatAdapterState) => void): void;
    offStateChange(handler: (_uiState: ChatAdapterState) => void): void;
    setState(state: ChatAdapterState): void;
    getState(): ChatAdapterState;
    setError(error: Error): void;
    updateClientState(clientState: ChatClientState): void;
}
/**
 * @private
 */
export declare class AzureCommunicationChatAdapter implements ChatAdapter {
    private chatClient;
    private chatThreadClient;
    private context;
    private handlers;
    private emitter;
    constructor(chatClient: StatefulChatClient, chatThreadClient: ChatThreadClient);
    private bindAllPublicMethods;
    dispose(): void;
    fetchInitialData(): Promise<void>;
    getState(): ChatAdapterState;
    onStateChange(handler: (state: ChatAdapterState) => void): void;
    offStateChange(handler: (state: ChatAdapterState) => void): void;
    sendMessage(content: string, options?: SendMessageOptions): Promise<void>;
    sendReadReceipt(chatMessageId: string): Promise<void>;
    sendTypingIndicator(): Promise<void>;
    removeParticipant(userId: string): Promise<void>;
    setTopic(topicName: string): Promise<void>;
    loadPreviousChatMessages(messagesToLoad: number): Promise<boolean>;
    updateMessage(messageId: string, content: string, metadata?: Record<string, string>, options?: {}): Promise<void>;
    deleteMessage(messageId: string): Promise<void>;
    downloadResourceToCache(resourceDetails: ResourceDetails): Promise<void>;
    removeResourceFromCache(resourceDetails: ResourceDetails): void;
    private messageReceivedListener;
    private messageEditedListener;
    private messageDeletedListener;
    private messageReadListener;
    private participantsAddedListener;
    private participantsRemovedListener;
    private chatThreadPropertiesUpdatedListener;
    private subscribeAllEvents;
    private unsubscribeAllEvents;
    on(event: 'messageReceived', listener: MessageReceivedListener): void;
    on(event: 'messageEdited', listener: MessageEditedListener): void;
    on(event: 'messageDeleted', listener: MessageDeletedListener): void;
    on(event: 'messageSent', listener: MessageReceivedListener): void;
    on(event: 'messageRead', listener: MessageReadListener): void;
    on(event: 'participantsAdded', listener: ParticipantsAddedListener): void;
    on(event: 'participantsRemoved', listener: ParticipantsRemovedListener): void;
    on(event: 'topicChanged', listener: TopicChangedListener): void;
    on(event: 'error', listener: (e: AdapterError) => void): void;
    off(event: 'messageReceived', listener: MessageReceivedListener): void;
    off(event: 'messageEdited', listener: MessageEditedListener): void;
    off(event: 'messageDeleted', listener: MessageDeletedListener): void;
    off(event: 'messageSent', listener: MessageReceivedListener): void;
    off(event: 'messageRead', listener: MessageReadListener): void;
    off(event: 'participantsAdded', listener: ParticipantsAddedListener): void;
    off(event: 'participantsRemoved', listener: ParticipantsRemovedListener): void;
    off(event: 'topicChanged', listener: TopicChangedListener): void;
    off(event: 'error', listener: (e: AdapterError) => void): void;
    private asyncTeeErrorToEventEmitter;
}
/**
 * Arguments for creating the Azure Communication Services implementation of {@link ChatAdapter}.
 *
 * @public
 */
export type AzureCommunicationChatAdapterArgs = {
    endpoint: string;
    userId: CommunicationUserIdentifier;
    displayName: string;
    credential: CommunicationTokenCredential;
    threadId: string;
};
/**
 * Create a {@link ChatAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link ChatAdapter} provided by this library.
 *
 * @public
 */
export declare const createAzureCommunicationChatAdapter: ({ endpoint: endpointUrl, userId, displayName, credential, threadId }: AzureCommunicationChatAdapterArgs) => Promise<ChatAdapter>;
/**
 * This inner function is used to allow injection of TelemetryImplementationHint without changing the public API.
 *
 * @internal
 */
export declare const _createAzureCommunicationChatAdapterInner: (endpoint: string, userId: CommunicationUserIdentifier, displayName: string, credential: CommunicationTokenCredential, threadId: string, telemetryImplementationHint?: _TelemetryImplementationHint) => Promise<ChatAdapter>;
/**
 * A custom React hook to simplify the creation of {@link ChatAdapter}.
 *
 * Similar to {@link createAzureCommunicationChatAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
export declare const useAzureCommunicationChatAdapter: (args: Partial<AzureCommunicationChatAdapterArgs>, afterCreate?: ((adapter: ChatAdapter) => Promise<ChatAdapter>) | undefined, beforeDispose?: ((adapter: ChatAdapter) => Promise<void>) | undefined) => ChatAdapter | undefined;
/**
 * Create a {@link ChatAdapter} using the provided {@link StatefulChatClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient}.
 * Consider using {@link createAzureCommunicationChatAdapter} for a simpler API.
 *
 * @public
 */
export declare function createAzureCommunicationChatAdapterFromClient(chatClient: StatefulChatClient, chatThreadClient: ChatThreadClient): Promise<ChatAdapter>;
//# sourceMappingURL=AzureCommunicationChatAdapter.d.ts.map