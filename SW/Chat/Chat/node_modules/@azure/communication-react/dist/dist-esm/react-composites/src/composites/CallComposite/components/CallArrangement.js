// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { mergeStyles, Stack } from '@fluentui/react';
import { _isInLobbyOrConnecting } from "../../../../../calling-component-bindings/src";
import { _ComplianceBanner, _DrawerMenu, _useContainerHeight, _useContainerWidth, ErrorBar, useTheme } from "../../../../../react-components/src";
import React, { useMemo, useRef, useState } from 'react';
import { useEffect } from 'react';
import { useCallback } from 'react';
/* @conditional-compile-remove(close-captions) */
import { CaptionsBanner } from '../../common/CaptionsBanner';
import { containerDivStyles } from '../../common/ContainerRectProps';
import { compositeMinWidthRem } from '../../common/styles/Composite.styles';
import { useAdapter } from '../adapter/CallAdapterProvider';
import { CallControls } from '../components/CallControls';
import { CommonCallControlBar } from '../../common/ControlBar/CommonCallControlBar';
import { callArrangementContainerStyles, notificationsContainerStyles, containerStyleDesktop, containerStyleMobile, mediaGalleryContainerStyles, galleryParentContainerStyles, bannerNotificationStyles, CONTROL_BAR_Z_INDEX, DRAWER_Z_INDEX } from '../styles/CallPage.styles';
import { MutedNotification } from './MutedNotification';
import { useSelector } from '../hooks/useSelector';
import { callStatusSelector } from '../selectors/callStatusSelector';
import { PreparedMoreDrawer } from '../../common/Drawer/PreparedMoreDrawer';
/* @conditional-compile-remove(close-captions) */
import { getCallStatus, getIsTeamsCall, getCaptionsStatus } from '../selectors/baseSelectors';
import { drawerContainerStyles } from '../styles/CallComposite.styles';
import { SidePane } from './SidePane/SidePane';
import { usePeoplePane } from './SidePane/usePeoplePane';
/* @conditional-compile-remove(video-background-effects) */
import { useVideoEffectsPane, VIDEO_EFFECTS_SIDE_PANE_ID, VIDEO_EFFECTS_SIDE_PANE_WIDTH_REM } from './SidePane/useVideoEffectsPane';
import { isDisabled } from '../utils';
import { useIsSidePaneOpen } from './SidePane/SidePaneProvider';
/* @conditional-compile-remove(video-background-effects) */
import { useIsParticularSidePaneOpen } from './SidePane/SidePaneProvider';
import { ModalLocalAndRemotePIP } from '../../common/ModalLocalAndRemotePIP';
import { getPipStyles } from '../../common/styles/ModalLocalAndRemotePIP.styles';
import { useMinMaxDragPosition } from '../../common/utils';
/* @conditional-compile-remove(video-background-effects) */
import { localVideoSelector } from '../../CallComposite/selectors/localVideoStreamSelector';
/* @conditional-compile-remove(capabilities) */
import { CapabilitiesChangedNotificationBar } from './CapabilitiesChangedNotificationBar';
import { useLocale } from '../../localization';
/**
 * @private
 */
export const CallArrangement = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const containerClassName = useMemo(() => {
        return props.mobileView ? containerStyleMobile : containerStyleDesktop;
    }, [props.mobileView]);
    const theme = useTheme();
    const callGalleryStyles = useMemo(() => galleryParentContainerStyles(theme.palette.neutralLighterAlt), [theme.palette.neutralLighterAlt]);
    const peopleButtonRef = useRef(null);
    const cameraButtonRef = useRef(null);
    const containerRef = useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const containerHeight = _useContainerHeight(containerRef);
    const isInLobby = _isInLobbyOrConnecting(useSelector(callStatusSelector).callStatus);
    const { updateSidePaneRenderer } = props;
    const adapter = useAdapter();
    const [drawerMenuItems, setDrawerMenuItems] = useState([]);
    const peoplePaneProps = useMemo(() => {
        var _a;
        return ({
            updateSidePaneRenderer,
            setDrawerMenuItems,
            inviteLink: props.callControlProps.callInvitationURL,
            onFetchParticipantMenuItems: (_a = props.callControlProps) === null || _a === void 0 ? void 0 : _a.onFetchParticipantMenuItems,
            mobileView: props.mobileView,
            peopleButtonRef
        });
    }, [updateSidePaneRenderer, props.callControlProps.callInvitationURL, (_a = props.callControlProps) === null || _a === void 0 ? void 0 : _a.onFetchParticipantMenuItems, props.mobileView, peopleButtonRef]);
    const locale = useLocale();
    const spotlightPeoplePaneProps = useMemo(() => {
        return {};
    }, []);
    const { isPeoplePaneOpen, openPeoplePane, closePeoplePane } = usePeoplePane(Object.assign(Object.assign({}, peoplePaneProps), spotlightPeoplePaneProps));
    const togglePeoplePane = useCallback(() => {
        if (isPeoplePaneOpen) {
            closePeoplePane();
        }
        else {
            openPeoplePane();
        }
    }, [closePeoplePane, isPeoplePaneOpen, openPeoplePane]);
    const isSidePaneOpen = useIsSidePaneOpen();
    const [renderGallery, setRenderGallery] = useState(!isSidePaneOpen && props.mobileView);
    useEffect(() => {
        if (isSidePaneOpen && props.mobileView) {
            setRenderGallery(false);
        }
        else {
            setRenderGallery(true);
        }
    }, [props.mobileView, isSidePaneOpen]);
    const modalStrings = {
        dismissModalAriaLabel: locale.strings.call.dismissModalAriaLabel
    };
    const isMobileWithActivePane = props.mobileView && isSidePaneOpen;
    const callCompositeContainerCSS = useMemo(() => {
        return {
            display: isMobileWithActivePane ? 'none' : 'flex',
            minWidth: props.mobileView ? 'unset' : `${compositeMinWidthRem}rem`,
            width: '100%',
            height: '100%',
            position: 'relative'
        };
    }, [isMobileWithActivePane, props.mobileView]);
    /* @conditional-compile-remove(video-background-effects) */
    const onResolveVideoEffectDependency = adapter.getState().onResolveVideoEffectDependency;
    /* @conditional-compile-remove(video-background-effects) */
    const { openVideoEffectsPane } = useVideoEffectsPane(props.updateSidePaneRenderer, props.mobileView, props.latestErrors, props.onDismissError, cameraButtonRef);
    const [showDrawer, setShowDrawer] = useState(false);
    const onMoreButtonClicked = useCallback(() => {
        setShowDrawer(true);
    }, []);
    const closeDrawer = useCallback(() => {
        setShowDrawer(false);
    }, []);
    const onMoreDrawerPeopleClicked = useCallback(() => {
        setShowDrawer(false);
        togglePeoplePane();
    }, [togglePeoplePane]);
    const drawerContainerStylesValue = useMemo(() => drawerContainerStyles(DRAWER_Z_INDEX), []);
    /* @conditional-compile-remove(rooms) */
    const role = (_b = adapter.getState().call) === null || _b === void 0 ? void 0 : _b.role;
    let canUnmute = true;
    /* @conditional-compile-remove(rooms) */
    canUnmute = role !== 'Consumer' ? true : false;
    let filteredLatestErrors = props.errorBarProps !== false ? props.latestErrors : [];
    /* @conditional-compile-remove(video-background-effects) */
    const isCameraOn = useSelector(localVideoSelector).isAvailable;
    /* @conditional-compile-remove(rooms) */
    // TODO: move this logic to the error bar selector once role is plumbed from the headless SDK
    if (role === 'Consumer' && props.errorBarProps) {
        filteredLatestErrors = filteredLatestErrors.filter(e => e.type !== 'callCameraAccessDenied' && e.type !== 'callCameraAccessDeniedSafari');
    }
    /* @conditional-compile-remove(video-background-effects) */
    const isVideoPaneOpen = useIsParticularSidePaneOpen(VIDEO_EFFECTS_SIDE_PANE_ID);
    /* @conditional-compile-remove(video-background-effects) */
    if ((isVideoPaneOpen || !isCameraOn) && props.errorBarProps) {
        filteredLatestErrors = filteredLatestErrors.filter(e => e.type !== 'unableToStartVideoEffect');
    }
    /* @conditional-compile-remove(close-captions) */
    const isTeamsCall = useSelector(getIsTeamsCall);
    /* @conditional-compile-remove(close-captions) */
    const hasJoinedCall = useSelector(getCallStatus) === 'Connected';
    /* @conditional-compile-remove(close-captions) */
    const isCaptionsOn = useSelector(getCaptionsStatus);
    const minMaxDragPosition = useMinMaxDragPosition(props.modalLayerHostId);
    const pipStyles = useMemo(() => getPipStyles(theme), [theme]);
    const verticalControlBar = props.mobileView && containerWidth && containerHeight && containerWidth / containerHeight > 1 ? true : false;
    /* @conditional-compile-remove(capabilities) */
    // Filter out shareScreen capability notifications if on mobile
    const filteredCapabilitesChangedNotifications = props.mobileView ? (_c = props.capabilitiesChangedNotificationBarProps) === null || _c === void 0 ? void 0 : _c.capabilitiesChangedNotifications.filter(notification => notification.capabilityName !== 'shareScreen') : (_d = props.capabilitiesChangedNotificationBarProps) === null || _d === void 0 ? void 0 : _d.capabilitiesChangedNotifications;
    return React.createElement("div", { ref: containerRef, className: mergeStyles(containerDivStyles), id: props.id },
        React.createElement(Stack, { verticalFill: true, horizontalAlign: "stretch", className: containerClassName, "data-ui-id": props.dataUiId },
            React.createElement(Stack, { reversed: true, horizontal: verticalControlBar, grow: true, styles: callArrangementContainerStyles(verticalControlBar) },
                ((_e = props.callControlProps) === null || _e === void 0 ? void 0 : _e.options) !== false && !isMobileWithActivePane && React.createElement(Stack, { verticalAlign: 'center', className: mergeStyles({
                        zIndex: CONTROL_BAR_Z_INDEX,
                        padding: verticalControlBar ? '0.25rem' : 'unset'
                    }) }, isLegacyCallControlEnabled((_f = props.callControlProps) === null || _f === void 0 ? void 0 : _f.options) ? React.createElement(CallControls, Object.assign({}, props.callControlProps, { containerWidth: containerWidth, containerHeight: containerHeight, isMobile: props.mobileView, displayVertical: verticalControlBar })) : React.createElement(CommonCallControlBar, Object.assign({}, props.callControlProps, { callControls: props.callControlProps.options, callAdapter: adapter, mobileView: props.mobileView, disableButtonsForLobbyPage: isInLobby, peopleButtonChecked: isPeoplePaneOpen, onPeopleButtonClicked: togglePeoplePane, onMoreButtonClicked: onMoreButtonClicked, 
                    /* @conditional-compile-remove(close-captions) */ isCaptionsSupported: isTeamsCall && hasJoinedCall, 
                    /* @conditional-compile-remove(close-captions) */ isCaptionsOn: isCaptionsOn, 
                    /* @conditional-compile-remove(video-background-effects) */ onClickVideoEffects: onResolveVideoEffectDependency ? openVideoEffectsPane : undefined, displayVertical: verticalControlBar, onUserSetOverflowGalleryPositionChange: props.onUserSetOverflowGalleryPositionChange, onUserSetGalleryLayout: props.onUserSetGalleryLayoutChange, userSetGalleryLayout: props.userSetGalleryLayout, onSetDialpadPage: props.onSetDialpadPage, dtmfDialerPresent: props.dtmfDialerPresent, peopleButtonRef: peopleButtonRef, cameraButtonRef: cameraButtonRef }))),
                ((_g = props.callControlProps) === null || _g === void 0 ? void 0 : _g.options) !== false && showDrawer && React.createElement(Stack, { styles: drawerContainerStylesValue },
                    React.createElement(PreparedMoreDrawer, { callControls: props.callControlProps.options, onLightDismiss: closeDrawer, onPeopleButtonClicked: onMoreDrawerPeopleClicked, isCaptionsSupported: isTeamsCall && hasJoinedCall, onUserSetGalleryLayout: props.onUserSetGalleryLayoutChange, userSetGalleryLayout: props.userSetGalleryLayout, onSetDialpadPage: props.onSetDialpadPage, dtmfDialerPresent: props.dtmfDialerPresent })),
                React.createElement(Stack, { horizontal: true, grow: true },
                    React.createElement(Stack.Item, { style: callCompositeContainerCSS },
                        React.createElement(Stack.Item, { styles: callGalleryStyles, grow: true },
                            React.createElement(Stack, { verticalFill: true, styles: mediaGalleryContainerStyles },
                                React.createElement(Stack.Item, { styles: notificationsContainerStyles },
                                    React.createElement(Stack, { styles: bannerNotificationStyles },
                                        React.createElement(_ComplianceBanner, Object.assign({}, props.complianceBannerProps))),
                                    props.errorBarProps !== false && React.createElement(Stack, { styles: bannerNotificationStyles },
                                        React.createElement(ErrorBar, Object.assign({}, props.errorBarProps, { onDismissError: props.onDismissError, activeErrorMessages: filteredLatestErrors }))), /* @conditional-compile-remove(capabilities) */
                                    props.capabilitiesChangedNotificationBarProps && props.capabilitiesChangedNotificationBarProps.capabilitiesChangedNotifications.length > 0 && React.createElement(Stack, { styles: bannerNotificationStyles },
                                        React.createElement(CapabilitiesChangedNotificationBar, Object.assign({}, props.capabilitiesChangedNotificationBarProps, { capabilitiesChangedNotifications: filteredCapabilitesChangedNotifications !== null && filteredCapabilitesChangedNotifications !== void 0 ? filteredCapabilitesChangedNotifications : [] }))),
                                    canUnmute && !!props.mutedNotificationProps && React.createElement(MutedNotification, Object.assign({}, props.mutedNotificationProps))),
                                renderGallery && props.onRenderGalleryContent && props.onRenderGalleryContent(), /* @conditional-compile-remove(close-captions) */
                                true && React.createElement(CaptionsBanner, { isMobile: props.mobileView, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData })))),
                    React.createElement(SidePane, { mobileView: props.mobileView, 
                        /* @conditional-compile-remove(video-background-effects) */ maxWidth: isVideoPaneOpen ? `${VIDEO_EFFECTS_SIDE_PANE_WIDTH_REM}rem` : undefined, minWidth: isVideoPaneOpen ? `${VIDEO_EFFECTS_SIDE_PANE_WIDTH_REM}rem` : undefined, updateSidePaneRenderer: props.updateSidePaneRenderer, onPeopleButtonClicked: props.mobileView && !shouldShowPeopleTabHeaderButton(props.callControlProps.options) ? undefined : togglePeoplePane, disablePeopleButton: typeof props.callControlProps.options !== 'boolean' && isDisabled((_h = props.callControlProps.options) === null || _h === void 0 ? void 0 : _h.participantsButton), onChatButtonClicked: (_j = props.mobileChatTabHeader) === null || _j === void 0 ? void 0 : _j.onClick, disableChatButton: (_k = props.mobileChatTabHeader) === null || _k === void 0 ? void 0 : _k.disabled }),
                    props.mobileView && React.createElement(ModalLocalAndRemotePIP, { modalLayerHostId: props.modalLayerHostId, hidden: !isSidePaneOpen, styles: pipStyles, strings: modalStrings, minDragPosition: minMaxDragPosition.minDragPosition, maxDragPosition: minMaxDragPosition.maxDragPosition, onDismissSidePane: () => {
                            closePeoplePane();
                            if (props.onCloseChatPane) {
                                props.onCloseChatPane();
                            }
                        } }),
                    drawerMenuItems.length > 0 && React.createElement(Stack, { styles: drawerContainerStyles() },
                        React.createElement(_DrawerMenu, { onLightDismiss: () => setDrawerMenuItems([]), items: drawerMenuItems }))))));
};
const isLegacyCallControlEnabled = (options) => {
    return !!options && options !== true && (options === null || options === void 0 ? void 0 : options.legacyControlBarExperience) === true;
};
const shouldShowPeopleTabHeaderButton = (callControls) => {
    if (callControls === undefined || callControls === true) {
        return true;
    }
    if (callControls === false) {
        return false;
    }
    return callControls.participantsButton !== false && callControls.peopleButton !== false;
};
//# sourceMappingURL=CallArrangement.js.map