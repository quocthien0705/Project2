// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { createSelector } from 'reselect';
import { getIdentifier, getDisplayName, getIsScreenSharingOn, getIsMuted } from './baseSelectors';
import { getRole } from './baseSelectors';
import { _isRingingPSTNParticipant } from './utils/callUtils';
import { memoizedConvertAllremoteParticipants } from './utils/participantListSelectorUtils';
/* @conditional-compile-remove(rooms) */
import { memoizedConvertAllremoteParticipantsBetaRelease } from './utils/participantListSelectorUtils';
/* @conditional-compile-remove(raise-hand) */
import { getLocalParticipantRaisedHand } from './baseSelectors';
import { toFlatCommunicationIdentifier } from "../../acs-ui-common/src";
import { getParticipantCount } from './baseSelectors';
import { isMicrosoftTeamsAppIdentifier, isPhoneNumberIdentifier } from '@azure/communication-common';
import { getRemoteParticipantsExcludingConsumers } from './getRemoteParticipantsExcludingConsumers';
const convertRemoteParticipantsToParticipantListParticipants = (remoteParticipants, localUserCanRemoveOthers, isHideAttendeeNamesEnabled, localUserRole, spotlightedParticipants) => {
    const conversionCallback = (memoizeFn) => {
        return remoteParticipants
            // Filter out MicrosoftBot participants
            .filter((participant) => {
            return !isMicrosoftTeamsAppIdentifier(participant.identifier);
            return true;
        })
            /**
             * hiding participants who are inLobby, idle, or connecting in ACS clients till we can admit users through ACS clients.
             * phone users will be in the connecting state until they are connected to the call.
             */ .filter(participant => {
            return !['InLobby', 'Idle', 'Connecting', 'Disconnected'].includes(participant.state) || isPhoneNumberIdentifier(participant.identifier);
        }).map((participant) => {
            const isScreenSharing = Object.values(participant.videoStreams).some(videoStream => videoStream.mediaStreamType === 'ScreenSharing' && videoStream.isAvailable);
            /**
             * We want to check the participant to see if they are a PSTN participant joining the call
             * and mapping their state to be 'Ringing'
             */
            const state = _isRingingPSTNParticipant(participant);
            let displayName = participant.displayName;
            return memoizeFn(toFlatCommunicationIdentifier(participant.identifier), displayName, state, participant.isMuted, isScreenSharing, participant.isSpeaking, /* @conditional-compile-remove(raise-hand) */ participant.raisedHand, localUserCanRemoveOthers);
        }).sort((a, b) => {
            var _a, _b;
            const nameA = ((_a = a.displayName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || '';
            const nameB = ((_b = b.displayName) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || '';
            if (nameA < nameB) {
                return -1;
            }
            else if (nameA > nameB) {
                return 1;
            }
            else {
                return 0;
            }
        });
    };
    /* @conditional-compile-remove(rooms) */
    return memoizedConvertAllremoteParticipantsBetaRelease(conversionCallback);
    return memoizedConvertAllremoteParticipants(conversionCallback);
};
/**
 * Selects data that drives {@link ParticipantList} component.
 *
 * @public
 */
export const participantListSelector = createSelector([getIdentifier, getDisplayName, getRemoteParticipantsExcludingConsumers, getIsScreenSharingOn, getIsMuted, /* @conditional-compile-remove(raise-hand) */ getLocalParticipantRaisedHand, getRole, getParticipantCount], (userId, displayName, remoteParticipants, isScreenSharingOn, isMuted, /* @conditional-compile-remove(raise-hand) */ raisedHand, role, partitipantCount) => {
    const localUserCanRemoveOthers = localUserCanRemoveOthersTrampoline(role);
    const participants = remoteParticipants ? convertRemoteParticipantsToParticipantListParticipants(updateUserDisplayNamesTrampoline(Object.values(remoteParticipants)), localUserCanRemoveOthers) : [];
    participants.push({
        userId: userId,
        displayName: displayName,
        isScreenSharing: isScreenSharingOn,
        isMuted: isMuted,
        /* @conditional-compile-remove(raise-hand) */
        raisedHand: raisedHand,
        state: 'Connected',
        // Local participant can never remove themselves.
        isRemovable: false
    });
    return {
        participants: participants,
        myUserId: userId
    };
});
const updateUserDisplayNamesTrampoline = (remoteParticipants) => {
    return remoteParticipants;
};
const localUserCanRemoveOthersTrampoline = (role) => {
    /* @conditional-compile-remove(rooms) */
    return role === 'Presenter' || role === 'Unknown' || role === undefined;
    return true;
};
//# sourceMappingURL=participantListSelector.js.map