// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import React from 'react';
/* @conditional-compile-remove(video-background-effects) */
import { useCallback, useMemo } from 'react';
/* @conditional-compile-remove(video-background-effects) */
import { MessageBar, MessageBarType, Stack, mergeStyles } from '@fluentui/react';
/* @conditional-compile-remove(video-background-effects) */
import { useLocale } from '../localization';
/* @conditional-compile-remove(video-background-effects) */
import { _VideoBackgroundEffectsPicker } from "../../../../react-components/src";
/* @conditional-compile-remove(video-background-effects) */
import { activeVideoBackgroundEffectSelector } from '../CallComposite/selectors/activeVideoBackgroundEffectSelector';
/* @conditional-compile-remove(video-background-effects) */
import { useSelector } from '../CallComposite/hooks/useSelector';
/* @conditional-compile-remove(video-background-effects) */
import { useAdapter } from '../CallComposite/adapter/CallAdapterProvider';
/* @conditional-compile-remove(video-background-effects) */
import { localVideoSelector } from '../CallComposite/selectors/localVideoStreamSelector';
/**
 * Pane that is used to show video effects button
 * @private
 */
/** @beta */
export const VideoEffectsPaneContent = (props) => {
    var _a;
    const { onDismissError, activeVideoEffectError, 
    /* @conditional-compile-remove(video-background-effects) */
    activeVideoEffectChange } = props;
    /* @conditional-compile-remove(video-background-effects) */
    const locale = useLocale();
    /* @conditional-compile-remove(video-background-effects) */
    const adapter = useAdapter();
    /* @conditional-compile-remove(video-background-effects) */
    const strings = locale.strings.call;
    /* @conditional-compile-remove(video-background-effects) */
    const activeVideoEffects = (_a = useSelector(localVideoSelector).activeVideoEffects) === null || _a === void 0 ? void 0 : _a.activeEffects;
    /* @conditional-compile-remove(video-background-effects) */
    const selectableVideoEffects = useMemo(() => {
        const videoEffects = [{
                itemKey: 'none',
                iconProps: {
                    iconName: 'RemoveVideoBackgroundEffect'
                },
                title: strings.removeBackgroundEffectButtonLabel,
                tooltipProps: {
                    content: strings.removeBackgroundTooltip
                }
            }, {
                itemKey: 'blur',
                iconProps: {
                    iconName: 'BlurVideoBackground'
                },
                title: strings.blurBackgroundEffectButtonLabel,
                tooltipProps: {
                    content: strings.blurBackgroundTooltip
                }
            }];
        const videoEffectImages = adapter.getState().videoBackgroundImages;
        if (videoEffectImages) {
            videoEffectImages.forEach((img) => {
                var _a;
                videoEffects.push({
                    itemKey: img.key,
                    backgroundProps: {
                        url: img.url
                    },
                    tooltipProps: {
                        content: (_a = img.tooltipText) !== null && _a !== void 0 ? _a : ''
                    }
                });
            });
        }
        return videoEffects;
    }, [strings, adapter]);
    /* @conditional-compile-remove(video-background-effects) */
    const onEffectChange = useCallback((effectKey) => __awaiter(void 0, void 0, void 0, function* () {
        if (effectKey === 'blur') {
            const blurEffect = {
                effectName: effectKey
            };
            activeVideoEffectChange({
                type: 'blur',
                timestamp: new Date(Date.now())
            });
            yield adapter.startVideoBackgroundEffect(blurEffect);
            adapter.updateSelectedVideoBackgroundEffect(blurEffect);
        }
        else if (effectKey === 'none') {
            const noneEffect = {
                effectName: effectKey
            };
            yield adapter.stopVideoBackgroundEffects();
            adapter.updateSelectedVideoBackgroundEffect(noneEffect);
        }
        else {
            const backgroundImg = selectableVideoEffects.find(effect => {
                return effect.itemKey === effectKey;
            });
            if (backgroundImg && backgroundImg.backgroundProps) {
                const replaceEffect = {
                    effectName: 'replacement',
                    key: effectKey,
                    backgroundImageUrl: backgroundImg.backgroundProps.url
                };
                activeVideoEffectChange({
                    type: 'replacement',
                    timestamp: new Date(Date.now())
                });
                yield adapter.startVideoBackgroundEffect(replaceEffect);
                adapter.updateSelectedVideoBackgroundEffect(replaceEffect);
            }
        }
    }), [adapter, activeVideoEffectChange, selectableVideoEffects]);
    /* @conditional-compile-remove(video-background-effects) */
    if (activeVideoEffectError && activeVideoEffects && activeVideoEffects.length === 0) {
        const noneEffect = {
            effectName: 'none'
        };
        adapter.updateSelectedVideoBackgroundEffect(noneEffect);
    }
    return VideoEffectsPaneTrampoline(onDismissError, activeVideoEffectError, /* @conditional-compile-remove(video-background-effects) */ selectableVideoEffects, /* @conditional-compile-remove(video-background-effects) */ onEffectChange);
};
const VideoEffectsPaneTrampoline = (onDismissError, activeVideoEffectError, selectableVideoEffects, onEffectChange) => {
    /* @conditional-compile-remove(video-background-effects) */
    const selectedEffect = useSelector(activeVideoBackgroundEffectSelector);
    /* @conditional-compile-remove(video-background-effects) */
    const isCameraOn = useSelector(localVideoSelector).isAvailable;
    /* @conditional-compile-remove(video-background-effects) */
    const showWarning = !isCameraOn && selectedEffect !== 'none';
    /* @conditional-compile-remove(video-background-effects) */
    const locale = useLocale();
    /* @conditional-compile-remove(video-background-effects) */
    return React.createElement(Stack, { tokens: {
            childrenGap: '0.75rem'
        }, className: mergeStyles({
            paddingLeft: '0.5rem'
        }) },
        activeVideoEffectError && isCameraOn && React.createElement(MessageBar, { messageBarType: MessageBarType.error, onDismiss: () => onDismissError(activeVideoEffectError) }, locale.strings.call.unableToStartVideoEffect),
        showWarning && React.createElement(MessageBar, { messageBarType: MessageBarType.warning }, locale.strings.call.cameraOffBackgroundEffectWarningText),
        React.createElement(_VideoBackgroundEffectsPicker, { label: locale.strings.call.videoEffectsPaneBackgroundSelectionTitle, styles: backgroundPickerStyles, options: selectableVideoEffects !== null && selectableVideoEffects !== void 0 ? selectableVideoEffects : [], onChange: onEffectChange, selectedEffectKey: selectedEffect }));
    return React.createElement(React.Fragment, null);
};
/* @conditional-compile-remove(video-background-effects) */
const backgroundPickerStyles = {
    label: {
        fontSize: '0.75rem',
        lineHeight: '0.5rem',
        fontWeight: '400'
    }
};
//# sourceMappingURL=VideoEffectsPane.js.map