// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { toFlatCommunicationIdentifier } from "../../../../../acs-ui-common/src";
import memoizeOne from 'memoize-one';
import { useAdapter } from '../adapter/CallAdapterProvider';
import { isCameraOn } from '../utils';
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
export const useHandlers = (_component) => {
    const adapter = useAdapter();
    const compositeHandlers = createCompositeHandlers(adapter);
    return compositeHandlers;
};
const createCompositeHandlers = memoizeOne((adapter) => {
    return {
        onCreateLocalStreamView: (options) => __awaiter(void 0, void 0, void 0, function* () {
            return yield adapter.createStreamView(undefined, options);
        }),
        onCreateRemoteStreamView: (userId, options) => __awaiter(void 0, void 0, void 0, function* () {
            return yield adapter.createStreamView(userId, options);
        }),
        onHangUp: (forEveryone) => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.leaveCall(forEveryone);
        }),
        onSendDtmfTone: (dtmfTone) => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.sendDtmfTone(dtmfTone);
        }),
        onRemoveParticipant: (userId) => __awaiter(void 0, void 0, void 0, function* () {
            if (typeof userId === 'string') {
                yield adapter.removeParticipant(userId);
            }
            else { }
        }),
        /* @conditional-compile-remove(raise-hand) */
        onRaiseHand: () => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.raiseHand();
        }),
        /* @conditional-compile-remove(raise-hand) */
        onLowerHand: () => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.lowerHand();
        }),
        /* @conditional-compile-remove(raise-hand) */
        onToggleRaiseHand: () => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            ((_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.raiseHand.localParticipantRaisedHand) ? yield adapter.lowerHand() : yield adapter.raiseHand();
        }),
        onSelectCamera: (deviceInfo, options) => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.setCamera(deviceInfo, options);
        }),
        onSelectMicrophone: (deviceInfo) => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.setMicrophone(deviceInfo);
        }),
        onSelectSpeaker: (deviceInfo) => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.setSpeaker(deviceInfo);
        }),
        onStartCall: (participants, options) => {
            const rawIds = participants.map(participant => toFlatCommunicationIdentifier(participant));
            return adapter.startCall(rawIds, options);
        },
        onStartScreenShare: () => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.startScreenShare();
        }),
        onStopScreenShare: () => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.stopScreenShare();
        }),
        onToggleCamera: (options) => __awaiter(void 0, void 0, void 0, function* () {
            isCameraOn(adapter.getState()) ? yield adapter.stopCamera() : yield adapter.startCamera(options);
        }),
        onToggleMicrophone: () => __awaiter(void 0, void 0, void 0, function* () {
            var _b;
            return ((_b = adapter.getState().call) === null || _b === void 0 ? void 0 : _b.isMuted) ? yield adapter.unmute() : yield adapter.mute();
        }),
        onToggleScreenShare: () => __awaiter(void 0, void 0, void 0, function* () {
            var _c;
            return ((_c = adapter.getState().call) === null || _c === void 0 ? void 0 : _c.isScreenSharingOn) ? yield adapter.stopScreenShare() : yield adapter.startScreenShare();
        }),
        onStartLocalVideo: () => __awaiter(void 0, void 0, void 0, function* () {
            if (adapter.getState().call) {
                return adapter.startCamera();
            }
        }),
        onDisposeLocalStreamView: () => __awaiter(void 0, void 0, void 0, function* () {
            return adapter.disposeLocalVideoStreamView();
        }),
        onDisposeRemoteStreamView: (userId) => __awaiter(void 0, void 0, void 0, function* () {
            return adapter.disposeStreamView(userId);
        }),
        onDisposeRemoteScreenShareStreamView: (userId) => __awaiter(void 0, void 0, void 0, function* () {
            return adapter.disposeScreenShareStreamView(userId);
        }),
        onDisposeRemoteVideoStreamView: (userId) => __awaiter(void 0, void 0, void 0, function* () {
            return adapter.disposeRemoteVideoStreamView(userId);
        }),
        /* @conditional-compile-remove(video-background-effects) */
        onRemoveVideoBackgroundEffects: () => __awaiter(void 0, void 0, void 0, function* () {
            return yield adapter.stopVideoBackgroundEffects();
        }),
        /* @conditional-compile-remove(video-background-effects) */
        onBlurVideoBackground: (backgroundBlurConfig) => __awaiter(void 0, void 0, void 0, function* () {
            const blurConfig = Object.assign({ effectName: 'blur' }, backgroundBlurConfig);
            return yield adapter.startVideoBackgroundEffect(blurConfig);
        }),
        /* @conditional-compile-remove(video-background-effects) */
        onReplaceVideoBackground: (backgroundReplacementConfig) => __awaiter(void 0, void 0, void 0, function* () {
            const replacementConfig = Object.assign({ effectName: 'replacement' }, backgroundReplacementConfig);
            return yield adapter.startVideoBackgroundEffect(replacementConfig);
        }),
        /* @conditional-compile-remove(close-captions) */
        onStartCaptions: (options) => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.startCaptions(options);
        }),
        /* @conditional-compile-remove(close-captions) */
        onStopCaptions: () => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.stopCaptions();
        }),
        /* @conditional-compile-remove(close-captions) */
        onSetSpokenLanguage: (language) => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.setSpokenLanguage(language);
        }),
        /* @conditional-compile-remove(close-captions) */
        onSetCaptionLanguage: (language) => __awaiter(void 0, void 0, void 0, function* () {
            yield adapter.setCaptionLanguage(language);
        })
    };
});
//# sourceMappingURL=useHandlers.js.map