'use strict';

var communicationCommon = require('@azure/communication-common');
var reselect = require('reselect');
var memoizeOne = require('memoize-one');
var communicationCalling = require('@azure/communication-calling');
var logger = require('@azure/logger');
var EventEmitter = require('events');
var immer = require('immer');
var React = require('react');
var react = require('@fluentui/react');
var reactIcons = require('@fluentui/react-icons');
var uuid = require('uuid');
var reactChat = require('@fluentui-contrib/react-chat');
var reactComponents = require('@fluentui/react-components');
var react$1 = require('@griffel/react');
var parse = require('html-react-parser');
var Linkify = require('react-linkify');
var DOMPurify = require('dompurify');
var reactHooks = require('@fluentui/react-hooks');
var reactUseDraggableScroll = require('react-use-draggable-scroll');
var reactWindowProvider = require('@fluentui/react-window-provider');
var copy = require('copy-to-clipboard');
require('@fluentui/react-file-type-icons');
var communicationChat = require('@azure/communication-chat');
var nanoid = require('nanoid');
var communicationCallingEffects = require('@azure/communication-calling-effects');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var reselect__namespace = /*#__PURE__*/_interopNamespaceDefault(reselect);
var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const argsCmp = (args1, args2, objCmp) => {
    return args1.length === args2.length && args1.every((arg1, index) => objCmp(args2[index], arg1));
};
/**
 * The function memoize a series of function calls in a single pass,
 * it memoizes all the args and return in a single run of the callback function, and read it in the next round of execution
 * note: this is a memory opimized function which will only memoize one round of bulk calls
 * @param  fnToMemoize - the function needs to be bulk memorized and a key key paramter needs to be provided as cache id
 * @param  shouldCacheUpdate - the validate function for comparing 2 argument, return true when 2 args are equal
 * @returns callback function includes a series calls of memoizedFn, and each call will get cache result if args are the same(according to shouldCacheUpdate fn)
 * @example
 * ```ts
 * const items = [{id:1, value:3}];
 * const heavyFn = (_key, value) => { // key is not used in the function, but it is a cache id
 *   // assume this is a heavy caculation
 *   return value+1;
 * }
 *
 * const memoizeHeavyFnAll = memoizeFnAll(heavyFn);
 * const generateValueArray = (memoizedHeavyFn) => (
 *   items.map(item => {
 *     memoizedHeavyFn(item.id, item.value);
 *   })
 * );
 *
 * const result = memoizeHeavyFnAll(generateValueArray); // Cache: {}, nextCache: {1: 4 *new}, heavyFn call times: 1
 *
 * // Argument changed
 * items[0].value = 2
 * const result0 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 4}, nextCache: {1: 3 *new}, heavyFn call times: 1
 *
 * // Cache added
 * items.push({id:3, value:4});
 * const result1 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 3 *hit}, nextCache: {1: 3, 3: 5 *new}, heavyFn call times: 1
 *
 * // Cache removed
 * delete items[0];
 * const result2 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 3, 3: 5 *hit}, nextCache: {3: 5}, heavyFn call times: 0
 * ```
 *
 * @public
 */
const memoizeFnAll = (fnToMemoize, shouldCacheUpdate = Object.is) => {
    let cache = new Map();
    let nextCache = new Map();
    return (callback) => {
        const memoizedFn = (key, ...args) => {
            const value = cache.get(key);
            if (value) {
                const [preArgs, ret] = value;
                if (argsCmp(preArgs, args, shouldCacheUpdate)) {
                    nextCache.set(key, [args, ret]);
                    return ret;
                }
            }
            const ret = fnToMemoize(key, ...args);
            nextCache.set(key, [args, ret]);
            return ret;
        };
        const retValue = callback(memoizedFn);
        cache = nextCache;
        nextCache = new Map();
        return retValue;
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A string representation of a {@link @azure/communication-common#CommunicationIdentifier}.
 *
 * This string representation of CommunicationIdentifier is guaranteed to be stable for
 * a unique Communication user. Thus,
 * - it can be used to persist a user's identity in external databases.
 * - it can be used as keys into a Map to store data for the user.
 *
 * @public
 */
const toFlatCommunicationIdentifier = (identifier) => {
    return communicationCommon.getIdentifierRawId(identifier);
};
/**
 * Reverse operation of {@link toFlatCommunicationIdentifier}.
 *
 * @public
 */
const fromFlatCommunicationIdentifier = (id) => {
    // if the id passed is a phone number we need to build the rawId to pass in
    const rawId = id.indexOf('+') === 0 ? '4:' + id : id;
    return communicationCommon.createIdentifierFromRawId(rawId);
};
/**
 * Returns a CommunicationIdentifier.
 * @internal
 */
const _toCommunicationIdentifier = (id) => {
    if (typeof id === 'string') {
        return fromFlatCommunicationIdentifier(id);
    }
    return id;
};
/**
 * Check if an object is identifier.
 *
 * @internal
 */
const _isValidIdentifier = (identifier) => {
    return communicationCommon.isCommunicationUserIdentifier(identifier) || communicationCommon.isPhoneNumberIdentifier(identifier) || communicationCommon.isMicrosoftTeamsUserIdentifier(identifier) || communicationCommon.isUnknownIdentifier(identifier);
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// GENERATED FILE. DO NOT EDIT MANUALLY.
var telemetryVersion = '1.14.0';


var telemetryVersion$1 = /*@__PURE__*/getDefaultExportFromCjs(telemetryVersion);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
// Removes long suffixes that don't fit the constraints for telemetry application ID.
// e.g., the build suffix is dropped for alpha package versions.
const sanitize = (version) => {
    const alphaIndex = version.search(/alpha/);
    if (alphaIndex >= 0) {
        return version.substring(0, alphaIndex + 5);
    }
    return version;
};
/**
 * Takes a telemetry implementation hint and returns the numerical value.
 *
 * @private
 */
const getTelemetryImplementationHint = (telemetryImplementationHint) => {
    switch (telemetryImplementationHint) {
        case 'Call':
            return 1;
        case 'Chat':
            return 2;
        case 'CallWithChat':
            return 3;
        case 'StatefulComponents':
            return 4;
        default:
            return 0;
    }
};
/**
 * Application ID to be included in telemetry data from the UI library.
 * Template: acXYYY/<version>
 * Where:
 * - X describes a platform, [r: web, i: iOS, a: Android]
 * - YYY describes what's running on this platform (optional, currently unused by this library):
 *    Y[0] is high-level artifact,
 *      [0: undefined, 1: AzureCommunicationLibrary, 2: ACS SampleApp]
 *    Y[1] is specific implementation,
 *      [0: undefined, 1: Call Composite, 2: Chat Composite, 3: CallWithChatComposite, 4: UI Components]
 *    Y[2] is reserved for implementation details,
 *      [0: undefined]
 *
 * @internal
 */
const _getApplicationId = (telemetryImplementationHint) => {
    // We assume AzureCommunicationLibrary, as we don't currently have any public API to inject otherwise.
    // This is consistent with the native iOS and Android implementations of telemetry.
    const highLevelArtifact = 1;
    const specificImplementation = getTelemetryImplementationHint(telemetryImplementationHint);
    const implementationDetails = 0;
    const version = telemetryVersion$1;
    return sanitize(`acr${highLevelArtifact}${specificImplementation}${implementationDetails}/${version}`);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 *
 * Replace the pattern "\{\}" in str with the values passed in as vars
 *
 * @example
 * ```ts
 *   _formatString("hello {name}. '{name}' is a rare name.", {name: "Foo"});
 *   // returns "hello Foo. 'Foo' is a rare name."
 * ```
 * @param str - The string to be formatted
 * @param variables - Variables to use to format the string
 * @returns a formatted string
 */
const _formatString = (str, vars) => {
    if (!str) {
        return '';
    }
    if (!vars) {
        return str;
    }
    // regex to search for the pattern "\{\}"
    const placeholdersRegex = /{(\w+)}/g;
    return str.replace(placeholdersRegex, (_, k) => vars[k] || `{${k}}`);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Wrap JSON.stringify in a try-catch as JSON.stringify throws an exception if it fails.
 *
 * Use this only in areas where the JSON.stringify is non-critical and OK for the JSON.stringify to fail, such as logging.
 *
 * @internal
 */
const _safeJSONStringify = (value, replacer = createSafeReplacer(), space) => {
    try {
        return JSON.stringify(value, replacer, space);
    }
    catch (e) {
        console.error(e);
        return undefined;
    }
};
// Log all visited refs to avoid circular ref
const createSafeReplacer = () => {
    const visited = new Set();
    return function replacer(key, value) {
        if (typeof value !== 'object') {
            return value;
        }
        if (visited.has(value)) {
            return 'Visited-Ref';
        }
        else {
            visited.add(value);
            return value;
        }
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 * Converts units of rem to units of pixels
 * @param rem - units of rem
 * @returns units of pixels
 */
const _convertRemToPx = (rem) => {
    return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
};
/**
 * @internal
 * Converts units of pixels to units of rem
 * @param px - units of px
 * @returns units of rem
 */
const _convertPxToRem = (px) => {
    return px / parseFloat(getComputedStyle(document.documentElement).fontSize);
};
/**
 * @internal
 * Disable dismiss on resize to work around a couple Fluent UI bugs
 * - The Callout is dismissed whenever *any child of window (inclusive)* is resized. In practice, this
 * happens when we change the VideoGallery layout, or even when the video stream element is internally resized
 * by the headless SDK.
 * - We also want to prevent dismiss when chat pane is scrolling especially a new message is added.
 * A side effect of this workaround is that the context menu stays open when window is resized, and may
 * get detached from original target visually. That bug is preferable to the bug when this value is not set -
 * The Callout (frequently) gets dismissed automatically.
 */
const _preventDismissOnEvent = (ev) => {
    return ev.type === 'resize' || ev.type === 'scroll';
};
/**
 * @internal
 * Helper function to get the keys of an object
 */
function _getKeys(obj) {
    return Object.keys(obj);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 * Converts px value to rem value.
 * For example, an input of `16` will return `1rem`.
 */
const _pxToRem = (px) => `${px / 16}rem`;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 * This is a log function to log structural data for easier parse in telemetry
 */
const _logEvent = (logger, event) => {
    logger[event.level](_safeJSONStringify(event));
};

/**
 * @private
 */
const getDeviceManager$1 = (state) => state.deviceManager;
/**
 * @private
 */
const getRole$1 = (state, props) => {
    var _a;
    /* @conditional-compile-remove(rooms) */
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.role;
};
/* @conditional-compile-remove(capabilities) */
/**
 * @private
 */
const getCapabilities = (state, props) => { var _a, _b; return (_b = (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.capabilitiesFeature) === null || _b === void 0 ? void 0 : _b.capabilities; };
/**
 * @private
 */
const getCallExists = (state, props) => !!state.calls[props.callId];
/**
 * @private
 */
const getDominantSpeakers = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.dominantSpeakers; };
/**
 * @private
 */
const getRemoteParticipants$1 = (state, props) => {
    var _a;
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.remoteParticipants;
};
/* @conditional-compile-remove(raise-hand) */
/**
 * @private
 */
const getLocalParticipantRaisedHand$1 = (state, props) => {
    var _a, _b;
    return (_b = (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.raiseHand) === null || _b === void 0 ? void 0 : _b.localParticipantRaisedHand;
};
/**
 * @private
 */
const getIsScreenSharingOn = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn; };
/**
 * @private
 */
const getIsMuted = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.isMuted; };
/* @conditional-compile-remove(optimal-video-count) */
/**
 * @private
 */
const getOptimalVideoCount = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.optimalVideoCount.maxRemoteVideoStreams; };
/**
 * @private
 */
const getLocalVideoStreams$1 = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.localVideoStreams; };
/**
 * @private
 */
const getScreenShareRemoteParticipant = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.screenShareRemoteParticipant; };
/**
 * @private
 */
const getDisplayName$2 = (state) => { var _a; return (_a = state.callAgent) === null || _a === void 0 ? void 0 : _a.displayName; };
/**
 * @private
 */
const getIdentifier = (state) => toFlatCommunicationIdentifier(state.userId);
/**
 * @private
 */
const getLatestErrors$1 = (state) => state.latestErrors;
/**
 * @private
 */
const getDiagnostics = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.diagnostics; };
/* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(raise-hand) */
/**
 * @private
 */
const getCallState = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.state; };
/**
 * @private
 */
const getEnvironmentInfo = (state) => {
    return undefined;
};
/** @private */
const getParticipantCount = (state, props) => {
    return undefined;
};
/* @conditional-compile-remove(close-captions) */
/** @private */
const getCaptions = (state, props) => {
    var _a;
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.captionsFeature.captions;
};
/* @conditional-compile-remove(close-captions) */
/** @private */
const getCaptionsStatus$1 = (state, props) => {
    var _a;
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.captionsFeature.isCaptionsFeatureActive;
};
/* @conditional-compile-remove(close-captions) */
/** @private */
const getStartCaptionsInProgress = (state, props) => {
    var _a;
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.captionsFeature.startCaptionsInProgress;
};
/* @conditional-compile-remove(close-captions) */
/** @private */
const getCurrentCaptionLanguage = (state, props) => {
    var _a;
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.captionsFeature.currentCaptionLanguage;
};
/* @conditional-compile-remove(close-captions) */
/** @private */
const getCurrentSpokenLanguage = (state, props) => {
    var _a;
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.captionsFeature.currentSpokenLanguage;
};
/* @conditional-compile-remove(close-captions) */
/** @private */
const getSupportedCaptionLanguages = (state, props) => {
    var _a;
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.captionsFeature.supportedCaptionLanguages;
};
/* @conditional-compile-remove(close-captions) */
/** @private */
const getSupportedSpokenLanguages = (state, props) => {
    var _a;
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.captionsFeature.supportedSpokenLanguages;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$J = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Check if the call state represents being in the call
 *
 * @internal
 */
const _isInCall = (callStatus) => !!callStatus && !['None', 'Disconnected', 'Connecting', 'Ringing', 'EarlyMedia', 'Disconnecting'].includes(callStatus);
/**
 * Check if the call state represents being in the lobby or waiting to be admitted.
 *
 * @internal
 */
const _isInLobbyOrConnecting = (callStatus) => !!callStatus && ['Connecting', 'Ringing', 'InLobby', 'EarlyMedia'].includes(callStatus);
/**
 * Check if the device manager local video is on when not part of a call
 * i.e. do unparented views exist.
 *
 * @internal
 */
const _isPreviewOn = (deviceManager) => {
    // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
    // handle cases where 'Preview' view is in progress and not necessary completed.
    return deviceManager.unparentedViews.length > 0 && deviceManager.unparentedViews[0].view !== undefined;
};
/**
 * Dispose of all preview views
 * We assume all unparented views are local preview views.
 *
 * @private
 */
const disposeAllLocalPreviewViews = (callClient) => __awaiter$J(void 0, void 0, void 0, function* () {
    const unparentedViews = callClient.getState().deviceManager.unparentedViews;
    for (const view of unparentedViews) {
        yield callClient.disposeView(undefined, undefined, view);
    }
});
/**
 * @private
 * A type guard to ensure all participants are acceptable type for ACS call
 */
const isACSCallParticipants = (participants) => {
    return participants.every(p => !communicationCommon.isMicrosoftTeamsUserIdentifier(p));
};
/**
 * @private
 * Checks whether the user is a 'Ringing' PSTN user.
 */
const _isRingingPSTNParticipant = (participant) => {
    return communicationCommon.isPhoneNumberIdentifier(participant.identifier) && participant.state === 'Connecting' ? 'Ringing' : participant.state;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Selector for {@link MicrophoneButton} component.
 *
 * @public
 */
const microphoneButtonSelector = reselect__namespace.createSelector([getCallExists, getIsMuted, getDeviceManager$1, /* @conditional-compile-remove(capabilities) */ getCapabilities, /* @conditional-compile-remove(capabilities) */ getRole$1], (callExists, isMuted, deviceManager, /* @conditional-compile-remove(capabilities) */ capabilities, /* @conditional-compile-remove(capabilities) */ role) => {
    const permission = deviceManager.deviceAccess ? deviceManager.deviceAccess.audio : true;
    /* @conditional-compile-remove(capabilities) */
    const incapable = (capabilities === null || capabilities === void 0 ? void 0 : capabilities.unmuteMic.isPresent) === false && (capabilities === null || capabilities === void 0 ? void 0 : capabilities.unmuteMic.reason) !== 'NotInitialized' || role === 'Consumer';
    return {
        disabled: !callExists || !permission || /* @conditional-compile-remove(capabilities) */ incapable,
        checked: callExists ? !isMuted : false,
        microphones: deviceManager.microphones,
        speakers: deviceManager.speakers,
        selectedMicrophone: deviceManager.selectedMicrophone,
        selectedSpeaker: deviceManager.selectedSpeaker
    };
});
/**
 * Selector for {@link CameraButton} component.
 *
 * @public
 */
const cameraButtonSelector = reselect__namespace.createSelector([getLocalVideoStreams$1, getDeviceManager$1, /* @conditional-compile-remove(capabilities) */ getCapabilities, /* @conditional-compile-remove(capabilities) */ getRole$1], (localVideoStreams, deviceManager, /* @conditional-compile-remove(capabilities) */ capabilities, /* @conditional-compile-remove(capabilities) */ role) => {
    const previewOn = _isPreviewOn(deviceManager);
    const localVideoFromCall = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
    const permission = deviceManager.deviceAccess ? deviceManager.deviceAccess.video : true;
    /* @conditional-compile-remove(capabilities) */
    const incapable = (capabilities === null || capabilities === void 0 ? void 0 : capabilities.turnVideoOn.isPresent) === false && (capabilities === null || capabilities === void 0 ? void 0 : capabilities.turnVideoOn.reason) !== 'NotInitialized' || role === 'Consumer';
    return {
        disabled: !deviceManager.selectedCamera || !permission || !deviceManager.cameras.length || /* @conditional-compile-remove(capabilities) */ incapable,
        checked: localVideoStreams !== undefined && localVideoStreams.length > 0 ? !!localVideoFromCall : previewOn,
        cameras: deviceManager.cameras,
        selectedCamera: deviceManager.selectedCamera
    };
});
/* @conditional-compile-remove(raise-hand) */
/**
 * Selector for {@link RaiseHandButton} component.
 *
 * @public
 */
const raiseHandButtonSelector = reselect__namespace.createSelector([getLocalParticipantRaisedHand$1, getCallState], (raisedHand, callState) => {
    var _a;
    return {
        checked: raisedHand ? true : false,
        disabled: callState === 'InLobby' ? true : (_a = callState === 'Connecting') !== null && _a !== void 0 ? _a : false
    };
});
/**
 * Selector for {@link ScreenShareButton} component.
 *
 * @public
 */
const screenShareButtonSelector = reselect__namespace.createSelector([getIsScreenSharingOn, /* @conditional-compile-remove(capabilities) */ getCapabilities, /* @conditional-compile-remove(capabilities) */ getRole$1], (isScreenSharingOn, /* @conditional-compile-remove(capabilities) */ capabilities, /* @conditional-compile-remove(capabilities) */ role) => {
    let disabled = undefined;
    /* @conditional-compile-remove(capabilities) */
    disabled = disabled || (capabilities === null || capabilities === void 0 ? void 0 : capabilities.shareScreen.isPresent) === false && (capabilities === null || capabilities === void 0 ? void 0 : capabilities.shareScreen.reason) !== 'NotInitialized' || role === 'Consumer' || role === 'Attendee';
    return {
        checked: isScreenSharingOn,
        disabled
    };
});
/**
 * Selector for {@link DevicesButton} component.
 *
 * @public
 */
const devicesButtonSelector = reselect__namespace.createSelector([getDeviceManager$1], deviceManager => {
    return {
        microphones: removeBlankNameDevices(deviceManager.microphones),
        speakers: removeBlankNameDevices(deviceManager.speakers),
        cameras: removeBlankNameDevices(deviceManager.cameras),
        selectedMicrophone: deviceManager.selectedMicrophone,
        selectedSpeaker: deviceManager.selectedSpeaker,
        selectedCamera: deviceManager.selectedCamera
    };
});
function removeBlankNameDevices(devices) {
    return devices.filter(device => device.name !== '');
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$I = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const areStreamsEqual = (prevStream, newStream) => {
    return !!prevStream && !!newStream && prevStream.source.id === newStream.source.id;
};
/**
 * Create the common implementation of {@link CallingHandlers} for all types of Call
 *
 * @private
 */
const createDefaultCommonCallingHandlers = memoizeOne((callClient, deviceManager, call, options) => {
    const onStartLocalVideo = () => __awaiter$I(void 0, void 0, void 0, function* () {
        // Before the call object creates a stream, dispose of any local preview streams.
        // @TODO: is there any way to parent the unparented view to the call object instead
        // of disposing and creating a new stream?
        yield disposeAllLocalPreviewViews(callClient);
        const callId = call === null || call === void 0 ? void 0 : call.id;
        let videoDeviceInfo = callClient.getState().deviceManager.selectedCamera;
        if (!videoDeviceInfo) {
            const cameras = yield (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.getCameras());
            videoDeviceInfo = cameras && cameras.length > 0 ? cameras[0] : undefined;
            videoDeviceInfo && (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.selectCamera(videoDeviceInfo));
        }
        if (!callId || !videoDeviceInfo) {
            return;
        }
        const stream = new communicationCalling.LocalVideoStream(videoDeviceInfo);
        if (call && !call.localVideoStreams.find(s => areStreamsEqual(s, stream))) {
            yield call.startVideo(stream);
        }
    });
    const onStopLocalVideo = (stream) => __awaiter$I(void 0, void 0, void 0, function* () {
        const callId = call === null || call === void 0 ? void 0 : call.id;
        if (!callId) {
            return;
        }
        if (call && call.localVideoStreams.find(s => areStreamsEqual(s, stream))) {
            yield call.stopVideo(stream);
        }
    });
    const onToggleCamera = (options) => __awaiter$I(void 0, void 0, void 0, function* () {
        const previewOn = _isPreviewOn(callClient.getState().deviceManager);
        // the disposal of the unparented views is to workaround: https://skype.visualstudio.com/SPOOL/_workitems/edit/3030558.
        // The root cause of the issue is caused by never transitioning the unparented view to the
        // call object when going from configuration page (disconnected call state) to connecting.
        //
        // Currently the only time the local video stream is moved from unparented view to the call
        // object is when we transition from connecting -> call state. If the camera was on,
        // inside the MediaGallery we trigger toggleCamera. This triggers onStartLocalVideo which
        // destroys the unparentedView and creates a new stream in the call - so all looks well.
        //
        // However, if someone turns off their camera during the lobbyOrConnecting screen, the
        // call.localVideoStreams will be empty (as the stream is currently stored in the unparented
        // views and was never transitioned to the call object) and thus we incorrectly try to create
        // a new video stream for the call object, instead of only stopping the unparented view.
        //
        // The correct fix for this is to ensure that callAgent.onStartCall is called with the
        // localvideostream as a videoOption. That will mean call.onLocalVideoStreamsUpdated will
        // be triggered when the call is in connecting state, which we can then transition the
        // local video stream to the stateful call client and get into a clean state.
        if (call && (_isInCall(call.state) || _isInLobbyOrConnecting(call.state))) {
            const stream = call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
            const unparentedViews = callClient.getState().deviceManager.unparentedViews;
            if (stream || unparentedViews.length > 0) {
                unparentedViews && (yield unparentedViews.forEach(view => view.mediaStreamType === 'Video' && callClient.disposeView(undefined, undefined, view)));
                stream && (yield onStopLocalVideo(stream));
            }
            else {
                yield onStartLocalVideo();
            }
        }
        else {
            /**
             * This will create a unparented view to be used on the configuration page and the connecting screen
             *
             * If the device that the stream will come from is not on from permissions checks, then it will take time
             * to create the stream since device is off. If we are turn the camera on immedietly on the configuration page we see it is
             * fast but that is because the device is already primed to return a stream.
             *
             * On the connecting page the device has already turned off and the connecting window is so small we do not see the resulting
             * unparented view from the code below.
             */
            const selectedCamera = callClient.getState().deviceManager.selectedCamera;
            if (selectedCamera) {
                if (previewOn) {
                    yield onDisposeLocalStreamView();
                }
                else {
                    yield callClient.createView(undefined, undefined, {
                        source: selectedCamera,
                        mediaStreamType: 'Video'
                    }, options);
                }
            }
        }
    });
    const onSelectMicrophone = (device) => __awaiter$I(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        return deviceManager.selectMicrophone(device);
    });
    const onSelectSpeaker = (device) => __awaiter$I(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        return deviceManager.selectSpeaker(device);
    });
    const onSelectCamera = (device, options) => __awaiter$I(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        if (call && _isInCall(call.state)) {
            deviceManager.selectCamera(device);
            const stream = call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
            yield (stream === null || stream === void 0 ? void 0 : stream.switchSource(device));
            /// TODO: TEMPORARY SOLUTION
            /// The Calling SDK needs to wait until the stream is ready before resolving the switchSource promise.
            /// This is a temporary solution to wait for the stream to be ready before resolving the promise.
            /// This allows the onSelectCamera to be throttled to prevent the streams from getting in to a frozen state
            /// if the user switches cameras too rapidly.
            /// This is to be removed once the Calling SDK has issued a fix.
            yield (stream === null || stream === void 0 ? void 0 : stream.getMediaStream());
        }
        else {
            const previewOn = _isPreviewOn(callClient.getState().deviceManager);
            if (!previewOn) {
                deviceManager.selectCamera(device);
                return;
            }
            yield onDisposeLocalStreamView();
            deviceManager.selectCamera(device);
            yield callClient.createView(undefined, undefined, {
                source: device,
                mediaStreamType: 'Video'
            }, options);
        }
    });
    /* @conditional-compile-remove(raise-hand) */
    const onRaiseHand = () => __awaiter$I(void 0, void 0, void 0, function* () { var _a; return yield ((_a = call === null || call === void 0 ? void 0 : call.feature(communicationCalling.Features.RaiseHand)) === null || _a === void 0 ? void 0 : _a.raiseHand()); });
    /* @conditional-compile-remove(raise-hand) */
    const onLowerHand = () => __awaiter$I(void 0, void 0, void 0, function* () { var _b; return yield ((_b = call === null || call === void 0 ? void 0 : call.feature(communicationCalling.Features.RaiseHand)) === null || _b === void 0 ? void 0 : _b.lowerHand()); });
    /* @conditional-compile-remove(raise-hand) */
    const onToggleRaiseHand = () => __awaiter$I(void 0, void 0, void 0, function* () {
        const raiseHandFeature = call === null || call === void 0 ? void 0 : call.feature(communicationCalling.Features.RaiseHand);
        const localUserId = callClient.getState().userId;
        const isLocalRaisedHand = raiseHandFeature === null || raiseHandFeature === void 0 ? void 0 : raiseHandFeature.getRaisedHands().find(publishedState => toFlatCommunicationIdentifier(publishedState.identifier) === toFlatCommunicationIdentifier(localUserId));
        if (isLocalRaisedHand) {
            yield (raiseHandFeature === null || raiseHandFeature === void 0 ? void 0 : raiseHandFeature.lowerHand());
        }
        else {
            yield (raiseHandFeature === null || raiseHandFeature === void 0 ? void 0 : raiseHandFeature.raiseHand());
        }
    });
    const onToggleMicrophone = () => __awaiter$I(void 0, void 0, void 0, function* () {
        if (!call || !(_isInCall(call.state) || _isInLobbyOrConnecting(call.state))) {
            throw new Error(`Please invoke onToggleMicrophone after call is started`);
        }
        return call.isMuted ? yield call.unmute() : yield call.mute();
    });
    const onStartScreenShare = () => __awaiter$I(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.startScreenSharing()); });
    const onStopScreenShare = () => __awaiter$I(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.stopScreenSharing()); });
    const onToggleScreenShare = () => __awaiter$I(void 0, void 0, void 0, function* () { return (call === null || call === void 0 ? void 0 : call.isScreenSharingOn) ? yield onStopScreenShare() : yield onStartScreenShare(); });
    const onHangUp = (forEveryone) => __awaiter$I(void 0, void 0, void 0, function* () {
        return yield (call === null || call === void 0 ? void 0 : call.hangUp({
            forEveryone: forEveryone === true ? true : false
        }));
    });
    const onCreateLocalStreamView = (options = {
        scalingMode: 'Crop',
        isMirrored: true
    }) => __awaiter$I(void 0, void 0, void 0, function* () {
        var _c;
        if (!call || call.localVideoStreams.length === 0) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            return;
        }
        const localStream = callState.localVideoStreams.find(item => item.mediaStreamType === 'Video');
        if (!localStream) {
            return;
        }
        const { view } = (_c = (yield callClient.createView(call.id, undefined, localStream, options))) !== null && _c !== void 0 ? _c : {};
        return view ? {
            view
        } : undefined;
    });
    const onCreateRemoteStreamView = (userId, options = {
        scalingMode: 'Crop'
    }) => __awaiter$I(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find(participant => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        // Find the first available stream, if there is none, then get the first stream
        const remoteVideoStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'Video' && i.isAvailable) || Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'Video');
        const screenShareStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'ScreenSharing' && i.isAvailable) || Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'ScreenSharing');
        let createViewResult = undefined;
        if (remoteVideoStream && remoteVideoStream.isAvailable && !remoteVideoStream.view) {
            createViewResult = yield callClient.createView(call.id, participant.identifier, remoteVideoStream, options);
        }
        if (screenShareStream && screenShareStream.isAvailable && !screenShareStream.view) {
            // Hardcoded `scalingMode` since it is highly unlikely that CONTOSO would ever want to use a different scaling mode for screenshare.
            // Using `Crop` would crop the contents of screenshare and `Stretch` would warp it.
            // `Fit` is the only mode that maintains the integrity of the screen being shared.
            createViewResult = yield callClient.createView(call.id, participant.identifier, screenShareStream, {
                scalingMode: 'Fit'
            });
        }
        return (createViewResult === null || createViewResult === void 0 ? void 0 : createViewResult.view) ? {
            view: createViewResult === null || createViewResult === void 0 ? void 0 : createViewResult.view
        } : undefined;
    });
    const onDisposeRemoteStreamView = (userId) => __awaiter$I(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find(participant => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        const remoteVideoStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'Video');
        const screenShareStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'ScreenSharing');
        if (remoteVideoStream && remoteVideoStream.view) {
            callClient.disposeView(call.id, participant.identifier, remoteVideoStream);
        }
        if (screenShareStream && screenShareStream.view) {
            callClient.disposeView(call.id, participant.identifier, screenShareStream);
        }
    });
    const onDisposeRemoteVideoStreamView = (userId) => __awaiter$I(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find(participant => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        const remoteVideoStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'Video');
        if (remoteVideoStream && remoteVideoStream.view) {
            callClient.disposeView(call.id, participant.identifier, remoteVideoStream);
        }
    });
    const onDisposeRemoteScreenShareStreamView = (userId) => __awaiter$I(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find(participant => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        const screenShareStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'ScreenSharing');
        if (screenShareStream && screenShareStream.view) {
            callClient.disposeView(call.id, participant.identifier, screenShareStream);
        }
    });
    const onDisposeLocalStreamView = () => __awaiter$I(void 0, void 0, void 0, function* () {
        // If the user is currently in a call, dispose of the local stream view attached to that call.
        const callState = call && callClient.getState().calls[call.id];
        const localStream = callState === null || callState === void 0 ? void 0 : callState.localVideoStreams.find(item => item.mediaStreamType === 'Video');
        if (call && callState && localStream) {
            callClient.disposeView(call.id, undefined, localStream);
        }
        // If the user is not in a call we currently assume any unparented view is a LocalPreview and stop all
        // since those are only used for LocalPreview currently.
        // TODO: we need to remember which LocalVideoStream was used for LocalPreview and dispose that one.
        yield disposeAllLocalPreviewViews(callClient);
    });
    /* @conditional-compile-remove(dialpad) */ /* @conditional-compile-remove(PSTN-calls) */
    const onSendDtmfTone = (dtmfTone) => __awaiter$I(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.sendDtmf(dtmfTone)); });
    const notImplemented = () => {
        throw new Error('Not implemented, cannot call a method from an abstract object');
    };
    /* @conditional-compile-remove(video-background-effects) */
    const onRemoveVideoBackgroundEffects = () => __awaiter$I(void 0, void 0, void 0, function* () {
        const stream = (call === null || call === void 0 ? void 0 : call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video')) || (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.getUnparentedVideoStreams().find(stream => stream.mediaStreamType === 'Video'));
        if (stream) {
            if (!(options === null || options === void 0 ? void 0 : options.onResolveVideoBackgroundEffectsDependency)) {
                throw new Error(`Video background effects dependency not resolved`);
            }
            else {
                return stream.feature(communicationCalling.Features.VideoEffects).stopEffects();
            }
        }
    });
    /* @conditional-compile-remove(video-background-effects) */
    const onBlurVideoBackground = (backgroundBlurConfig) => __awaiter$I(void 0, void 0, void 0, function* () {
        var _d;
        const stream = (call === null || call === void 0 ? void 0 : call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video')) || (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.getUnparentedVideoStreams().find(stream => stream.mediaStreamType === 'Video'));
        if (stream) {
            if (!(options === null || options === void 0 ? void 0 : options.onResolveVideoBackgroundEffectsDependency)) {
                throw new Error(`Video background effects dependency not resolved`);
            }
            const createEffect = (options === null || options === void 0 ? void 0 : options.onResolveVideoBackgroundEffectsDependency) && ((_d = (yield options.onResolveVideoBackgroundEffectsDependency())) === null || _d === void 0 ? void 0 : _d.createBackgroundBlurEffect);
            return createEffect && stream.feature(communicationCalling.Features.VideoEffects).startEffects(createEffect(backgroundBlurConfig));
        }
    });
    /* @conditional-compile-remove(video-background-effects) */
    const onReplaceVideoBackground = (backgroundReplacementConfig) => __awaiter$I(void 0, void 0, void 0, function* () {
        var _e;
        const stream = (call === null || call === void 0 ? void 0 : call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video')) || (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.getUnparentedVideoStreams().find(stream => stream.mediaStreamType === 'Video'));
        if (stream) {
            if (!(options === null || options === void 0 ? void 0 : options.onResolveVideoBackgroundEffectsDependency)) {
                throw new Error(`Video background effects dependency not resolved`);
            }
            const createEffect = (options === null || options === void 0 ? void 0 : options.onResolveVideoBackgroundEffectsDependency) && ((_e = (yield options.onResolveVideoBackgroundEffectsDependency())) === null || _e === void 0 ? void 0 : _e.createBackgroundReplacementEffect);
            return createEffect && stream.feature(communicationCalling.Features.VideoEffects).startEffects(createEffect(backgroundReplacementConfig));
        }
    });
    /* @conditional-compile-remove(close-captions) */
    const onStartCaptions = (options) => __awaiter$I(void 0, void 0, void 0, function* () {
        const captionsFeature = call === null || call === void 0 ? void 0 : call.feature(communicationCalling.Features.Captions).captions;
        yield (captionsFeature === null || captionsFeature === void 0 ? void 0 : captionsFeature.startCaptions(options));
    });
    /* @conditional-compile-remove(close-captions) */
    const onStopCaptions = () => __awaiter$I(void 0, void 0, void 0, function* () {
        const captionsFeature = call === null || call === void 0 ? void 0 : call.feature(communicationCalling.Features.Captions).captions;
        yield (captionsFeature === null || captionsFeature === void 0 ? void 0 : captionsFeature.stopCaptions());
    });
    /* @conditional-compile-remove(close-captions) */
    const onSetSpokenLanguage = (language) => __awaiter$I(void 0, void 0, void 0, function* () {
        const captionsFeature = call === null || call === void 0 ? void 0 : call.feature(communicationCalling.Features.Captions).captions;
        yield (captionsFeature === null || captionsFeature === void 0 ? void 0 : captionsFeature.setSpokenLanguage(language));
    });
    /* @conditional-compile-remove(close-captions) */
    const onSetCaptionLanguage = (language) => __awaiter$I(void 0, void 0, void 0, function* () {
        const captionsFeature = call === null || call === void 0 ? void 0 : call.feature(communicationCalling.Features.Captions).captions;
        yield captionsFeature.setCaptionLanguage(language);
    });
    return {
        onHangUp,
        onSelectCamera,
        onSelectMicrophone,
        onSelectSpeaker,
        onStartScreenShare,
        onStopScreenShare,
        onToggleCamera,
        onToggleMicrophone,
        onToggleScreenShare,
        onCreateLocalStreamView,
        onCreateRemoteStreamView,
        onStartLocalVideo,
        onDisposeRemoteStreamView,
        onDisposeLocalStreamView,
        onDisposeRemoteScreenShareStreamView,
        onDisposeRemoteVideoStreamView,
        /* @conditional-compile-remove(raise-hand) */
        onRaiseHand,
        /* @conditional-compile-remove(raise-hand) */
        onLowerHand,
        /* @conditional-compile-remove(raise-hand) */
        onToggleRaiseHand,
        onRemoveParticipant: notImplemented,
        onStartCall: notImplemented,
        /* @conditional-compile-remove(dialpad) */ /* @conditional-compile-remove(PSTN-calls) */ onSendDtmfTone,
        /* @conditional-compile-remove(video-background-effects) */
        onRemoveVideoBackgroundEffects,
        /* @conditional-compile-remove(video-background-effects) */
        onBlurVideoBackground,
        /* @conditional-compile-remove(video-background-effects) */
        onReplaceVideoBackground,
        /* @conditional-compile-remove(close-captions) */
        onStartCaptions,
        /* @conditional-compile-remove(close-captions) */
        onStopCaptions,
        /* @conditional-compile-remove(close-captions) */
        onSetCaptionLanguage,
        /* @conditional-compile-remove(close-captions) */
        onSetSpokenLanguage
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$H = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Create the default implementation of {@link CallingHandlers} for teams call.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const createDefaultCallingHandlers = memoizeOne((...args) => {
    const [callClient, callAgent, deviceManager, call, /* @conditional-compile-remove(video-background-effects) */ options] = args;
    return Object.assign(Object.assign({}, createDefaultCommonCallingHandlers(callClient, deviceManager, call, /* @conditional-compile-remove(video-background-effects) */ options)), { 
        // FIXME: onStartCall API should use string, not the underlying SDK types.
        onStartCall: (participants, options) => {
            if (!isACSCallParticipants(participants)) {
                throw new Error('TeamsUserIdentifier in Teams call is not supported!');
            }
            return callAgent === null || callAgent === void 0 ? void 0 : callAgent.startCall(participants, options);
        }, onRemoveParticipant: (userId) => __awaiter$H(void 0, void 0, void 0, function* () {
            const participant = _toCommunicationIdentifier(userId);
            yield (call === null || call === void 0 ? void 0 : call.removeParticipant(participant));
        }) });
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(close-captions) */
/* @conditional-compile-remove(close-captions) */
/**
 * Selector for {@link StartCaptionsButton} component.
 *
 * @internal
 */
const _startCaptionsButtonSelector = reselect__namespace.createSelector([getCaptionsStatus$1, getCurrentCaptionLanguage, getCurrentSpokenLanguage], (isCaptionsFeatureActive, currentCaptionLanguage, currentSpokenLanguage) => {
    return {
        checked: isCaptionsFeatureActive !== null && isCaptionsFeatureActive !== void 0 ? isCaptionsFeatureActive : false,
        currentCaptionLanguage: currentCaptionLanguage !== null && currentCaptionLanguage !== void 0 ? currentCaptionLanguage : '',
        currentSpokenLanguage: currentSpokenLanguage !== null && currentSpokenLanguage !== void 0 ? currentSpokenLanguage : 'en-us'
    };
});
/* @conditional-compile-remove(close-captions) */
/**
 * Selector for Changing caption language and spoken language
 *
 * @internal
 */
const _captionSettingsSelector = reselect__namespace.createSelector([getSupportedCaptionLanguages, getCurrentCaptionLanguage, getSupportedSpokenLanguages, getCurrentSpokenLanguage, getCaptionsStatus$1], (supportedCaptionLanguages, currentCaptionLanguage, supportedSpokenLanguages, currentSpokenLanguage, isCaptionsFeatureActive) => {
    return {
        supportedCaptionLanguages: supportedCaptionLanguages !== null && supportedCaptionLanguages !== void 0 ? supportedCaptionLanguages : [],
        currentCaptionLanguage: currentCaptionLanguage !== null && currentCaptionLanguage !== void 0 ? currentCaptionLanguage : 'en',
        supportedSpokenLanguages: supportedSpokenLanguages !== null && supportedSpokenLanguages !== void 0 ? supportedSpokenLanguages : ['en-us'],
        currentSpokenLanguage: currentSpokenLanguage !== null && currentSpokenLanguage !== void 0 ? currentSpokenLanguage : 'en-us',
        isCaptionsFeatureActive: isCaptionsFeatureActive !== null && isCaptionsFeatureActive !== void 0 ? isCaptionsFeatureActive : false
    };
});
/* @conditional-compile-remove(close-captions) */
/**
 * Selector for {@link CaptionsBanner} component.
 *
 * @internal
 */
const _captionsBannerSelector = reselect__namespace.createSelector([getCaptions, getCaptionsStatus$1, getStartCaptionsInProgress], (captions, isCaptionsFeatureActive, startCaptionsInProgress) => {
    // Following Teams app logic, no matter how many 'Partial' captions come,
    // we only pick first one according to start time, and all the other partial captions will be filtered out
    // This will give customers a stable captions experience when others talking over the dominant speaker
    const captionsToRender = captions === null || captions === void 0 ? void 0 : captions.filter(captions => captions.resultType === 'Final');
    const firstPartialCaptions = captions === null || captions === void 0 ? void 0 : captions.filter(captions => captions.resultType === 'Partial').sort(captionsComparator)[0];
    firstPartialCaptions && (captionsToRender === null || captionsToRender === void 0 ? void 0 : captionsToRender.push(firstPartialCaptions));
    const captionsInfo = captionsToRender === null || captionsToRender === void 0 ? void 0 : captionsToRender.map(c => {
        var _a, _b;
        const userId = getCaptionsSpeakerIdentifier(c);
        return {
            id: c.timestamp.getTime() + userId + c.speaker.displayName,
            displayName: (_a = c.speaker.displayName) !== null && _a !== void 0 ? _a : 'Unnamed Participant',
            captionText: (_b = c.captionText) !== null && _b !== void 0 ? _b : '',
            userId
        };
    });
    return {
        captions: captionsInfo !== null && captionsInfo !== void 0 ? captionsInfo : [],
        isCaptionsOn: isCaptionsFeatureActive !== null && isCaptionsFeatureActive !== void 0 ? isCaptionsFeatureActive : false,
        startCaptionsInProgress: startCaptionsInProgress !== null && startCaptionsInProgress !== void 0 ? startCaptionsInProgress : false
    };
});
/* @conditional-compile-remove(close-captions) */
const captionsComparator = (captionsA, captionsB) => {
    return captionsA.timestamp.getTime() - captionsB.timestamp.getTime() || getCaptionsSpeakerIdentifier(captionsA).localeCompare(getCaptionsSpeakerIdentifier(captionsB));
};
/* @conditional-compile-remove(close-captions) */
const getCaptionsSpeakerIdentifier = (captions) => {
    return captions.speaker.identifier ? toFlatCommunicationIdentifier(captions.speaker.identifier) : '';
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$G = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyDeviceManager proxies DeviceManager and subscribes to all events that affect device manager state. State updates
 * are set on the provided context. Also any queries for state are proxied and stored in state as well. Only one device
 * manager should exist for a given CallClient so if CallClient.getDeviceManager is called multiple times, either a
 * cached ProxyDeviceManager should be returned or the existing ProxyDeviceManager should be destructed via destructor()
 * and a new ProxyDeviceManager created.
 */
class ProxyDeviceManager {
    constructor(deviceManager, context) {
        this.setDeviceManager = () => {
            // isSpeakerSelectionAvailable, selectedMicrophone, and selectedSpeaker are properties on DeviceManager. Since they
            // are not functions we can't proxy them so we'll update whenever we think they may need updating such as at
            // construction time or when certain events happen.
            this._context.setDeviceManagerIsSpeakerSelectionAvailable(this._deviceManager.isSpeakerSelectionAvailable);
            this._context.setDeviceManagerSelectedMicrophone(this._deviceManager.selectedMicrophone);
            this._context.setDeviceManagerSelectedSpeaker(this._deviceManager.selectedSpeaker);
        };
        this.subscribe = () => {
            this._deviceManager.on('videoDevicesUpdated', this.videoDevicesUpdated);
            this._deviceManager.on('audioDevicesUpdated', this.audioDevicesUpdated);
            this._deviceManager.on('selectedMicrophoneChanged', this.selectedMicrophoneChanged);
            this._deviceManager.on('selectedSpeakerChanged', this.selectedSpeakerChanged);
        };
        /**
         * This is used to unsubscribe DeclarativeDeviceManager from the DeviceManager events.
         */
        this.unsubscribe = () => {
            this._deviceManager.off('videoDevicesUpdated', this.videoDevicesUpdated);
            this._deviceManager.off('audioDevicesUpdated', this.audioDevicesUpdated);
            this._deviceManager.off('selectedMicrophoneChanged', this.selectedMicrophoneChanged);
            this._deviceManager.off('selectedSpeakerChanged', this.selectedSpeakerChanged);
        };
        /**
         * Used to set a camera inside the proxy device manager.
         *
         * @param videoDeviceInfo VideoDeviceInfo
         */
        this.selectCamera = (videoDeviceInfo) => {
            this._context.setDeviceManagerSelectedCamera(videoDeviceInfo);
        };
        this.videoDevicesUpdated = () => __awaiter$G(this, void 0, void 0, function* () {
            // Device Manager always has a camera with '' name if there are no real camera devices available.
            // We don't want to show that in the UI.
            const realCameras = (yield this._deviceManager.getCameras()).filter(c => !!c.name);
            this._context.setDeviceManagerCameras(dedupeById(realCameras));
        });
        this.audioDevicesUpdated = () => __awaiter$G(this, void 0, void 0, function* () {
            this._context.setDeviceManagerMicrophones(dedupeById(yield this._deviceManager.getMicrophones()));
            this._context.setDeviceManagerSpeakers(dedupeById(yield this._deviceManager.getSpeakers()));
        });
        this.selectedMicrophoneChanged = () => {
            this._context.setDeviceManagerSelectedMicrophone(this._deviceManager.selectedMicrophone);
        };
        this.selectedSpeakerChanged = () => {
            this._context.setDeviceManagerSelectedSpeaker(this._deviceManager.selectedSpeaker);
        };
        this._deviceManager = deviceManager;
        this._context = context;
        this.setDeviceManager();
        this.subscribe();
    }
    get(target, prop) {
        switch (prop) {
            case 'getCameras':
                {
                    return this._context.withAsyncErrorTeedToState(() => {
                        return target.getCameras().then((cameras) => {
                            // Device Manager always has a camera with '' name if there are no real camera devices available.
                            // We don't want to show that in the UI.
                            const realCameras = cameras.filter(c => !!c.name);
                            this._context.setDeviceManagerCameras(dedupeById(realCameras));
                            return realCameras;
                        });
                    }, 'DeviceManager.getCameras');
                }
            case 'getMicrophones':
                {
                    return this._context.withAsyncErrorTeedToState(() => {
                        return target.getMicrophones().then((microphones) => {
                            this._context.setDeviceManagerMicrophones(dedupeById(microphones));
                            return microphones;
                        });
                    }, 'DeviceManager.getMicrophones');
                }
            case 'getSpeakers':
                {
                    return this._context.withAsyncErrorTeedToState(() => {
                        return target.getSpeakers().then((speakers) => {
                            this._context.setDeviceManagerSpeakers(dedupeById(speakers));
                            return speakers;
                        });
                    }, 'DeviceManager.getSpeakers');
                }
            case 'selectMicrophone':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => {
                        return target.selectMicrophone(...args).then(() => {
                            this._context.setDeviceManagerSelectedMicrophone(target.selectedMicrophone);
                        });
                    }, 'DeviceManager.selectMicrophone');
                }
            case 'selectSpeaker':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => {
                        return target.selectSpeaker(...args).then(() => {
                            this._context.setDeviceManagerSelectedSpeaker(target.selectedSpeaker);
                        });
                    }, 'DeviceManager.selectSpeaker');
                }
            case 'askDevicePermission':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => {
                        return target.askDevicePermission(...args).then((deviceAccess) => {
                            this._context.setDeviceManagerDeviceAccess(deviceAccess);
                            this.setDeviceManager();
                            return deviceAccess;
                        });
                    }, 'DeviceManager.askDevicePermission');
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
// TODO: Remove this when SDK no longer returns duplicate audio and video devices
/** Helper function to dedupe duplicate audio and video devices obtained from SDK */
const dedupeById = (devices) => {
    const ids = new Set();
    const uniqueDevices = [];
    devices.forEach((device) => {
        if (!ids.has(device.id)) {
            uniqueDevices.push(device);
            ids.add(device.id);
        }
    });
    return uniqueDevices;
};
/**
 * Creates a declarative DeviceManager by proxying DeviceManager with ProxyDeviceManager. The declarative DeviceManager
 * will put state updates in the given context.
 *
 * @param deviceManager - DeviceManager from SDK
 * @param context - CallContext from StatefulCallClient
 *
 * @private
 */
const deviceManagerDeclaratify = (deviceManager, context, internalContext) => {
    const proxyDeviceManager = new ProxyDeviceManager(deviceManager, context);
    Object.defineProperty(deviceManager, 'unsubscribe', {
        configurable: false,
        value: () => proxyDeviceManager.unsubscribe()
    });
    Object.defineProperty(deviceManager, 'selectCamera', {
        configurable: false,
        value: (videoDeviceInfo) => proxyDeviceManager.selectCamera(videoDeviceInfo)
    });
    /* @conditional-compile-remove(video-background-effects) */
    Object.defineProperty(deviceManager, 'getUnparentedVideoStreams', {
        configurable: false,
        value: () => internalContext.getUnparentedRenderInfos()
    });
    return new Proxy(deviceManager, proxyDeviceManager);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Error thrown from failed stateful API methods.
 *
 * @public
 */
class CallError extends Error {
    constructor(target, innerError, timestamp) {
        super();
        this.target = target;
        this.innerError = innerError;
        // Testing note: It is easier to mock Date::now() than the Date() constructor.
        this.timestamp = timestamp !== null && timestamp !== void 0 ? timestamp : new Date(Date.now());
        this.name = 'CallError';
        this.message = `${this.target}: ${this.innerError.message}`;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const callingStatefulLogger = logger.createClientLogger('communication-react:calling-stateful');
/**
 * @private
 */
var EventNames;
(function (EventNames) {
    // Info
    EventNames["VIEW_RENDER_SUCCEED"] = "VIEW_RENDER_SUCCEED";
    EventNames["START_DISPOSE_STREAM"] = "START_DISPOSE_STREAM";
    EventNames["START_STREAM_RENDERING"] = "START_STREAM_RENDERING";
    EventNames["DISPOSING_RENDERER"] = "DISPOSING_RENDERER";
    EventNames["CREATING_VIEW"] = "CREATING_VIEW";
    // Warning
    EventNames["CREATE_STREAM_INVALID_PARAMS"] = "CREATE_STREAM_INVALID_PARAMS";
    EventNames["DISPOSE_STREAM_INVALID_PARAMS"] = "DISPOSE_STREAM_INVALID_PARAMS";
    EventNames["STREAM_ALREADY_RENDERED"] = "STREAM_ALREADY_RENDERED";
    EventNames["STREAM_ALREADY_DISPOSED"] = "STREAM_ALREADY_DISPOSED";
    EventNames["STREAM_STOPPING"] = "STREAM_STOPPING";
    EventNames["CREATED_STREAM_STOPPING"] = "CREATED_STREAM_STOPPING";
    EventNames["STREAM_RENDERING"] = "STREAM_RENDERING";
    // Error
    EventNames["STREAM_NOT_FOUND"] = "STREAM_NOT_FOUND";
    EventNames["RENDER_INFO_NOT_FOUND"] = "RENDER_INFO_NOT_FOUND";
    EventNames["DISPOSE_INFO_NOT_FOUND"] = "DISPOSE_INFO_NOT_FOUND";
    EventNames["RENDERER_NOT_FOUND"] = "RENDERER_NOT_FOUND";
    EventNames["CREATE_STREAM_FAIL"] = "CREATE_STREAM_FAIL";
})(EventNames || (EventNames = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 * Call Id will change during the call for at least 1 time
 * This is to avoid async bug that call id has been changed during an async-await function
 * but the function still uses stale call id to access state
 */
class CallIdHistory {
    constructor() {
        this._callIdHistory = new Map();
    }
    updateCallIdHistory(newCallId, oldCallId) {
        // callId for a call can fluctuate between some set of values.
        // But if a newCallId already exists, and maps to different call, we're in trouble.
        // This can only happen if a callId is reused across two distinct calls.
        const existing = this._callIdHistory.get(newCallId);
        if (existing !== undefined && this.latestCallId(newCallId) !== oldCallId) {
            console.trace(`${newCallId} alredy exists and maps to ${existing}, which is not the same as ${oldCallId}`);
        }
        // The latest callId never maps to another callId.
        this._callIdHistory.delete(newCallId);
        this._callIdHistory.set(oldCallId, newCallId);
    }
    latestCallId(callId) {
        let latest = callId;
        /* eslint no-constant-condition: ["error", { "checkLoops": false }] */
        while (true) {
            const newer = this._callIdHistory.get(latest);
            if (newer === undefined) {
                break;
            }
            latest = newer;
        }
        return latest;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
function convertSdkLocalStreamToDeclarativeLocalStream(stream) {
    /* @conditional-compile-remove(video-background-effects) */
    const localVideoStreamEffectsAPI = stream.feature(communicationCalling.Features.VideoEffects);
    return {
        source: stream.source,
        mediaStreamType: stream.mediaStreamType,
        view: undefined,
        /* @conditional-compile-remove(video-background-effects) */
        videoEffects: convertFromSDKToDeclarativeVideoStreamVideoEffects(localVideoStreamEffectsAPI.activeEffects)
    };
}
/**
 * @private
 */
function convertSdkRemoteStreamToDeclarativeRemoteStream(stream) {
    return {
        id: stream.id,
        mediaStreamType: stream.mediaStreamType,
        isAvailable: stream.isAvailable,
        view: undefined,
        streamSize: stream.size
    };
}
/**
 * @private
 */
function convertSdkParticipantToDeclarativeParticipant(participant) {
    const declarativeVideoStreams = {};
    for (const videoStream of participant.videoStreams) {
        declarativeVideoStreams[videoStream.id] = convertSdkRemoteStreamToDeclarativeRemoteStream(videoStream);
    }
    return {
        identifier: participant.identifier,
        displayName: participant.displayName,
        state: participant.state,
        callEndReason: participant.callEndReason,
        videoStreams: declarativeVideoStreams,
        isMuted: participant.isMuted,
        isSpeaking: participant.isSpeaking,
        /* @conditional-compile-remove(raise-hand) */
        raisedHand: undefined
    };
}
/**
 * @private
 *
 * Note at the time of writing only one LocalVideoStream is supported by the SDK.
 */
function convertSdkCallToDeclarativeCall(call) {
    const declarativeRemoteParticipants = {};
    call.remoteParticipants.forEach((participant) => {
        declarativeRemoteParticipants[toFlatCommunicationIdentifier(participant.identifier)] = convertSdkParticipantToDeclarativeParticipant(participant);
    });
    return {
        id: call.id,
        callerInfo: call.callerInfo,
        state: call.state,
        callEndReason: call.callEndReason,
        diagnostics: {
            network: {
                latest: {}
            },
            media: {
                latest: {}
            }
        },
        direction: call.direction,
        isMuted: call.isMuted,
        isScreenSharingOn: call.isScreenSharingOn,
        localVideoStreams: call.localVideoStreams.map(convertSdkLocalStreamToDeclarativeLocalStream),
        remoteParticipants: declarativeRemoteParticipants,
        remoteParticipantsEnded: {},
        recording: {
            isRecordingActive: false
        },
        /* @conditional-compile-remove(raise-hand) */
        raiseHand: {
            raisedHands: []
        },
        transcription: {
            isTranscriptionActive: false
        },
        screenShareRemoteParticipant: undefined,
        startTime: new Date(),
        endTime: undefined,
        /* @conditional-compile-remove(rooms) */
        role: call.role,
        /* @conditional-compile-remove(close-captions) */
        captionsFeature: {
            captions: [],
            supportedSpokenLanguages: [],
            supportedCaptionLanguages: [],
            currentCaptionLanguage: '',
            currentSpokenLanguage: '',
            isCaptionsFeatureActive: false,
            startCaptionsInProgress: false
        },
        /* @conditional-compile-remove(call-transfer) */
        transfer: {
            acceptedTransfers: {}
        },
        /* @conditional-compile-remove(optimal-video-count) */
        optimalVideoCount: {
            maxRemoteVideoStreams: call.feature(communicationCalling.Features.OptimalVideoCount).optimalVideoCount
        }
    };
}
/**
 * @private
 */
function convertSdkIncomingCallToDeclarativeIncomingCall(call) {
    return {
        id: call.id,
        callerInfo: call.callerInfo,
        startTime: new Date(),
        endTime: undefined
    };
}
/**
 * @private
 */
function convertFromSDKToDeclarativeVideoStreamRendererView(view) {
    return {
        scalingMode: view.scalingMode,
        isMirrored: view.isMirrored,
        target: view.target
    };
}
/* @conditional-compile-remove(close-captions) */
/**
 * @private
 */
function convertFromSDKToCaptionInfoState(caption) {
    return Object.assign({}, caption);
}
/* @conditional-compile-remove(video-background-effects) */
/** @private */
function convertFromSDKToDeclarativeVideoStreamVideoEffects(videoEffects) {
    return {
        activeEffects: videoEffects
    };
}
/* @conditional-compile-remove(raise-hand) */
/**
 * @private
 */
function convertFromSDKToRaisedHandState(raisedHand) {
    return {
        raisedHandOrderPosition: raisedHand.order
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$F = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
immer.enableMapSet();
// Needed to generate state diff for verbose logging.
immer.enablePatches();
// TODO: How can we make this configurable?
/**
 * @private
 */
const MAX_CALL_HISTORY_LENGTH = 10;
/**
 * @private
 */
let CallContext$2 = class CallContext {
    constructor(userId, maxListeners = 50) {
        this._callIdHistory = new CallIdHistory();
        /**
         * Tees direct errors to state.
         * @remarks
         * This is typically used for errors that are caught and intended to be shown to the user.
         *
         * @param error The raw error to report.
         * @param target The error target to tee error to.
         *
         * @private
         */
        this.teeErrorToState = (error, target) => {
            const callError = toCallError(target, error);
            this.setLatestError(target, callError);
        };
        this._logger = logger.createClientLogger('communication-react:calling-context');
        this._state = {
            calls: {},
            callsEnded: {},
            incomingCalls: {},
            incomingCallsEnded: {},
            deviceManager: {
                isSpeakerSelectionAvailable: false,
                cameras: [],
                microphones: [],
                speakers: [],
                unparentedViews: []
            },
            callAgent: undefined,
            userId: userId,
            latestErrors: {}
        };
        this._emitter = new EventEmitter();
        this._emitter.setMaxListeners(maxListeners);
        this._atomicId = 0;
    }
    getState() {
        return this._state;
    }
    modifyState(modifier) {
        const priorState = this._state;
        this._state = immer.produce(this._state, modifier, (patches) => {
            if (logger.getLogLevel() === 'verbose') {
                // Log to `info` because AzureLogger.verbose() doesn't show up in console.
                this._logger.info(`State change: ${_safeJSONStringify(patches)}`);
            }
        });
        if (this._state !== priorState) {
            this._emitter.emit('stateChanged', this._state);
        }
    }
    onStateChange(handler) {
        this._emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this._emitter.off('stateChanged', handler);
    }
    // Disposing of the CallAgentDeclarative will not clear the state. If we create a new CallAgentDeclarative, we should
    // make sure the state is clean because any left over state (if previous CallAgentDeclarative was disposed) may be
    // invalid.
    clearCallRelatedState() {
        this.modifyState((draft) => {
            draft.calls = {};
            draft.incomingCalls = {};
            draft.callsEnded = {};
            draft.incomingCallsEnded = {};
        });
    }
    setCallAgent(callAgent) {
        this.modifyState((draft) => {
            draft.callAgent = callAgent;
        });
    }
    setCall(call) {
        this.modifyState((draft) => {
            const latestCallId = this._callIdHistory.latestCallId(call.id);
            const existingCall = draft.calls[latestCallId];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
                existingCall.state = call.state;
                existingCall.callEndReason = call.callEndReason;
                existingCall.direction = call.direction;
                existingCall.isMuted = call.isMuted;
                existingCall.isScreenSharingOn = call.isScreenSharingOn;
                existingCall.localVideoStreams = call.localVideoStreams;
                existingCall.remoteParticipants = call.remoteParticipants;
                existingCall.transcription.isTranscriptionActive = call.transcription.isTranscriptionActive;
                /* @conditional-compile-remove(optimal-video-count) */
                existingCall.optimalVideoCount.maxRemoteVideoStreams = call.optimalVideoCount.maxRemoteVideoStreams;
                existingCall.recording.isRecordingActive = call.recording.isRecordingActive;
                /* @conditional-compile-remove(raise-hand) */
                existingCall.raiseHand.raisedHands = call.raiseHand.raisedHands;
                /* @conditional-compile-remove(raise-hand) */
                existingCall.raiseHand.localParticipantRaisedHand = call.raiseHand.localParticipantRaisedHand;
                /* @conditional-compile-remove(rooms) */
                existingCall.role = call.role;
                // We don't update the startTime and endTime if we are updating an existing active call
                /* @conditional-compile-remove(close-captions) */
                existingCall.captionsFeature.currentSpokenLanguage = call.captionsFeature.currentSpokenLanguage;
                /* @conditional-compile-remove(close-captions) */
                existingCall.captionsFeature.currentCaptionLanguage = call.captionsFeature.currentCaptionLanguage;
            }
            else {
                draft.calls[latestCallId] = call;
            }
        });
    }
    removeCall(callId) {
        this.modifyState((draft) => {
            delete draft.calls[this._callIdHistory.latestCallId(callId)];
        });
    }
    setCallEnded(callId, callEndReason) {
        const latestCallId = this._callIdHistory.latestCallId(callId);
        this.modifyState((draft) => {
            const call = draft.calls[latestCallId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.calls[latestCallId];
                // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.callsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.callsEnded[findOldestCallEnded(draft.callsEnded)];
                }
                draft.callsEnded[latestCallId] = call;
            }
        });
    }
    setCallState(callId, state) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.state = state;
            }
        });
    }
    setCallId(newCallId, oldCallId) {
        this._callIdHistory.updateCallIdHistory(newCallId, oldCallId);
        this.modifyState((draft) => {
            const call = draft.calls[oldCallId];
            if (call) {
                call.id = newCallId;
                delete draft.calls[oldCallId];
                draft.calls[newCallId] = call;
            }
        });
    }
    setCallIsScreenSharingOn(callId, isScreenSharingOn) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.isScreenSharingOn = isScreenSharingOn;
            }
        });
    }
    setCallRemoteParticipants(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipants[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipants[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
                // TODO: need to remove after contentSharingRole avaible in WebCalling SDK.
            }
        });
    }
    setCallRemoteParticipantsEnded(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipantsEnded[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipantsEnded[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
            }
        });
    }
    setCallLocalVideoStream(callId, streamsAdded, streamsRemoved) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                for (const removedStream of streamsRemoved) {
                    const index = call.localVideoStreams.findIndex(i => i.mediaStreamType === removedStream.mediaStreamType);
                    if (index > -1) {
                        call.localVideoStreams.splice(index, 1);
                    }
                }
                for (const addedStream of streamsAdded) {
                    const index = call.localVideoStreams.findIndex(i => i.mediaStreamType === addedStream.mediaStreamType);
                    if (index > -1) {
                        call.localVideoStreams[index] = addedStream;
                    }
                    else {
                        call.localVideoStreams.push(addedStream);
                    }
                }
            }
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    setCallLocalVideoStreamVideoEffects(callId, videoEffects) {
        this.modifyState((draft) => {
            var _a;
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const stream = (_a = call.localVideoStreams) === null || _a === void 0 ? void 0 : _a.find(i => i.mediaStreamType === 'Video');
                if (stream) {
                    stream.videoEffects = videoEffects;
                }
            }
        });
    }
    setCallIsMicrophoneMuted(callId, isMicrophoneMuted) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.isMuted = isMicrophoneMuted;
            }
        });
    }
    /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(capabilities) */
    setRole(callId, role) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.role = role;
            }
        });
    }
    setCallDominantSpeakers(callId, dominantSpeakers) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.dominantSpeakers = dominantSpeakers;
            }
        });
    }
    setCallRecordingActive(callId, isRecordingActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.recording.isRecordingActive = isRecordingActive;
            }
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    setCallRaisedHands(callId, raisedHands) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.raiseHand.raisedHands = raisedHands.map(raisedHand => {
                    return convertFromSDKToRaisedHandState(raisedHand);
                });
                const raisedHand = raisedHands.find(raisedHand => toFlatCommunicationIdentifier(raisedHand.identifier) === toFlatCommunicationIdentifier(this._state.userId));
                if (raisedHand) {
                    call.raiseHand.localParticipantRaisedHand = convertFromSDKToRaisedHandState(raisedHand);
                }
                else {
                    call.raiseHand.localParticipantRaisedHand = undefined;
                }
            }
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    setParticipantIsRaisedHand(callId, participantKey, raisedHand) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.raisedHand = raisedHand ? convertFromSDKToRaisedHandState(raisedHand) : raisedHand;
                }
            }
        });
    }
    setCallTranscriptionActive(callId, isTranscriptionActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.transcription.isTranscriptionActive = isTranscriptionActive;
            }
        });
    }
    /* @conditional-compile-remove(capabilities) */
    setCapabilities(callId, capabilities, capabilitiesChangeInfo) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.capabilitiesFeature = {
                    capabilities,
                    latestCapabilitiesChangeInfo: capabilitiesChangeInfo
                };
            }
        });
    }
    setCallScreenShareParticipant(callId, participantKey) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.screenShareRemoteParticipant = participantKey;
            }
        });
    }
    setLocalVideoStreamRendererView(callId, localVideoMediaStreamType, view) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const localVideoStream = call.localVideoStreams.find(localVideoStream => localVideoStream.mediaStreamType === localVideoMediaStreamType);
                if (localVideoStream) {
                    localVideoStream.view = view;
                }
            }
        });
    }
    setParticipantState(callId, participantKey, state) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.state = state;
                }
            }
        });
    }
    setParticipantIsMuted(callId, participantKey, muted) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isMuted = muted;
                }
            }
        });
    }
    /* @conditional-compile-remove(optimal-video-count) */
    setOptimalVideoCount(callId, optimalVideoCount) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.optimalVideoCount.maxRemoteVideoStreams = optimalVideoCount;
            }
        });
    }
    /* @conditional-compile-remove(rooms) */
    setParticipantRole(callId, participantKey, role) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.role = role;
                }
            }
        });
    }
    setParticipantDisplayName(callId, participantKey, displayName) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.displayName = displayName;
                }
            }
        });
    }
    setParticipantIsSpeaking(callId, participantKey, isSpeaking) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isSpeaking = isSpeaking;
                }
            }
        });
    }
    setParticipantVideoStream(callId, participantKey, stream) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    // Set is called by subscriber will not modify any rendered stream so if there is existing stream only
                    // modify the values that subscriber has access to.
                    const existingStream = participant.videoStreams[stream.id];
                    if (existingStream) {
                        existingStream.isAvailable = stream.isAvailable;
                        existingStream.mediaStreamType = stream.mediaStreamType;
                    }
                    else {
                        participant.videoStreams[stream.id] = stream;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamIsAvailable(callId, participantKey, streamId, isAvailable) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.isAvailable = isAvailable;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamSize(callId, participantKey, streamId, size) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.streamSize = size;
                    }
                }
            }
        });
    }
    setRemoteVideoStreams(callId, participantKey, addRemoteVideoStream, removeRemoteVideoStream) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    for (const id of removeRemoteVideoStream) {
                        delete participant.videoStreams[id];
                    }
                    for (const newStream of addRemoteVideoStream) {
                        // This should only be called by the subscriber and some properties are add by other components so if the
                        // stream already exists, only update the values that subscriber knows about.
                        const stream = participant.videoStreams[newStream.id];
                        if (stream) {
                            stream.mediaStreamType = newStream.mediaStreamType;
                            stream.isAvailable = newStream.isAvailable;
                        }
                        else {
                            participant.videoStreams[newStream.id] = newStream;
                        }
                    }
                }
            }
        });
    }
    setRemoteVideoStreamRendererView(callId, participantKey, streamId, view) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.view = view;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamViewScalingMode(callId, participantKey, streamId, scalingMode) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream && stream.view) {
                        stream.view.scalingMode = scalingMode;
                    }
                }
            }
        });
    }
    setIncomingCall(call) {
        this.modifyState((draft) => {
            const existingCall = draft.incomingCalls[call.id];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
            }
            else {
                draft.incomingCalls[call.id] = call;
            }
        });
    }
    removeIncomingCall(callId) {
        this.modifyState((draft) => {
            delete draft.incomingCalls[callId];
        });
    }
    setIncomingCallEnded(callId, callEndReason) {
        this.modifyState((draft) => {
            const call = draft.incomingCalls[callId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.incomingCalls[callId];
                // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.incomingCallsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.incomingCallsEnded[findOldestCallEnded(draft.incomingCallsEnded)];
                }
                draft.incomingCallsEnded[callId] = call;
            }
        });
    }
    setDeviceManagerIsSpeakerSelectionAvailable(isSpeakerSelectionAvailable) {
        this.modifyState((draft) => {
            draft.deviceManager.isSpeakerSelectionAvailable = isSpeakerSelectionAvailable;
        });
    }
    setDeviceManagerSelectedMicrophone(selectedMicrophone) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedMicrophone = selectedMicrophone;
        });
    }
    setDeviceManagerSelectedSpeaker(selectedSpeaker) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedSpeaker = selectedSpeaker;
        });
    }
    setDeviceManagerSelectedCamera(selectedCamera) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedCamera = selectedCamera;
        });
    }
    setDeviceManagerCameras(cameras) {
        this.modifyState((draft) => {
            /**
             * SDK initializes cameras with one dummy camera with value { id: 'camera:id', name: '', deviceType: 'USBCamera' } immediately after
             * camera permissions are granted. So selectedCamera will have this value before the actual cameras are obtained. Therefore we should reset
             * selectedCamera to the first camera when there are cameras AND when current selectedCamera does not exist in the new array of cameras *
             */
            if (cameras.length > 0 && !cameras.some(camera => { var _a; return camera.id === ((_a = draft.deviceManager.selectedCamera) === null || _a === void 0 ? void 0 : _a.id); })) {
                draft.deviceManager.selectedCamera = cameras[0];
            }
            draft.deviceManager.cameras = cameras;
        });
    }
    setDeviceManagerMicrophones(microphones) {
        this.modifyState((draft) => {
            draft.deviceManager.microphones = microphones;
        });
    }
    setDeviceManagerSpeakers(speakers) {
        this.modifyState((draft) => {
            draft.deviceManager.speakers = speakers;
        });
    }
    setDeviceManagerDeviceAccess(deviceAccess) {
        this.modifyState((draft) => {
            draft.deviceManager.deviceAccess = deviceAccess;
        });
    }
    setDeviceManagerUnparentedView(localVideoStream, view) {
        this.modifyState((draft) => {
            draft.deviceManager.unparentedViews.push({
                source: localVideoStream.source,
                mediaStreamType: localVideoStream.mediaStreamType,
                view: view
            });
        });
    }
    deleteDeviceManagerUnparentedView(localVideoStream) {
        this.modifyState((draft) => {
            const foundIndex = draft.deviceManager.unparentedViews.findIndex(stream => stream.mediaStreamType === localVideoStream.mediaStreamType);
            if (foundIndex !== -1) {
                draft.deviceManager.unparentedViews.splice(foundIndex, 1);
            }
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    setDeviceManagerUnparentedViewVideoEffects(localVideoStream, videoEffects) {
        this.modifyState((draft) => {
            const foundIndex = draft.deviceManager.unparentedViews.findIndex(stream => stream.mediaStreamType === localVideoStream.mediaStreamType);
            if (foundIndex !== -1) {
                draft.deviceManager.unparentedViews[foundIndex].videoEffects = videoEffects;
            }
        });
    }
    getAndIncrementAtomicId() {
        const id = this._atomicId;
        this._atomicId++;
        return id;
    }
    /* @conditional-compile-remove(close-captions) */
    processNewCaption(captions, newCaption) {
        // going through current captions to find the last caption said by the same speaker, remove that caption if it's partial and replace with the new caption
        for (let index = captions.length - 1; index >= 0; index--) {
            const currentCaption = captions[index];
            if (currentCaption && currentCaption.resultType !== 'Final' && currentCaption.speaker.identifier && newCaption.speaker.identifier && toFlatCommunicationIdentifier(currentCaption.speaker.identifier) === toFlatCommunicationIdentifier(newCaption.speaker.identifier)) {
                captions.splice(index, 1);
                break;
            }
        }
        captions.push(newCaption);
        // If the array length exceeds 50, remove the oldest caption
        if (captions.length > 50) {
            captions.shift();
        }
    }
    /* @conditional-compile-remove(close-captions) */
    addCaption(callId, caption) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const currentCaptionLanguage = call.captionsFeature.currentCaptionLanguage;
                if (caption.captionLanguage.toUpperCase() === currentCaptionLanguage.toUpperCase() || currentCaptionLanguage === '' || currentCaptionLanguage === undefined) {
                    this.processNewCaption(call.captionsFeature.captions, convertFromSDKToCaptionInfoState(caption));
                }
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    clearCaptions(callId) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.captions = [];
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setIsCaptionActive(callId, isCaptionsActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.isCaptionsFeatureActive = isCaptionsActive;
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setStartCaptionsInProgress(callId, startCaptionsInProgress) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.startCaptionsInProgress = startCaptionsInProgress;
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setSelectedSpokenLanguage(callId, spokenLanguage) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.currentSpokenLanguage = spokenLanguage;
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setSelectedCaptionLanguage(callId, captionLanguage) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.currentCaptionLanguage = captionLanguage;
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setAvailableCaptionLanguages(callId, captionLanguages) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.supportedCaptionLanguages = captionLanguages;
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setAvailableSpokenLanguages(callId, spokenLanguages) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.captionsFeature.supportedSpokenLanguages = spokenLanguages;
            }
        });
    }
    /* @conditional-compile-remove(call-transfer) */
    setAcceptedTransfer(callId, acceptedTransfer) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.transfer.acceptedTransfers[acceptedTransfer.callId] = acceptedTransfer;
            }
        });
    }
    /**
     * Tees any errors encountered in an async function to the state.
     *
     * @param action Async function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withAsyncErrorTeedToState(action, target) {
        return (...args) => __awaiter$F(this, void 0, void 0, function* () {
            try {
                return yield action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        });
    }
    /**
     * Tees any errors encountered in an function to the state.
     *
     * @param action Function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withErrorTeedToState(action, target) {
        return (...args) => {
            try {
                callingStatefulLogger.info(`Calling stateful client target function called: ${target}`);
                return action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        };
    }
    setLatestError(target, error) {
        this.modifyState((draft) => {
            draft.latestErrors[target] = error;
        });
    }
};
const toCallError = (target, error) => {
    if (error instanceof Error) {
        return new CallError(target, error);
    }
    return new CallError(target, new Error(error));
};
const findOldestCallEnded = (calls) => {
    var _a, _b, _c, _d;
    const callEntries = Object.entries(calls);
    let [oldestCallId, oldestCall] = callEntries[0];
    if (oldestCall.endTime === undefined) {
        return oldestCallId;
    }
    for (const [callId, call] of callEntries.slice(1)) {
        if (call.endTime === undefined) {
            return callId;
        }
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) < ((_d = (_c = oldestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            [oldestCallId, oldestCall] = [callId, call];
        }
    }
    return oldestCallId;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(close-captions) */
/**
 * @private
 */
class CaptionsSubscriber {
    constructor(callIdRef, context, captions) {
        this.subscribe = () => {
            this._captions.on('CaptionsActiveChanged', this.isCaptionsActiveChanged);
            this._captions.on('CaptionsReceived', this.onCaptionsReceived);
            this._captions.on('CaptionLanguageChanged', this.isCaptionLanguageChanged);
            this._captions.on('SpokenLanguageChanged', this.isSpokenLanguageChanged);
        };
        this.unsubscribe = () => {
            this._captions.off('CaptionsActiveChanged', this.isCaptionsActiveChanged);
            this._captions.off('CaptionsReceived', this.onCaptionsReceived);
            this._captions.off('CaptionLanguageChanged', this.isCaptionLanguageChanged);
            this._captions.off('SpokenLanguageChanged', this.isSpokenLanguageChanged);
        };
        this.onCaptionsReceived = (caption) => {
            this._context.addCaption(this._callIdRef.callId, caption);
        };
        this.isCaptionsActiveChanged = () => {
            this._context.setIsCaptionActive(this._callIdRef.callId, this._captions.isCaptionsFeatureActive);
        };
        this.isCaptionLanguageChanged = () => {
            this._context.setSelectedCaptionLanguage(this._callIdRef.callId, this._captions.activeCaptionLanguage);
        };
        this.isSpokenLanguageChanged = () => {
            this._context.setSelectedSpokenLanguage(this._callIdRef.callId, this._captions.activeSpokenLanguage);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._captions = captions;
        if (this._captions.isCaptionsFeatureActive) {
            this._context.setIsCaptionActive(this._callIdRef.callId, this._captions.isCaptionsFeatureActive);
        }
        this._context.setAvailableSpokenLanguages(this._callIdRef.callId, this._captions.supportedSpokenLanguages);
        if ('supportedCaptionLanguages' in this._captions) {
            this._context.setAvailableCaptionLanguages(this._callIdRef.callId, this._captions.supportedCaptionLanguages);
        }
        this._context.setSelectedSpokenLanguage(this._callIdRef.callId, this._captions.activeSpokenLanguage);
        this._context.setSelectedCaptionLanguage(this._callIdRef.callId, this._captions.activeCaptionLanguage);
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(video-background-effects) */
/* @conditional-compile-remove(video-background-effects) */
/**
 * Subscribes to a LocalVideoStream's video effects events and updates the call context appropriately.
 * @private
 */
class LocalVideoStreamVideoEffectsSubscriber {
    constructor(args) {
        this.subscribe = () => {
            this._localVideoStreamEffectsAPI.on('effectsStarted', this.effectsStarted);
            this._localVideoStreamEffectsAPI.on('effectsStopped', this.effectsStopped);
            this._localVideoStreamEffectsAPI.on('effectsError', this.effectsError);
        };
        this.unsubscribe = () => {
            this._localVideoStreamEffectsAPI.off('effectsStarted', this.effectsStarted);
            this._localVideoStreamEffectsAPI.off('effectsStopped', this.effectsStopped);
            this._localVideoStreamEffectsAPI.off('effectsError', this.effectsError);
        };
        this.effectsStarted = () => {
            this.updateStatefulVideoEffects();
        };
        this.effectsStopped = () => {
            this.updateStatefulVideoEffects();
        };
        this.effectsError = (error) => {
            // When there is an error the effects have stopped. Ensure state is updated to reflect if effects are active or not.
            this.updateStatefulVideoEffects();
            this._context.teeErrorToState(new Error(error.message), 'VideoEffectsFeature.startEffects');
        };
        this.updateStatefulVideoEffects = () => {
            const statefulVideoEffects = convertFromSDKToDeclarativeVideoStreamVideoEffects(this._localVideoStreamEffectsAPI.activeEffects);
            if (this._parent === 'unparented') {
                this._context.setDeviceManagerUnparentedViewVideoEffects(this._localVideoStream, statefulVideoEffects);
            }
            else {
                this._context.setCallLocalVideoStreamVideoEffects(this._parent.callId, statefulVideoEffects);
            }
        };
        this._parent = args.parent;
        this._context = args.context;
        this._localVideoStream = args.localVideoStream;
        this._localVideoStreamEffectsAPI = args.localVideoStreamEffectsAPI;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
class RemoteVideoStreamSubscriber {
    constructor(callIdRef, participantKey, remoteVideoStream, context) {
        this.subscribe = () => {
            this._remoteVideoStream.on('isAvailableChanged', this.isAvailableChanged);
            this._remoteVideoStream.on('sizeChanged', this.isSizeChanged);
            this.checkAndUpdateScreenShareState();
        };
        this.unsubscribe = () => {
            this._remoteVideoStream.off('isAvailableChanged', this.isAvailableChanged);
            this._remoteVideoStream.off('sizeChanged', this.isSizeChanged);
        };
        this.includesActiveScreenShareStream = (streams) => {
            for (const stream of Object.values(streams)) {
                if (stream.mediaStreamType === 'ScreenSharing' && stream.isAvailable) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Update the state with the active screen share stream. If there is an existing stream will overwrite it if this one
         * is active (newer stream takes priority). If there is an existing stream and this one is set to unavailable, and the
         * existing stream is different participant, then don't set the active screen share stream to undefined, else set it
         * to undefined.
         */
        this.checkAndUpdateScreenShareState = () => {
            var _a, _b, _c;
            if (this._remoteVideoStream.mediaStreamType !== 'ScreenSharing') {
                return;
            }
            if (this._remoteVideoStream.isAvailable) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, this._participantKey);
                return;
            }
            const existingScreenShare = (_a = this._context.getState().calls[this._callIdRef.callId]) === null || _a === void 0 ? void 0 : _a.screenShareRemoteParticipant;
            // If somehow we end up with an event where a RemoteParticipant's ScreenShare stream is set to
            // unavailable but there exists already another different participant actively sharing, and they are still
            // sharing then this event shouldn't set the screenShareRemoteParticipant to undefined.
            if (!existingScreenShare || existingScreenShare === this._participantKey) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
            const streams = (_c = (_b = this._context.getState().calls[this._callIdRef.callId]) === null || _b === void 0 ? void 0 : _b.remoteParticipants[existingScreenShare]) === null || _c === void 0 ? void 0 : _c.videoStreams;
            if (!streams) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
            // If the existing ScreenShare that is not owned by the current RemoteParticipant is still active, don't
            // overwrite it with undefined. So only overwrite if it is not active.
            if (!this.includesActiveScreenShareStream(streams)) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
        };
        this.isAvailableChanged = () => {
            this._context.setRemoteVideoStreamIsAvailable(this._callIdRef.callId, this._participantKey, this._remoteVideoStream.id, this._remoteVideoStream.isAvailable);
            this.checkAndUpdateScreenShareState();
        };
        this.isSizeChanged = () => {
            var _a, _b, _c, _d, _e, _f, _g;
            if (((_a = this._remoteVideoStream) === null || _a === void 0 ? void 0 : _a.size.width) === 0 && ((_b = this._remoteVideoStream) === null || _b === void 0 ? void 0 : _b.size.height) === 0) {
                return;
            }
            const streamSize = (_e = (_d = (_c = this._context.getState().calls[this._callIdRef.callId]) === null || _c === void 0 ? void 0 : _c.remoteParticipants[this._participantKey]) === null || _d === void 0 ? void 0 : _d.videoStreams[this._remoteVideoStream.id]) === null || _e === void 0 ? void 0 : _e.streamSize;
            const existingAspectRatio = streamSize ? streamSize.width / streamSize.height : undefined;
            const newAspectRatio = ((_f = this._remoteVideoStream) === null || _f === void 0 ? void 0 : _f.size.width) / ((_g = this._remoteVideoStream) === null || _g === void 0 ? void 0 : _g.size.height);
            if (!streamSize || existingAspectRatio !== newAspectRatio) {
                this._context.setRemoteVideoStreamSize(this._callIdRef.callId, this._participantKey, this._remoteVideoStream.id, this._remoteVideoStream.size);
            }
        };
        this._callIdRef = callIdRef;
        this._participantKey = participantKey;
        this._remoteVideoStream = remoteVideoStream;
        this._context = context;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * helper function to manage logging for stream disposals
 *
 * @param eventName Name of event that occured when managing streams
 * @param streamLogInfo Data about the stream in the event
 * @returns
 */
function _logDisposeStreamEvent(eventName, streamLogInfo) {
    switch (eventName) {
        case EventNames.DISPOSE_STREAM_INVALID_PARAMS:
            _logEvent(callingStatefulLogger, {
                name: EventNames.DISPOSE_STREAM_INVALID_PARAMS,
                level: 'warning',
                message: 'Dispose View invalid combination of parameters.',
                data: {
                    streamType: streamLogInfo.streamType
                }
            });
            return;
        case EventNames.START_DISPOSE_STREAM:
            _logEvent(callingStatefulLogger, {
                name: EventNames.START_DISPOSE_STREAM,
                level: 'info',
                message: 'Start disposing stream.',
                data: streamLogInfo
            });
            return;
        case EventNames.DISPOSE_INFO_NOT_FOUND:
            _logEvent(callingStatefulLogger, {
                name: EventNames.DISPOSE_INFO_NOT_FOUND,
                level: 'error',
                message: 'Cannot find render info when disposing stream.',
                data: streamLogInfo
            });
            return;
        case EventNames.STREAM_STOPPING:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_STOPPING,
                level: 'info',
                message: 'Stream is currently marked as stopping, will continue if is local preview',
                data: streamLogInfo
            });
            return;
        case EventNames.DISPOSING_RENDERER:
            _logEvent(callingStatefulLogger, {
                name: EventNames.DISPOSING_RENDERER,
                level: 'info',
                message: 'Disposing view renderer.',
                data: streamLogInfo
            });
            return;
        case EventNames.RENDERER_NOT_FOUND:
            _logEvent(callingStatefulLogger, {
                name: EventNames.RENDERER_NOT_FOUND,
                level: 'error',
                message: 'Cannot find renderer when disposing stream.',
                data: streamLogInfo
            });
            return;
        case EventNames.STREAM_ALREADY_DISPOSED:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_ALREADY_DISPOSED,
                level: 'info',
                message: 'Stream is already disposed.',
                data: streamLogInfo
            });
            return;
        default:
            return;
    }
}
/**
 * helper function to manage logging for local stream creations
 *
 * @param eventName Name of the event to occured when creating a local stream
 * @param streamLogInfo Data about the stream in the event
 * @param error that is thrown by caller
 * @returns
 */
function _logCreateStreamEvent(eventName, streamLogInfo, error) {
    switch (eventName) {
        case EventNames.CREATE_STREAM_INVALID_PARAMS:
            _logEvent(callingStatefulLogger, {
                name: EventNames.CREATE_STREAM_INVALID_PARAMS,
                level: 'warning',
                message: 'Create View invalid combination of parameters.',
                data: {
                    streamType: streamLogInfo.streamType
                }
            });
            return;
        case EventNames.START_STREAM_RENDERING:
            _logEvent(callingStatefulLogger, {
                name: EventNames.START_STREAM_RENDERING,
                level: 'info',
                message: 'Start creating view for local video.',
                data: streamLogInfo
            });
            return;
        case EventNames.STREAM_NOT_FOUND:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_NOT_FOUND,
                level: 'error',
                message: 'Stream not found in state.',
                data: {
                    callId: streamLogInfo.callId
                }
            });
            return;
        case EventNames.STREAM_ALREADY_RENDERED:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_ALREADY_RENDERED,
                level: 'warning',
                message: 'Stream is already rendered.',
                data: streamLogInfo
            });
            return;
        case EventNames.STREAM_RENDERING:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_RENDERING,
                level: 'warning',
                message: 'Stream is rendering.',
                data: streamLogInfo
            });
            return;
        case EventNames.STREAM_STOPPING:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_STOPPING,
                level: 'warning',
                message: 'Stream was marked as stopping by dispose view. Resetting state to "Rendering".',
                data: streamLogInfo
            });
            return;
        case EventNames.CREATE_STREAM_FAIL:
            _logEvent(callingStatefulLogger, {
                name: EventNames.CREATE_STREAM_FAIL,
                level: 'error',
                message: 'Failed to create view.',
                data: {
                    error: error,
                    streamType: streamLogInfo.streamType,
                    callId: streamLogInfo.callId
                }
            });
            return;
        case EventNames.RENDER_INFO_NOT_FOUND:
            _logEvent(callingStatefulLogger, {
                name: EventNames.RENDER_INFO_NOT_FOUND,
                level: 'error',
                message: 'Cannot find render info after create the view. ',
                data: streamLogInfo
            });
            return;
        case EventNames.CREATED_STREAM_STOPPING:
            _logEvent(callingStatefulLogger, {
                name: EventNames.CREATED_STREAM_STOPPING,
                level: 'warning',
                message: 'Render info status is stopping, dispose renderer.',
                data: streamLogInfo
            });
            return;
        case EventNames.VIEW_RENDER_SUCCEED:
            _logEvent(callingStatefulLogger, {
                name: EventNames.VIEW_RENDER_SUCCEED,
                level: 'info',
                message: `Successfully render the view.`,
                data: streamLogInfo
            });
            return;
        case EventNames.CREATING_VIEW:
            _logEvent(callingStatefulLogger, {
                name: EventNames.CREATING_VIEW,
                level: 'info',
                message: 'Start creating view for remote video.',
                data: streamLogInfo
            });
            return;
        default:
            return;
    }
}
/**
 * helper function to fire streamUtils logging events
 *
 * @param eventName Name of event from streamUtils
 * @param streamLogInfo informaiton about the event and who called it
 * @param error if any errors present will be added to message in logging
 */
function _logStreamEvent(eventName, streamLogInfo, error) {
    if (streamLogInfo.streamEventType === 'disposeViewLocal' || streamLogInfo.streamEventType === 'disposeViewRemote' || streamLogInfo.streamEventType === 'disposeViewUnparented') {
        _logDisposeStreamEvent(eventName, streamLogInfo);
    }
    else if (streamLogInfo.streamEventType === 'createViewLocal' || streamLogInfo.streamEventType === 'createViewRemote') {
        _logCreateStreamEvent(eventName, streamLogInfo, error);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$E = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createViewVideo(context, internalContext, callId, stream, participantId, options) {
    return __awaiter$E(this, void 0, void 0, function* () {
        // we can only have 3 types of createView
        let streamEventType;
        // we will reuse these for local as well but we need to make sure the remote stream is passed in like before.
        if (participantId) {
            streamEventType = 'createViewRemote';
        }
        else if (callId) {
            streamEventType = 'createViewLocal';
        }
        else {
            // TODO update for when unparented view.
            throw new Error('unparented createView not implemented yet here');
        }
        const streamType = stream === null || stream === void 0 ? void 0 : stream.mediaStreamType;
        const localStreamKey = stream.mediaStreamType;
        const remoteStreamId = stream.id;
        // we want to check to see if there is a participantId this will tell us whether its a local stream or a remote one.
        const participantKey = streamEventType === 'createViewRemote' && participantId ? typeof participantId === 'string' ? participantId : toFlatCommunicationIdentifier(participantId) : undefined;
        const streamLogInfo = {
            callId,
            participantKey,
            streamId: remoteStreamId !== null && remoteStreamId !== void 0 ? remoteStreamId : localStreamKey,
            streamType,
            streamEventType
        };
        // make different logging announcement based on whether or not we are starting a local or remote
        _logStreamEvent(EventNames.CREATING_VIEW, streamLogInfo);
        // if we have a participant Id and a stream get the remote info, else get the local render info from state.
        const renderInfo = streamEventType === 'createViewRemote' && participantKey ? internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, remoteStreamId) : internalContext.getLocalRenderInfo(callId, localStreamKey);
        if (!renderInfo) {
            _logStreamEvent(EventNames.STREAM_NOT_FOUND, streamLogInfo);
            return;
        }
        if (renderInfo.status === 'Rendered') {
            _logStreamEvent(EventNames.STREAM_ALREADY_RENDERED, streamLogInfo);
            return;
        }
        if (renderInfo.status === 'Rendering') {
            // Do not log to console here as this is a very common situation due to UI rerenders while
            // the video rendering is in progress.
            _logStreamEvent(EventNames.STREAM_RENDERING, streamLogInfo);
            return;
        }
        // "Stopping" only happens if the stream was in "rendering" but `disposeView` was called.
        // Now that `createView` has been re-called, we can flip the state back to "rendering".
        if (renderInfo.status === 'Stopping') {
            if (streamEventType === 'createViewRemote' && participantKey) {
                _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);
                internalContext.setRemoteRenderInfo(callId, participantKey, remoteStreamId, renderInfo.stream, 'Rendering', renderInfo.renderer);
            }
            else if (streamEventType === 'createViewLocal') {
                _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);
                internalContext.setLocalRenderInfo(callId, localStreamKey, renderInfo.stream, 'Rendering', renderInfo.renderer);
            }
            return;
        }
        const renderer = new communicationCalling.VideoStreamRenderer(renderInfo.stream);
        streamEventType === 'createViewRemote' && participantKey ? internalContext.setRemoteRenderInfo(callId, participantKey, remoteStreamId, renderInfo.stream, 'Rendering', undefined) : internalContext.setLocalRenderInfo(callId, localStreamKey, renderInfo.stream, 'Rendering', renderer);
        let view;
        try {
            view = yield renderer.createView(options);
        }
        catch (e) {
            if (streamEventType === 'createViewRemote' && participantKey) {
                _logStreamEvent(EventNames.CREATE_STREAM_FAIL, streamLogInfo);
                internalContext.setRemoteRenderInfo(callId, participantKey, remoteStreamId, renderInfo.stream, 'NotRendered', undefined);
            }
            else if (streamEventType === 'createViewLocal') {
                _logStreamEvent(EventNames.CREATE_STREAM_FAIL, streamLogInfo, e);
                internalContext.setLocalRenderInfo(callId, localStreamKey, renderInfo.stream, 'NotRendered', undefined);
            }
            throw e;
        }
        // Since render could take some time, we need to check if the stream is still valid and if we received a signal to
        // stop rendering.
        const refreshedRenderInfo = streamEventType === 'createViewRemote' && participantKey ? internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, remoteStreamId) : internalContext.getLocalRenderInfo(callId, localStreamKey);
        if (!refreshedRenderInfo) {
            // RenderInfo was removed. This should not happen unless stream was removed from the call so dispose the renderer
            // and clean up the state.
            _logStreamEvent(EventNames.RENDER_INFO_NOT_FOUND, streamLogInfo);
            renderer.dispose();
            streamEventType === 'createViewRemote' && participantKey ? context.setRemoteVideoStreamRendererView(callId, participantKey, remoteStreamId, undefined) : context.setLocalVideoStreamRendererView(callId, localStreamKey, undefined);
            return;
        }
        if (refreshedRenderInfo.status === 'Stopping') {
            _logStreamEvent(EventNames.CREATED_STREAM_STOPPING, streamLogInfo);
            renderer.dispose();
            if (streamEventType === 'createViewRemote' && participantKey) {
                internalContext.setRemoteRenderInfo(callId, participantKey, remoteStreamId, refreshedRenderInfo.stream, 'NotRendered', undefined);
                context.setRemoteVideoStreamRendererView(callId, participantKey, remoteStreamId, undefined);
            }
            else if (streamEventType === 'createViewLocal') {
                internalContext.setLocalRenderInfo(callId, localStreamKey, refreshedRenderInfo.stream, 'NotRendered', undefined);
                context.setLocalVideoStreamRendererView(callId, localStreamKey, undefined);
            }
            return;
        }
        // Else the stream still exists and status is not telling us to stop rendering. Complete the render process by
        // updating the state.
        if (streamEventType === 'createViewRemote' && participantKey) {
            internalContext.setRemoteRenderInfo(callId, participantKey, remoteStreamId, refreshedRenderInfo.stream, 'Rendered', renderer);
            context.setRemoteVideoStreamRendererView(callId, participantKey, remoteStreamId, convertFromSDKToDeclarativeVideoStreamRendererView(view));
            _logStreamEvent(EventNames.VIEW_RENDER_SUCCEED, streamLogInfo);
        }
        else if (streamEventType === 'createViewLocal') {
            internalContext.setLocalRenderInfo(callId, localStreamKey, refreshedRenderInfo.stream, 'Rendered', renderer);
            context.setLocalVideoStreamRendererView(callId, localStreamKey, convertFromSDKToDeclarativeVideoStreamRendererView(view));
            _logStreamEvent(EventNames.VIEW_RENDER_SUCCEED, streamLogInfo);
        }
        return {
            renderer,
            view
        };
    });
}
function createViewUnparentedVideo(context, internalContext, stream, options) {
    return __awaiter$E(this, void 0, void 0, function* () {
        const renderInfo = internalContext.getUnparentedRenderInfo(stream);
        if (renderInfo && renderInfo.status === 'Rendered') {
            console.warn('Unparented LocalVideoStream is already rendered');
            return;
        }
        if (renderInfo && renderInfo.status === 'Rendering') {
            // Do not log to console here as this is a very common situation due to UI rerenders while
            // the video rendering is in progress.
            return;
        }
        if (renderInfo && renderInfo.status === 'Stopping') {
            console.warn('Unparented LocalVideoStream is in the middle of stopping');
            return;
        }
        const localVideoStream = new communicationCalling.LocalVideoStream(stream.source);
        const renderer = new communicationCalling.VideoStreamRenderer(localVideoStream);
        internalContext.setUnparentedRenderInfo(stream, localVideoStream, 'Rendering', undefined);
        let view;
        try {
            view = yield renderer.createView(options);
        }
        catch (e) {
            // Special case for unparented views. Since they are not tied to anything and created by us based on the calls to
            // this function we'll delete it to clean up the data since keeping it around doesn't help us and if developer wants
            // to create a new view they can check that the view is not rendered and call this function again.
            internalContext.deleteUnparentedRenderInfo(stream);
            throw e;
        }
        // Since render could take some time, we need to check if the stream is still valid and if we received a signal to
        // stop rendering.
        const refreshedRenderInfo = internalContext.getUnparentedRenderInfo(stream);
        if (!refreshedRenderInfo) {
            // Unparented stream's RenderInfo was deleted. Currently this shouldn't happen but if it does we'll just dispose the
            // renderer and clean up state. If developer wanted the stream they could call this function again and that should
            // generate new working state via this function.
            renderer.dispose();
            context.deleteDeviceManagerUnparentedView(stream);
            return;
        }
        if (refreshedRenderInfo.status === 'Stopping') {
            // Stop render was called on this stream after we had started rendering. We will dispose this view and do not
            // put the view into the state. Special case for unparented views, delete them from state when stopped to free up
            // the memory since we were the ones generating this and not tied to any Call state.
            internalContext.deleteUnparentedRenderInfo(stream);
            context.deleteDeviceManagerUnparentedView(stream);
            return;
        }
        // Else the stream still exists and status is not telling us to stop rendering. Complete the render process by
        // updating the state.
        internalContext.setUnparentedRenderInfo(stream, localVideoStream, 'Rendered', renderer);
        internalContext.subscribeToUnparentedViewVideoEffects(localVideoStream, context);
        context.setDeviceManagerUnparentedView(stream, convertFromSDKToDeclarativeVideoStreamRendererView(view));
        return {
            renderer,
            view
        };
    });
}
function disposeViewVideo(context, internalContext, callId, stream, participantId) {
    // we can only have 3 types of createView
    let streamEventType;
    // we will reuse these for local as well but we need to make sure the remote stream is passed in like before.
    if (participantId) {
        streamEventType = 'disposeViewRemote';
    }
    else if (callId) {
        streamEventType = 'disposeViewLocal';
    }
    else {
        // TODO update for when unparented view.
        streamEventType = 'disposeViewUnparented';
    }
    const streamType = stream.mediaStreamType;
    const localStreamKey = stream.mediaStreamType;
    const remoteStreamId = stream.id;
    // we want to check to see if there is a participantId this will tell us whether its a local stream or a remote one.
    const participantKey = streamEventType === 'disposeViewRemote' && participantId ? typeof participantId === 'string' ? participantId : toFlatCommunicationIdentifier(participantId) : undefined;
    const streamLogInfo = {
        callId,
        participantKey,
        streamId: remoteStreamId !== null && remoteStreamId !== void 0 ? remoteStreamId : localStreamKey,
        streamType
    };
    _logStreamEvent(EventNames.START_DISPOSE_STREAM, streamLogInfo);
    if (streamEventType === 'disposeViewRemote' && participantKey) {
        context.setRemoteVideoStreamRendererView(callId, participantKey, remoteStreamId, undefined);
    }
    const renderInfo = streamEventType === 'disposeViewRemote' && participantKey ? internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, remoteStreamId) : internalContext.getLocalRenderInfo(callId, localStreamKey);
    if (!renderInfo) {
        _logStreamEvent(EventNames.DISPOSE_INFO_NOT_FOUND, streamLogInfo);
        return;
    }
    // Nothing to dispose of or clean up -- we can safely exit early here.
    if (renderInfo.status === 'NotRendered') {
        _logStreamEvent(EventNames.STREAM_ALREADY_DISPOSED, streamLogInfo);
        return;
    }
    // Status is already marked as "stopping" so we can exit early here. This is because stopping only occurs
    // when the stream is being created in createView but hasn't been completed being created yet. The createView
    // method will see the "stopping" status and perform the cleanup
    if (renderInfo.status === 'Stopping') {
        _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);
        return;
    }
    // If the stream is in the middle of being rendered (i.e. has state "Rendering"), we need the status as
    // "stopping" without performing any cleanup. This will tell the `createView` method that it should stop
    // rendering and clean up the state once the view has finished being created.
    if (renderInfo.status === 'Rendering') {
        _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);
        streamEventType === 'disposeViewRemote' && participantKey ? internalContext.setRemoteRenderInfo(callId, participantKey, remoteStreamId, renderInfo.stream, 'Stopping', undefined) : internalContext.setLocalRenderInfo(callId, localStreamKey, renderInfo.stream, 'Stopping', renderInfo.renderer);
        return;
    }
    if (renderInfo.renderer) {
        _logStreamEvent(EventNames.DISPOSING_RENDERER, streamLogInfo);
        renderInfo.renderer.dispose();
        // Else the state must be in the "Rendered" state, so we can dispose the renderer and clean up the state.
        if (streamEventType === 'disposeViewRemote' && participantKey) {
            internalContext.setRemoteRenderInfo(callId, participantKey, remoteStreamId, renderInfo.stream, 'NotRendered', undefined);
        }
        else if (streamEventType === 'disposeViewLocal') {
            internalContext.setLocalRenderInfo(callId, localStreamKey, renderInfo.stream, 'NotRendered', undefined);
            context.setLocalVideoStreamRendererView(callId, localStreamKey, undefined);
        }
    }
    else {
        _logStreamEvent(EventNames.RENDERER_NOT_FOUND, streamLogInfo);
    }
}
function disposeViewUnparentedVideo(context, internalContext, stream) {
    const streamType = stream.mediaStreamType;
    const streamLogInfo = {
        streamType,
        streamEventType: 'disposeViewUnparented'
    };
    _logStreamEvent(EventNames.START_DISPOSE_STREAM, streamLogInfo);
    context.deleteDeviceManagerUnparentedView(stream);
    const renderInfo = internalContext.getUnparentedRenderInfo(stream);
    if (!renderInfo) {
        _logStreamEvent(EventNames.DISPOSE_INFO_NOT_FOUND, streamLogInfo);
        return;
    }
    if (renderInfo.status === 'Rendering') {
        _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);
        internalContext.setUnparentedRenderInfo(stream, renderInfo.stream, 'Stopping', undefined);
    }
    else {
        internalContext.deleteUnparentedRenderInfo(stream);
    }
    if (renderInfo.renderer) {
        _logStreamEvent(EventNames.DISPOSING_RENDERER, streamLogInfo);
        renderInfo.renderer.dispose();
    }
    else {
        _logStreamEvent(EventNames.RENDERER_NOT_FOUND, streamLogInfo);
    }
}
/**
 * @private
 */
function createView(context, internalContext, callId, participantId, stream, options) {
    const streamType = stream.mediaStreamType;
    if (callId) {
        return createViewVideo(context, internalContext, callId, stream, participantId, options);
    }
    else if (!('id' in stream) && !callId) {
        // Render LocalVideoStream that is not part of a Call
        // Because it is not part of the call we don't tee errors to state naturally (e.g. via a Call Client function such as startVideo).
        // We do not have a startLocalPreviewVideo function, so as a workaround we ensure any errors are propagated here.
        return context.withAsyncErrorTeedToState(() => __awaiter$E(this, void 0, void 0, function* () { return yield createViewUnparentedVideo(context, internalContext, stream, options); }), 'Call.startVideo')();
    }
    else {
        _logStreamEvent(EventNames.CREATE_STREAM_INVALID_PARAMS, {
            streamType
        });
        return Promise.resolve(undefined);
    }
}
/**
 * @private
 */
function disposeView(context, internalContext, callId, participantId, stream) {
    const streamType = stream.mediaStreamType;
    if (callId) {
        disposeViewVideo(context, internalContext, callId, stream, participantId);
    }
    else if (!('id' in stream) && !callId) {
        // Stop rendering LocalVideoStream that is not part of a Call
        // Because it is not part of the call we don't tee errors to state naturally (e.g. via a Call Client function such as startVideo).
        // We do not have a stopLocalPreviewVideo function, so as a workaround we ensure any errors are propagated here.
        context.withErrorTeedToState(() => disposeViewUnparentedVideo(context, internalContext, stream), 'Call.stopVideo')();
    }
    else {
        _logStreamEvent(EventNames.DISPOSE_STREAM_INVALID_PARAMS, {
            streamType
        });
        return;
    }
}
/**
 * @private
 * Only stops videos that are tied to a Call.
 */
function disposeAllViewsFromCall(context, internalContext, callId) {
    const remoteStreams = internalContext.getRemoteRenderInfoForCall(callId);
    if (remoteStreams) {
        for (const [participantKey, participantStreams] of remoteStreams.entries()) {
            for (const [_, remoteStreamAndRenderer] of participantStreams.entries()) {
                // We don't want to accept SDK stream as parameter but we also don't cache the declarative stream so we have to
                // convert the SDK stream to declarative stream which is not pretty so this could use some further refactoring.
                disposeView(context, internalContext, callId, participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(remoteStreamAndRenderer.stream));
            }
        }
    }
    const localStreams = internalContext.getLocalRenderInfosForCall(callId);
    if (localStreams) {
        for (const localStreamAndRenderer of localStreams.values()) {
            if (localStreamAndRenderer && localStreamAndRenderer.renderer) {
                // We don't want to accept SDK stream as parameter but we also don't cache the declarative stream so we have to
                // convert the SDK stream to declarative stream which is not pretty so this could use some further refactoring.
                disposeView(context, internalContext, callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(localStreamAndRenderer.stream));
            }
        }
    }
}
/**
 * @private
 */
function disposeAllViews(context, internalContext) {
    const callIds = internalContext.getCallIds();
    for (const callId of callIds) {
        disposeAllViewsFromCall(context, internalContext, callId);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Keeps track of the listeners assigned to a particular participant because when we get an event from SDK, it doesn't
 * tell us which participant it is for. If we keep track of this then we know which participant in the state that needs
 * an update and also which property of that participant. Also we can use this when unregistering to a participant.
 */
let ParticipantSubscriber$1 = class ParticipantSubscriber {
    constructor(callIdRef, participant, context, internalContext) {
        this.subscribe = () => {
            this._participant.on('stateChanged', this.stateChanged);
            this._participant.on('isMutedChanged', this.isMutedChanged);
            this._participant.on('displayNameChanged', this.displayNameChanged);
            this._participant.on('isSpeakingChanged', this.isSpeakingChanged);
            this._participant.on('videoStreamsUpdated', this.videoStreamsUpdated);
            /* @conditional-compile-remove(rooms) */
            this._participant.on('roleChanged', this.roleChanged);
            if (this._participant.videoStreams.length > 0) {
                for (const stream of this._participant.videoStreams) {
                    this._internalContext.setRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id, stream, 'NotRendered', undefined);
                    this.addRemoteVideoStreamSubscriber(stream);
                }
                this._context.setRemoteVideoStreams(this._callIdRef.callId, this._participantKey, this._participant.videoStreams.map(convertSdkRemoteStreamToDeclarativeRemoteStream), []);
            }
        };
        this.unsubscribe = () => {
            this._participant.off('stateChanged', this.stateChanged);
            this._participant.off('isMutedChanged', this.isMutedChanged);
            this._participant.off('displayNameChanged', this.displayNameChanged);
            this._participant.off('isSpeakingChanged', this.isSpeakingChanged);
            this._participant.off('videoStreamsUpdated', this.videoStreamsUpdated);
            /* @conditional-compile-remove(rooms) */
            this._participant.off('roleChanged', this.roleChanged);
            // If unsubscribing it means the participant left the call. If they have any rendering streams we should stop them
            // as it doesn't make sense to render for an ended participant.
            if (this._participant.videoStreams.length > 0) {
                for (const stream of this._participant.videoStreams) {
                    disposeView(this._context, this._internalContext, this._callIdRef.callId, this._participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(stream));
                    this._internalContext.deleteRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id);
                }
            }
        };
        this.addRemoteVideoStreamSubscriber = (remoteVideoStream) => {
            var _a;
            (_a = this._remoteVideoStreamSubscribers.get(remoteVideoStream.id)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this._remoteVideoStreamSubscribers.set(remoteVideoStream.id, new RemoteVideoStreamSubscriber(this._callIdRef, this._participantKey, remoteVideoStream, this._context));
        };
        this.stateChanged = () => {
            this._context.setParticipantState(this._callIdRef.callId, this._participantKey, this._participant.state);
        };
        this.isMutedChanged = () => {
            this._context.setParticipantIsMuted(this._callIdRef.callId, this._participantKey, this._participant.isMuted);
        };
        /* @conditional-compile-remove(rooms) */
        this.roleChanged = () => {
            this._context.setParticipantRole(this._callIdRef.callId, this._participantKey, this._participant.role);
        };
        this.displayNameChanged = () => {
            this._context.setParticipantDisplayName(this._callIdRef.callId, this._participantKey, this._participant.displayName || '');
        };
        this.isSpeakingChanged = () => {
            this._context.setParticipantIsSpeaking(this._callIdRef.callId, this._participantKey, this._participant.isSpeaking);
        };
        this.videoStreamsUpdated = (event) => {
            var _a;
            for (const stream of event.removed) {
                (_a = this._remoteVideoStreamSubscribers.get(stream.id)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                disposeView(this._context, this._internalContext, this._callIdRef.callId, this._participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(stream));
                this._internalContext.deleteRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id);
            }
            for (const stream of event.added) {
                this._internalContext.setRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id, stream, 'NotRendered', undefined);
                this.addRemoteVideoStreamSubscriber(stream);
            }
            this._context.setRemoteVideoStreams(this._callIdRef.callId, this._participantKey, event.added.map(convertSdkRemoteStreamToDeclarativeRemoteStream), event.removed.map((stream) => stream.id));
        };
        this._callIdRef = callIdRef;
        this._participant = participant;
        this._context = context;
        this._internalContext = internalContext;
        this._participantKey = toFlatCommunicationIdentifier(this._participant.identifier);
        this._remoteVideoStreamSubscribers = new Map();
        this.subscribe();
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
class RecordingSubscriber {
    constructor(callIdRef, context, recording) {
        this.subscribe = () => {
            this._recording.on('isRecordingActiveChanged', this.isAvailableChanged);
        };
        this.unsubscribe = () => {
            this._recording.off('isRecordingActiveChanged', this.isAvailableChanged);
        };
        this.isAvailableChanged = () => {
            this._context.setCallRecordingActive(this._callIdRef.callId, this._recording.isRecordingActive);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._recording = recording;
        // If recording as already started when we joined the call, make sure it is reflected in state as there may not
        // be an event for it.
        if (this._recording.isRecordingActive) {
            this._context.setCallRecordingActive(this._callIdRef.callId, this._recording.isRecordingActive);
        }
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
class TranscriptionSubscriber {
    constructor(callIdRef, context, transcription) {
        this.subscribe = () => {
            this._transcription.on('isTranscriptionActiveChanged', this.isTranscriptionActiveChanged);
        };
        this.unsubscribe = () => {
            this._transcription.off('isTranscriptionActiveChanged', this.isTranscriptionActiveChanged);
        };
        this.isTranscriptionActiveChanged = () => {
            this._context.setCallTranscriptionActive(this._callIdRef.callId, this._transcription.isTranscriptionActive);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._transcription = transcription;
        // If transcription as already started when we joined the call, make sure it is reflected in state as there may not
        // be an event for it.
        if (this._transcription.isTranscriptionActive) {
            this._context.setCallTranscriptionActive(this._callIdRef.callId, this._transcription.isTranscriptionActive);
        }
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
class UserFacingDiagnosticsSubscriber {
    constructor(callIdRef, context, diagnostics) {
        this.unsubscribe = () => {
            this._diagnostics.network.off('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
            this._diagnostics.media.off('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._diagnostics = diagnostics;
        this.setInitialDiagnostics();
        this.subscribe();
    }
    setInitialDiagnostics() {
        const network = this._diagnostics.network.getLatest();
        const media = this._diagnostics.media.getLatest();
        if (Object.entries(network).length === 0 && Object.entries(media).length === 0) {
            return;
        }
        this._context.modifyState(state => {
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            call.diagnostics = {
                network: {
                    latest: network
                },
                media: {
                    latest: media
                }
            };
        });
    }
    subscribe() {
        this._diagnostics.network.on('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
        this._diagnostics.media.on('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
    }
    networkDiagnosticsChanged(args) {
        this._context.modifyState(state => {
            var _a;
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            const network = (_a = call.diagnostics) === null || _a === void 0 ? void 0 : _a.network.latest;
            if (network) {
                network[args.diagnostic] = latestFromEvent(args);
            }
        });
    }
    mediaDiagnosticsChanged(args) {
        this._context.modifyState(state => {
            var _a;
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            const media = (_a = call.diagnostics) === null || _a === void 0 ? void 0 : _a.media.latest;
            if (media) {
                media[args.diagnostic] = latestFromEvent(args);
            }
        });
    }
}
const latestFromEvent = (args) => ({
    value: args.value,
    valueType: args.valueType
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(raise-hand) */
/* @conditional-compile-remove(raise-hand) */
/**
 * @private
 */
class RaiseHandSubscriber {
    constructor(callIdRef, context, raiseHand) {
        this.subscribe = () => {
            this._raiseHand.on('raisedHandEvent', this.raisedHand);
            this._raiseHand.on('loweredHandEvent', this.loweredHand);
        };
        this.unsubscribe = () => {
            this._raiseHand.off('raisedHandEvent', this.raisedHand);
            this._raiseHand.off('loweredHandEvent', this.loweredHand);
        };
        this.raisedHand = () => {
            this._context.setCallRaisedHands(this._callIdRef.callId, this._raiseHand.getRaisedHands());
            for (const raisedHand of this._raiseHand.getRaisedHands()) {
                this._context.setParticipantIsRaisedHand(this._callIdRef.callId, toFlatCommunicationIdentifier(raisedHand.identifier), raisedHand);
            }
        };
        this.loweredHand = (event) => {
            this.raisedHand();
            this._context.setParticipantIsRaisedHand(this._callIdRef.callId, toFlatCommunicationIdentifier(event.identifier), undefined);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._raiseHand = raiseHand;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(optimal-video-count) */
/**
 * Subscribes to a Optimal Video Count Feature events and updates the call context appropriately.
 * @private
 */
class OptimalVideoCountSubscriber {
    constructor(args) {
        this.subscribe = () => {
            this._localOptimalVideoCountFeature.on('optimalVideoCountChanged', this.optimalVideoCountChanged);
        };
        this.unsubscribe = () => {
            this._localOptimalVideoCountFeature.off('optimalVideoCountChanged', this.optimalVideoCountChanged);
        };
        this.optimalVideoCountChanged = () => {
            this.updateOptimalVideoCountState({
                maxRemoteVideoStreams: this._localOptimalVideoCountFeature.optimalVideoCount
            });
        };
        this.updateOptimalVideoCountState = (newOptimalVideoCountState) => {
            this._context.setOptimalVideoCount(this._callIdRef.callId, newOptimalVideoCountState.maxRemoteVideoStreams);
        };
        this._callIdRef = args.callIdRef;
        this._context = args.context;
        this._localOptimalVideoCountFeature = args.localOptimalVideoCountFeature;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(capabilities) */
/**
 * @private
 */
class CapabilitiesSubscriber {
    constructor(callIdRef, context, capabilities) {
        this.subscribe = () => {
            this._capabilitiesFeature.on('capabilitiesChanged', this.capabilitiesChanged);
        };
        this.unsubscribe = () => {
            this._capabilitiesFeature.off('capabilitiesChanged', this.capabilitiesChanged);
        };
        this.capabilitiesChanged = (data) => {
            this._context.setCapabilities(this._callIdRef.callId, this._capabilitiesFeature.capabilities, data);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._capabilitiesFeature = capabilities;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Keeps track of the listeners assigned to a particular call because when we get an event from SDK, it doesn't tell us
 * which call it is for. If we keep track of this then we know which call in the state that needs an update and also
 * which property of that call. Also we can use this when unregistering to a call.
 */
class CallSubscriber {
    constructor(call, context, internalContext) {
        this.subscribe = () => {
            this._call.on('stateChanged', this.stateChanged);
            /* @conditional-compile-remove(close-captions) */
            this._call.on('stateChanged', this.initCaptionSubscriber);
            this._call.on('idChanged', this.idChanged);
            this._call.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged);
            this._call.on('remoteParticipantsUpdated', this.remoteParticipantsUpdated);
            this._call.on('localVideoStreamsUpdated', this.localVideoStreamsUpdated);
            this._call.on('isMutedChanged', this.isMuteChanged);
            /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(capabilities) */
            this._call.on('roleChanged', this.callRoleChangedHandler);
            this._call.feature(communicationCalling.Features.DominantSpeakers).on('dominantSpeakersChanged', this.dominantSpeakersChanged);
            for (const localVideoStream of this._call.localVideoStreams) {
                this._internalContext.setLocalRenderInfo(this._callIdRef.callId, localVideoStream.mediaStreamType, localVideoStream, 'NotRendered', undefined);
            }
            if (this._call.remoteParticipants.length > 0) {
                this._call.remoteParticipants.forEach((participant) => {
                    this.addParticipantListener(participant);
                });
                this._context.setCallRemoteParticipants(this._callIdRef.callId, this._call.remoteParticipants.map(convertSdkParticipantToDeclarativeParticipant), []);
            }
        };
        this.unsubscribe = () => {
            var _a, _b;
            this._call.off('stateChanged', this.stateChanged);
            /* @conditional-compile-remove(close-captions) */
            this._call.off('stateChanged', this.initCaptionSubscriber);
            this._call.off('idChanged', this.idChanged);
            this._call.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged);
            this._call.off('remoteParticipantsUpdated', this.remoteParticipantsUpdated);
            this._call.off('localVideoStreamsUpdated', this.localVideoStreamsUpdated);
            this._call.off('isMutedChanged', this.isMuteChanged);
            /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(capabilities) */
            this._call.off('roleChanged', this.callRoleChangedHandler);
            this._participantSubscribers.forEach((participantSubscriber) => {
                participantSubscriber.unsubscribe();
            });
            this._participantSubscribers.clear();
            // If we are unsubscribing that means we no longer want to display any video for this call (callEnded or callAgent
            // disposed) and we should not be updating it any more. So if video is rendering we stop rendering.
            for (const localVideoStream of this._call.localVideoStreams) {
                const mediaStreamType = localVideoStream.mediaStreamType;
                disposeView(this._context, this._internalContext, this._callIdRef.callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(localVideoStream));
                this._internalContext.deleteLocalRenderInfo(this._callIdRef.callId, mediaStreamType);
            }
            this._diagnosticsSubscriber.unsubscribe();
            this._recordingSubscriber.unsubscribe();
            this._transcriptionSubscriber.unsubscribe();
            /* @conditional-compile-remove(optimal-video-count) */
            this._optimalVideoCountSubscriber.unsubscribe();
            /* @conditional-compile-remove(close-captions) */
            (_a = this._captionsSubscriber) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            /* @conditional-compile-remove(raise-hand) */
            (_b = this._raiseHandSubscriber) === null || _b === void 0 ? void 0 : _b.unsubscribe();
            /* @conditional-compile-remove(capabilities) */
            this._capabilitiesSubscriber.unsubscribe();
        };
        this.stateChanged = () => {
            this._context.setCallState(this._callIdRef.callId, this._call.state);
        };
        /* @conditional-compile-remove(close-captions) */
        this.initCaptionSubscriber = () => {
            // subscribe to captions here so that we don't call captions when call is not initialized
            if (this._call.state === 'Connected' && !this._captionsSubscriber) {
                if (this._call.feature(communicationCalling.Features.Captions).captions.kind === 'TeamsCaptions') {
                    this._captionsSubscriber = new CaptionsSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.Captions).captions);
                    this._call.off('stateChanged', this.initCaptionSubscriber);
                }
            }
        };
        this.idChanged = () => {
            this._internalContext.setCallId(this._call.id, this._callIdRef.callId);
            this._context.setCallId(this._call.id, this._callIdRef.callId);
            this._callIdRef.callId = this._call.id;
        };
        this.isScreenSharingOnChanged = () => {
            this._context.setCallIsScreenSharingOn(this._callIdRef.callId, this._call.isScreenSharingOn);
        };
        this.isMuteChanged = () => {
            this._context.setCallIsMicrophoneMuted(this._callIdRef.callId, this._call.isMuted);
        };
        /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(capabilities) */
        this.callRoleChangedHandler = () => {
            this._context.setRole(this._callIdRef.callId, this._call.role);
        };
        this.remoteParticipantsUpdated = (event) => {
            event.added.forEach((participant) => {
                this.addParticipantListener(participant);
            });
            event.removed.forEach((participant) => {
                this.removeParticipantListener(participant);
            });
            // Remove any added participants from remoteParticipantsEnded if they are there and add any removed participants to
            // remoteParticipantsEnded.
            this._context.setCallRemoteParticipantsEnded(this._callIdRef.callId, event.removed.map(convertSdkParticipantToDeclarativeParticipant), event.added.map((participant) => {
                return toFlatCommunicationIdentifier(participant.identifier);
            }));
            // Add added participants to remoteParticipants and remove removed participants from remoteParticipants.
            this._context.setCallRemoteParticipants(this._callIdRef.callId, event.added.map(convertSdkParticipantToDeclarativeParticipant), event.removed.map((participant) => {
                return toFlatCommunicationIdentifier(participant.identifier);
            }));
        };
        this.localVideoStreamsUpdated = (event) => {
            var _a, _b;
            for (const localVideoStream of event.added) {
                const mediaStreamType = localVideoStream.mediaStreamType;
                // IMPORTANT: The internalContext should be set before context. This is done to ensure that the internal context
                // has the required data when component re-renders due to external state changes.
                this._internalContext.setLocalRenderInfo(this._callIdRef.callId, mediaStreamType, localVideoStream, 'NotRendered', undefined);
                // Subscribe to video effect changes
                (_a = this._localVideoStreamVideoEffectsSubscribers.get(mediaStreamType)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                this._localVideoStreamVideoEffectsSubscribers.set(mediaStreamType, new LocalVideoStreamVideoEffectsSubscriber({
                    parent: this._callIdRef,
                    context: this._context,
                    localVideoStream: localVideoStream,
                    localVideoStreamEffectsAPI: localVideoStream.feature(communicationCalling.Features.VideoEffects)
                }));
            }
            for (const localVideoStream of event.removed) {
                const mediaStreamType = localVideoStream.mediaStreamType;
                (_b = this._localVideoStreamVideoEffectsSubscribers.get(mediaStreamType)) === null || _b === void 0 ? void 0 : _b.unsubscribe();
                disposeView(this._context, this._internalContext, this._callIdRef.callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(localVideoStream));
                this._internalContext.deleteLocalRenderInfo(this._callIdRef.callId, mediaStreamType);
            }
            this._context.setCallLocalVideoStream(this._callIdRef.callId, event.added.map(convertSdkLocalStreamToDeclarativeLocalStream), event.removed.map(convertSdkLocalStreamToDeclarativeLocalStream));
        };
        this.dominantSpeakersChanged = () => {
            const dominantSpeakers = this._call.feature(communicationCalling.Features.DominantSpeakers).dominantSpeakers;
            this._context.setCallDominantSpeakers(this._callIdRef.callId, dominantSpeakers);
        };
        this._call = call;
        this._callIdRef = {
            callId: call.id
        };
        this._context = context;
        this._internalContext = internalContext;
        this._diagnosticsSubscriber = new UserFacingDiagnosticsSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.UserFacingDiagnostics));
        this._participantSubscribers = new Map();
        this._recordingSubscriber = new RecordingSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.Recording));
        this._transcriptionSubscriber = new TranscriptionSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.Transcription));
        /* @conditional-compile-remove(raise-hand) */
        this._raiseHandSubscriber = new RaiseHandSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.RaiseHand));
        /* @conditional-compile-remove(optimal-video-count) */
        this._optimalVideoCountSubscriber = new OptimalVideoCountSubscriber({
            callIdRef: this._callIdRef,
            context: this._context,
            localOptimalVideoCountFeature: this._call.feature(communicationCalling.Features.OptimalVideoCount)
        });
        /* @conditional-compile-remove(video-background-effects) */
        this._localVideoStreamVideoEffectsSubscribers = new Map();
        /* @conditional-compile-remove(capabilities) */
        this._capabilitiesSubscriber = new CapabilitiesSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.Capabilities));
        this.subscribe();
    }
    addParticipantListener(participant) {
        var _a;
        const participantKey = toFlatCommunicationIdentifier(participant.identifier);
        (_a = this._participantSubscribers.get(participantKey)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this._participantSubscribers.set(participantKey, new ParticipantSubscriber$1(this._callIdRef, participant, this._context, this._internalContext));
    }
    removeParticipantListener(participant) {
        const participantKey = toFlatCommunicationIdentifier(participant.identifier);
        const participantSubscriber = this._participantSubscribers.get(participantKey);
        if (participantSubscriber) {
            participantSubscriber.unsubscribe();
            this._participantSubscribers.delete(participantKey);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$D = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
class ProxyIncomingCall {
    constructor(context) {
        this._context = context;
    }
    get(target, prop) {
        switch (prop) {
            case 'accept':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$D(this, void 0, void 0, function* () {
                            return yield target.accept(...args);
                        });
                    }, 'IncomingCall.accept');
                }
            case 'reject':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$D(this, void 0, void 0, function* () {
                            return yield target.reject(...args);
                        });
                    }, 'IncomingCall.reject');
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a declarative Incoming Call by proxying IncomingCall using ProxyIncomingCall.
 * @param incomingCall - IncomingCall from SDK
 * @returns proxied IncomingCall
 */
const incomingCallDeclaratify = (incomingCall, context) => {
    const proxyIncomingCall = new ProxyIncomingCall(context);
    return new Proxy(incomingCall, proxyIncomingCall);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Keeps track of the listeners assigned to a particular incoming call because when we get an event from SDK, it doesn't
 * tell us which incoming call it is for. If we keep track of this then we know which incoming call in the state that
 * needs an update and also which property of that incoming call. Also we can use this when unregistering to a incoming
 * call.
 */
class IncomingCallSubscriber {
    constructor(incomingCall, 
    // setIncomingCallEnded callback is used so parent can clean up IncomingCallSubscriber.
    setIncomingCallEnded) {
        this.subscribe = () => {
            this._incomingCall.on('callEnded', this.callEnded);
        };
        this.unsubscribe = () => {
            this._incomingCall.off('callEnded', this.callEnded);
        };
        this.callEnded = (event) => {
            this._setIncomingCallEnded(this._incomingCall.id, event.callEndReason);
        };
        this._incomingCall = incomingCall;
        this._setIncomingCallEnded = setIncomingCallEnded;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$C = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyCallAgent proxies CallAgent and saves any returned state in the given context. It will subscribe to all state
 * updates in the CallAgent and in the contained Calls and RemoteParticipants. When dispose is called it will
 * unsubscribe from all state updates.
 */
class ProxyCallAgentCommon {
    constructor(context, internalContext) {
        // Unsubscribe is called when CallAgent is disposed. This should mean no more updating of existing call but we don't
        // remove any existing state.
        this.unregisterSubscriber = () => {
            for (const [_, callSubscriber] of this._callSubscribers.entries()) {
                callSubscriber.unsubscribe();
            }
            this._callSubscribers.clear();
            for (const [_, incomingCallSubscriber] of this._incomingCallSubscribers.entries()) {
                incomingCallSubscriber.unsubscribe();
            }
            this._incomingCallSubscribers.clear();
            this._declarativeIncomingCalls.clear();
            for (const [_, declarativeCall] of this._declarativeCalls.entries()) {
                declarativeCall.unsubscribe();
            }
            this._declarativeCalls.clear();
        };
        this.callsUpdated = (event) => {
            const addedStatefulCall = [];
            for (const call of event.added) {
                const statefulCall = this.addCall(call);
                addedStatefulCall.push(statefulCall);
            }
            const removedStatefulCall = [];
            for (const call of event.removed) {
                disposeAllViewsFromCall(this._context, this._internalContext, call.id);
                const callSubscriber = this._callSubscribers.get(call);
                if (callSubscriber) {
                    callSubscriber.unsubscribe();
                    this._callSubscribers.delete(call);
                }
                this._context.setCallEnded(call.id, call.callEndReason);
                const declarativeCall = this._declarativeCalls.get(call);
                if (declarativeCall) {
                    declarativeCall.unsubscribe();
                    removedStatefulCall.push(declarativeCall);
                    this._declarativeCalls.delete(call);
                }
                else {
                    removedStatefulCall.push(this.callDeclaratify(call, this._context));
                }
            }
            for (const externalCallsUpdatedListener of this._externalCallsUpdatedListeners) {
                externalCallsUpdatedListener({
                    added: addedStatefulCall,
                    removed: removedStatefulCall
                });
            }
        };
        this.setIncomingCallEnded = (incomingCallId, callEndReason) => {
            const incomingCallSubscriber = this._incomingCallSubscribers.get(incomingCallId);
            if (incomingCallSubscriber) {
                incomingCallSubscriber.unsubscribe();
                this._incomingCallSubscribers.delete(incomingCallId);
            }
            this._declarativeIncomingCalls.delete(incomingCallId);
            this._context.setIncomingCallEnded(incomingCallId, callEndReason);
        };
        this.incomingCall = ({ incomingCall }) => {
            // Make sure to not subscribe to the incoming call if we are already subscribed to it.
            if (!this._incomingCallSubscribers.has(incomingCall.id)) {
                this._incomingCallSubscribers.set(incomingCall.id, new IncomingCallSubscriber(incomingCall, this.setIncomingCallEnded));
            }
            this._declarativeIncomingCalls.set(incomingCall.id, incomingCallDeclaratify(incomingCall, this._context));
            this._context.setIncomingCall(convertSdkIncomingCallToDeclarativeIncomingCall(incomingCall));
        };
        this.addCall = (call) => {
            var _a;
            (_a = this._callSubscribers.get(call)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            // For API extentions we need to have the call in the state when we are subscribing as we may want to update the
            // state during the subscription process in the subscriber so we add the call to state before subscribing.
            this._context.setCall(convertSdkCallToDeclarativeCall(call));
            this._callSubscribers.set(call, new CallSubscriber(call, this._context, this._internalContext));
            return this.getOrCreateDeclarativeCall(call);
        };
        this.getOrCreateDeclarativeCall = (call) => {
            const declarativeCall = this._declarativeCalls.get(call);
            if (declarativeCall) {
                return declarativeCall;
            }
            const newDeclarativeCall = this.callDeclaratify(call, this._context);
            this._declarativeCalls.set(call, newDeclarativeCall);
            return newDeclarativeCall;
        };
        this._context = context;
        this._internalContext = internalContext;
        this._callSubscribers = new Map();
        this._incomingCallSubscribers = new Map();
        this._declarativeIncomingCalls = new Map();
        this._declarativeCalls = new Map();
        this._externalCallsUpdatedListeners = new Set();
    }
    // We can't directly override get function because it is proxied,
    // Add a getCommon function and call it in child class
    getCommon(target, prop) {
        switch (prop) {
            case 'startCall':
                {
                    return this._context.withErrorTeedToState((...args) => {
                        const call = this.startCall(target, args);
                        this.addCall(call);
                        return this.getOrCreateDeclarativeCall(call);
                    }, 'CallAgent.startCall');
                }
            case 'join':
                {
                    return this._context.withErrorTeedToState((...args) => {
                        const call = this.joinCall(target, args);
                        this.addCall(call);
                        return this.getOrCreateDeclarativeCall(call);
                    }, 'CallAgent.join');
                }
            case 'calls':
                {
                    return Array.from(this._declarativeCalls.values());
                }
            case 'on':
                {
                    return (...args) => {
                        // typescript is not smart enough to handle multiple overloads and pull the correct type here so force casting args
                        const event = args[0];
                        const isCallsUpdated = event === 'callsUpdated';
                        if (isCallsUpdated) {
                            const listener = args[1];
                            this._externalCallsUpdatedListeners.add(listener);
                        }
                        else {
                            this.agentSubscribe(target, args);
                        }
                    };
                }
            case 'off':
                {
                    return (...args) => {
                        // typescript is not smart enough to handle multiple overloads and pull the correct type here so force casting args
                        const event = args[0];
                        const isCallsUpdated = event === 'callsUpdated';
                        if (isCallsUpdated) {
                            const listener = args[1];
                            this._externalCallsUpdatedListeners.delete(listener);
                        }
                        else {
                            this.agentUnsubscribe(target, args);
                        }
                    };
                }
            case 'dispose':
                {
                    // Wrapping CallAgent.dispose in a callback type (): Promise<void> to accomodate the change of CallAgent.dispose
                    // in calling beta version 1.8.0-beta.1 from callback type (): Promise<void> to (): void
                    const callAgentDisposeAsyncCallbackWrapper = () => __awaiter$C(this, void 0, void 0, function* () {
                        yield target.dispose();
                        return Promise.resolve();
                    });
                    return () => {
                        return callAgentDisposeAsyncCallbackWrapper().then(() => {
                            this.unsubscribe();
                        });
                    };
                }
            /**
             * This attribute is a special case and doesn't exist on the CallAgent interface.
             * We need this to be able to return a declarative incoming call object using the call agent.
             * In a standard headless SDK usage, the right way to get an incoming call is to use the `incomingCall` event.
             * However, using the declarative layer, the ideal usage would be to:
             * 1. subscribe to the `onStateChange` event
             * 2. Get the incoming call from the new state and it's ID
             * 3. Use `callAgent.incomingCalls` and filter an incoming call ID to get a declarative incoming call object
             */
            case 'incomingCalls':
                {
                    return Array.from(this._declarativeIncomingCalls.values());
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * @private
 */
const clearCallRelatedState = (context, internalContext) => {
    // Make sure there are no existing call data if creating a new CallAgentDeclarative (if creating a new
    // CallAgentDeclarative after disposing of the hold one will mean context have old call state). TODO: should we stop
    // rendering when the previous callAgent is disposed?
    disposeAllViews(context, internalContext);
    context.clearCallRelatedState();
    internalContext.clearCallRelatedState();
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$B = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
class ProxyCallCommon {
    constructor(context) {
        this._context = context;
    }
    unsubscribe() {
        /** No subscriptions yet. But there will be one for transfer feature soon. */
    }
    getContext() {
        return this._context;
    }
    get(target, prop) {
        switch (prop) {
            case 'mute':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$B(this, void 0, void 0, function* () {
                            return yield target.mute(...args);
                        });
                    }, 'Call.mute');
                }
            case 'unmute':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$B(this, void 0, void 0, function* () {
                            return yield target.unmute(...args);
                        });
                    }, 'Call.unmute');
                }
            case 'startVideo':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$B(this, void 0, void 0, function* () {
                            return yield target.startVideo(...args);
                        });
                    }, 'Call.startVideo');
                }
            case 'stopVideo':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$B(this, void 0, void 0, function* () {
                            return yield target.stopVideo(...args);
                        });
                    }, 'Call.stopVideo');
                }
            case 'startScreenSharing':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$B(this, void 0, void 0, function* () {
                            return yield target.startScreenSharing(...args);
                        });
                    }, 'Call.startScreenSharing');
                }
            case 'stopScreenSharing':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$B(this, void 0, void 0, function* () {
                            return yield target.stopScreenSharing(...args);
                        });
                    }, 'Call.stopScreenSharing');
                }
            case 'hold':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$B(this, void 0, void 0, function* () {
                            return yield target.hold(...args);
                        });
                    }, 'Call.hold');
                }
            case 'resume':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$B(this, void 0, void 0, function* () {
                            return yield target.resume(...args);
                        });
                    }, 'Call.resume');
                }
            case 'feature':
                {
                    // these are mini version of Proxy object - if it grows too big, a real Proxy object should be used.
                    return this._context.withErrorTeedToState((...args) => {
                        /* @conditional-compile-remove(close-captions) */
                        if (args[0] === communicationCalling.Features.Captions) {
                            const captionsFeature = target.feature(communicationCalling.Features.Captions).captions;
                            const proxyFeature = new ProxyTeamsCaptions(this._context, target);
                            return {
                                captions: new Proxy(captionsFeature, proxyFeature)
                            };
                        }
                        /* @conditional-compile-remove(call-transfer) */
                        if (args[0] === communicationCalling.Features.Transfer) {
                            const transferFeature = target.feature(communicationCalling.Features.Transfer);
                            const proxyFeature = new ProxyTransferCallFeature(this._context, target);
                            return new Proxy(transferFeature, proxyFeature);
                        }
                        return target.feature(...args);
                    }, 'Call.feature');
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/* @conditional-compile-remove(close-captions) */
/**
 * @private
 */
class ProxyTeamsCaptions {
    constructor(context, call) {
        this._context = context;
        this._call = call;
    }
    get(target, prop) {
        switch (prop) {
            case 'startCaptions':
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$B(this, void 0, void 0, function* () {
                    var _a, _b;
                    this._context.setStartCaptionsInProgress(this._call.id, true);
                    const ret = yield target.startCaptions(...args);
                    this._context.setSelectedSpokenLanguage(this._call.id, (_b = (_a = args[0]) === null || _a === void 0 ? void 0 : _a.spokenLanguage) !== null && _b !== void 0 ? _b : 'en-us');
                    return ret;
                }), 'Call.feature');
            case 'stopCaptions':
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$B(this, void 0, void 0, function* () {
                    const ret = yield target.stopCaptions(...args);
                    this._context.setIsCaptionActive(this._call.id, false);
                    this._context.setStartCaptionsInProgress(this._call.id, false);
                    this._context.clearCaptions(this._call.id);
                    return ret;
                }), 'Call.feature');
            case 'setSpokenLanguage':
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$B(this, void 0, void 0, function* () {
                    const ret = yield target.setSpokenLanguage(...args);
                    this._context.setSelectedSpokenLanguage(this._call.id, args[0]);
                    return ret;
                }), 'Call.feature');
            case 'setCaptionLanguage':
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$B(this, void 0, void 0, function* () {
                    const ret = yield target.setCaptionLanguage(...args);
                    this._context.setSelectedCaptionLanguage(this._call.id, args[0]);
                    return ret;
                }), 'Call.feature');
            default:
                return Reflect.get(target, prop);
        }
    }
}
/* @conditional-compile-remove(call-transfer) */
/**
 * @private
 */
class ProxyTransferCallFeature {
    constructor(context, call) {
        this._context = context;
        this._call = call;
    }
    get(target, prop) {
        switch (prop) {
            case 'on':
                return (...args) => {
                    const isTransferAccepted = args[0] === 'transferAccepted';
                    if (isTransferAccepted) {
                        const listener = args[1];
                        const newListener = (args) => {
                            this._context.setAcceptedTransfer(this._call.id, {
                                callId: args.targetCall.id,
                                timestamp: new Date()
                            });
                            listener(args);
                        };
                        return target.on('transferAccepted', newListener);
                    }
                };
            default:
                return Reflect.get(target, prop);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$A = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProxyCall extends ProxyCallCommon {
    get(target, prop) {
        switch (prop) {
            case 'addParticipant':
                {
                    return this.getContext().withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$A(this, void 0, void 0, function* () {
                            return yield target.addParticipant(...args);
                        });
                    }, 'Call.addParticipant');
                }
            default:
                return super.get(target, prop);
        }
    }
}
/**
 * Creates a declarative Call by proxying Call with ProxyCall.
 * This should only be used with CallAgentDeclarative as CallAgentDeclarative will add that
 * call to the context properly (need to have the Call in context to update it - CallAgentDeclarative will add Call to
 * context)
 *
 * @param call - Call from SDK
 * @param context - CallContext from StatefulCallClient
 */
const callDeclaratify = (call, context) => {
    const proxyCall = new ProxyCall(context);
    Object.defineProperty(call, 'unsubscribe', {
        configurable: false,
        value: () => proxyCall.unsubscribe()
    });
    return new Proxy(call, proxyCall);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 */
const _isACSCall = (call) => {
    return true;
};
/**
 * @internal
 */
const _isACSCallAgent = (callAgent) => {
    return true;
};
/**
 * @internal
 */
const _isTeamsCall = (call) => {
    return false;
};
/**
 * @internal
 */
const _isTeamsCallAgent = (callAgent) => {
    return false;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * ProxyCallAgent proxies CallAgent and saves any returned state in the given context. It will subscribe to all state
 * updates in the CallAgent and in the contained Calls and RemoteParticipants. When dispose is called it will
 * unsubscribe from all state updates.
 */
class ProxyCallAgent extends ProxyCallAgentCommon {
    constructor(callAgent, context, internalContext) {
        super(context, internalContext);
        this.subscribe = () => {
            this._callAgent.on('callsUpdated', this.callsUpdated);
            this._callAgent.on('incomingCall', this.incomingCall);
            // There could be scenario that when ProxyCallAgent is created that the given CallAgent already has Calls. In this
            // case we need to make sure to subscribe to those already existing Calls.
            for (const call of this._callAgent.calls) {
                this.addCall(call);
            }
        };
        this.unsubscribe = () => {
            this._callAgent.off('callsUpdated', this.callsUpdated);
            this._callAgent.off('incomingCall', this.incomingCall);
            this.unregisterSubscriber();
        };
        this._callAgent = callAgent;
        this.subscribe();
    }
    callDeclaratify(call, context) {
        {
            return callDeclaratify(call, context);
        }
    }
    startCall(agent, args) {
        {
            return agent.startCall(...args);
        }
    }
    joinCall(agent, args) {
        {
            return agent.join(...args);
        }
    }
    agentSubscribe(agent, args) {
        {
            return agent.on(...args);
        }
    }
    agentUnsubscribe(agent, args) {
        {
            return agent.off(...args);
        }
    }
    get(target, prop) {
        return super.getCommon(target, prop);
    }
}
/**
 * Creates a declarative CallAgent by proxying CallAgent with ProxyCallAgent which will track state updates by updating
 * the given context.
 *
 * @param callAgent - CallAgent from SDK
 * @param context - CallContext from StatefulCallClient
 * @param internalContext- InternalCallContext from StatefulCallClient
 */
const callAgentDeclaratify = (callAgent, context, internalContext) => {
    clearCallRelatedState(context, internalContext);
    return new Proxy(callAgent, new ProxyCallAgent(callAgent, context, internalContext));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Contains internal data used between different Declarative components to share data.
 */
class InternalCallContext {
    constructor() {
        // <CallId, <ParticipantKey, <StreamId, RemoteRenderInfo>>
        this._remoteRenderInfos = new Map();
        // <CallId, <MediaStreamType, LocalRenderInfo>>.
        this._localRenderInfos = new Map();
        // Used for keeping track of rendered LocalVideoStreams that are not part of a Call.
        this._unparentedRenderInfos = new Map();
        this._callIdHistory = new CallIdHistory();
        // Used for keeping track of video effects subscribers that are not part of a Call.
        // The key is the stream ID. We assume each stream ID
        /* @conditional-compile-remove(video-background-effects) */
        this._unparentedViewVideoEffectsSubscriber = new Map();
    }
    setCallId(newCallId, oldCallId) {
        this._callIdHistory.updateCallIdHistory(newCallId, oldCallId);
        const remoteRenderInfos = this._remoteRenderInfos.get(oldCallId);
        if (remoteRenderInfos) {
            this._remoteRenderInfos.delete(oldCallId);
            this._remoteRenderInfos.set(newCallId, remoteRenderInfos);
        }
        const localRenderInfos = this._localRenderInfos.get(oldCallId);
        if (localRenderInfos) {
            this._localRenderInfos.delete(oldCallId);
            this._localRenderInfos.set(newCallId, localRenderInfos);
        }
    }
    getCallIds() {
        return this._remoteRenderInfos.keys();
    }
    getRemoteRenderInfoForCall(callId) {
        return this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
    }
    getRemoteRenderInfoForParticipant(callId, participantKey, streamId) {
        const callRenderInfos = this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!callRenderInfos) {
            return undefined;
        }
        const participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            return undefined;
        }
        return participantRenderInfos.get(streamId);
    }
    setRemoteRenderInfo(callId, participantKey, streamId, stream, status, renderer) {
        let callRenderInfos = this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!callRenderInfos) {
            callRenderInfos = new Map();
            this._remoteRenderInfos.set(this._callIdHistory.latestCallId(callId), callRenderInfos);
        }
        let participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            participantRenderInfos = new Map();
            callRenderInfos.set(participantKey, participantRenderInfos);
        }
        participantRenderInfos.set(streamId, {
            stream,
            status,
            renderer
        });
    }
    deleteRemoteRenderInfo(callId, participantKey, streamId) {
        const callRenderInfos = this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!callRenderInfos) {
            return;
        }
        const participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            return;
        }
        participantRenderInfos.delete(streamId);
    }
    setLocalRenderInfo(callId, streamKey, stream, status, renderer) {
        let localRenderInfosForCall = this._localRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!localRenderInfosForCall) {
            localRenderInfosForCall = new Map();
            this._localRenderInfos.set(this._callIdHistory.latestCallId(callId), localRenderInfosForCall);
        }
        localRenderInfosForCall.set(streamKey, {
            stream,
            status,
            renderer
        });
    }
    getLocalRenderInfosForCall(callId) {
        return this._localRenderInfos.get(this._callIdHistory.latestCallId(callId));
    }
    getLocalRenderInfo(callId, streamKey) {
        const localRenderInfosForCall = this._localRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!localRenderInfosForCall) {
            return undefined;
        }
        return localRenderInfosForCall.get(streamKey);
    }
    deleteLocalRenderInfo(callId, streamKey) {
        const localRenderInfoForCall = this._localRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!localRenderInfoForCall) {
            return;
        }
        localRenderInfoForCall.delete(streamKey);
    }
    getUnparentedRenderInfo(localVideoStream) {
        return this._unparentedRenderInfos.get(localVideoStream.mediaStreamType);
    }
    getUnparentedRenderInfos() {
        return [...this._unparentedRenderInfos].map(([, renderInfo]) => renderInfo.stream);
    }
    setUnparentedRenderInfo(statefulStream, stream, status, renderer) {
        this._unparentedRenderInfos.set(statefulStream.mediaStreamType, {
            stream,
            status,
            renderer
        });
    }
    deleteUnparentedRenderInfo(localVideoStream) {
        var _a;
        /* @conditional-compile-remove(video-background-effects) */
        (_a = this._unparentedViewVideoEffectsSubscriber.get(localVideoStream.mediaStreamType)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this._unparentedRenderInfos.delete(localVideoStream.mediaStreamType);
    }
    subscribeToUnparentedViewVideoEffects(localVideoStream, callContext) {
        var _a;
        /* @conditional-compile-remove(video-background-effects) */
        {
            // Ensure we aren't setting multiple subscriptions
            (_a = this._unparentedViewVideoEffectsSubscriber.get(localVideoStream.mediaStreamType)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this._unparentedViewVideoEffectsSubscriber.set(localVideoStream.mediaStreamType, new LocalVideoStreamVideoEffectsSubscriber({
                parent: 'unparented',
                context: callContext,
                localVideoStream: localVideoStream,
                localVideoStreamEffectsAPI: localVideoStream.feature(communicationCalling.Features.VideoEffects)
            }));
        }
    }
    // UnparentedRenderInfos are not cleared as they are not part of the Call state.
    clearCallRelatedState() {
        this._remoteRenderInfos.clear();
        this._localRenderInfos.clear();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$z = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
class ProxyVideoStreamRendererView {
    constructor(context, callId, participantId, _streamId) {
        this._context = context;
        this._callId = callId;
        this._participantId = participantId;
        this._streamId = _streamId;
    }
    get(target, prop) {
        switch (prop) {
            case 'updateScalingMode':
                {
                    return (...args) => __awaiter$z(this, void 0, void 0, function* () {
                        yield target.updateScalingMode(...args);
                        this._context.setRemoteVideoStreamViewScalingMode(this._callId, this._participantId, this._streamId, args[0]);
                    });
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a declarative VideoStreamRendererView that is backed by a VideoStreamRendererView from the SDK.
 * Calling methods on this declarative object triggers state updates in the stateful client.
 */
const videoStreamRendererViewDeclaratify = (view, context, callId, participantId, streamId) => {
    const proxyVideoStreamRendererView = new ProxyVideoStreamRendererView(context, callId, participantId, streamId);
    return new Proxy(view, proxyVideoStreamRendererView);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$y = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyCallClient proxies CallClient {@link @azure/communication-calling#CallClient} and subscribes to all events that
 * affect state. ProxyCallClient keeps its own copy of the call state and when state is updated, ProxyCallClient emits
 * the event 'stateChanged'.
 */
class ProxyCallClient {
    constructor(context, internalContext) {
        this._context = context;
        this._internalContext = internalContext;
    }
    get(target, prop) {
        switch (prop) {
            case 'createCallAgent':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$y(this, void 0, void 0, function* () {
                        // createCallAgent will throw an exception if the previous callAgent was not disposed. If the previous
                        // callAgent was disposed then it would have unsubscribed to events so we can just create a new declarative
                        // callAgent if the createCallAgent succeeds.
                        const callAgent = yield target.createCallAgent(...args);
                        this._callAgent = callAgentDeclaratify(callAgent, this._context, this._internalContext);
                        this._context.setCallAgent({
                            displayName: this._callAgent.displayName
                        });
                        return this._callAgent;
                    }), 'CallClient.createCallAgent');
                }
            case 'createTeamsCallAgent':
                {
                    return Reflect.get(target, prop);
                }
            case 'getDeviceManager':
                {
                    return this._context.withAsyncErrorTeedToState(() => __awaiter$y(this, void 0, void 0, function* () {
                        // As of writing, the SDK always returns the same instance of DeviceManager so we keep a reference of
                        // DeviceManager and if it does not change we return the cached DeclarativeDeviceManager. If it does not we'll
                        // throw an error that indicate we need to fix this issue as our implementation has diverged from the SDK.
                        const deviceManager = yield target.getDeviceManager();
                        if (this._sdkDeviceManager) {
                            if (this._sdkDeviceManager === deviceManager) {
                                return this._deviceManager;
                            }
                            else {
                                throw new Error('Multiple DeviceManager not supported. This means a incompatible version of communication-calling is ' + 'used OR calling declarative was not properly updated to communication-calling version.');
                            }
                        }
                        else {
                            this._sdkDeviceManager = deviceManager;
                        }
                        this._deviceManager = deviceManagerDeclaratify(deviceManager, this._context, this._internalContext);
                        return this._deviceManager;
                    }), 'CallClient.getDeviceManager');
                }
            case 'feature':
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a StatefulCallClient {@link StatefulCallClient} by proxying CallClient
 * {@link @azure/communication-calling#CallClient} with ProxyCallClient {@link ProxyCallClient} which then allows access
 * to state in a declarative way.
 *
 * It is important to use the {@link @azure/communication-calling#DeviceManager} and
 * {@link @azure/communication-calling#CallAgent} and {@link @azure/communication-calling#Call} (and etc.) that are
 * obtained from the StatefulCallClient in order for their state changes to be proxied properly.
 *
 * @param args - {@link StatefulCallClientArgs}
 * @param options - {@link StatefulCallClientOptions}
 *
 * @public
 */
const createStatefulCallClient = (args, options) => {
    return _createStatefulCallClientInner(args, options);
};
/**
 * This inner function is used to allow injection of TelemetryImplementationHint without changing the public API.
 *
 * @internal
 */
const _createStatefulCallClientInner = (args, options, telemetryImplementationHint = 'StatefulComponents') => {
    callingStatefulLogger.info(`Creating calling stateful client using library version: ${_getApplicationId(telemetryImplementationHint)}`);
    return createStatefulCallClientWithDeps(new communicationCalling.CallClient(withTelemetryTag(telemetryImplementationHint, options === null || options === void 0 ? void 0 : options.callClientOptions)), new CallContext$2(communicationCommon.getIdentifierKind(args.userId), options === null || options === void 0 ? void 0 : options.maxStateChangeListeners), new InternalCallContext());
};
/**
 * Package-internal version of createStatefulCallClient that allows dependency injection.
 *
 * This function should not be exported from the package.
 */
const createStatefulCallClientWithDeps = (callClient, context, internalContext) => {
    Object.defineProperty(callClient, 'getState', {
        configurable: false,
        value: () => context.getState()
    });
    Object.defineProperty(callClient, 'onStateChange', {
        configurable: false,
        value: (handler) => context.onStateChange(handler)
    });
    Object.defineProperty(callClient, 'offStateChange', {
        configurable: false,
        value: (handler) => context.offStateChange(handler)
    });
    Object.defineProperty(callClient, 'createView', {
        configurable: false,
        value: (callId, participantId, stream, options) => __awaiter$y(void 0, void 0, void 0, function* () {
            const participantIdKind = participantId ? communicationCommon.getIdentifierKind(participantId) : undefined;
            const result = yield createView(context, internalContext, callId, participantIdKind, stream, options);
            // We only need to declaratify the VideoStreamRendererView object for remote participants. Because the updateScalingMode only needs to be called on remote participant stream views.
            if ('id' in stream && callId && participantId && result) {
                const participantKey = toFlatCommunicationIdentifier(participantId);
                result.view = videoStreamRendererViewDeclaratify(result.view, context, callId, participantKey, stream.id);
            }
            return result;
        })
    });
    Object.defineProperty(callClient, 'disposeView', {
        configurable: false,
        value: (callId, participantId, stream) => {
            const participantIdKind = participantId ? communicationCommon.getIdentifierKind(participantId) : undefined;
            disposeView(context, internalContext, callId, participantIdKind, stream);
        }
    });
    return new Proxy(callClient, new ProxyCallClient(context, internalContext));
};
const withTelemetryTag = (telemetryImplementationHint, options) => {
    var _a, _b;
    const tags = (_b = (_a = options === null || options === void 0 ? void 0 : options.diagnostics) === null || _a === void 0 ? void 0 : _a.tags) !== null && _b !== void 0 ? _b : [];
    tags.push(_getApplicationId(telemetryImplementationHint));
    return Object.assign(Object.assign({}, options), { diagnostics: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.diagnostics), { tags }) });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const CallAgentContext = React.createContext(undefined);
const CallAgentProviderBase = (props) => {
    const { callAgent } = props;
    const initialState = {
        callAgent
    };
    return React.createElement(CallAgentContext.Provider, { value: initialState }, props.children);
};
/**
 * A {@link React.Context} that stores a {@link @azure/communication-calling#CallAgent}.
 *
 * Calling components from this package must be wrapped with a {@link CallAgentProvider}.
 *
 * @public
 */
const CallAgentProvider = (props) => React.createElement(CallAgentProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link @azure/communication-calling#CallAgent} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useCallAgent = () => {
    var _a;
    const callAgent = (_a = React.useContext(CallAgentContext)) === null || _a === void 0 ? void 0 : _a.callAgent;
    if (callAgent && !_isACSCallAgent()) {
        throw new Error('TeamsCallAgent object was provided, try useTeamsCall() instead');
    }
    return callAgent;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const CallClientContext = React.createContext(undefined);
/**
 * @private
 */
const CallClientProviderBase = (props) => {
    const { callClient } = props;
    const [deviceManager, setDeviceManager] = React.useState(undefined);
    /**
     * Initialize the DeviceManager inside CallClientState
     */
    React.useEffect(() => {
        callClient.getDeviceManager().then(manager => {
            manager.getCameras();
            manager.getMicrophones();
            manager.getSpeakers();
            setDeviceManager(manager);
        }).catch(error => {
            throw new Error(error);
        });
    }, [callClient]);
    const initialState = {
        callClient,
        deviceManager
    };
    return React.createElement(CallClientContext.Provider, { value: initialState }, props.children);
};
/**
 * A {@link React.Context} that stores a {@link StatefulCallClient}.
 *
 * Calling components from this package must be wrapped with a {@link CallClientProvider}.
 *
 * @public
 */
const CallClientProvider = (props) => React.createElement(CallClientProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link StatefulCallClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useCallClient = () => {
    const context = React.useContext(CallClientContext);
    if (context === undefined) {
        throw new Error('CallClient Context is undefined');
    }
    return context.callClient;
};
/**
 * Hook to obtain {@link StatefulDeviceManager} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useDeviceManager = () => {
    var _a;
    return (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.deviceManager;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const CallContext$1 = React.createContext(undefined);
/**
 * @private
 */
const CallProviderBase = (props) => {
    const { children, call } = props;
    const initialState = {
        call
    };
    return React.createElement(CallContext$1.Provider, { value: initialState }, children);
};
/**
 * A {@link React.Context} that stores a {@link @azure/communication-calling#Call}.
 *
 * Calling components from this package must be wrapped with a {@link CallProvider}.
 *
 * @public
 */
const CallProvider = (props) => React.createElement(CallProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link @azure/communication-calling#Call} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * you must have previously used the CallProvider with a Call object to use this hook
 *
 * @public
 */
const useCall = () => {
    var _a;
    const call = (_a = React.useContext(CallContext$1)) === null || _a === void 0 ? void 0 : _a.call;
    if (call && !_isACSCall()) {
        throw new Error('Incorrect call type: Must provide a Regular Call object.');
    }
    return call;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const typingIndicatorContainerStyle = react.mergeStyles({
    minHeight: '2.125rem',
    // flexFlow set to column-reverse to align the text to the bottom of the container
    flexFlow: 'column-reverse'
});
/**
 * @private
 */
const typingIndicatorStringStyle = react.mergeStyles({
    fontWeight: 400,
    width: '100%',
    alignSelf: 'center',
    wordBreak: 'break-word'
});

var participantItem$k={isMeText:"(you)",menuTitle:"More Options",removeButtonLabel:"Remove",sharingIconLabel:"Sharing",mutedIconLabel:"Muted",displayNamePlaceholder:"Unnamed participant",participantStateRinging:"Calling...",participantStateHold:"On hold",attendeeRole:"Attendee"};var ParticipantList$l={overflowParticipantCount:"+{overflowCount} more"};var typingIndicator$k={singleUser:"{user} is typing ...",multipleUsers:"{users} are typing ...",multipleUsersAbbreviateOne:"{users} and 1 other are typing ...",multipleUsersAbbreviateMany:"{users} and {numOthers} others are typing ...",delimiter:", "};var sendBox$k={placeholderText:"Enter a message",textTooLong:"Your message length is over the maximum limit.",sendButtonAriaLabel:"Send message",fileUploadsPendingError:"Uploading... Please wait.",removeFile:"Remove file",uploading:"Uploading",uploadCompleted:"Upload completed"};var richTextSendBox$k={placeholderText:"Enter a message",textTooLong:"Your message length is over the maximum limit.",sendButtonAriaLabel:"Send message",fileUploadsPendingError:"Uploading... Please wait.",removeFile:"Remove file",uploading:"Uploading",uploadCompleted:"Upload completed",boldTooltip:"Bold",italicTooltip:"Italic",underlineTooltip:"Underline",bulletListTooltip:"Bulleted list",numberListTooltip:"Numbered list",increaseIndentTooltip:"Increase indent",decreaseIndentTooltip:"Decrease indent",richTextFormatButtonTooltip:"Format"};var mentionPopover$k={mentionPopoverHeader:"Suggestions"};var imageOverlay$k={downloadButtonLabel:"Download",dismissButtonAriaLabel:"Close"};var messageStatusIndicator$k={deliveredAriaLabel:"Message sent",deliveredTooltipText:"Sent",seenAriaLabel:"Message seen by others",seenTooltipText:"Seen",readByTooltipText:"Read by {messageThreadReadCount} of {remoteParticipantsCount}",sendingAriaLabel:"Message sending",sendingTooltipText:"Sending",failedToSendAriaLabel:"Message failed to send",failedToSendTooltipText:"Failed to send"};var endCallButton$k={label:"Leave",tooltipContent:"Leave call"};var cameraButton$k={onLabel:"Camera",offLabel:"Camera",tooltipDisabledContent:"Camera is disabled",tooltipOnContent:"Turn off camera",tooltipOffContent:"Turn on camera",tooltipVideoLoadingContent:"Video is loading",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",cameraButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Turn off camera and camera options",offSplitButtonAriaLabel:"Turn on camera and camera options",cameraActionTurnedOnAnnouncement:"Your camera has been turned on",cameraActionTurnedOffAnnouncement:"Your camera has been turned off",onSplitButtonPrimaryActionCamera:"Turn off camera",offSplitButtonPrimaryActionCamera:"Turn on camera",cameraPrimaryActionSplitButtonTitle:"Use camera",videoEffectsMenuItemTitle:"Effects"};var microphoneButton$k={onLabel:"Mic",offLabel:"Mic",tooltipDisabledContent:"Microphone is disabled",tooltipOnContent:"Mute microphone",tooltipOffContent:"Unmute microphone",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker",microphoneButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Mute microphone and audio options",offSplitButtonAriaLabel:"Unmute microphone and audio options",microphoneActionTurnedOnAnnouncement:"Your microphone has been turned on",microphoneActionTurnedOffAnnouncement:"Your microphone has been turned off",offSplitButtonMicrophonePrimaryAction:"Unmute microphone",onSplitButtonMicrophonePrimaryAction:"Mute microphone",microphonePrimaryActionSplitButtonTitle:"Use microphone"};var devicesButton$k={label:"Devices",tooltipContent:"Manage devices",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",audioDeviceMenuTitle:"Audio Device",audioDeviceMenuTooltip:"Choose audio device",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker"};var participantsButton$k={label:"People",tooltipContent:"Show participants",menuHeader:"In this call",participantsListButtonLabel:"{numParticipants} people",muteAllButtonLabel:"Mute all",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied"};var screenShareButton$k={onLabel:"Stop presenting",offLabel:"Present",tooltipDisabledContent:"Presenting is disabled",tooltipOnContent:"Presenting your screen",tooltipOffContent:"Present your screen"};var raiseHandButton$k={offLabel:"Raise",onLabel:"Lower",tooltipDisabledContent:"Raise Hand action is disabled",tooltipOnContent:"Lower Hand",tooltipOffContent:"Raise Hand"};var reactionButton$k={label:"React",ariaLabel:"React Button, Send a reaction",tooltipDisabledContent:"Reaction action is disabled",tooltipContent:"Send a reaction",likeReactionTooltipContent:"Like",heartReactionTooltipContent:"Love",laughReactionTooltipContent:"Laugh",applauseReactionTooltipContent:"Applause",surprisedReactionTooltipContent:"Surprised"};var messageThread$k={yesterday:"Yesterday",sunday:"Sunday",monday:"Monday",tuesday:"Tuesday",wednesday:"Wednesday",thursday:"Thursday",friday:"Friday",saturday:"Saturday",participantJoined:"joined the chat.",participantLeft:"left the chat.",editMessage:"Edit",removeMessage:"Delete",resendMessage:"Try sending again",failToSendTag:"Failed to send",editedTag:"Edited",liveAuthorIntro:"{author} says",messageContentAriaText:"{author} said {message}",messageContentMineAriaText:"You said {message}",editBoxTextLimit:"Your message is over the limit of {limitNumber} characters",editBoxPlaceholderText:"Edit your message",newMessagesIndicator:"New messages",noDisplayNameSub:"No name",editBoxCancelButton:"Cancel",editBoxSubmitButton:"Done",messageReadCount:"Read by {messageReadByCount} of {remoteParticipantsCount}",actionMenuMoreOptions:"More Options",downloadFile:"Download file",blockedWarningText:"This message was deleted due to organizational policy.",blockedWarningLinkText:"Details",fileCardGroupMessage:"The message has {fileCount} attachment",messageDeletedAnnouncementAriaLabel:"The message is deleted"};var errorBar$k={unableToReachChatService:"You are offline",accessDenied:"Unable to access chat services - please check the user credentials provided",userNotInChatThread:"You are no longer in this chat thread",sendMessageNotInChatThread:"Failed to send message because you are no longer in this chat thread",sendMessageGeneric:"Failed to send message",callingNetworkFailure:"Troubling connecting call - you seem to be offline",startVideoGeneric:"Failed to start video",stopVideoGeneric:"Failed to stop video",muteGeneric:"Failed to mute microphone",unmuteGeneric:"Failed to unmute microphone",speakingWhileMuted:"Your microphone is muted",startScreenShareGeneric:"There was an issue starting screen share.",stopScreenShareGeneric:"Failed to stop screen sharing",callNetworkQualityLow:"Network quality is low.",callNoSpeakerFound:"No speakers or headphones found. Connect an audio device to hear the call.",callNoMicrophoneFound:"No microphones found. Connect an audio input device.",callMicrophoneAccessDenied:"Unable to access microphone. Click the lock in the address bar to grant permission to this webpage.",callMicrophoneAccessDeniedSafari:"Unable to access microphone. Refresh the page to allow permissions, or check this browsers settings and verify permissions are enabled for this website.",callMicrophoneMutedBySystem:"You are muted by your system.",callMicrophoneUnmutedBySystem:"Your microphone recovered and you were unmuted by your system.",callMacOsMicrophoneAccessDenied:"Unable to access microphone. Grant microphone permission in your macOS privacy settings.",callLocalVideoFreeze:"Network bandwidth is poor. Your video may appear paused for others on the call.",callCameraAccessDenied:"Unable to access camera. Click the lock in the address bar to grant permission to this webpage.",callCameraAccessDeniedSafari:"Unable to access camera. Refresh the page to allow permissions, or check this browsers settings and verify permissions are enabled for this website.",callCameraAlreadyInUse:"Unable to access camera. It may already be in use by another application.",callVideoStoppedBySystem:"Your video has been stopped by your system.",callVideoRecoveredBySystem:"Your video has resumed.",callMacOsCameraAccessDenied:"MacOS is blocking access to your camera. Update your privacy settings to allow this browser to access your camera.",callMacOsScreenShareAccessDenied:"MacOS is blocking screen sharing. Update your privacy settings to allow this browser to record your screen.",dismissButtonAriaLabel:"Close",failedToJoinCallGeneric:"Failed to join call.",failedToJoinCallInvalidMeetingLink:"Unable to join Meeting. Invalid Link.",cameraFrozenForRemoteParticipants:"Users in the call are having issues seeing your video. Please check your devices and network.",unableToStartVideoEffect:"Unable to apply video effect.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Cannot start spotlight on participant(s) because the maximum number of participants are already spotlighted."};var videoGallery$k={screenIsBeingSharedMessage:"You are sharing your screen",screenShareLoadingMessage:"Loading {participant}'s screen",localVideoLabel:"You",localVideoCameraSwitcherLabel:"Switch camera",localVideoMovementLabel:"Movable Local Video Tile",localVideoSelectedDescription:"{cameraName} selected",displayNamePlaceholder:"Unnamed participant",fitRemoteParticipantToFrame:"Fit to frame",fillRemoteParticipantFrame:"Fill frame",pinParticipantForMe:"Pin for me",pinParticipantForMeLimitReached:"Pin (limit reached)",unpinParticipantForMe:"Unpin",pinParticipantMenuItemAriaLabel:"Pin {participantName}",unpinParticipantMenuItemAriaLabel:"Unpin {participantName}",pinnedParticipantAnnouncementAriaLabel:"Pinned {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Unpinned {participantName}",startSpotlightVideoTileMenuLabel:"Spotlight for everyone",addSpotlightVideoTileMenuLabel:"Add spotlight",spotlightLimitReachedMenuTitle:"Spotlight limit reached",stopSpotlightVideoTileMenuLabel:"Stop spotlighting",stopSpotlightOnSelfVideoTileMenuLabel:"Exit spotlight",attendeeRole:"Attendee"};var dialpad$k={placeholderText:"Enter phone number",deleteButtonAriaLabel:"Delete"};var holdButton$k={onLabel:"Resume",offLabel:"Hold",tooltipOnContent:"Resume call",tooltipOffContent:"Hold call"};var videoTile$k={participantStateRinging:"Calling...",participantStateHold:"On hold"};var CameraAndMicrophoneSitePermissionsRequest$k={primaryText:"Allow {appName} to use your camera and microphone",secondaryText:"This is so participants can see and hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera and microphone",ariaLabel:"Allow camera and microphone access"};var CameraSitePermissionsRequest$k={primaryText:"Allow {appName} to use your camera",secondaryText:"This is so participants can see you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera",ariaLabel:"Allow camera access"};var MicrophoneSitePermissionsRequest$k={primaryText:"Allow {appName} to use your microphone",secondaryText:"This is so participants can hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without microphone",ariaLabel:"Allow microphone access"};var CameraAndMicrophoneSitePermissionsCheck$k={primaryText:"Checking for camera and microphone access",secondaryText:"Allow access if prompted. This is so participants can see and hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera and microphone",ariaLabel:"Checking for camera and microphone access. Allow access if prompted."};var CameraSitePermissionsCheck$k={primaryText:"Checking for camera access",secondaryText:"Allow access if prompted. This is so participants can see you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera",ariaLabel:"Checking for camera access. Allow access if prompted."};var MicrophoneSitePermissionsCheck$k={primaryText:"Checking for microphone access",secondaryText:"Allow access if prompted. This is so participants can hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without microphone",ariaLabel:"Checking for microphone access. Allow access if prompted."};var CameraAndMicrophoneSitePermissionsDenied$k={primaryText:"Unable to access camera and microphone",secondaryText:"Click the lock icon in the address bar to grant microphone permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without camera and microphone",linkText:"Need help? Get troubleshooting help"};var CameraAndMicrophoneSitePermissionsDeniedSafari$k={primaryText:"Unable to access camera and microphone",secondaryText:"Refresh the page to allow permissions, or check this browsers settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without camera and microphone",linkText:"Need help? Get troubleshooting help"};var CameraSitePermissionsDenied$k={primaryText:"Unable to access camera",secondaryText:"Click the lock icon in the address bar to grant camera permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without camera",linkText:"Need help? Get troubleshooting help"};var MicrophoneSitePermissionsDenied$k={primaryText:"Unable to access microphone",secondaryText:"Click the lock icon in the address bar to grant microphone permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without microphone",linkText:"Need help? Get troubleshooting help"};var CameraSitePermissionsDeniedSafari$k={primaryText:"Unable to access camera",secondaryText:"Refresh the page to allow permissions, or check this browsers settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without camera",linkText:"Need help? Get troubleshooting help"};var MicrophoneSitePermissionsDeniedSafari$k={primaryText:"Unable to access microphone",secondaryText:"Refresh the page to allow permissions, or check this browsers settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without microphone",linkText:"Need help? Get troubleshooting help"};var UnsupportedBrowser$k={primaryText:"Browser not supported",secondaryText:"Please join this call using a compatible browser.",moreHelpLinkText:"See compatibility requirements"};var UnsupportedBrowserVersion$k={primaryText:"Browser update needed",secondaryText:"To ensure the best call possible, please update your browser and then try joining the call again.",moreHelpLinkText:"See compatibility requirements",continueAnywayButtonText:"Start call without updating"};var UnsupportedOperatingSystem$k={primaryText:"Operating system not supported",secondaryText:"Please join this call using a device with a compatible operating system.",moreHelpLinkText:"See compatibility requirements"};var BrowserPermissionDenied$k={primaryText:"Can't use your camera or microphone",secondaryText:"Your browser might not have access to your camera or microphone. To fix this, open System Preferences.",primaryButtonText:"Try again",linkText:"Need help? Get troubleshooting help"};var BrowserPermissionDeniedIOS$k={primaryText:"Allow microphone access to continue",secondaryText:"So other participants can hear you.",primaryButtonText:"Try again",imageAltText:"Microphone and camera device permission location for iOS",linkText:"Need help? Get troubleshooting help",step1Text:"Go to the Settings app",step2Text:"Scroll down to settings for this browser",step3Text:"Turn on Microphone (Camera optional)",step4Text:"Try joining the call again",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$k={leftNavButtonAriaLabel:"previous page",rightNavButtonAriaLabel:"next page"};var en_US$1 = {participantItem:participantItem$k,ParticipantList:ParticipantList$l,typingIndicator:typingIndicator$k,sendBox:sendBox$k,richTextSendBox:richTextSendBox$k,mentionPopover:mentionPopover$k,imageOverlay:imageOverlay$k,messageStatusIndicator:messageStatusIndicator$k,endCallButton:endCallButton$k,cameraButton:cameraButton$k,microphoneButton:microphoneButton$k,devicesButton:devicesButton$k,participantsButton:participantsButton$k,screenShareButton:screenShareButton$k,raiseHandButton:raiseHandButton$k,reactionButton:reactionButton$k,messageThread:messageThread$k,errorBar:errorBar$k,videoGallery:videoGallery$k,dialpad:dialpad$k,holdButton:holdButton$k,videoTile:videoTile$k,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$k,CameraSitePermissionsRequest:CameraSitePermissionsRequest$k,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$k,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$k,CameraSitePermissionsCheck:CameraSitePermissionsCheck$k,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$k,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$k,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$k,CameraSitePermissionsDenied:CameraSitePermissionsDenied$k,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$k,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$k,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$k,UnsupportedBrowser:UnsupportedBrowser$k,UnsupportedBrowserVersion:UnsupportedBrowserVersion$k,UnsupportedOperatingSystem:UnsupportedOperatingSystem$k,BrowserPermissionDenied:BrowserPermissionDenied$k,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$k,verticalGallery:verticalGallery$k};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for English (US).
 *
 * @public
 */
const COMPONENT_LOCALE_EN_US = {
    strings: en_US$1
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Context for providing localized strings to components exported from this library.
 *
 * @public
 */
const LocaleContext$1 = React.createContext(COMPONENT_LOCALE_EN_US);
/**
 * Provider to provide localized strings for this library's react components.
 *
 * @remarks Components will be provided localized strings in English (US) by default if this
 * provider is not used.
 *
 * @public
 */
const LocalizationProvider$1 = (props) => {
    const { locale, children } = props;
    return React.createElement(LocaleContext$1.Provider, { value: locale }, children);
};
/** React hook to access locale */
const useLocale$1 = () => React.useContext(LocaleContext$1);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const defaultIdentifiers = {
    sendboxTextField: 'sendbox-textfield',
    participantButtonPeopleMenuItem: 'participant-button-people-menu-item',
    participantItemMenuButton: 'participant-item-menu-button',
    participantList: 'participant-list',
    participantListPeopleButton: 'participant-list-people-button',
    participantListRemoveParticipantButton: 'participant-list-remove-participant-button',
    messageContent: 'message-content',
    messageTimestamp: 'message-timestamp',
    typingIndicator: 'typing-indicator',
    videoGallery: 'video-gallery',
    videoTile: 'video-tile',
    overflowGalleryLeftNavButton: 'overflow-gallery-left-nav-button',
    overflowGalleryRightNavButton: 'overflow-gallery-right-nav-button',
    /* @conditional-compile-remove(vertical-gallery) */
    verticalGalleryVideoTile: 'vertical-gallery-video-tile',
    horizontalGalleryVideoTile: 'horizontal-gallery-video-tile',
    /* @conditional-compile-remove(vertical-gallery) */
    verticalGalleryPageCounter: 'vertical-gallery-page-counter'
};
/**
 * @private
 */
const IdentifierContext = React.createContext(defaultIdentifiers);
/**
 * React Context provider for {@link _Identifiers}.
 *
 * @experimental
 *
 * See documentation for {@link _Identifiers}.
 *
 * @internal
 */
const _IdentifierProvider = (props) => {
    const { identifiers, children } = props;
    return React.createElement(IdentifierContext.Provider, { value: identifiers !== null && identifiers !== void 0 ? identifiers : defaultIdentifiers }, children);
};
/**
 * @private
 */
const useIdentifiers = () => React.useContext(IdentifierContext);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const MAXIMUM_LENGTH_OF_TYPING_USERS = 35;
/**
 * Helper function to create element wrapping all typing users
 * @param typingUsers typing users
 * @param delimiter string to separate typing users
 * @param onRenderUser optional callback to render each typing user
 * @param userDisplayNameStyles optional additional IStyle to apply to each element containing users name
 * @returns element wrapping all typing users
 */
const getUsersElement = (typingUsers, delimiter, onRenderUser, userDisplayNameStyles) => {
    const userElements = [];
    typingUsers.forEach((user, index) => {
        let truncatedDisplayName = user.displayName;
        if (truncatedDisplayName && truncatedDisplayName.length > 50) {
            truncatedDisplayName = truncatedDisplayName.substring(0, 50) + '...';
        }
        userElements.push(onRenderUser ? onRenderUser(user) : React.createElement(react.Text, { className: react.mergeStyles(userDisplayNameStyles), key: `user-${index}` }, truncatedDisplayName));
        userElements.push(React.createElement(react.Text, { key: `comma-${index}` }, `${delimiter}`));
    });
    // pop last comma
    userElements.pop();
    return React.createElement(React.Fragment, null, userElements);
};
/**
 * Helper function to get a string of all typing users
 * @param typingUsers typing users
 * @param delimiter string to separate typing users
 * @returns string of all typing users
 */
const getNamesString = (typingUsers, delimiter) => {
    const userNames = [];
    typingUsers.forEach(user => {
        if (user.displayName) {
            userNames.push(user.displayName);
        }
    });
    return userNames.join(delimiter);
};
/**
 * Helper function to create span elements making up the typing indicator string
 * @param strings TypingIndicatorStrings containing strings to create span elements
 * @param usersElement JSX.Element containing all typing users
 * @param numTypingUsers number of total typing users
 * @param numUserNotMentioned number of typing users abbreviated
 * @returns array of span elements making up the typing indicator string
 */
const getSpanElements = (strings, usersElement, numTypingUsers, numTypingUsersAbbreviated) => {
    let variables = {};
    let typingString = '';
    if (numTypingUsers === 1) {
        typingString = strings.singleUser;
        variables = {
            user: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated === 0) {
        typingString = strings.multipleUsers;
        variables = {
            users: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated === 1) {
        typingString = strings.multipleUsersAbbreviateOne;
        variables = {
            users: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated > 1) {
        typingString = strings.multipleUsersAbbreviateMany;
        variables = {
            users: usersElement,
            numOthers: React.createElement(React.Fragment, null, numTypingUsersAbbreviated)
        };
    }
    return formatInlineElements(typingString, variables);
};
/**
 * Helper function to get the string making up the typing indicator string
 * @param strings TypingIndicatorStrings containing strings to create span elements
 * @param namesString string of all typing users
 * @param numTypingUsers number of total typing users
 * @param numUserNotMentioned number of typing users abbreviated
 * @returns typing indicator string
 */
const getIndicatorString = (strings, namesString, numTypingUsers, numTypingUsersAbbreviated) => {
    if (numTypingUsers === 1) {
        return strings.singleUser.replace('{user}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated === 0) {
        return strings.multipleUsers.replace('{users}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated === 1) {
        return strings.multipleUsersAbbreviateOne.replace('{users}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated > 1) {
        return strings.multipleUsersAbbreviateMany.replace('{users}', namesString).replace('{numOthers}', `${numTypingUsersAbbreviated}`);
    }
    return undefined;
};
const IndicatorComponent = (typingUsers, strings, onRenderUser, styles) => {
    const typingUsersMentioned = [];
    let totalCharacterCount = 0;
    const ids = useIdentifiers();
    for (const typingUser of typingUsers) {
        if (!typingUser.displayName) {
            continue;
        }
        let additionalCharCount = typingUser.displayName.length;
        // The typing users will be separated by the delimiter. We account for that additional length when we generate the final string.
        if (typingUsersMentioned.length > 0) {
            additionalCharCount += strings.delimiter.length;
        }
        if (totalCharacterCount + additionalCharCount <= MAXIMUM_LENGTH_OF_TYPING_USERS || typingUsersMentioned.length === 0) {
            typingUsersMentioned.push(typingUser);
            totalCharacterCount += additionalCharCount;
        }
        else {
            break;
        }
    }
    const usersElement = getUsersElement(typingUsersMentioned, strings.delimiter, onRenderUser, styles === null || styles === void 0 ? void 0 : styles.typingUserDisplayName);
    const numUserNotMentioned = typingUsers.length - typingUsersMentioned.length;
    const spanElements = getSpanElements(strings, usersElement, typingUsers.length, numUserNotMentioned);
    const labelString = getIndicatorString(strings, getNamesString(typingUsersMentioned, strings.delimiter), typingUsers.length, numUserNotMentioned);
    return React.createElement("div", { "data-ui-id": ids.typingIndicator, className: react.mergeStyles(typingIndicatorStringStyle, styles === null || styles === void 0 ? void 0 : styles.typingString), key: "typingStringKey", role: "status", "aria-label": labelString }, spanElements);
};
/**
 * Component to notify local user when one or more participants in the chat thread are typing.
 *
 * @public
 */
const TypingIndicator = (props) => {
    const { typingUsers, onRenderUser, styles } = props;
    const { strings } = useLocale$1();
    const typingUsersToRender = typingUsers.filter(typingUser => typingUser.displayName !== undefined);
    const indicatorComponent = IndicatorComponent(typingUsersToRender, Object.assign(Object.assign({}, strings.typingIndicator), props.strings), onRenderUser, styles);
    return React.createElement(react.Stack, { className: react.mergeStyles(typingIndicatorContainerStyle, styles === null || styles === void 0 ? void 0 : styles.root) }, indicatorComponent);
};
/**
 * Create an array of span elements by replacing the pattern "\{\}" in str with the elements
 * passed in as vars and creating inline elements from the rest
 *
 * @param str - The string to be formatted
 * @param vars - Variables to use to format the string
 * @returns formatted JSX elements
 */
const formatInlineElements = (str, vars) => {
    if (!str) {
        return [];
    }
    if (!vars) {
        return [];
    }
    const elements = [];
    // regex to search for the pattern "{}"
    const placeholdersRegex = /{(\w+)}/g;
    const regex = RegExp(placeholdersRegex);
    let array = regex.exec(str);
    let prev = 0;
    while (array !== null) {
        if (prev !== array.index) {
            elements.push(React.createElement(react.Text, { key: elements.length }, str.substring(prev, array.index)));
        }
        elements.push(React.createElement(react.Text, { key: elements.length }, vars[array[0].substring(1, array[0].length - 1)]));
        prev = regex.lastIndex;
        array = regex.exec(str);
    }
    elements.push(React.createElement(react.Text, { key: elements.length }, str.substring(prev)));
    return elements;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 * @param dismissedErrors
 * @param toDismiss
 * @returns DismissedError[]
 * Always returns a new Array so that the state variable is updated, trigerring a render.
 */
const dismissError = (dismissedErrors, toDismiss) => {
    var _a;
    const now = new Date(Date.now());
    for (const error of dismissedErrors) {
        if (error.type === toDismiss.type) {
            // Bump the timestamp for latest dismissal of this error to now.
            error.dismissedAt = now;
            error.activeSince = toDismiss.timestamp;
            return Array.from(dismissedErrors);
        }
    }
    const toDismissTimestamp = (_a = toDismiss.timestamp) !== null && _a !== void 0 ? _a : now;
    // Record that this error was dismissed for the first time right now.
    return [...dismissedErrors, {
            type: toDismiss.type,
            // the error time could be sometimes later than the button click time, which cause the dismiss not working
            // so we set the dismiss time to the later one
            dismissedAt: now > toDismissTimestamp ? now : toDismissTimestamp,
            activeSince: toDismiss.timestamp
        }];
};
/**
 * @private
 * @param activeErrorMessages
 * @param dismissedErrors
 * @returns DismissedError[]
 *  Returns a new Array if and only if contents change, to avoid re-rendering when nothing was dropped.
 */
const dropDismissalsForInactiveErrors = (activeErrorMessages, dismissedErrors) => {
    const active = new Map();
    for (const message of activeErrorMessages) {
        active.set(message.type, message);
    }
    // For an error such that:
    // * It was previously active, and dismissed.
    // * It did not have a timestamp associated with it.
    // * It is no longer active.
    //
    // We remove it from dismissals. When it becomes active again next time, it will be shown again on the UI.
    const shouldDeleteDismissal = (dismissed) => dismissed.activeSince === undefined && active.get(dismissed.type) === undefined;
    if (dismissedErrors.some(dismissed => shouldDeleteDismissal(dismissed))) {
        return dismissedErrors.filter(dismissed => !shouldDeleteDismissal(dismissed));
    }
    return dismissedErrors;
};
/**
 * @private
 * @param activeErrorMessages
 * @param dismissedErrors
 * @returns ActiveErrorMessage[]
 */
const errorsToShow = (activeErrorMessages, dismissedErrors, mountTimestamp) => {
    const dismissed = new Map();
    for (const error of dismissedErrors) {
        dismissed.set(error.type, error);
    }
    return activeErrorMessages.filter(error => {
        if (mountTimestamp && error.timestamp && mountTimestamp > error.timestamp) {
            // Error has a timestamp and it is older than when the component was mounted.
            return false;
        }
        const dismissal = dismissed.get(error.type);
        if (!dismissal) {
            // This error was never dismissed.
            return true;
        }
        if (!error.timestamp) {
            // No timestamp associated with the error. In this case, the existence of a dismissal is enough to suppress the error.
            return false;
        }
        // Error has an associated timestamp, so compare with last dismissal.
        return error.timestamp > dismissal.dismissedAt;
    });
};
/**
 * @private
 * @param errorType
 * @returns MessageBarType
 */
const messageBarType = (errorType) => {
    switch (errorType) {
        case 'callNetworkQualityLow':
        case 'callNoSpeakerFound':
        case 'callNoMicrophoneFound':
        case 'callMicrophoneAccessDenied':
        case 'callMicrophoneAccessDeniedSafari':
        case 'callMicrophoneMutedBySystem':
        case 'callMicrophoneUnmutedBySystem':
        case 'callMacOsMicrophoneAccessDenied':
        case 'callLocalVideoFreeze':
        case 'callCameraAccessDenied':
        case 'callCameraAccessDeniedSafari':
        case 'callCameraAlreadyInUse':
        case 'callVideoStoppedBySystem':
        case 'callVideoRecoveredBySystem':
        case 'callMacOsCameraAccessDenied':
        case 'callMacOsScreenShareAccessDenied':
        case 'startScreenShareGeneric':
        case 'cameraFrozenForRemoteParticipants':
            return react.MessageBarType.warning;
        default:
            return react.MessageBarType.error;
    }
};
/**
 * @private
 * @param errorType
 * @returns IIconProps | undefined
 */
const messageBarIconProps = (errorType) => {
    const iconName = customIconName[errorType];
    return iconName ? {
        iconName
    } : undefined;
};
/**
 * @private
 */
const customIconName = {
    callNetworkQualityLow: 'ErrorBarCallNetworkQualityLow',
    callNoSpeakerFound: 'ErrorBarCallNoSpeakerFound',
    callNoMicrophoneFound: 'ErrorBarCallNoMicrophoneFound',
    callMicrophoneAccessDenied: 'ErrorBarCallMicrophoneAccessDenied',
    callMicrophoneAccessDeniedSafari: 'ErrorBarCallMicrophoneAccessDenied',
    callMicrophoneMutedBySystem: 'ErrorBarCallMicrophoneMutedBySystem',
    callMicrophoneUnmutedBySystem: 'ErrorBarCallMicrophoneUnmutedBySystem',
    callMacOsMicrophoneAccessDenied: 'ErrorBarCallMacOsMicrophoneAccessDenied',
    callLocalVideoFreeze: 'ErrorBarCallLocalVideoFreeze',
    callCameraAccessDenied: 'ErrorBarCallCameraAccessDenied',
    callCameraAccessDeniedSafari: 'ErrorBarCallCameraAccessDenied',
    callCameraAlreadyInUse: 'ErrorBarCallCameraAlreadyInUse',
    callVideoStoppedBySystem: 'ErrorBarCallVideoStoppedBySystem',
    callVideoRecoveredBySystem: 'ErrorBarCallVideoRecoveredBySystem',
    callMacOsCameraAccessDenied: 'ErrorBarCallMacOsCameraAccessDenied'
};
/**
 * Chunk an array into rows of a given size.
 * @private
 */
function chunk(options, itemsPerRow) {
    const rows = [];
    let currentRow = [];
    for (const option of options) {
        currentRow.push(option);
        if (currentRow.length === itemsPerRow) {
            rows.push(currentRow);
            currentRow = [];
        }
    }
    if (currentRow.length > 0) {
        rows.push(currentRow);
    }
    return rows;
}
/**
 * @private
 */
const defaultSpokenLanguage = 'en-us';
/**
 * @private
 */
const SAFARI_COMPOSITION_KEYCODE = 229;
/**
 * Determine if the press of the enter key is from a composition session or not (Safari only)
 *
 * @private
 */
const isEnterKeyEventFromCompositionSession = (e) => 
// Uses KeyCode 229 and which code 229 to determine if the press of the enter key is from a composition session or not (Safari only)
e.nativeEvent.isComposing || e.nativeEvent.keyCode === SAFARI_COMPOSITION_KEYCODE || e.nativeEvent.which === SAFARI_COMPOSITION_KEYCODE;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A component to show error messages on the UI.
 * All strings that can be shown are accepted as the {@link ErrorBarProps.strings} so that they can be localized.
 * Active errors are selected by {@link ErrorBarProps.activeErrorMessages}.
 *
 * This component internally tracks dismissed by the user.
 *   * Errors that have an associated timestamp: The error is shown on the UI again if it occurs after being dismissed.
 *   * Errors that do not have a timestamp: The error is dismissed until it disappears from the props.
 *         If the error recurs, it is shown in the UI.
 *
 * Uses {@link @fluentui/react#MessageBar} UI element.
 *
 * @public
 */
const ErrorBar = (props) => {
    var _a;
    const localeStrings = useLocale$1().strings.errorBar;
    const strings = (_a = props.strings) !== null && _a !== void 0 ? _a : localeStrings;
    const trackDismissedErrorsInternally = !props.onDismissError;
    // Timestamp for when this comopnent is first mounted.
    // Never updated through the lifecycle of this component.
    const mountTimestamp = React.useRef(new Date(Date.now()));
    const [dismissedErrors, setDismissedErrors] = React.useState([]);
    // dropDismissalsForInactiveErrors only returns a new object if `dismissedErrors` actually changes.
    // Without this behaviour, this `useEffect` block would cause a render loop.
    React.useEffect(() => {
        trackDismissedErrorsInternally && setDismissedErrors(dropDismissalsForInactiveErrors(props.activeErrorMessages, dismissedErrors));
    }, [props.activeErrorMessages, dismissedErrors, trackDismissedErrorsInternally]);
    const toShow = errorsToShow(props.activeErrorMessages, dismissedErrors, props.ignorePremountErrors ? mountTimestamp.current : undefined);
    return React.createElement(react.Stack, { "data-ui-id": "error-bar-stack" }, toShow.map(error => React.createElement(react.MessageBar, Object.assign({}, props, { styles: {
            innerText: {
                alignSelf: 'center'
            },
            icon: {
                height: 0
            },
            content: {
                lineHeight: 'inherit'
            },
            dismissal: {
                height: 0,
                paddingTop: '0.8rem'
            }
        }, key: error.type, messageBarType: messageBarType(error.type), messageBarIconProps: messageBarIconProps(error.type), onDismiss: () => { var _a; return trackDismissedErrorsInternally ? setDismissedErrors(dismissError(dismissedErrors, error)) : (_a = props.onDismissError) === null || _a === void 0 ? void 0 : _a.call(props, error); }, dismissButtonAriaLabel: strings.dismissButtonAriaLabel, dismissIconProps: {
            iconName: 'ErrorBarClear'
        } }), strings[error.type])));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const gridLayoutStyle = react.mergeStyles({
    width: '100%',
    height: '100%',
    display: 'grid',
    gridGap: '0.5rem'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A component to lay out audio / video participants tiles in a call.
 *
 * @public
 */
const GridLayout = (props) => {
    const { children, styles } = props;
    const numberOfChildren = React.Children.count(children);
    const [currentWidth, setCurrentWidth] = React.useState(0);
    const [currentHeight, setCurrentHeight] = React.useState(0);
    const containerRef = React.useRef(null);
    const observer = React.useRef(new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        setCurrentWidth(width);
        setCurrentHeight(height);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => currentObserver.disconnect();
    }, [observer, containerRef]);
    const gridProps = React.useMemo(() => {
        return calculateGridProps(numberOfChildren, currentWidth, currentHeight);
    }, [numberOfChildren, currentWidth, currentHeight]);
    const cssGridStyles = React.useMemo(() => createGridStyles(numberOfChildren, gridProps), [numberOfChildren, gridProps]);
    return React.createElement("div", { ref: containerRef, className: react.mergeStyles(gridLayoutStyle, cssGridStyles, styles === null || styles === void 0 ? void 0 : styles.root), "data-ui-id": "grid-layout" }, children);
};
/**
 * The cell aspect ratio we aim for in a grid
 */
const TARGET_CELL_ASPECT_RATIO = 16 / 9;
/**
 * The minimum cell aspect ratio we allow
 */
const MINIMUM_CELL_ASPECT_RATIO_ALLOWED = 8 / 9;
const isCloserThan = (a, b, target) => {
    return Math.abs(target - a) < Math.abs(target - b);
};
/**
 * Get the best GridProps to place a number of items in a grid as evenly as possible given the width and height of the grid
 * @param numberOfItems - number of items to place in grid
 * @param width - width of grid
 * @param height - height of grid
 * @returns GridProps
 */
const calculateGridProps = (numberOfItems, width, height) => {
    if (numberOfItems <= 0) {
        return {
            fillDirection: 'horizontal',
            rows: 0,
            columns: 0
        };
    }
    // If width or height are 0 then we return rows and column evenly
    if (width <= 0 || height <= 0) {
        return {
            fillDirection: 'horizontal',
            rows: Math.ceil(Math.sqrt(numberOfItems)),
            columns: Math.ceil(Math.sqrt(numberOfItems))
        };
    }
    const aspectRatio = width / height;
    // Approximate how many rows to divide the grid to achieve cells close to the TARGET_CELL_ASPECT_RATIO
    let rows = Math.floor(Math.sqrt(TARGET_CELL_ASPECT_RATIO / aspectRatio * numberOfItems)) || 1;
    // Make sure rows do not exceed numberOfItems
    rows = Math.min(rows, numberOfItems);
    // Given the rows, get the minimum columns needed to create enough cells for the number of items
    let columns = Math.ceil(numberOfItems / rows);
    // Default fill direction to horizontal
    let fillDirection = 'horizontal';
    while (rows < numberOfItems) {
        // If cell aspect ratio is less than MINIMUM_CELL_ASPECT_RATIO_ALLOWED then try more rows
        if (rows / columns * aspectRatio < MINIMUM_CELL_ASPECT_RATIO_ALLOWED) {
            rows += 1;
            columns = Math.ceil(numberOfItems / rows);
            continue;
        }
        if (numberOfItems < rows * columns) {
            // We need to check that stretching columns vertically will result in only one less cell in stretched columns.
            // Likewise, we need to check that stretching rows horizonally will result in only one less cell in stretched rows.
            // e.g. For 4 rows, 2 columns, but only 6 items, we cannot stretch vertically because that would result in a
            // column of 2 cells which is less by more than 1 compared to the unstretched column.
            //  _________
            // |____|    |
            // |____|____|
            // |____|    |
            // |____|____|
            const canStretchVertically = numberOfItems >= rows + (columns - 1) * (rows - 1);
            const canStretchHorizontally = numberOfItems >= columns + (rows - 1) * (columns - 1);
            if (!canStretchVertically && !canStretchHorizontally) {
                rows += 1;
                columns = Math.ceil(numberOfItems / rows);
                continue;
            }
            else if (!canStretchVertically) {
                break;
            }
            else if (!canStretchHorizontally) {
                fillDirection = 'vertical';
                break;
            }
            // We need to figure out whether the big cells should stretch horizontally or vertically
            // to fill in the empty spaces
            // e.g. For 2 rows, 3 columns, but only 5 items, we need to choose whether to stretch cells
            //       horizontally            or           vertically
            //  ______________________               _______________________
            // |       |       |      |             |       |       |       |
            // |_______|_______|______|             |_______|_______|       |
            // |           |          |             |       |       |       |
            // |___________|__________|             |_______|_______|_______|
            // Calculate the aspect ratio of big cells stretched horizontally
            const horizontallyStretchedCellRatio = rows / (columns - 1) * aspectRatio;
            // Calculate the aspect ratio of big cells stretched vertically
            const verticallyStretchedCellRatio = (rows - 1) / columns * aspectRatio;
            // We know the horizontally stretched cells aspect ratio is higher than MINIMUM_CELL_ASPECT_RATIO_ALLOWED. If vertically stretched cells
            // is also higher than the MINIMUM_CELL_ASPECT_RATIO_ALLOWED, then choose which aspect ratio is better.
            if (verticallyStretchedCellRatio >= MINIMUM_CELL_ASPECT_RATIO_ALLOWED) {
                // If vertically stetched cell has an aspect ratio closer to TARGET_CELL_ASPECT_RATIO then change the fill direction to vertical
                if (isCloserThan(verticallyStretchedCellRatio, horizontallyStretchedCellRatio, TARGET_CELL_ASPECT_RATIO)) {
                    fillDirection = 'vertical';
                }
            }
        }
        break;
    }
    return {
        fillDirection,
        rows,
        columns
    };
};
/**
 * Creates a styles classname with CSS Grid related styles given GridProps and the number of items to distribute as evenly as possible.
 * @param numberOfItems - number of items to place in grid
 * @param gridProps - GridProps that define the number of rows, number of columns, and the fill direction
 * @returns - classname
 */
const createGridStyles = (numberOfItems, gridProps) => {
    const isHorizontal = gridProps.fillDirection === 'horizontal';
    // Blocks are either rows or columns depending on whether we fill horizontally or vertically. Each block may differ in the number of cells.
    const blocks = isHorizontal ? gridProps.rows : gridProps.columns;
    const smallCellsPerBlock = Math.ceil(numberOfItems / blocks);
    const bigCellsPerBlock = Math.floor(numberOfItems / blocks);
    const numBigCells = (gridProps.rows * gridProps.columns - numberOfItems) * bigCellsPerBlock;
    // Get grid units
    // e.g. If some blocks have 2 big cells while others have 3 small cells, we need to work with 6 units per block
    const units = smallCellsPerBlock * bigCellsPerBlock;
    const gridStyles = isHorizontal ? {
        gridTemplateColumns: `repeat(${units}, minmax(0, 1fr))`,
        gridTemplateRows: `repeat(${blocks}, minmax(0, 1fr))`,
        gridAutoFlow: 'row'
    } : {
        gridTemplateColumns: `repeat(${blocks}, minmax(0, 1fr))`,
        gridTemplateRows: `repeat(${units}, minmax(0, 1fr))`,
        gridAutoFlow: 'column'
    };
    const smallCellStyle = isHorizontal ? {
        '> *': {
            gridColumn: `auto / span ${units / smallCellsPerBlock}`
        }
    } : {
        '> *': {
            gridRow: `auto / span ${units / smallCellsPerBlock}`
        }
    };
    // If there are big cells, we are choosing to place the latest children into the big cells.
    // That is why we use the '> *:nth-last-child(-n + ${numBigCells})' CSS selector below
    const bigCellStyle = numBigCells ? {
        [`> *:nth-last-child(-n + ${numBigCells})`]: isHorizontal ? {
            gridColumn: `auto / span ${units / bigCellsPerBlock}`
        } : {
            gridRow: `auto / span ${units / bigCellsPerBlock}`
        }
    } : {};
    return react.mergeStyles(gridStyles, smallCellStyle, bigCellStyle);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const sendBoxWrapperStyles = react.mergeStyles({
    margin: '0.25rem',
    overflow: 'hidden',
    /**
     * margin-top set for all the child components of sendbox except first
     */
    ':not(:first-child)': {
        marginTop: '0.25rem'
    }
});
/**
 * @private
 */
const sendButtonStyle = react.mergeStyles({
    height: '2.25rem',
    width: '2.25rem'
});
/**
 * @private
 */
const sendIconStyle = (props) => {
    const { theme, hasText, disabled = false, hasErrorMessage, customSendIconStyle, defaultTextColor = theme.palette.neutralTertiary } = props;
    const hasNoContent = !hasText;
    return react.mergeStyles(editorTextBoxButtonStyle, {
        color: disabled || hasErrorMessage || hasNoContent ? defaultTextColor : theme.palette.themePrimary
    }, customSendIconStyle);
};
/**
 * @private
 */
const editorTextBoxButtonStyle = {
    width: '1.25rem',
    height: '1.25rem',
    margin: 'auto'
};
/**
 * @private
 */
react.mergeStyles({
    margin: '0 0.25rem 0.25rem 0.25rem',
    maxHeight: '12.5rem',
    overflow: 'auto'
});
/**
 * @private
 */
react.mergeStyles({
    width: '100%',
    padding: '0.50rem'
});
/**
 * @private
 */
const defaultSendBoxInactiveBorderThicknessREM = 0.0625;
/**
 * @private
 */
const defaultSendBoxActiveBorderThicknessREM = 0.125;
/**
 * @private
 */
const borderAndBoxShadowStyle = (props) => {
    return react.mergeStyles(borderEditBoxStyle(Object.assign(Object.assign({}, props), { defaultBorderColor: props.theme.palette.neutralSecondary })));
};
/**
 * @private
 */
const borderEditBoxStyle = (props) => {
    const { theme, hasErrorMessage, disabled, defaultBorderColor } = props;
    const borderColor = hasErrorMessage ? theme.semanticColors.errorText : defaultBorderColor;
    const borderColorActive = hasErrorMessage ? theme.semanticColors.errorText : theme.palette.themePrimary;
    const borderThickness = disabled ? 0 : defaultSendBoxInactiveBorderThicknessREM;
    const borderActiveThickness = disabled ? 0 : defaultSendBoxActiveBorderThicknessREM;
    return {
        borderRadius: theme.effects.roundedCorner4,
        border: `${borderThickness}rem solid ${borderColor}`,
        // The border thickness of the sendbox wrapper changes on hover, to prevent the border thickness change causing the
        // input box to shift we apply a margin to compensate. This margin is then removed on hover when the border is thicker.
        margin: `${defaultSendBoxActiveBorderThicknessREM - borderThickness}rem`,
        ':hover, :active, :focus, :focus-within': {
            border: `${borderActiveThickness}rem solid ${borderColorActive}`,
            margin: `${defaultSendBoxActiveBorderThicknessREM - borderActiveThickness}rem`
        }
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Preset light theme for components exported from this library.
 *
 * @public
 */
const lightTheme = {
    palette: {
        themePrimary: '#0078d4',
        themeLighterAlt: '#eff6fc',
        themeLighter: '#deecf9',
        themeLight: '#c7e0f4',
        themeTertiary: '#71afe5',
        themeSecondary: '#2b88d8',
        themeDarkAlt: '#106ebe',
        themeDark: '#59b0f7',
        themeDarker: '#004578',
        neutralLighterAlt: '#faf9f8',
        neutralLighter: '#f3f2f1',
        neutralLight: '#edebe9',
        neutralQuaternaryAlt: '#e1dfdd',
        neutralQuaternary: '#d0d0d0',
        neutralTertiaryAlt: '#c8c6c4',
        neutralTertiary: '#a19f9d',
        neutralSecondary: '#605e5c',
        neutralPrimaryAlt: '#3b3a39',
        neutralPrimary: '#323130',
        neutralDark: '#201f1e',
        black: '#000000',
        white: '#ffffff',
        whiteTranslucent40: 'rgba(255, 255, 255, 0.4)'
    },
    callingPalette: {
        callRed: '#a42e43',
        callRedDark: '#8b2c3d',
        callRedDarker: '#772a38',
        iconWhite: '#ffffff',
        /* @conditional-compile-remove(raise-hand) */
        raiseHandGold: '#eaa300'
    },
    semanticColors: {
        errorText: '#a80000'
    }
};
/**
 * Preset dark theme for components exported from this library.
 *
 * @public
 */
const darkTheme = {
    palette: {
        themePrimary: '#2899f5',
        themeLighterAlt: '#02060a',
        themeLighter: '#061827',
        themeLight: '#0c2e49',
        themeTertiary: '#185b93',
        themeSecondary: '#2286d7',
        themeDarkAlt: '#3ca2f6',
        themeDark: '#59b0f7',
        themeDarker: '#84c5f9',
        neutralLighterAlt: '#302e2d',
        neutralLighter: '#383735',
        neutralLight: '#464443',
        neutralQuaternaryAlt: '#4e4d4b',
        neutralQuaternary: '#4d4b49',
        neutralTertiaryAlt: '#72706e',
        neutralTertiary: '#c8c8c8',
        neutralSecondary: '#d0d0d0',
        neutralPrimaryAlt: '#dadada',
        neutralPrimary: '#ffffff',
        neutralDark: '#f4f4f4',
        black: '#f8f8f8',
        white: '#252423',
        whiteTranslucent40: 'rgba(0, 0, 0, 0.4)'
    },
    callingPalette: {
        callRed: '#c4314b',
        callRedDark: '#a42e43',
        callRedDarker: '#8b2c3d',
        iconWhite: '#ffffff',
        /* @conditional-compile-remove(raise-hand) */
        raiseHandGold: '#eaa300'
    },
    semanticColors: {
        errorText: '#f1707b'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const wrapper = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'auto',
    // Add NorthStar styling used previously in the library
    '*': {
        boxSizing: 'border-box'
    },
    '*:before': {
        boxSizing: 'border-box'
    },
    '*:after': {
        boxSizing: 'border-box'
    },
    /* Adding priority for HTML `hidden` attribute to be applied correctly */
    '[hidden]': {
        display: 'none!important'
    }
});
const defaultTheme = Object.assign({}, react.mergeThemes(react.getTheme(), lightTheme));
/** Theme context for library's react components */
const ThemeContext = React.createContext(defaultTheme);
/**
 * Provider to apply a Fluent theme across this library's react components.
 *
 * @remarks Components in this library are composed primarily from [Fluent UI](https://developer.microsoft.com/fluentui#/controls/web),
 * controls, mixing v8 and v9 controls.
 * This provider handles applying any theme provided to the underlying Fluent UI controls. *
 * @public
 */
const FluentThemeProvider = (props) => {
    const { fluentTheme, rtl, children, 
    /* @conditional-compile-remove(image-overlay) */ rootStyle } = props;
    let fluentV8Theme = react.mergeThemes(defaultTheme, fluentTheme);
    fluentV8Theme = react.mergeThemes(fluentV8Theme, {
        rtl
    });
    return React.createElement(ThemeContext.Provider, { value: fluentV8Theme },
        React.createElement(react.ThemeProvider, { theme: fluentV8Theme, className: wrapper, 
            /* @conditional-compile-remove(image-overlay) */ style: rootStyle }, children));
};
/**
 * React hook to access theme
 *
 * @public
 */
const useTheme = () => React.useContext(ThemeContext);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const WifiWarning16Filled = () => 
// All ErrorBar icons are 16px x 16px (when 1rem = 16 px).
// There is no 16px version of this icon in the fluent icon package, so scale the larger
// one down to required size.
React.createElement("div", { className: react.mergeStyles({
        transform: 'scale(0.8)'
    }) },
    React.createElement(reactIcons.WifiWarning20Filled, null));
const MoreHorizontal18Regular = () => 
// MoreHorizontal icons are 16px x 16px or 20px x 20px so scaling to get desired size
React.createElement("div", { className: react.mergeStyles({
        transform: 'scale(0.9)'
    }) },
    React.createElement(reactIcons.MoreHorizontal20Regular, null));
const GalleryLeftButton = () => {
    const rtl = useTheme().rtl;
    return rtl ? React.createElement(reactIcons.ChevronRight20Regular, null) : React.createElement(reactIcons.ChevronLeft20Regular, null);
};
const GalleryRightButton = () => {
    const rtl = useTheme().rtl;
    return rtl ? React.createElement(reactIcons.ChevronLeft20Regular, null) : React.createElement(reactIcons.ChevronRight20Regular, null);
};
const ControlButtonRaiseHandIcon = () => {
    return React.createElement(reactIcons.HandRight20Filled, null);
};
const ControlButtonLowerHandIcon = () => {
    return React.createElement(reactIcons.HandRightOff20Filled, null);
};
/**
 * The default set of icons that are available to use in the UI components.
 *
 * @remark Icons used only in the composites are available in {@link DEFAULT_COMPOSITE_ICONS}.
 *
 * @public
 */
const DEFAULT_COMPONENT_ICONS = {
    ChatMessageOptions: React.createElement(MoreHorizontal18Regular, null),
    ControlButtonCameraOff: React.createElement(reactIcons.VideoOff20Filled, null),
    ControlButtonCameraOn: React.createElement(reactIcons.Video20Filled, null),
    ControlButtonEndCall: React.createElement(reactIcons.CallEnd20Filled, null),
    ControlButtonMicOff: React.createElement(reactIcons.MicOff20Filled, null),
    ControlButtonMicOn: React.createElement(reactIcons.Mic20Filled, null),
    ControlButtonOptions: React.createElement(reactIcons.Settings20Filled, null),
    ControlButtonParticipants: React.createElement(reactIcons.People20Filled, null),
    /* @conditional-compile-remove(dialpad) */ /* @conditional-compile-remove(PSTN-calls) */
    ControlButtonParticipantsContextualMenuItem: React.createElement(reactIcons.People20Regular, null),
    ControlButtonScreenShareStart: React.createElement(reactIcons.ShareScreenStart20Filled, null),
    ControlButtonScreenShareStop: React.createElement(reactIcons.ShareScreenStop20Filled, null),
    /* @conditional-compile-remove(raise-hand) */
    ControlButtonRaiseHand: React.createElement(ControlButtonRaiseHandIcon, null),
    /* @conditional-compile-remove(raise-hand) */
    ControlButtonLowerHand: React.createElement(ControlButtonLowerHandIcon, null),
    /* @conditional-compile-remove(raise-hand) */
    RaiseHandContextualMenuItem: React.createElement(reactIcons.HandRight20Regular, null),
    /* @conditional-compile-remove(raise-hand) */
    LowerHandContextualMenuItem: React.createElement(reactIcons.HandRightOff20Regular, null),
    EditBoxCancel: React.createElement(reactIcons.Dismiss20Regular, null),
    EditBoxSubmit: React.createElement(reactIcons.Checkmark20Regular, null),
    ErrorBarCallCameraAccessDenied: React.createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallCameraAlreadyInUse: React.createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallLocalVideoFreeze: React.createElement(WifiWarning16Filled, null),
    ErrorBarCallMacOsCameraAccessDenied: React.createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallMacOsMicrophoneAccessDenied: React.createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallMicrophoneAccessDenied: React.createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallMicrophoneMutedBySystem: React.createElement(reactIcons.MicOff16Filled, null),
    ErrorBarCallMicrophoneUnmutedBySystem: React.createElement(reactIcons.Mic16Filled, null),
    ErrorBarCallNetworkQualityLow: React.createElement(WifiWarning16Filled, null),
    ErrorBarCallNoMicrophoneFound: React.createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallNoSpeakerFound: React.createElement(reactIcons.SpeakerMute16Filled, null),
    ErrorBarClear: React.createElement(reactIcons.Dismiss16Regular, null),
    ErrorBarCallVideoRecoveredBySystem: React.createElement(reactIcons.Video16Filled, null),
    ErrorBarCallVideoStoppedBySystem: React.createElement(reactIcons.VideoProhibited16Filled, null),
    HorizontalGalleryLeftButton: React.createElement(GalleryLeftButton, null),
    HorizontalGalleryRightButton: React.createElement(GalleryRightButton, null),
    MessageDelivered: React.createElement(reactIcons.CheckmarkCircle16Regular, null),
    MessageEdit: React.createElement(reactIcons.Edit20Regular, null),
    MessageFailed: React.createElement(reactIcons.ErrorCircle16Regular, null),
    MessageRemove: React.createElement(reactIcons.Delete20Regular, null),
    MessageResend: React.createElement(reactIcons.ArrowClockwise16Regular, null),
    MessageSeen: React.createElement(reactIcons.Eye16Regular, null),
    MessageSending: React.createElement(reactIcons.Circle16Regular, null),
    OptionsCamera: React.createElement(reactIcons.Video20Regular, null),
    OptionsMic: React.createElement(reactIcons.Mic20Regular, null),
    OptionsSpeaker: React.createElement(reactIcons.Speaker220Regular, null),
    ParticipantItemMicOff: React.createElement(reactIcons.MicOff16Regular, null),
    ParticipantItemOptions: React.createElement(React.Fragment, null),
    ParticipantItemOptionsHovered: React.createElement(reactIcons.MoreHorizontal20Filled, null),
    ParticipantItemScreenShareStart: React.createElement(reactIcons.ShareScreenStart20Filled, null),
    SendBoxSend: React.createElement(reactIcons.Send20Regular, null),
    SendBoxSendHovered: React.createElement(reactIcons.Send20Filled, null),
    VideoTileMicOff: React.createElement(reactIcons.MicOff16Filled, null),
    /* @conditional-compile-remove(dialpad) */ /* @conditional-compile-remove(PSTN-calls) */
    DialpadBackspace: React.createElement(reactIcons.Backspace20Regular, null),
    VideoTilePinned: React.createElement(reactIcons.Pin16Filled, null),
    VideoTileMoreOptions: React.createElement(reactIcons.MoreHorizontal20Filled, null),
    VideoTileScaleFit: React.createElement(reactIcons.ScaleFit20Regular, null),
    VideoTileScaleFill: React.createElement(reactIcons.ScaleFill20Regular, null),
    PinParticipant: React.createElement(reactIcons.Pin16Regular, null),
    UnpinParticipant: React.createElement(reactIcons.PinOff16Regular, null),
    SplitButtonPrimaryActionCameraOn: React.createElement(reactIcons.Video20Filled, null),
    SplitButtonPrimaryActionCameraOff: React.createElement(reactIcons.VideoOff20Filled, null),
    SplitButtonPrimaryActionMicUnmuted: React.createElement(reactIcons.Mic20Filled, null),
    SplitButtonPrimaryActionMicMuted: React.createElement(reactIcons.MicOff20Filled, null),
    /* @conditional-compile-remove(vertical-gallery) */
    VerticalGalleryLeftButton: React.createElement(GalleryLeftButton, null),
    /* @conditional-compile-remove(vertical-gallery) */
    VerticalGalleryRightButton: React.createElement(GalleryRightButton, null),
    /* @conditional-compile-remove(video-background-effects) */
    ControlButtonVideoEffectsOption: React.createElement(reactIcons.VideoBackgroundEffect20Regular, null),
    /* @conditional-compile-remove(video-background-effects) */
    ConfigurationScreenVideoEffectsButton: React.createElement(reactIcons.VideoBackgroundEffect20Filled, null),
    /* @conditional-compile-remove(close-captions) */
    CaptionsIcon: React.createElement(reactIcons.ClosedCaption20Regular, null),
    /* @conditional-compile-remove(close-captions) */
    CaptionsOffIcon: React.createElement(reactIcons.ClosedCaptionOff20Regular, null),
    /* @conditional-compile-remove(close-captions) */
    CaptionsSettingsIcon: React.createElement(reactIcons.Settings20Regular, null),
    /* @conditional-compile-remove(close-captions) */
    ChangeSpokenLanguageIcon: React.createElement(reactIcons.PersonVoice20Regular, null),
    /* @conditional-compile-remove(close-captions) */
    ChangeCaptionLanguageIcon: React.createElement(reactIcons.Translate20Regular, null),
    ContextMenuCameraIcon: React.createElement(reactIcons.Video20Regular, null),
    ContextMenuMicIcon: React.createElement(reactIcons.Mic20Regular, null),
    ContextMenuSpeakerIcon: React.createElement(reactIcons.Speaker220Regular, null)
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const inputBoxWrapperStyle = react.mergeStyles({
    padding: '0'
});
/**
 * @private
 */
const inputBoxStyle = react.mergeStyles({
    overflow: 'auto',
    minHeight: '2.25rem',
    // prevents the input text box from being sized to 0px when the CallWithChatComposite chat pane is closed.
    maxHeight: '8.25rem',
    outline: 'red 5px',
    fontWeight: react.FontWeights.regular,
    fontSize: '0.875rem',
    width: '100%',
    height: '2.25rem',
    lineHeight: '1.5rem',
    '::-webkit-input-placeholder': {
        fontSize: '0.875rem'
    },
    '::-moz-placeholder': {
        fontSize: '0.875rem'
    },
    ':-moz-placeholder': {
        fontSize: '0.875rem'
    }
});
/**
 *
 * @private
 */
const textContainerStyle = {
    alignSelf: 'center',
    position: 'relative',
    width: '100%'
};
/**
 * @private
 */
const textFieldStyle = {
    root: {
        width: '100%',
        minHeight: '0',
        fontSize: '8.25rem'
    },
    wrapper: {},
    fieldGroup: {
        outline: 'none',
        border: 'none',
        height: 'auto',
        minHeight: '0',
        /**
         * Removing fieldGroup border to make sure no border is rendered around the text area in sendbox.
         */
        ':after': {
            border: 'none'
        }
    },
    field: {
        borderRadius: '0.25rem'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const InputBoxComponent = (props) => {
    const { styles, id, 'data-ui-id': dataUiId, textValue, onChange, textFieldRef, placeholderText, onKeyDown, onEnterKeyDown, supportNewline, inputClassName, errorMessage, disabled, children } = props;
    const mergedRootStyle = react.mergeStyles(inputBoxWrapperStyle, styles === null || styles === void 0 ? void 0 : styles.root);
    const mergedInputFieldStyle = react.mergeStyles(inputBoxStyle, inputClassName);
    const mergedTextContainerStyle = react.mergeStyles(textContainerStyle, styles === null || styles === void 0 ? void 0 : styles.textFieldContainer);
    const mergedTextFieldStyle = react.concatStyleSets(textFieldStyle, {
        fieldGroup: styles === null || styles === void 0 ? void 0 : styles.textField,
        errorMessage: styles === null || styles === void 0 ? void 0 : styles.systemMessage,
        suffix: {
            backgroundColor: 'transparent',
            padding: '0 0'
        }
    });
    const onTextFieldKeyDown = React.useCallback((ev) => {
        if (isEnterKeyEventFromCompositionSession(ev)) {
            return;
        }
        if (ev.key === 'Enter' && (ev.shiftKey === false || !supportNewline)) {
            ev.preventDefault();
            onEnterKeyDown && onEnterKeyDown();
        }
        onKeyDown && onKeyDown(ev);
    }, [onEnterKeyDown, onKeyDown, supportNewline]);
    const onRenderChildren = () => {
        return React.createElement(React.Fragment, null, children);
    };
    const renderTextField = () => {
        const textFieldProps = {
            autoFocus: props.autoFocus === 'sendBoxTextField',
            multiline: true,
            autoAdjustHeight: true,
            multiple: false,
            resizable: false,
            componentRef: textFieldRef,
            id,
            inputClassName: mergedInputFieldStyle,
            placeholder: placeholderText,
            autoComplete: 'off',
            styles: mergedTextFieldStyle,
            disabled,
            errorMessage,
            onRenderSuffix: props.children ? onRenderChildren : undefined
        };
        return React.createElement("div", { style: textFieldProps.errorMessage ? {
                padding: '0 0 5px 5px'
            } : undefined },
            React.createElement(react.TextField, Object.assign({}, textFieldProps, { "data-ui-id": dataUiId, value: textValue, onChange: onChange, onKeyDown: onTextFieldKeyDown, onFocus: e => {
                    // Fix for setting the cursor to the correct position when multiline is true
                    // This approach should be reviewed during migration to FluentUI v9
                    e.currentTarget.value = '';
                    e.currentTarget.value = textValue;
                } })));
    };
    return React.createElement(react.Stack, { className: mergedRootStyle },
        React.createElement("div", { className: mergedTextContainerStyle }, renderTextField()));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const isDarkThemed = (theme) => {
    const themeBlackBrightness = getPerceptualBrightnessOfHexColor(theme.palette.black);
    const themeWhiteBrightness = getPerceptualBrightnessOfHexColor(theme.palette.white);
    if (Number.isNaN(themeBlackBrightness) || Number.isNaN(themeWhiteBrightness)) {
        return false;
    }
    return themeBlackBrightness > themeWhiteBrightness;
};
const getPerceptualBrightnessOfHexColor = (hexColor) => {
    // return NaN if hexColor is not a hex code
    if (!/^#[0-9A-Fa-f]{6}$/i.test(hexColor)) {
        return NaN;
    }
    const r = parseInt(hexColor.substring(1, 3), 16);
    const g = parseInt(hexColor.substring(3, 5), 16);
    const b = parseInt(hexColor.substring(5, 7), 16);
    // arithmetic mean  of the red, green, and blue color coordinates. Source: https://en.wikipedia.org/wiki/Brightness
    return (r + g + b) / 3;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const inputBoxButtonStyle = react.mergeStyles({
    color: 'grey',
    margin: 'auto',
    width: '1.0625rem',
    height: '1.0625rem',
    backgroundColor: 'transparent',
    '&:hover': {
        backgroundColor: 'transparent'
    }
});
/**
 * @private
 */
const inputBoxButtonTooltipStyle = react.mergeStyles({
    // The toolTip host container show be a flex box, so that alignItems: 'center' works for inside buttons
    display: 'flex'
});
/**
 * @private
 */
const iconWrapperStyle$1 = react.mergeStyles({
    pointerEvents: 'none'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const InputBoxButton = (props) => {
    const { onRenderIcon, onClick, ariaLabel, className, id, tooltipContent, 'data-testId': dataTestId } = props;
    const [isHover, setIsHover] = React.useState(false);
    const mergedButtonStyle = react.mergeStyles(inputBoxButtonStyle, className);
    const theme = react.useTheme();
    const calloutStyle = {
        root: {
            padding: 0
        },
        calloutMain: {
            padding: '0.5rem'
        }
    };
    // Place callout with no gap between it and the button.
    const calloutProps = {
        gapSpace: 0,
        styles: calloutStyle,
        backgroundColor: isDarkThemed(theme) ? theme.palette.neutralLighter : ''
    };
    return React.createElement(react.TooltipHost, { hostClassName: inputBoxButtonTooltipStyle, content: tooltipContent, calloutProps: Object.assign({}, calloutProps) },
        React.createElement(react.IconButton, { className: mergedButtonStyle, ariaLabel: ariaLabel, onClick: onClick, id: id, onMouseEnter: () => {
                setIsHover(true);
            }, onMouseLeave: () => {
                setIsHover(false);
            }, 
            // VoiceOver fix: Avoid icon from stealing focus when IconButton is double-tapped to send message by wrapping with Stack with pointerEvents style to none
            onRenderIcon: () => React.createElement(react.Stack, { className: iconWrapperStyle$1 }, onRenderIcon(isHover)), "data-testid": dataTestId }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const MAXIMUM_LENGTH_OF_MESSAGE = 8000;
const EMPTY_MESSAGE_REGEX = /^\s*$/;
/**
 * @private
 */
const isMessageTooLong = (valueLength) => {
    return valueLength > MAXIMUM_LENGTH_OF_MESSAGE;
};
/**
 * @private
 */
const sanitizeText = (message) => {
    if (EMPTY_MESSAGE_REGEX.test(message)) {
        return '';
    }
    else {
        return message;
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Component for typing and sending messages.
 *
 * Supports sending typing notification when user starts entering text.
 * Supports an optional message below the text input field.
 *
 * @public
 */
const SendBox$1 = (props) => {
    const { disabled, systemMessage, supportNewline, onSendMessage, onTyping, onRenderIcon, onRenderSystemMessage, styles, autoFocus } = props;
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.sendBox;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const ids = useIdentifiers();
    const [textValue, setTextValue] = React.useState('');
    const [textValueOverflow, setTextValueOverflow] = React.useState(false);
    const sendTextFieldRef = React.useRef(null);
    const sendMessageOnClick = () => {
        var _a;
        // don't send a message when disabled
        if (disabled || textValueOverflow) {
            return;
        }
        // Don't send message until all files have been uploaded successfully
        const message = textValue;
        // we don't want to send empty messages including spaces, newlines, tabs
        // Message can be empty if there is a valid file upload
        if (sanitizeText(message).length > 0) {
            onSendMessage && onSendMessage(message);
            setTextValue('');
        }
        (_a = sendTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const setText = (newValue) => {
        if (newValue === undefined) {
            return;
        }
        setTextValueOverflow(isMessageTooLong(newValue.length));
        setTextValue(newValue);
    };
    const textTooLongMessage = textValueOverflow ? strings.textTooLong : undefined;
    const errorMessage = systemMessage !== null && systemMessage !== void 0 ? systemMessage : textTooLongMessage;
    const mergedSendButtonStyle = React.useMemo(() => react.mergeStyles(sendButtonStyle, styles === null || styles === void 0 ? void 0 : styles.sendMessageIconContainer), [styles === null || styles === void 0 ? void 0 : styles.sendMessageIconContainer]);
    const mergedStyles = React.useMemo(() => react.concatStyleSets(styles), [styles]);
    const mergedSendIconStyle = React.useMemo(() => sendIconStyle({
        theme,
        hasText: !!textValue,
        hasErrorMessage: !!errorMessage,
        customSendIconStyle: styles === null || styles === void 0 ? void 0 : styles.sendMessageIcon
    }), [theme, textValue, errorMessage, styles === null || styles === void 0 ? void 0 : styles.sendMessageIcon]);
    const onRenderSendIcon = React.useCallback((isHover) => onRenderIcon ? onRenderIcon(isHover) : React.createElement(react.Icon, { iconName: isHover && textValue ? 'SendBoxSendHovered' : 'SendBoxSend', className: mergedSendIconStyle }), [mergedSendIconStyle, onRenderIcon, textValue]);
    // Ensure that errors are cleared when there are no files in sendBox
    return React.createElement(react.Stack, { className: react.mergeStyles(sendBoxWrapperStyles, {
            overflow: 'visible'
        } // This is needed for the mention popup to be visible
        ) },
        React.createElement(react.Stack, { className: borderAndBoxShadowStyle({
                theme,
                hasErrorMessage: !!errorMessage,
                disabled: !!disabled
            }) },
            React.createElement(InputBoxComponent, { autoFocus: autoFocus, "data-ui-id": ids.sendboxTextField, disabled: disabled, errorMessage: onRenderSystemMessage ? onRenderSystemMessage(errorMessage) : errorMessage, textFieldRef: sendTextFieldRef, id: "sendbox", placeholderText: strings.placeholderText, textValue: textValue, onChange: (_, newValue) => setText(newValue), onKeyDown: ev => {
                    const keyWasSendingMessage = ev.key === 'Enter' && (ev.shiftKey === false || !supportNewline);
                    if (!keyWasSendingMessage) {
                        onTyping === null || onTyping === void 0 ? void 0 : onTyping();
                    }
                }, onEnterKeyDown: () => {
                    sendMessageOnClick();
                }, styles: mergedStyles, supportNewline: supportNewline, maxLength: MAXIMUM_LENGTH_OF_MESSAGE },
                React.createElement(InputBoxButton, { onRenderIcon: onRenderSendIcon, onClick: e => {
                        if (!textValueOverflow) {
                            sendMessageOnClick();
                        }
                        e.stopPropagation();
                    }, id: 'sendIconWrapper', className: mergedSendButtonStyle, ariaLabel: localeStrings.sendButtonAriaLabel, tooltipContent: localeStrings.sendButtonAriaLabel }))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const cancelIcon = {
    iconName: 'Cancel'
};
/**
 * @private
 */
const downloadIcon = {
    iconName: 'Download'
};
/* @conditional-compile-remove(image-overlay) */
/**
 * @private
 */
const overlayStyles = (theme) => {
    var _a;
    return {
        root: {
            background: (_a = theme.semanticColors) === null || _a === void 0 ? void 0 : _a.bodyBackground
        }
    };
};
/**
 * @private
 */
const focusTrapZoneStyle = {
    boxShadow: 'none',
    background: 'transparent',
    display: 'flex',
    width: '100%',
    height: '100%',
    maxWidth: '100%',
    maxHeight: '100%'
};
/**
 * @private
 */
const scrollableContentStyle = {
    overflowY: 'hidden',
    display: 'flex',
    maxWidth: '100%',
    maxHeight: '100%',
    flexDirection: 'column',
    flexWrap: 'nowrap'
};
/**
 * @private
 */
const themeProviderRootStyle = {
    background: 'transparent',
    display: 'flex',
    flexDirection: 'column'
};
/**
 * @private
 */
const headerStyle = {
    fontSize: 'inherit',
    margin: '0',
    width: '100%',
    height: '3.5rem',
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: '0.25rem 0.75rem'
};
/**
 * @private
 */
const titleBarContainerStyle = {
    flexDirection: 'row',
    justifyContent: 'start',
    flexWrap: 'wrap',
    alignContent: 'center',
    alignItems: 'center'
};
/**
 * @private
 */
const titleStyle$2 = (theme) => {
    var _a;
    return {
        paddingLeft: '0.5rem',
        color: (_a = theme.palette) === null || _a === void 0 ? void 0 : _a.black,
        fontFamily: 'inherit',
        fontSize: '0.875rem',
        fontStyle: 'normal',
        fontWeight: '600',
        lineHeight: '1.25rem'
    };
};
/**
 * @private
 */
const controlBarContainerStyle = {
    flexDirection: 'row',
    justifyContent: 'start',
    flexWrap: 'wrap',
    alignContent: 'center',
    alignItems: 'center'
};
/**
 * @private
 */
const downloadIconStyle = {
    marginRight: '0.5em',
    fontSize: '0.875rem' // 14px
};
/**
 * @private
 */
const bodyContainer = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%',
    height: '100%',
    overflow: 'hidden',
    padding: '1rem 2rem 3rem 2rem',
    '@media (max-width: 25rem) or (max-height: 25rem)': {
        padding: '0rem 1rem 2rem 1rem'
    }
};
/**
 * @private
 */
const normalImageStyle = {
    objectFit: 'contain',
    maxHeight: '100%',
    maxWidth: '100%'
};
/**
 * @private
 */
const brokenImageStyle = (theme) => {
    var _a;
    return {
        color: (_a = theme.palette) === null || _a === void 0 ? void 0 : _a.black
    };
};
/**
 * @private
 */
const closeButtonStyles = (theme) => {
    var _a, _b, _c;
    return {
        color: (_a = theme.palette) === null || _a === void 0 ? void 0 : _a.black,
        ':hover': {
            color: (_b = theme.palette) === null || _b === void 0 ? void 0 : _b.black
        },
        ':active': {
            color: (_c = theme.palette) === null || _c === void 0 ? void 0 : _c.black
        }
    };
};
/**
 * @private
 */
const downloadButtonStyle = {
    margin: '0 0.5rem',
    height: '32px',
    borderWidth: '1px',
    fontSize: '0.875rem',
    // 14px
    fontWeight: 600,
    padding: '0.38rem 0.75rem',
    borderRadius: '4px',
    whiteSpace: 'nowrap',
    '@media (max-width: 25rem)': {
        display: 'none'
    }
};
/**
 * @private
 */
const smallDownloadButtonContainerStyle = (theme) => {
    var _a, _b, _c;
    return {
        marginRight: '0.5rem',
        whiteSpace: 'nowrap',
        color: (_a = theme.palette) === null || _a === void 0 ? void 0 : _a.black,
        ':hover': {
            color: (_b = theme.palette) === null || _b === void 0 ? void 0 : _b.black
        },
        ':active': {
            color: (_c = theme.palette) === null || _c === void 0 ? void 0 : _c.black
        },
        '@media (min-width: 25rem)': {
            display: 'none'
        }
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(image-overlay) */
/* @conditional-compile-remove(image-overlay) */
/**
 * Component to render a fullscreen modal for a selected image.
 *
 * @public
 */
const ImageOverlay = (props) => {
    const { isOpen, imageSrc, title, titleIcon, altText, onDownloadButtonClicked, onDismiss } = props;
    /* @conditional-compile-remove(image-overlay) */
    const localeStrings = useLocale$1().strings.imageOverlay;
    const [isImageLoaded, setIsImageLoaded] = React.useState(true);
    /* @conditional-compile-remove(image-overlay) */
    const overlayTheme = React.useMemo(() => {
        return Object.assign(Object.assign({}, darkTheme), { semanticColors: Object.assign(Object.assign({}, darkTheme.semanticColors), { bodyBackground: 'rgba(0, 0, 0, 0.85)' }) });
    }, []);
    const imageStyle = isImageLoaded ? normalImageStyle : brokenImageStyle(overlayTheme);
    const renderHeaderBar = () => {
        return React.createElement(react.Stack, { className: react.mergeStyles(headerStyle) },
            React.createElement(react.Stack, { className: react.mergeStyles(titleBarContainerStyle) },
                titleIcon,
                React.createElement(react.Stack.Item, { className: react.mergeStyles(titleStyle$2(overlayTheme)), "aria-label": title || 'Image' }, title)),
            React.createElement(react.Stack, { className: react.mergeStyles(controlBarContainerStyle) },
                onDownloadButtonClicked && React.createElement(react.DefaultButton, { className: react.mergeStyles(downloadButtonStyle), 
                    /* @conditional-compile-remove(image-overlay) */ text: localeStrings.downloadButtonLabel, onClick: () => onDownloadButtonClicked && onDownloadButtonClicked(imageSrc), onRenderIcon: () => React.createElement(react.Icon, { iconName: downloadIcon.iconName, className: react.mergeStyles(downloadIconStyle) }), "aria-live": 'polite', "aria-label": localeStrings.downloadButtonLabel, disabled: imageSrc === '' }),
                onDownloadButtonClicked && React.createElement(react.IconButton, { iconProps: downloadIcon, className: react.mergeStyles(smallDownloadButtonContainerStyle(overlayTheme)), onClick: () => onDownloadButtonClicked && onDownloadButtonClicked(imageSrc), "aria-label": localeStrings.downloadButtonLabel, "aria-live": 'polite', disabled: imageSrc === '' }),
                React.createElement(react.IconButton, { iconProps: cancelIcon, className: react.mergeStyles(closeButtonStyles(overlayTheme)), onClick: onDismiss, 
                    /* @conditional-compile-remove(image-overlay) */ ariaLabel: localeStrings.dismissButtonAriaLabel, "aria-live": 'polite' })));
    };
    const renderBodyWithLightDismiss = () => {
        return React.createElement(react.Stack, { className: react.mergeStyles(bodyContainer), onClick: () => props.onDismiss() }, imageSrc && React.createElement("img", { src: imageSrc, className: react.mergeStyles(imageStyle), alt: altText || 'image', "aria-label": 'image-overlay-main-image', "aria-live": 'polite', onError: () => {
                setIsImageLoaded(false);
            }, onClick: event => event.stopPropagation(), onDoubleClick: event => {
                event.persist();
            } }));
    };
    return React.createElement(react.Modal, { titleAriaId: title, isOpen: isOpen, onDismiss: onDismiss, overlay: {
            styles: Object.assign({}, overlayStyles(overlayTheme))
        }, styles: {
            main: focusTrapZoneStyle,
            scrollableContent: scrollableContentStyle
        }, isDarkOverlay: true },
        React.createElement(FluentThemeProvider, { fluentTheme: overlayTheme, rootStyle: themeProviderRootStyle },
            renderHeaderBar(),
            renderBodyWithLightDismiss()));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const MESSAGE_STATUS_INDICATOR_SIZE_REM = 1;
/**
 * ErrorIcon seems designed slightly smaller than other icons we try to match the size and then fix positioning here.
 *
 * @private
 */
const MessageStatusIndicatorErrorIconStyle = react.mergeStyles({
    marginRight: '-0.06rem',
    fontSize: '1.06rem'
});
/**
 * @private
 */
const MessageStatusIndicatorIconStyle = react.mergeStyles({
    fontSize: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`,
    width: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`,
    height: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/// Adapted from: https://github.com/AlmeroSteyn/react-aria-live/blob/master/src/modules/AnnouncerContext.js
/** @private */
const AnnouncerContext = React.createContext({
    announceAssertive: logContextWarning,
    announcePolite: logContextWarning
});
function logContextWarning() {
    console.warn('Announcement failed, LiveAnnouncer context is missing');
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/// Adapted from: https://github.com/AlmeroSteyn/react-aria-live/blob/master/src/modules/AnnouncerMessage.js
/** @private */
const AnnouncerMessage = (props) => {
    const { message, ariaLive, clearOnUnmount, announceAssertive, announcePolite } = props;
    const announce = React.useCallback(() => {
        if (ariaLive === 'assertive') {
            announceAssertive(message || '', uuid.v1());
        }
        if (ariaLive === 'polite') {
            announcePolite(message || '', uuid.v1());
        }
    }, [announceAssertive, announcePolite, ariaLive, message]);
    React.useEffect(() => {
        announce();
        return () => {
            if (clearOnUnmount) {
                announceAssertive('', uuid.v1());
                announcePolite('', uuid.v1());
            }
        };
    }, [message, clearOnUnmount, announce, announceAssertive, announcePolite]);
    return null;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/// Adapted from: https://github.com/AlmeroSteyn/react-aria-live/blob/master/src/modules/LiveMessage.js
/** @private */
const LiveMessage = (props) => React.createElement(AnnouncerContext.Consumer, null, contextProps => React.createElement(AnnouncerMessage, Object.assign({}, contextProps, props)));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Component to display message status icon
 *
 * @internal
 */
const MessageStatusIcon = (props) => {
    const { shouldAnnounce, iconName, iconClassName, ariaLabel } = props;
    return React.createElement(React.Fragment, null,
        ariaLabel && React.createElement(LiveMessage, { message: ariaLabel, ariaLive: "polite" }),
        React.createElement("div", { 
            // make icon accessible
            tabIndex: 0 },
            React.createElement(react.Icon, { role: 'status', "aria-live": shouldAnnounce ? 'polite' : 'off', "data-ui-id": 'chat-composite-message-status-icon', "aria-label": ariaLabel, iconName: iconName, className: iconClassName })));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Component to display the status of a sent message.
 *
 * Adds an icon and tooltip corresponding to the message status.
 *
 * @internal
 */
const MessageStatusIndicatorInternal = (props) => {
    const { status, styles, remoteParticipantsCount, onToggleToolTip, readCount, shouldAnnounce } = props;
    const localeStrings = useLocale$1().strings.messageStatusIndicator;
    const [isTooltipToggled, setIsTooltipToggled] = React.useState(false);
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = useTheme();
    const calloutStyle = {
        root: {
            padding: 0
        },
        calloutMain: {
            padding: '0.5rem'
        }
    };
    // Place callout with no gap between it and the button.
    const calloutProps = {
        gapSpace: 0,
        styles: calloutStyle,
        backgroundColor: isDarkThemed(theme) ? theme.palette.neutralLighter : ''
    };
    switch (status) {
        case 'failed':
            return React.createElement(react.TooltipHost, { content: strings.failedToSendTooltipText, "data-ui-id": "chat-composite-message-tooltip", calloutProps: Object.assign({}, calloutProps), styles: hostStyles$1 },
                React.createElement(MemoMessageStatusIcon, { shouldAnnounce: shouldAnnounce, iconName: "MessageFailed", iconClassName: react.mergeStyles(MessageStatusIndicatorErrorIconStyle, {
                        color: theme.palette.redDark
                    }, styles === null || styles === void 0 ? void 0 : styles.root), ariaLabel: strings.failedToSendAriaLabel }));
        case 'sending':
            return React.createElement(react.TooltipHost, { content: strings.sendingTooltipText, "data-ui-id": "chat-composite-message-tooltip", calloutProps: Object.assign({}, calloutProps), styles: hostStyles$1 },
                React.createElement(MemoMessageStatusIcon, { shouldAnnounce: shouldAnnounce, iconName: "MessageSending", iconClassName: react.mergeStyles(MessageStatusIndicatorIconStyle, {
                        color: theme.palette.themePrimary
                    }, styles === null || styles === void 0 ? void 0 : styles.root), ariaLabel: strings.sendingAriaLabel }));
        case 'seen':
            return React.createElement(react.TooltipHost, { calloutProps: Object.assign({}, calloutProps), "data-ui-id": "chat-composite-message-tooltip", styles: hostStyles$1, content: 
                // when it's just 1 to 1 texting, we don't need to know who has read the message, just show message as 'seen'
                // when readCount is 0, we have a bug, show 'seen' to cover up as a fall back
                // when participant count is 0, we have a bug, show 'seen' to cover up as a fall back
                readCount === 0 || remoteParticipantsCount && remoteParticipantsCount <= 1 || !readCount || !remoteParticipantsCount || strings.readByTooltipText === undefined ? strings.seenTooltipText : _formatString(strings.readByTooltipText, {
                    messageThreadReadCount: `${readCount}`,
                    remoteParticipantsCount: `${remoteParticipantsCount}`
                }), onTooltipToggle: () => {
                    if (onToggleToolTip) {
                        onToggleToolTip(!isTooltipToggled);
                        setIsTooltipToggled(!isTooltipToggled);
                    }
                } },
                React.createElement(MemoMessageStatusIcon, { shouldAnnounce: shouldAnnounce, iconName: "MessageSeen", iconClassName: react.mergeStyles({
                        color: theme.palette.themePrimary
                    }, styles === null || styles === void 0 ? void 0 : styles.root), ariaLabel: strings.seenAriaLabel }));
        case 'delivered':
            return React.createElement(react.TooltipHost, { calloutProps: Object.assign({}, calloutProps), content: strings.deliveredTooltipText, "data-ui-id": "chat-composite-message-tooltip", styles: hostStyles$1 },
                React.createElement(MemoMessageStatusIcon, { shouldAnnounce: shouldAnnounce, iconName: "MessageDelivered", iconClassName: react.mergeStyles(MessageStatusIndicatorIconStyle, {
                        color: theme.palette.themePrimary
                    }, styles === null || styles === void 0 ? void 0 : styles.root), ariaLabel: strings.deliveredAriaLabel }));
        default:
            return React.createElement(React.Fragment, null);
    }
};
// The TooltipHost root uses display: inline by default.
// To prevent sizing issues or tooltip positioning issues, we override to inline-block.
// For more details see "Icon Button with Tooltip" on https://developer.microsoft.com/en-us/fluentui#/controls/web/button
const hostStyles$1 = {
    root: {
        display: 'inline-block'
    }
};
const MemoMessageStatusIcon = React.memo((obj) => {
    return React.createElement(MessageStatusIcon, Object.assign({}, obj));
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Component to display the status of a sent message.
 *
 * Adds an icon and tooltip corresponding to the message status.
 *
 * @public
 */
const MessageStatusIndicator = (props) => {
    const internalProps = Object.assign(Object.assign({}, props), { shouldAnnounce: true });
    return React.createElement(MessageStatusIndicatorInternal, Object.assign({}, internalProps));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// Minimum chat bubble width. This matches the minimum chat bubble width from FluentUI
// that can contain a message and a timestamp.
const CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM = 6.25;
// Chat messages should span just short of the width of the container.
// When calculating the width of a message we also must take into account
// the width of the avatar/gutter and the gap between the message and avatar/gutter.
const AVATAR_WIDTH_REM = 2;
const AVATAR_MARGIN_LEFT = 2.5;
const AVATAR_MESSAGE_GAP_REM = 0.125;
const MESSAGE_AMOUNT_OUT_FROM_EDGE_REM = 2;
// Avatars should display on top of chat messages when the chat thread is narrow
const MESSAGE_AVATAR_OVERLAP_REM = 0.925;
const CHAT_MESSAGE_ZINDEX = 1;
const AVATAR_ZINDEX = 2;
// new message button should be on top of chat message
const NEW_MESSAGE_BUTTON_ZINDEX = 2;
/**
 * @private
 */
const messageThreadContainerStyle = react.mergeStyles({
    height: '100%',
    width: '100%',
    maxHeight: '100%',
    overflow: 'auto',
    position: 'relative',
    alignSelf: 'center'
});
/**
 * @private
 */
const messageThreadWrapperContainerStyle = react.mergeStyles({
    height: '100%',
    width: '100%',
    position: 'relative'
});
/**
 * @private
 */
const noMessageStatusStyle = react.mergeStyles({
    // This should match the size of the message status indicator icon to ensure
    // multiple messages sent by the user are aligned correctly.
    width: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`
});
/**
 * @private
 */
const useChatStyles = reactComponents.makeStyles({
    root: Object.assign(Object.assign(Object.assign({ paddingTop: '0.8rem', paddingBottom: '0.5rem', paddingRight: '0.6rem', paddingLeft: '0.6rem' }, reactComponents.shorthands.border('none')), reactComponents.shorthands.overflow('auto')), { 
        // `height: 100%` ensures that the Chat component covers 100% of it's parents height
        // to prevent intermittent scrollbars when GIFs are present in the chat.
        height: '100%', '& a:link': {
            color: reactComponents.tokens.colorBrandForegroundLink
        }, '& a:visited': {
            color: reactComponents.tokens.colorBrandForegroundLinkHover
        }, '& a:hover': {
            color: reactComponents.tokens.colorBrandForegroundLinkHover
        } })
});
/**
 * @private
 */
const useChatMessageRenderStyles = reactComponents.makeStyles({
    rootCommon: {
        '&:focus-visible': Object.assign({}, reactComponents.shorthands.outline('0'))
    },
    rootMessage: Object.assign(Object.assign(Object.assign({}, reactComponents.shorthands.padding('0')), reactComponents.shorthands.margin('0')), { maxWidth: '100%', minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem` }),
    rootMyMessage: Object.assign(Object.assign({ gridTemplateColumns: 'auto fit-content(0)', gridTemplateAreas: `
        "body status"
      `, columnGap: '0', gridGap: '0' }, reactComponents.shorthands.padding('0')), { marginTop: '0', marginRight: '0', marginBottom: '0', marginLeft: '50px', width: `calc(100% - 50px)` }),
    bodyCommon: Object.assign(Object.assign({}, reactComponents.shorthands.padding('0')), { marginRight: '0', marginBottom: '0', backgroundColor: 'transparent', maxWidth: '100%', minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem` }),
    bodyMyMessage: {
        width: '100%',
        marginTop: '0'
    },
    bodyWithoutAvatar: {
        marginLeft: `${AVATAR_MARGIN_LEFT}rem`,
        marginTop: '0'
    },
    bodyWithAvatar: {
        marginLeft: `0`,
        marginTop: '0.75rem'
    },
    avatarNoOverlap: {
        width: `calc(100% - ${AVATAR_WIDTH_REM + MESSAGE_AMOUNT_OUT_FROM_EDGE_REM + AVATAR_MESSAGE_GAP_REM}rem)`
    },
    avatarOverlap: {
        width: `calc(100% - ${AVATAR_WIDTH_REM + MESSAGE_AMOUNT_OUT_FROM_EDGE_REM - MESSAGE_AVATAR_OVERLAP_REM}rem)`
    }
});
/**
 * @private
 */
const useChatMyMessageStyles = reactComponents.makeStyles({
    root: {
        gridTemplateColumns: 'auto auto',
        gridTemplateAreas: `
        ". actions"
        "body body"
      `,
        gridGap: '0',
        columnGap: '0',
        paddingTop: '0',
        marginLeft: '0',
        '&:focus-visible': Object.assign({}, reactComponents.shorthands.outline('0'))
    },
    body: Object.assign(Object.assign({ paddingBottom: '10px', marginTop: '1rem', maxWidth: '100%', minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem`, marginLeft: '0rem' }, reactComponents.shorthands.border('1px', 'solid', 'transparent')), { '&:hover ~ .fui-ChatMyMessage__actions': {
            visibility: 'visible'
        }, '&:focus ~ .fui-ChatMyMessage__actions': {
            visibility: 'visible'
        }, '& msft-mention': {
            color: reactComponents.tokens.colorStatusWarningBackground3,
            fontWeight: 600
        } }),
    bodyAttached: {
        marginTop: '0.125rem'
    },
    menu: Object.assign(Object.assign({ boxShadow: reactComponents.tokens.shadow4, backgroundColor: reactComponents.tokens.colorNeutralBackground1, marginRight: '1px', position: 'absolute', top: '-2px', right: '0' }, reactComponents.shorthands.borderRadius(reactComponents.tokens.borderRadiusMedium)), { zIndex: 1, lineHeight: reactComponents.tokens.lineHeightBase100, visibility: 'hidden', '&:hover, &:focus': {
            cursor: 'pointer',
            visibility: 'visible'
        } }),
    menuAttached: {
        top: '-18px'
    },
    menuHidden: {
        visibility: 'hidden'
    },
    menuVisible: {
        visibility: 'visible'
    }
});
/**
 * @private
 */
const newMessageButtonContainerStyle = react.mergeStyles({
    position: 'absolute',
    zIndex: NEW_MESSAGE_BUTTON_ZINDEX,
    bottom: 0,
    right: '1.5rem'
});
/**
 * @private
 */
const useChatMessageStyles = reactComponents.makeStyles({
    root: {
        paddingTop: '0',
        '&:focus-visible': Object.assign({}, reactComponents.shorthands.outline('0'))
    },
    body: Object.assign(Object.assign({ maxWidth: '100%', minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem`, marginRight: '0rem', paddingBottom: '10px', zIndex: CHAT_MESSAGE_ZINDEX }, reactComponents.shorthands.border('1px', 'solid', 'transparent')), { '& > div:first-of-type': {
            flexWrap: 'wrap'
        }, '& msft-mention': {
            color: reactComponents.tokens.colorStatusWarningBackground3,
            fontWeight: reactComponents.tokens.fontWeightSemibold
        }, '& img': {
            maxWidth: '100% !important',
            // Add !important to make sure it won't be overridden by style defined in element
            height: 'auto !important'
        }, '& video': {
            maxWidth: '100% !important',
            // Add !important to make sure it won't be overridden by style defined in element
            height: 'auto !important'
        }, '& p': Object.assign({}, reactComponents.shorthands.marginBlock('0.125rem')), '& blockquote': Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ backgroundColor: reactComponents.tokens.colorBrandBackgroundInverted, clear: 'left', minHeight: '2.25rem', width: 'fit-content', marginTop: '7px', marginRight: '0px', marginLeft: '0px', marginBottom: '7px', paddingTop: '7px', paddingRight: '15px', paddingLeft: '15px', paddingBottom: '7px' }, reactComponents.shorthands.border('solid')), reactComponents.shorthands.borderRadius('4px')), reactComponents.shorthands.borderWidth('1px')), reactComponents.shorthands.borderColor(reactComponents.tokens.colorNeutralStroke1Selected)), { borderLeftWidth: '4px' }), '& table': Object.assign(Object.assign({ backgroundColor: reactComponents.tokens.colorBrandBackgroundInverted }, reactComponents.shorthands.borderColor(reactComponents.tokens.colorNeutralStroke1Selected)), { borderCollapse: 'collapse', tableLayout: 'auto', width: '100%', '& tr': Object.assign(Object.assign({}, reactComponents.shorthands.border('1px', 'solid', `${reactComponents.tokens.colorNeutralStroke1Selected}`)), { '& td': Object.assign(Object.assign({}, reactComponents.shorthands.border('1px', 'solid', `${reactComponents.tokens.colorNeutralStroke1Selected}`)), { wordBreak: 'normal', paddingTop: '0px', paddingRight: '5px' }) }) }) }),
    bodyWithPlaceholderImage: {
        '& img[src=""]': {
            display: 'block',
            position: 'relative',
            marginBottom: '5px'
        },
        '& img[src=""]:after': {
            backgroundColor: reactComponents.tokens.colorNeutralBackground1Selected,
            content: `url("data:image/gif;base64,R0lGODlhAQABAAAAACw=")`,
            backgroundSize: 'center',
            position: 'absolute',
            width: '100%',
            height: '100%',
            top: '0',
            left: '0',
            display: 'block'
        }
    },
    bodyWithoutAvatar: {
        marginTop: '0.125rem'
    },
    bodyWithAvatar: {
        marginTop: `0.375rem`
    },
    avatarNoOverlap: {
        marginLeft: `${-AVATAR_MARGIN_LEFT + AVATAR_MESSAGE_GAP_REM}rem`
    },
    avatarOverlap: {
        marginLeft: `${-AVATAR_MARGIN_LEFT - MESSAGE_AVATAR_OVERLAP_REM}rem`
    }
});
/**
 * @private
 */
const useChatMessageCommonStyles = reactComponents.makeStyles({
    failed: {
        //TODO: can we reuse a theme color here?
        backgroundColor: 'rgba(168, 0, 0, 0.2)'
    },
    blocked: Object.assign(Object.assign({ maxWidth: '100%', minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem`, marginRight: '0rem', color: reactComponents.tokens.colorNeutralForeground2 }, reactComponents.shorthands.border('1px', 'solid', 'transparent')), { '& i': {
            paddingTop: '0.25rem'
        }, '& p': Object.assign(Object.assign({}, reactComponents.shorthands.marginBlock('0.125rem')), { paddingRight: '0.75rem', fontStyle: 'italic' }), '& a': Object.assign(Object.assign(Object.assign({}, reactComponents.shorthands.marginBlock('0.125rem')), { fontStyle: 'normal', color: reactComponents.tokens.colorBrandForegroundLink }), reactComponents.shorthands.textDecoration('none')) })
});
/**
 * @private
 */
const gutterWithAvatar = {
    paddingTop: '1.65rem',
    width: `${AVATAR_WIDTH_REM}rem`,
    position: 'relative',
    float: 'left',
    display: 'block',
    visibility: 'visible',
    zIndex: AVATAR_ZINDEX
};
/**
 * @private
 */
const gutterWithHiddenAvatar = Object.assign(Object.assign({}, gutterWithAvatar), { visibility: 'hidden', 
    // we use this hidden avatar just as a width placeholder
    // the placeholder is needed for responsive bubble width
    height: 0 });
/**
 * @private
 */
const newMessageButtonStyle = react.mergeStyles({
    float: 'right',
    width: 'fit-content'
});
/**
 * @private
 */
const buttonWithIconStyles$1 = {
    textContainer: {
        display: 'contents'
    }
};
/**
 * @private
 */
react.mergeStyles({
    border: 'none',
    minHeight: '1.5rem',
    '&:hover': {
        background: 'none'
    },
    '&:active': {
        background: 'none'
    }
});
/**
 * @private
 */
const DownIconStyle = react.mergeStyles({
    marginRight: '0.5em'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const delay = (delay) => {
    return new Promise(function (resolve) {
        setTimeout(resolve, delay);
    });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A utility hook for providing the width of a parent element.
 * Returns updated width if parent/window resizes.
 * @param containerRef - Ref of a parent element whose width will be returned.
 * @internal
 */
const _useContainerWidth = (containerRef) => {
    const [width, setWidth] = React.useState(undefined);
    const observer = React.useRef(new ResizeObserver(entries => {
        const { width } = entries[0].contentRect;
        setWidth(width);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => {
            currentObserver.disconnect();
        };
    }, [containerRef, observer]);
    return width;
};
/**
 * A utility hook for providing the height of a parent element.
 * Returns updated height if parent/window resizes.
 * @param containerRef - Ref of a parent element whose height will be returned.
 * @internal
 */
const _useContainerHeight = (containerRef) => {
    const [height, setHeight] = React.useState(undefined);
    const observer = React.useRef(new ResizeObserver(entries => {
        const { height } = entries[0].contentRect;
        setHeight(height);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => {
            currentObserver.disconnect();
        };
    }, [containerRef, observer]);
    return height;
};
const NARROW_WIDTH_REM = 30;
const SHORT_HEIGHT_REM = 23.75;
/**
 * Utility function to determine if container width is narrow
 * @param containerWidthRem  container width in rem
 * @returns boolean
 */
const isNarrowWidth = (containerWidthRem) => containerWidthRem <= _convertRemToPx(NARROW_WIDTH_REM);
/**
 * Utility function to determine if container width is short
 * @param containerWidthRem  container height in rem
 * @returns boolean
 */
const isShortHeight = (containerHeightRem) => containerHeightRem <= _convertRemToPx(SHORT_HEIGHT_REM);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 *logic: Looking at message A, how do we know it's read number?
 * Assumption: if user read the latest message, user has read all messages before that
 * ReadReceipt behaviour: read receipt is only sent to the last message
 *
 * If participant read a message that is sent later than message A, then the participant has read message A
 * How do we check if the message is sent later than message A?
 * We compare if the messageID of the last read message is larger than or equal to the message A's id
 * Because messageID is the creation timestamp of each message
 * Timestamps are in epoch time so lecixographical ordering is the same as time ordering.
 *
 * if MessageId of B is larger than message Id of A, then B is created after A
 * if the last read message is created after the message A is sent, then user should have read message A as well */
var getParticipantsWhoHaveReadMessage = ((message, readReceiptsBySenderId) => {
    return Object.entries(readReceiptsBySenderId)
        // Filter to only read receipts that match the message OR the participant has read a different message after this message has been created
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        .filter(([_, readReceipt]) => readReceipt.lastReadMessage >= message.messageId)
        // make sure the person is not removed from chat
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        .filter(([_, readReceipt]) => readReceipt.displayName && readReceipt.displayName !== '')
        // Map properties to useful array
        .map(([id, readReceipt]) => ({
        id,
        displayName: readReceipt.displayName
    }));
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// These color records are required for createV9Theme
// For more info, check https://react.fluentui.dev/iframe.html?viewMode=docs&id=concepts-migration-from-v8-components-theme-migration--page#compatible-themes
/**
 * @private
 */
const grey = {
    '0': '#000000',
    '2': '#050505',
    '4': '#0a0a0a',
    '6': '#0f0f0f',
    '8': '#141414',
    '10': '#1a1a1a',
    '12': '#1f1f1f',
    '14': '#242424',
    '16': '#292929',
    '18': '#2e2e2e',
    '20': '#333333',
    '22': '#383838',
    '24': '#3d3d3d',
    '26': '#424242',
    '28': '#474747',
    '30': '#4d4d4d',
    '32': '#525252',
    '34': '#575757',
    '36': '#5c5c5c',
    '38': '#616161',
    '40': '#666666',
    '42': '#6b6b6b',
    '44': '#707070',
    '46': '#757575',
    '48': '#7a7a7a',
    '50': '#808080',
    '52': '#858585',
    '54': '#8a8a8a',
    '56': '#8f8f8f',
    '58': '#949494',
    '60': '#999999',
    '62': '#9e9e9e',
    '64': '#a3a3a3',
    '66': '#a8a8a8',
    '68': '#adadad',
    '70': '#b3b3b3',
    '72': '#b8b8b8',
    '74': '#bdbdbd',
    '76': '#c2c2c2',
    '78': '#c7c7c7',
    '80': '#cccccc',
    '82': '#d1d1d1',
    '84': '#d6d6d6',
    '86': '#dbdbdb',
    '88': '#e0e0e0',
    '90': '#e6e6e6',
    '92': '#ebebeb',
    '94': '#f0f0f0',
    '96': '#f5f5f5',
    '98': '#fafafa',
    '100': '#ffffff'
};
/**
 * @private
 */
const whiteAlpha = {
    '5': 'rgba(255, 255, 255, 0.05)',
    '10': 'rgba(255, 255, 255, 0.1)',
    '20': 'rgba(255, 255, 255, 0.2)',
    '30': 'rgba(255, 255, 255, 0.3)',
    '40': 'rgba(255, 255, 255, 0.4)',
    '50': 'rgba(255, 255, 255, 0.5)',
    '60': 'rgba(255, 255, 255, 0.6)',
    '70': 'rgba(255, 255, 255, 0.7)',
    '80': 'rgba(255, 255, 255, 0.8)',
    '90': 'rgba(255, 255, 255, 0.9)'
};
/**
 * @private
 */
const blackAlpha = {
    '5': 'rgba(0, 0, 0, 0.05)',
    '10': 'rgba(0, 0, 0, 0.1)',
    '20': 'rgba(0, 0, 0, 0.2)',
    '30': 'rgba(0, 0, 0, 0.3)',
    '40': 'rgba(0, 0, 0, 0.4)',
    '50': 'rgba(0, 0, 0, 0.5)',
    '60': 'rgba(0, 0, 0, 0.6)',
    '70': 'rgba(0, 0, 0, 0.7)',
    '80': 'rgba(0, 0, 0, 0.8)',
    '90': 'rgba(0, 0, 0, 0.9)'
};
/**
 * @private
 */
const grey10Alpha = {
    '5': 'rgba(26, 26, 26, 0.05)',
    '10': 'rgba(26, 26, 26, 0.1)',
    '20': 'rgba(26, 26, 26, 0.2)',
    '30': 'rgba(26, 26, 26, 0.3)',
    '40': 'rgba(26, 26, 26, 0.4)',
    '50': 'rgba(26, 26, 26, 0.5)',
    '60': 'rgba(26, 26, 26, 0.6)',
    '70': 'rgba(26, 26, 26, 0.7)',
    '80': 'rgba(26, 26, 26, 0.8)',
    '90': 'rgba(26, 26, 26, 0.9)'
};
/**
 * @private
 */
const grey12Alpha = {
    '5': 'rgba(31, 31, 31, 0.05)',
    '10': 'rgba(31, 31, 31, 0.1)',
    '20': 'rgba(31, 31, 31, 0.2)',
    '30': 'rgba(31, 31, 31, 0.3)',
    '40': 'rgba(31, 31, 31, 0.4)',
    '50': 'rgba(31, 31, 31, 0.5)',
    '60': 'rgba(31, 31, 31, 0.6)',
    '70': 'rgba(31, 31, 31, 0.7)',
    '80': 'rgba(31, 31, 31, 0.8)',
    '90': 'rgba(31, 31, 31, 0.9)'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// These mappings are required for createV9Theme
// For more info, check https://react.fluentui.dev/iframe.html?viewMode=docs&id=concepts-migration-from-v8-components-theme-migration--page#compatible-themes
/**
 * Creates v9 color tokens from a v8 palette.
 */
const mapAliasColors = (palette, inverted) => {
    return {
        colorNeutralForeground1: palette.neutralPrimary,
        colorNeutralForeground1Hover: palette.neutralPrimary,
        colorNeutralForeground1Pressed: palette.neutralPrimary,
        colorNeutralForeground1Selected: palette.neutralPrimary,
        colorNeutralForeground2: palette.neutralSecondary,
        colorNeutralForeground2Hover: palette.neutralPrimary,
        colorNeutralForeground2Pressed: palette.neutralPrimary,
        colorNeutralForeground2Selected: palette.neutralPrimary,
        colorNeutralForeground2BrandHover: palette.themePrimary,
        colorNeutralForeground2BrandPressed: palette.themeDarkAlt,
        colorNeutralForeground2BrandSelected: palette.themePrimary,
        colorNeutralForeground3: palette.neutralTertiary,
        colorNeutralForeground3Hover: palette.neutralSecondary,
        colorNeutralForeground3Pressed: palette.neutralSecondary,
        colorNeutralForeground3Selected: palette.neutralSecondary,
        colorNeutralForeground3BrandHover: palette.themePrimary,
        colorNeutralForeground3BrandPressed: palette.themeDarkAlt,
        colorNeutralForeground3BrandSelected: palette.themePrimary,
        colorNeutralForeground4: palette.neutralQuaternary,
        colorNeutralForegroundDisabled: palette.neutralTertiaryAlt,
        colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
        colorBrandForegroundLink: palette.themeDarkAlt,
        colorBrandForegroundLinkHover: palette.themeDark,
        colorBrandForegroundLinkPressed: palette.themeDarker,
        colorBrandForegroundLinkSelected: palette.themeDarkAlt,
        colorNeutralForeground2Link: palette.neutralSecondary,
        colorNeutralForeground2LinkHover: palette.neutralPrimary,
        colorNeutralForeground2LinkPressed: palette.neutralPrimary,
        colorNeutralForeground2LinkSelected: palette.neutralPrimary,
        colorCompoundBrandForeground1: palette.themePrimary,
        colorCompoundBrandForeground1Hover: palette.themeDarkAlt,
        colorCompoundBrandForeground1Pressed: palette.themeDark,
        colorBrandForeground1: palette.themePrimary,
        colorBrandForeground2: palette.themeDarkAlt,
        colorBrandForeground2Hover: palette.themeDarkAlt,
        colorBrandForeground2Pressed: palette.themeDarkAlt,
        colorNeutralForeground1Static: palette.neutralPrimary,
        colorNeutralForegroundInverted: palette.white,
        colorNeutralForegroundInvertedHover: palette.white,
        colorNeutralForegroundInvertedPressed: palette.white,
        colorNeutralForegroundInvertedSelected: palette.white,
        colorNeutralForegroundOnBrand: palette.white,
        colorNeutralForegroundStaticInverted: palette.white,
        colorNeutralForegroundInvertedLink: palette.white,
        colorNeutralForegroundInvertedLinkHover: palette.white,
        colorNeutralForegroundInvertedLinkPressed: palette.white,
        colorNeutralForegroundInvertedLinkSelected: palette.white,
        colorNeutralForegroundInverted2: palette.white,
        colorBrandForegroundInverted: palette.themeSecondary,
        colorBrandForegroundInvertedHover: palette.themeTertiary,
        colorBrandForegroundInvertedPressed: palette.themeSecondary,
        colorBrandForegroundOnLight: palette.themePrimary,
        colorBrandForegroundOnLightHover: palette.themeDarkAlt,
        colorBrandForegroundOnLightPressed: palette.themeDark,
        colorBrandForegroundOnLightSelected: palette.themeDark,
        colorNeutralBackground1: palette.white,
        colorNeutralBackground1Hover: palette.neutralLighter,
        colorNeutralBackground1Pressed: palette.neutralQuaternaryAlt,
        colorNeutralBackground1Selected: palette.neutralLight,
        colorNeutralBackground2: palette.neutralLighterAlt,
        colorNeutralBackground2Hover: palette.neutralLighter,
        colorNeutralBackground2Pressed: palette.neutralQuaternaryAlt,
        colorNeutralBackground2Selected: palette.neutralLight,
        colorNeutralBackground3: palette.neutralLighter,
        colorNeutralBackground3Hover: palette.neutralLight,
        colorNeutralBackground3Pressed: palette.neutralQuaternary,
        colorNeutralBackground3Selected: palette.neutralQuaternaryAlt,
        colorNeutralBackground4: palette.neutralLighter,
        colorNeutralBackground4Hover: palette.neutralLighterAlt,
        colorNeutralBackground4Pressed: palette.neutralLighter,
        colorNeutralBackground4Selected: palette.white,
        colorNeutralBackground5: palette.neutralLight,
        colorNeutralBackground5Hover: palette.neutralLighter,
        colorNeutralBackground5Pressed: palette.neutralLighter,
        colorNeutralBackground5Selected: palette.neutralLighterAlt,
        colorNeutralBackground6: palette.neutralLight,
        colorNeutralBackgroundStatic: grey[20],
        colorNeutralBackgroundInverted: palette.neutralSecondary,
        colorNeutralBackgroundAlpha: inverted ? grey10Alpha[50] : whiteAlpha[50],
        colorNeutralBackgroundAlpha2: inverted ? grey12Alpha[70] : whiteAlpha[80],
        colorSubtleBackground: 'transparent',
        colorSubtleBackgroundHover: palette.neutralLighter,
        colorSubtleBackgroundPressed: palette.neutralQuaternaryAlt,
        colorSubtleBackgroundSelected: palette.neutralLight,
        colorSubtleBackgroundLightAlphaHover: inverted ? whiteAlpha[10] : whiteAlpha[80],
        colorSubtleBackgroundLightAlphaPressed: inverted ? whiteAlpha[5] : whiteAlpha[50],
        colorSubtleBackgroundLightAlphaSelected: 'transparent',
        colorSubtleBackgroundInverted: 'transparent',
        colorSubtleBackgroundInvertedHover: blackAlpha[10],
        colorSubtleBackgroundInvertedPressed: blackAlpha[30],
        colorSubtleBackgroundInvertedSelected: blackAlpha[20],
        colorTransparentBackground: 'transparent',
        colorTransparentBackgroundHover: 'transparent',
        colorTransparentBackgroundPressed: 'transparent',
        colorTransparentBackgroundSelected: 'transparent',
        colorNeutralBackgroundDisabled: palette.neutralLighter,
        colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
        colorNeutralStencil1: palette.neutralLight,
        colorNeutralStencil2: palette.neutralLighterAlt,
        colorNeutralStencil1Alpha: inverted ? whiteAlpha[10] : blackAlpha[10],
        colorNeutralStencil2Alpha: inverted ? whiteAlpha[5] : blackAlpha[5],
        colorBackgroundOverlay: blackAlpha[40],
        colorScrollbarOverlay: blackAlpha[50],
        colorBrandBackground: palette.themePrimary,
        colorBrandBackgroundHover: palette.themeDarkAlt,
        colorBrandBackgroundPressed: palette.themeDarker,
        colorBrandBackgroundSelected: palette.themeDark,
        colorCompoundBrandBackground: palette.themePrimary,
        colorCompoundBrandBackgroundHover: palette.themeDarkAlt,
        colorCompoundBrandBackgroundPressed: palette.themeDark,
        colorBrandBackgroundStatic: palette.themePrimary,
        colorBrandBackground2: palette.themeLighterAlt,
        colorBrandBackground2Hover: palette.themeLighterAlt,
        colorBrandBackground2Pressed: palette.themeLighterAlt,
        colorBrandBackground3Static: palette.themeDark,
        colorBrandBackground4Static: palette.themeDarker,
        colorBrandBackgroundInverted: palette.white,
        colorBrandBackgroundInvertedHover: palette.themeLighterAlt,
        colorBrandBackgroundInvertedPressed: palette.themeLight,
        colorBrandBackgroundInvertedSelected: palette.themeLighter,
        colorNeutralCardBackground: inverted ? grey[20] : grey[98],
        colorNeutralCardBackgroundHover: inverted ? grey[24] : palette.white,
        colorNeutralCardBackgroundPressed: inverted ? grey[18] : grey[96],
        colorNeutralCardBackgroundSelected: inverted ? grey[22] : grey[92],
        colorNeutralCardBackgroundDisabled: inverted ? grey[8] : grey[94],
        colorNeutralStrokeAccessible: palette.neutralSecondary,
        colorNeutralStrokeAccessibleHover: palette.neutralSecondary,
        colorNeutralStrokeAccessiblePressed: palette.neutralSecondary,
        colorNeutralStrokeAccessibleSelected: palette.themePrimary,
        colorNeutralStroke1: palette.neutralQuaternary,
        colorNeutralStroke1Hover: palette.neutralTertiaryAlt,
        colorNeutralStroke1Pressed: palette.neutralTertiaryAlt,
        colorNeutralStroke1Selected: palette.neutralTertiaryAlt,
        colorNeutralStroke2: palette.neutralQuaternaryAlt,
        colorNeutralStroke3: palette.neutralLighter,
        colorNeutralStrokeSubtle: palette.neutralQuaternaryAlt,
        colorNeutralStrokeOnBrand: palette.white,
        colorNeutralStrokeOnBrand2: palette.white,
        colorNeutralStrokeOnBrand2Hover: palette.white,
        colorNeutralStrokeOnBrand2Pressed: palette.white,
        colorNeutralStrokeOnBrand2Selected: palette.white,
        colorBrandStroke1: palette.themePrimary,
        colorBrandStroke2: palette.themeLight,
        colorBrandStroke2Hover: palette.themeLight,
        colorBrandStroke2Pressed: palette.themeLight,
        colorBrandStroke2Contrast: palette.themeLight,
        colorCompoundBrandStroke: palette.themePrimary,
        colorCompoundBrandStrokeHover: palette.themeDarkAlt,
        colorCompoundBrandStrokePressed: palette.themeDark,
        colorNeutralStrokeDisabled: palette.neutralQuaternaryAlt,
        colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
        colorTransparentStroke: 'transparent',
        colorTransparentStrokeInteractive: 'transparent',
        colorTransparentStrokeDisabled: 'transparent',
        colorNeutralStrokeAlpha: inverted ? whiteAlpha[10] : blackAlpha[5],
        colorNeutralStrokeAlpha2: whiteAlpha[20],
        colorStrokeFocus1: palette.white,
        colorStrokeFocus2: palette.black,
        colorNeutralShadowAmbient: 'rgba(0,0,0,0.12)',
        colorNeutralShadowKey: 'rgba(0,0,0,0.14)',
        colorNeutralShadowAmbientLighter: 'rgba(0,0,0,0.06)',
        colorNeutralShadowKeyLighter: 'rgba(0,0,0,0.07)',
        colorNeutralShadowAmbientDarker: 'rgba(0,0,0,0.20)',
        colorNeutralShadowKeyDarker: 'rgba(0,0,0,0.24)',
        colorBrandShadowAmbient: 'rgba(0,0,0,0.30)',
        colorBrandShadowKey: 'rgba(0,0,0,0.25)'
    };
};
/**
 * Creates v9 shadow tokens from v8 effects.
 */
const mapShadowTokens = (effects) => {
    return {
        shadow4: effects.elevation4,
        shadow8: effects.elevation8,
        shadow16: effects.elevation16,
        shadow64: effects.elevation64
    };
};
/**
 * Creates v9 border radius tokens from v8 effects
 */
const mapBorderRadiusTokens = (effects) => {
    return {
        borderRadiusSmall: effects.roundedCorner2,
        borderRadiusMedium: effects.roundedCorner4,
        borderRadiusLarge: effects.roundedCorner6
    };
};
/**
 * Creates a v9 theme from a v8 theme and base v9 theme.
 * FluentUI webLightTheme is used in case if no baseThemeV9 is provided.
 *
 * @private
 */
const createV9Theme = (themeV8, baseThemeV9) => {
    const baseTheme = baseThemeV9 !== null && baseThemeV9 !== void 0 ? baseThemeV9 : reactComponents.webLightTheme;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseTheme), mapAliasColors(themeV8.palette, themeV8.isInverted)), mapShadowTokens(themeV8.effects)), mapBorderRadiusTokens(themeV8.effects)), { colorBrandBackground2: themeV8.palette.themeLight, 
        // updated from palette.themeLighterAlt
        colorBrandBackground2Hover: themeV8.palette.themeLight, 
        // updated from palette.themeLighterAlt
        colorBrandBackground2Pressed: themeV8.palette.themeLight, 
        // updated from palette.themeLighterAlt
        colorStatusWarningBackground3: '#D83B01', errorText: themeV8.semanticColors.errorText, colorNeutralStroke1Selected: themeV8.palette.neutralQuaternary, colorNeutralForeground2: themeV8.palette.neutralSecondary, colorBrandForegroundLink: themeV8.palette.themePrimary, colorBrandForegroundLinkHover: themeV8.palette.themeDarker, colorNeutralBackground1Selected: themeV8.palette.neutralQuaternaryAlt, 
        // Fix for an issue with black borders for iOS that are added with 'after' selector
        colorStrokeFocus2: 'transparent' });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const useFluentV9Wrapper = reactComponents.makeStyles({
    body: Object.assign(Object.assign(Object.assign(Object.assign({ height: '100%' }, reactComponents.shorthands.margin(0)), reactComponents.shorthands.overflow('hidden')), reactComponents.shorthands.padding(0)), { width: '100%' })
});
/**
 * @private
 */
const FluentV9ThemeProvider = (props) => {
    const { v8Theme, children } = props;
    const v9Theme = createV9Theme(v8Theme);
    const dir = v8Theme.rtl ? 'rtl' : 'ltr';
    return (
    // TextDirectionProvider is needed to fix issue with direction value update in FluentProvider
    React.createElement(react$1.TextDirectionProvider, { dir: dir },
        React.createElement(FluentProviderWithStylesOverrides, { theme: v9Theme, dir: dir }, children)));
};
const FluentProviderWithStylesOverrides = props => {
    const classes = useFluentV9Wrapper();
    return React.createElement(reactComponents.FluentProvider, Object.assign({}, props, { className: classes.body }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/// Adapted from: https://github.com/AlmeroSteyn/react-aria-live/blob/master/src/modules/MessageBlock.js
const offScreenStyle = {
    border: 0,
    clip: 'rect(0 0 0 0)',
    height: '1px',
    margin: '-1px',
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    padding: 0,
    width: '1px',
    position: 'absolute'
};
/** @private */
const MessageBlock = (props) => React.createElement("div", { style: offScreenStyle, role: "log", "aria-live": props.ariaLive }, props.message ? props.message : '');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/// Adapted from: https://github.com/AlmeroSteyn/react-aria-live/blob/master/src/modules/Announcer.js
/** @private */
const EMPTY_MESSAGE = {
    message: '',
    id: ''
};
/** @private */
const Announcer$1 = (props) => {
    var _a, _b;
    const newAssertive = (_a = props.assertive) !== null && _a !== void 0 ? _a : EMPTY_MESSAGE;
    const oldAssertive = React.useRef(EMPTY_MESSAGE);
    const [activeAssertive1, setActiveAssertive1] = React.useState(EMPTY_MESSAGE);
    const [activeAssertive2, setActiveAssertive2] = React.useState(EMPTY_MESSAGE);
    const alternateAssertive = React.useRef(false);
    React.useEffect(() => {
        if (oldAssertive.current.message !== (newAssertive === null || newAssertive === void 0 ? void 0 : newAssertive.message) || oldAssertive.current.id !== (newAssertive === null || newAssertive === void 0 ? void 0 : newAssertive.id)) {
            setActiveAssertive1(alternateAssertive.current ? EMPTY_MESSAGE : newAssertive);
            setActiveAssertive2(alternateAssertive.current ? newAssertive : EMPTY_MESSAGE);
            oldAssertive.current = newAssertive;
            alternateAssertive.current = !alternateAssertive.current;
        }
    }, [newAssertive]);
    const newPolite = (_b = props.polite) !== null && _b !== void 0 ? _b : EMPTY_MESSAGE;
    const oldPolite = React.useRef(EMPTY_MESSAGE);
    const [activePolite1, setActivePolite1] = React.useState(EMPTY_MESSAGE);
    const [activePolite2, setActivePolite2] = React.useState(EMPTY_MESSAGE);
    const alternatePolite = React.useRef(false);
    React.useEffect(() => {
        if (oldPolite.current.message !== (newPolite === null || newPolite === void 0 ? void 0 : newPolite.message) || oldPolite.current.id !== (newPolite === null || newPolite === void 0 ? void 0 : newPolite.id)) {
            setActivePolite1(alternatePolite.current ? EMPTY_MESSAGE : newPolite);
            setActivePolite2(alternatePolite.current ? newPolite : EMPTY_MESSAGE);
            oldPolite.current = newPolite;
            alternatePolite.current = !alternatePolite.current;
        }
    }, [newPolite]);
    return React.createElement("div", null,
        React.createElement(MessageBlock, { ariaLive: "assertive", message: activeAssertive1.message }),
        React.createElement(MessageBlock, { ariaLive: "assertive", message: activeAssertive2.message }),
        React.createElement(MessageBlock, { ariaLive: "polite", message: activePolite1.message }),
        React.createElement(MessageBlock, { ariaLive: "polite", message: activePolite2.message }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/// Adapted from: https://github.com/AlmeroSteyn/react-aria-live/blob/master/src/modules/LiveAnnouncer.js
/** @private */
const LiveAnnouncer = (props) => {
    const [politeMessage, setPoliteMessage] = React.useState(EMPTY_MESSAGE);
    const [assertiveMessage, setAssertiveMessage] = React.useState(EMPTY_MESSAGE);
    const announcePolite = React.useCallback((message, id) => {
        setPoliteMessage({
            message,
            id
        });
    }, []);
    const announceAssertive = React.useCallback((message, id) => {
        setAssertiveMessage({
            message,
            id
        });
    }, []);
    const updateFunctions = React.useMemo(() => ({
        announcePolite,
        announceAssertive
    }), [announceAssertive, announcePolite]);
    return React.createElement(AnnouncerContext.Provider, { value: updateFunctions },
        props.children,
        React.createElement(Announcer$1, { assertive: assertiveMessage, polite: politeMessage }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Function to create a React.CSSProperties object from a v8 style object.
 * This function is still not ideal
 * as v8Style can use pseudo-class selectors that style objects can't process correctly.
 *
 * @private
 */
function createStyleFromV8Style(v8Style) {
    const result = {};
    if (v8Style === undefined || v8Style === null || typeof v8Style === 'boolean' || typeof v8Style === 'string') {
        return undefined;
    }
    else if (typeof v8Style === 'object') {
        // v8Style is a style object
        for (const record in v8Style) {
            if (typeof v8Style[record] === 'string') {
                // v8Style[record] is just a simple style
                const msSuffix = 'MS';
                if (record.startsWith(msSuffix)) {
                    // React.CSSProperties uses camelCase for MS properties but v8Style uses PascalCase
                    const newRecord = record.substring(0, msSuffix.length).toLowerCase + record.substring(msSuffix.length);
                    result[newRecord] = v8Style[record];
                }
                else {
                    result[record] = v8Style[record];
                }
            }
            else {
                result[record] = createStyleFromV8Style(v8Style[record]);
            }
        }
    }
    return result;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const editBoxStyle = react.mergeStyles({
    marginTop: '0.0875rem',
    marginBottom: '0.0875rem'
});
/**
 * @private
 */
const editingButtonStyle = react.mergeStyles({
    margin: '0',
    width: '2.125rem',
    height: '2.125rem',
    padding: '0.375rem 0 0 0'
});
/**
 * @private
 */
const inputBoxIcon = react.mergeStyles({
    margin: 'auto',
    '&:hover svg': {
        stroke: 'currentColor'
    }
});
/**
 * @private
 */
react.mergeStyles(editorTextBoxButtonStyle, {
    '&:hover svg': {
        stroke: 'currentColor'
    }
});
/**
 * @private
 */
const editBoxWidthStyles = {
    minWidth: '6.25rem',
    maxWidth: '100%'
};
/**
 * @private
 */
const editBoxStyleSet = {
    root: editBoxWidthStyles
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const MINIMUM_TOUCH_TARGET_HEIGHT_REM$1 = 3;
const errorTextColor = 'var(--errorText)';
/**
 * @private
 */
const iconWrapperStyle = (theme, isSubMenuOpen) => ({
    root: {
        margin: _pxToRem(3),
        // Show hover styles when the Edit/Delete menu is showing as this action button is still considered 'active'
        color: isSubMenuOpen ? theme.palette.black : theme.palette.neutralPrimary,
        strokeWidth: isSubMenuOpen ? _pxToRem(0.5) : _pxToRem(0),
        stroke: theme.palette.black,
        ':hover, :focus': {
            color: theme.palette.black,
            strokeWidth: _pxToRem(0.5)
        }
    }
});
/**
 * @private
 */
const chatMessageDateStyle = react.mergeStyles({
    color: reactComponents.tokens.colorNeutralForeground2,
    fontWeight: react.FontWeights.regular,
    fontSize: '0.75rem'
});
/**
 * @private
 */
const chatMessageAuthorStyle = react.mergeStyles({
    fontWeight: react.FontWeights.semibold,
    fontSize: '0.75rem'
});
/**
 * @private
 */
const chatMessageEditedTagStyle = (theme) => react.mergeStyles({
    fontWeight: react.FontWeights.semibold,
    color: theme.palette.neutralSecondary
});
/**
 * @private
 */
const chatMessageFailedTagStyle = (theme) => react.mergeStyles({
    fontWeight: react.FontWeights.regular,
    color: theme.semanticColors.errorText,
    fontSize: theme.fonts.smallPlus.fontSize,
    lineHeight: '1rem'
});
/**
 * @private
 */
const editChatMessageFailedTagStyle = react.mergeStyles({
    marginBottom: '0.5rem'
});
/**
 * @private
 */
const chatMessageFailedTagStackItemStyle = react.mergeStyles({
    alignSelf: 'end'
});
/**
 * @private
 */
const editChatMessageButtonsStackStyle = react.mergeStyles({
    padding: '0 0.5rem',
    marginTop: '-0.25rem'
});
/**
 * @private
 */
const chatMessageMenuStyle = react.mergeStyles({
    minWidth: '8.5rem',
    height: 'max-content',
    cursor: 'pointer',
    overflow: 'hidden'
});
/**
 * @private
 */
const useChatMessageEditContainerStyles = reactComponents.makeStyles({
    body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, reactComponents.shorthands.padding(0)), { backgroundColor: 'transparent', boxSizing: 'border-box' }), reactComponents.shorthands.border(`${defaultSendBoxInactiveBorderThicknessREM}rem`, 'solid')), reactComponents.shorthands.borderRadius(reactComponents.tokens.borderRadiusMedium)), reactComponents.shorthands.margin('21px', '1px', '1px', '1px')), { 
        // Width should be updated on hover to include the border width change
        width: `calc(100% - ${defaultSendBoxActiveBorderThicknessREM}rem)`, '&:hover, &:active, &:focus, &:focus-within': Object.assign(Object.assign(Object.assign({}, reactComponents.shorthands.borderWidth(`${defaultSendBoxActiveBorderThicknessREM}rem`)), reactComponents.shorthands.margin('20px', 0, 0, 0)), { width: '100%' }) }),
    bodyAttached: {
        marginBottom: '1px',
        marginTop: '3px',
        // Width should be updated on hover to include the border width change
        width: `calc(100% - ${defaultSendBoxActiveBorderThicknessREM}rem)`,
        '&:hover, &:active, &:focus, &:focus-within': {
            marginTop: '2px',
            marginBottom: 0
        }
    },
    bodyError: Object.assign({}, reactComponents.shorthands.borderColor(errorTextColor)),
    bodyDefault: Object.assign(Object.assign({}, reactComponents.shorthands.borderColor(reactComponents.tokens.colorNeutralStrokeAccessible)), { '&:hover, &:active, &:focus, &:focus-within': Object.assign({}, reactComponents.shorthands.borderColor(reactComponents.tokens.colorCompoundBrandStroke)) })
});
/**
 * @private
 */
reactComponents.makeStyles({
    body: Object.assign(Object.assign(Object.assign(Object.assign({}, reactComponents.shorthands.padding(0)), { backgroundColor: 'transparent' }), reactComponents.shorthands.margin('1.25rem', 0, 0, 0)), { width: '100%' }),
    bodyAttached: {
        marginTop: '0.125rem',
        marginBottom: 0
    }
});
/**
 * Styles that can be applied to ensure flyout items have the minimum touch target size.
 *
 * @private
 */
const menuItemIncreasedSizeStyles = {
    root: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        maxHeight: 'unset'
    },
    linkContent: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        maxHeight: 'unset'
    },
    icon: {
        maxHeight: 'unset'
    }
};
/**
 * @private
 */
const menuIconStyleSet = {
    root: {
        height: 'calc(100% - 8px)',
        // Adjust for the pixel margin Fluent applies
        width: '1.25rem'
    }
};
/**
 * @private
 */
const menuSubIconStyleSet = {
    root: {
        height: 'unset',
        lineHeight: '100%',
        width: '1.25rem'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const onRenderCancelIcon = (className) => {
    return React.createElement(react.Icon, { iconName: 'EditBoxCancel', className: className });
};
/**
 * @private
 */
const onRenderSubmitIcon = (className) => {
    return React.createElement(react.Icon, { iconName: 'EditBoxSubmit', className: className });
};
function isMessageEmpty(messageText) {
    return messageText.trim().length === 0;
}
/**
 * @private
 */
function getMessageState(messageText) {
    return isMessageEmpty(messageText) ? 'too short' : isMessageTooLong(messageText.length) ? 'too long' : 'OK';
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const ChatMessageComponentAsEditBox = (props) => {
    const { onCancel, onSubmit, strings, message } = props;
    const [textValue, setTextValue] = React.useState(message.content || '');
    const editTextFieldRef = React.useRef(null);
    const theme = useTheme();
    const messageState = getMessageState(textValue);
    const submitEnabled = messageState === 'OK';
    const editContainerStyles = useChatMessageEditContainerStyles();
    const chatMyMessageStyles = useChatMyMessageStyles();
    React.useEffect(() => {
        var _a;
        (_a = editTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, []);
    const setText = (event, newValue) => {
        setTextValue(newValue !== null && newValue !== void 0 ? newValue : '');
    };
    const textTooLongMessage = messageState === 'too long' ? _formatString(strings.editBoxTextLimit, {
        limitNumber: `${MAXIMUM_LENGTH_OF_MESSAGE}`
    }) : undefined;
    const iconClassName = React.useCallback((isHover) => {
        const color = isHover ? theme.palette.accent : theme.palette.neutralSecondary;
        return react.mergeStyles(inputBoxIcon, {
            color
        });
    }, [theme.palette.accent, theme.palette.neutralSecondary]);
    const onRenderThemedCancelIcon = React.useCallback((isHover) => {
        return onRenderCancelIcon(iconClassName(isHover));
    }, [iconClassName]);
    const onRenderThemedSubmitIcon = React.useCallback((isHover) => {
        return onRenderSubmitIcon(iconClassName(isHover));
    }, [iconClassName]);
    const editBoxStyles = React.useMemo(() => {
        return react.concatStyleSets(editBoxStyleSet, {
            textField: {
                borderColor: theme.palette.themePrimary
            }
        });
    }, [theme.palette.themePrimary]);
    const getContent = () => {
        return React.createElement(React.Fragment, null,
            React.createElement(InputBoxComponent, { "data-ui-id": "edit-box", textFieldRef: editTextFieldRef, inputClassName: editBoxStyle, placeholderText: strings.editBoxPlaceholderText, textValue: textValue, onChange: setText, onKeyDown: ev => {
                    if (ev.key === 'ArrowUp' || ev.key === 'ArrowDown') {
                        ev.stopPropagation();
                    }
                }, onEnterKeyDown: () => {
                    submitEnabled && onSubmit(textValue, message.metadata);
                }, supportNewline: false, maxLength: MAXIMUM_LENGTH_OF_MESSAGE, errorMessage: textTooLongMessage, styles: editBoxStyles }),
            React.createElement(react.Stack, { horizontal: true, horizontalAlign: "end", className: editChatMessageButtonsStackStyle, tokens: {
                    childrenGap: '0.25rem'
                } },
                message.failureReason && React.createElement(react.Stack.Item, { grow: true, align: "stretch", className: chatMessageFailedTagStackItemStyle },
                    React.createElement("div", { className: react.mergeStyles(chatMessageFailedTagStyle(theme), editChatMessageFailedTagStyle) }, message.failureReason)),
                React.createElement(react.Stack.Item, { align: "end" },
                    React.createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxCancelButton, tooltipContent: strings.editBoxCancelButton, onRenderIcon: onRenderThemedCancelIcon, onClick: () => {
                            onCancel && onCancel(message.messageId);
                        }, id: 'dismissIconWrapper' })),
                React.createElement(react.Stack.Item, { align: "end" },
                    React.createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxSubmitButton, tooltipContent: strings.editBoxSubmitButton, onRenderIcon: onRenderThemedSubmitIcon, onClick: e => {
                            submitEnabled && onSubmit(textValue, message.metadata);
                            e.stopPropagation();
                        }, id: 'submitIconWrapper' }))));
    };
    const attached = message.attached === true ? 'center' : message.attached === 'bottom' ? 'bottom' : 'top';
    return React.createElement(reactChat.ChatMyMessage, { attached: attached, root: {
            className: chatMyMessageStyles.root
        }, body: {
            className: reactComponents.mergeClasses(editContainerStyles.body, message.failureReason !== undefined ? editContainerStyles.bodyError : editContainerStyles.bodyDefault, attached !== 'top' ? editContainerStyles.bodyAttached : undefined)
        } }, getContent());
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const formatTimeForChatMessage = (messageDate) => {
    return messageDate.toLocaleTimeString([], {
        hour: 'numeric',
        minute: '2-digit'
    });
};
/**
 * @private
 */
const formatDateForChatMessage = (messageDate) => {
    return messageDate.toLocaleDateString();
};
/**
 * Given a message date object in ISO8601 and a current date object, generates a user friendly timestamp text
 * using the system locale.
 * <time in locale format>.
 * Yesterday <time in locale format>.
 * <dateStrings day of week> <time in locale format>.
 * <date in locale format> <time in locale format>.
 *
 * If message is after yesterday, then only show the time.
 * If message is before yesterday and after day before yesterday, then show 'Yesterday' plus the time.
 * If message is before day before yesterday and within the current week, then show 'Monday/Tuesday/etc' plus the time.
 *   - We consider start of the week as Sunday. If current day is Sunday, then any time before that is in previous week.
 * If message is in previous or older weeks, then show date string plus the time.
 *
 * @param messageDate - date of message
 * @param currentDate - date used as offset to create the user friendly timestamp (e.g. to create 'Yesterday' instead of an absolute date)
 *
 * @private
 */
const formatTimestampForChatMessage = (messageDate, todayDate, dateStrings) => {
    // If message was in the same day timestamp string is just the time like '1:30 p.m.'.
    const startOfDay = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate());
    if (messageDate > startOfDay) {
        return formatTimeForChatMessage(messageDate);
    }
    // If message was yesterday then timestamp string is like this 'Yesterday 1:30 p.m.'.
    const yesterdayDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate() - 1);
    if (messageDate > yesterdayDate) {
        return dateStrings.yesterday + ' ' + formatTimeForChatMessage(messageDate);
    }
    // If message was before Sunday and today is Sunday (start of week) then timestamp string is like
    // '2021-01-10 1:30 p.m.'.
    const weekDay = todayDate.getDay();
    if (weekDay === 0) {
        return formatDateForChatMessage(messageDate) + ' ' + formatTimeForChatMessage(messageDate);
    }
    // If message was before first day of the week then timestamp string is like Monday 1:30 p.m.
    const firstDayOfTheWeekDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate() - weekDay);
    if (messageDate > firstDayOfTheWeekDate) {
        return dayToDayName(messageDate.getDay(), dateStrings) + ' ' + formatTimeForChatMessage(messageDate);
    }
    // If message date is in previous or older weeks then timestamp string is like 2021-01-10 1:30 p.m.
    return formatDateForChatMessage(messageDate) + ' ' + formatTimeForChatMessage(messageDate);
};
const dayToDayName = (day, dateStrings) => {
    switch (day) {
        case 0:
            return dateStrings.sunday;
        case 1:
            return dateStrings.monday;
        case 2:
            return dateStrings.tuesday;
        case 3:
            return dateStrings.wednesday;
        case 4:
            return dateStrings.thursday;
        case 5:
            return dateStrings.friday;
        case 6:
            return dateStrings.saturday;
        default:
            throw new Error(`Invalid day [${day}] passed`);
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Chat message actions flyout that contains actions such as Edit Message, or Remove Message.
 *
 * @private
 */
const ChatMessageActionFlyout = (props) => {
    var _a, _b;
    const theme = react.useTheme();
    const messageReadByCount = (_a = props.messageReadBy) === null || _a === void 0 ? void 0 : _a.length;
    const sortedMessageReadyByList = [...((_b = props.messageReadBy) !== null && _b !== void 0 ? _b : [])].sort((a, b) => a.displayName.localeCompare(b.displayName));
    const messageReadByList = sortedMessageReadyByList === null || sortedMessageReadyByList === void 0 ? void 0 : sortedMessageReadyByList.map(person => {
        const personaOptions = {
            hidePersonaDetails: true,
            size: react.PersonaSize.size24,
            text: person.displayName,
            showOverflowTooltip: false,
            styles: {
                root: {
                    margin: '0.25rem'
                }
            }
        };
        const { onRenderAvatar } = props;
        return {
            'data-ui-id': 'chat-composite-message-contextual-menu-read-name-list-item',
            key: person.displayName,
            text: person.displayName,
            itemProps: {
                styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined
            },
            onRenderIcon: () => { var _a; return onRenderAvatar ? onRenderAvatar((_a = person.id) !== null && _a !== void 0 ? _a : '', personaOptions) : React.createElement(react.Persona, Object.assign({}, personaOptions)); },
            iconProps: {
                styles: menuIconStyleSet
            }
        };
    });
    const menuItems = React.useMemo(() => {
        const items = [{
                key: 'Edit',
                'data-ui-id': 'chat-composite-message-contextual-menu-edit-action',
                text: props.strings.editMessage,
                itemProps: {
                    styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined
                },
                iconProps: {
                    iconName: 'MessageEdit',
                    styles: menuIconStyleSet
                },
                onClick: props.onEditClick
            }, {
                key: 'Remove',
                text: props.strings.removeMessage,
                itemProps: {
                    styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined
                },
                iconProps: {
                    iconName: 'MessageRemove',
                    styles: menuIconStyleSet
                },
                onClick: props.onRemoveClick
            }];
        // only show read by x of x if more than 3 participants in total including myself
        // TODO: change strings.messageReadCount to be required if we can fallback to our own en-us strings for anything that Contoso doesn't provide
        if (props.remoteParticipantsCount && messageReadByCount !== undefined && props.remoteParticipantsCount >= 2 && props.showMessageStatus && props.strings.messageReadCount && props.messageStatus !== 'failed') {
            items.push({
                key: 'Read Count',
                'data-ui-id': 'chat-composite-message-contextual-menu-read-info',
                text: _formatString(props.strings.messageReadCount, {
                    messageReadByCount: `${messageReadByCount}`,
                    remoteParticipantsCount: `${props.remoteParticipantsCount}`
                }),
                itemProps: {
                    styles: react.concatStyleSets({
                        linkContent: {
                            color: messageReadByCount > 0 ? theme.palette.neutralPrimary : theme.palette.neutralTertiary
                        },
                        root: {
                            borderTop: `1px solid ${theme.palette.neutralLighter}`
                        }
                    }, props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined)
                },
                calloutProps: preventUnwantedDismissProps,
                subMenuProps: {
                    items: messageReadByList !== null && messageReadByList !== void 0 ? messageReadByList : [],
                    calloutProps: preventUnwantedDismissProps,
                    styles: react.concatStyleSets({
                        root: {
                            maxWidth: _pxToRem(320),
                            span: {
                                overflow: 'hidden',
                                textOverflow: 'ellipsis'
                            }
                        }
                    })
                },
                iconProps: {
                    iconName: 'MessageSeen',
                    styles: {
                        root: {
                            color: messageReadByCount > 0 ? theme.palette.themeDarkAlt : theme.palette.neutralTertiary
                        }
                    }
                },
                submenuIconProps: {
                    iconName: 'HorizontalGalleryRightButton',
                    styles: menuSubIconStyleSet
                },
                disabled: messageReadByCount <= 0
            });
        }
        else if (props.messageStatus === 'failed' && props.strings.resendMessage) {
            items.push({
                key: 'Resend',
                text: props.strings.resendMessage,
                itemProps: {
                    styles: react.concatStyleSets({
                        linkContent: {
                            color: theme.palette.neutralPrimary
                        },
                        root: {
                            borderTop: `1px solid ${theme.palette.neutralLighter}`
                        }
                    }, props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined)
                },
                calloutProps: preventUnwantedDismissProps,
                iconProps: {
                    iconName: 'MessageResend',
                    styles: {
                        root: {
                            color: theme.palette.themeDarkAlt
                        }
                    }
                },
                onClick: props.onResendClick
            });
        }
        return items;
    }, [props.strings.editMessage, props.strings.removeMessage, props.strings.messageReadCount, props.strings.resendMessage, props.messageStatus, props.increaseFlyoutItemSize, props.onEditClick, props.onRemoveClick, props.onResendClick, props.remoteParticipantsCount, props.showMessageStatus, messageReadByCount, theme.palette.neutralPrimary, theme.palette.neutralTertiary, theme.palette.neutralLighter, theme.palette.themeDarkAlt, messageReadByList]);
    // gap space uses pixels
    return React.createElement(react.ContextualMenu, { alignTargetEdge: true, gapSpace: 2 /*px*/, isBeakVisible: false, items: menuItems, hidden: props.hidden, target: props.target, onDismiss: props.onDismiss, directionalHint: react.DirectionalHint.topRightEdge, className: chatMessageMenuStyle, calloutProps: calloutMenuProps });
};
/**
 * Similar to {@link preventDismissOnEvent}, but not prevent dismissing from scrolling, since it is causing bugs in chat thread.
 */
const preventUnwantedDismissProps = {
    preventDismissOnEvent: (ev) => {
        return ev.type === 'resize';
    }
};
const calloutMenuProps = Object.assign(Object.assign({}, preventUnwantedDismissProps), { styles: {
        root: {
            marginRight: '3px'
        }
    } });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const ChatMessageContent = (props) => {
    switch (props.message.contentType) {
        case 'text':
            return MessageContentAsText(props);
        case 'html':
            return MessageContentAsRichTextHTML(props);
        case 'richtext/html':
            return MessageContentAsRichTextHTML(props);
        default:
            console.warn('unknown message content type');
            return React.createElement(React.Fragment, null);
    }
};
const MessageContentWithLiveAria = (props) => {
    return React.createElement("div", { "data-ui-status": props.message.status, role: "text", "aria-label": props.ariaLabel },
        React.createElement(LiveMessage, { message: props.liveMessage, ariaLive: "polite" }),
        props.content);
};
const MessageContentAsRichTextHTML = (props) => {
    return React.createElement(MessageContentWithLiveAria, { message: props.message, liveMessage: generateLiveMessage(props), ariaLabel: messageContentAriaText(props), content: processHtmlToReact(props) });
};
const MessageContentAsText = (props) => {
    return React.createElement(MessageContentWithLiveAria, { message: props.message, liveMessage: generateLiveMessage(props), ariaLabel: messageContentAriaText(props), content: React.createElement(Linkify, { componentDecorator: (decoratedHref, decoratedText, key) => {
                return React.createElement(react.Link, { target: "_blank", href: decoratedHref, key: key }, decoratedText);
            } }, props.message.content) });
};
const extractContentForAllyMessage = (props) => {
    if (props.message.content) {
        // Replace all <img> tags with 'image' for aria.
        const parsedContent = DOMPurify.sanitize(props.message.content, {
            ALLOWED_TAGS: ['img'],
            RETURN_DOM_FRAGMENT: true
        });
        parsedContent.childNodes.forEach(child => {
            if (child.nodeName.toLowerCase() !== 'img') {
                return;
            }
            const imageTextNode = document.createElement('div');
            imageTextNode.innerHTML = 'image ';
            parsedContent.replaceChild(imageTextNode, child);
        });
        // Strip all html tags from the content for aria.
        const message = DOMPurify.sanitize(parsedContent, {
            ALLOWED_TAGS: []
        });
        return message;
    }
    return '';
};
const generateLiveMessage = (props) => {
    const liveAuthor = _formatString(props.strings.liveAuthorIntro, {
        author: `${props.message.senderDisplayName}`
    });
    return `${props.message.editedOn ? props.strings.editedTag : ''} ${props.message.mine ? '' : liveAuthor} ${extractContentForAllyMessage(props)} `;
};
const messageContentAriaText = (props) => {
    const message = extractContentForAllyMessage(props);
    return props.message.mine ? _formatString(props.strings.messageContentMineAriaText, {
        message: message
    }) : _formatString(props.strings.messageContentAriaText, {
        author: `${props.message.senderDisplayName}`,
        message: message
    });
};
/* @conditional-compile-remove(image-overlay) */
const defaultOnRenderInlineImage = (inlineImage) => {
    return React.createElement("img", Object.assign({ key: inlineImage.imageAttributes.id, tabIndex: 0, "data-ui-id": inlineImage.imageAttributes.id }, inlineImage.imageAttributes));
};
const processHtmlToReact = (props) => {
    var _a;
    const options = {
        transform(reactNode, domNode) {
            var _a;
            if (domNode instanceof parse.Element && domNode.attribs) {
                // Transform custom rendering of mentions
                // Transform inline images
                /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
                if (domNode.name && domNode.name === 'img' && domNode.attribs && domNode.attribs.id) {
                    domNode.attribs['aria-label'] = domNode.attribs.name;
                    const imgProps = parse.attributesToProps(domNode.attribs);
                    /* @conditional-compile-remove(image-overlay) */
                    const inlineImageProps = {
                        messageId: props.message.messageId,
                        imageAttributes: imgProps
                    };
                    /* @conditional-compile-remove(image-overlay) */
                    return ((_a = props.inlineImageOptions) === null || _a === void 0 ? void 0 : _a.onRenderInlineImage) ? props.inlineImageOptions.onRenderInlineImage(inlineImageProps, defaultOnRenderInlineImage) : defaultOnRenderInlineImage(inlineImageProps);
                }
            }
            // Pass through the original node
            return reactNode;
        }
    };
    return React.createElement(React.Fragment, null, parse((_a = props.message.content) !== null && _a !== void 0 ? _a : '', options));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Props for the Chat.Message action menu.
 * This is the 3 dots that appear when hovering over one of your own chat messages.
 *
 * @private
 */
const chatMessageActionMenuProps = (menuProps) => {
    const { ariaLabel, enabled, theme, menuExpanded } = menuProps;
    // Show the action button while the flyout is open (otherwise this will dismiss when the pointer is hovered over the flyout)
    const showActionMenu = enabled || menuExpanded;
    const actionMenuProps = {
        children: React.createElement("div", { tabIndex: showActionMenu ? 0 : undefined, key: "menuButton", "data-ui-id": "chat-composite-message-action-icon", ref: menuProps.menuButtonRef, onClick: showActionMenu ? () => menuProps.onActionButtonClick() : undefined, style: {
                margin: showActionMenu ? '1px' : 0,
                minHeight: showActionMenu ? undefined : '30px'
            }, role: "button", "aria-label": showActionMenu ? ariaLabel : undefined, "aria-haspopup": showActionMenu, "aria-expanded": menuExpanded, onKeyDown: e => {
                // simulate <button> tag behavior
                if (showActionMenu && (e.key === 'Enter' || e.key === ' ')) {
                    menuProps.onActionButtonClick();
                }
            } }, showActionMenu ? React.createElement(react.Icon, { iconName: "ChatMessageOptions", "aria-label": ariaLabel, styles: iconWrapperStyle(theme, menuExpanded) }) : undefined)
    };
    return actionMenuProps;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const generateDefaultTimestamp = (createdOn, showDate, strings) => {
    const formattedTimestamp = showDate ? formatTimestampForChatMessage(createdOn, new Date(), strings) : formatTimeForChatMessage(createdOn);
    return formattedTimestamp;
};
// onDisplayDateTimeString from props overwrite onDisplayDateTimeString from locale
const generateCustomizedTimestamp = (props, createdOn, locale) => {
    return '';
};
/** @private */
const MessageBubble = (props) => {
    var _a;
    const ids = useIdentifiers();
    const theme = useTheme();
    useLocale$1();
    const { userId, message, onRemoveClick, onResendClick, disableEditing, showDate, messageContainerStyle, strings, onEditClick, remoteParticipantsCount = 0, onRenderAvatar, showMessageStatus, messageStatus, 
    /* @conditional-compile-remove(image-overlay) */
    inlineImageOptions, shouldOverlapAvatarAndMessage } = props;
    const defaultTimeStamp = message.createdOn ? generateDefaultTimestamp(message.createdOn, showDate, strings) : undefined;
    const customTimestamp = message.createdOn ? generateCustomizedTimestamp(props, message.createdOn) : '';
    const formattedTimestamp = customTimestamp || defaultTimeStamp;
    // Track if the action menu was opened by touch - if so we increase the touch targets for the items
    const [wasInteractionByTouch, setWasInteractionByTouch] = React.useState(false);
    // `focused` state is used for show/hide actionMenu
    const [focused, setFocused] = React.useState(false);
    // The chat message action flyout should target the Chat.Message action menu if clicked,
    // or target the chat message if opened via touch press.
    // Undefined indicates the flyout menu should not be being shown.
    const messageRef = React.useRef(null);
    const messageActionButtonRef = React.useRef(null);
    const [chatMessageActionFlyoutTarget, setChatMessageActionFlyoutTarget] = React.useState(undefined);
    const chatActionsEnabled = !disableEditing && message.status !== 'sending' && !!message.mine;
    const [messageReadBy, setMessageReadBy] = React.useState([]);
    const actionMenuProps = chatMessageActionMenuProps({
        ariaLabel: (_a = strings.actionMenuMoreOptions) !== null && _a !== void 0 ? _a : '',
        enabled: chatActionsEnabled,
        menuButtonRef: messageActionButtonRef,
        menuExpanded: chatMessageActionFlyoutTarget === messageActionButtonRef,
        onActionButtonClick: () => {
            if (message.messageType === 'chat') {
                props.onActionButtonClick(message, setMessageReadBy);
                setChatMessageActionFlyoutTarget(messageActionButtonRef);
            }
        },
        theme
    });
    const onActionFlyoutDismiss = React.useCallback(() => {
        // When the flyout dismiss is called, since we control if the action flyout is visible
        // or not we need to set the target to undefined here to actually hide the action flyout
        setChatMessageActionFlyoutTarget(undefined);
    }, [setChatMessageActionFlyoutTarget]);
    const defaultOnRenderFileDownloads = React.useCallback(() => { }, [userId, message]);
    const editedOn = 'editedOn' in message ? message.editedOn : undefined;
    const getMessageDetails = React.useCallback(() => {
        if (messageStatus === 'failed') {
            return React.createElement("div", { className: chatMessageFailedTagStyle(theme) }, strings.failToSendTag);
        }
        else if (message.messageType === 'chat' && editedOn) {
            return React.createElement("div", { className: chatMessageEditedTagStyle(theme) }, strings.editedTag);
        }
        return undefined;
    }, [editedOn, message.messageType, messageStatus, strings.editedTag, strings.failToSendTag, theme]);
    const getContent = React.useCallback(() => {
        return React.createElement("div", { tabIndex: 0, className: "ui-chat__message__content" },
            React.createElement(ChatMessageContent, { message: message, strings: strings, inlineImageOptions: inlineImageOptions }));
    }, [defaultOnRenderFileDownloads, /* @conditional-compile-remove(image-overlay) */ inlineImageOptions, message, props, strings, userId]);
    const chatMyMessageStyles = useChatMyMessageStyles();
    const chatMessageCommonStyles = useChatMessageCommonStyles();
    const chatMessageStyles = useChatMessageStyles();
    const chatItemMessageContainerClassName = reactComponents.mergeClasses(
    // messageContainerStyle used in className and style prop as style prop can't handle CSS selectors
    chatMessageStyles.body, 
    // disable placeholder functionality for GA releases as it might confuse users
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    chatMessageStyles.bodyWithPlaceholderImage, props.message.status === 'failed' ? chatMessageCommonStyles.failed : undefined, shouldOverlapAvatarAndMessage ? chatMessageStyles.avatarOverlap : chatMessageStyles.avatarNoOverlap, message.attached === 'top' || message.attached === false ? chatMessageStyles.bodyWithAvatar : chatMessageStyles.bodyWithoutAvatar, react.mergeStyles(messageContainerStyle));
    const attached = message.attached === true ? 'center' : message.attached === 'bottom' ? 'bottom' : 'top';
    const chatMessage = React.createElement(React.Fragment, null,
        React.createElement("div", { key: props.message.messageId }, message.mine ? React.createElement(reactChat.ChatMyMessage, { attached: attached, key: props.message.messageId, body: {
                // messageContainerStyle used in className and style prop as style prop can't handle CSS selectors
                className: reactComponents.mergeClasses(chatMyMessageStyles.body, props.message.status === 'failed' ? chatMessageCommonStyles.failed : undefined, attached !== 'top' ? chatMyMessageStyles.bodyAttached : undefined, react.mergeStyles(messageContainerStyle)),
                style: Object.assign({}, createStyleFromV8Style(messageContainerStyle)),
                ref: messageRef
            }, root: {
                className: chatMyMessageStyles.root,
                onBlur: e => {
                    // `focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
                    // with keyboard the focused element will be changed and there is no way to use `:focus` selector
                    if (chatMessageActionFlyoutTarget === null || chatMessageActionFlyoutTarget === void 0 ? void 0 : chatMessageActionFlyoutTarget.current) {
                        // doesn't dismiss action button if flyout is open, otherwise, narrator's focus will stay on the closed action menu
                        return;
                    }
                    const shouldPreserveFocusState = e.currentTarget.contains(e.relatedTarget);
                    setFocused(shouldPreserveFocusState);
                },
                onFocus: () => {
                    // react onFocus is called even when nested component receives focus (i.e. it bubbles)
                    // so when focus moves within actionMenu, the `focus` state in chatMessage remains true, and keeps actionMenu visible
                    setFocused(true);
                },
                // make body not focusable to remove repetitions from narrators.
                // inner components are already focusable
                role: 'none',
                tabIndex: -1
            }, "data-ui-id": "chat-composite-message", author: React.createElement(react.Text, { className: chatMessageDateStyle, tabIndex: 0 }, message.senderDisplayName), timestamp: React.createElement(react.Text, { className: chatMessageDateStyle, "data-ui-id": ids.messageTimestamp, tabIndex: 0 }, formattedTimestamp), details: getMessageDetails(), actions: {
                children: actionMenuProps === null || actionMenuProps === void 0 ? void 0 : actionMenuProps.children,
                className: reactComponents.mergeClasses(chatMyMessageStyles.menu, 
                // Make actions menu visible when the message is focused or the flyout is shown
                focused || (chatMessageActionFlyoutTarget === null || chatMessageActionFlyoutTarget === void 0 ? void 0 : chatMessageActionFlyoutTarget.current) ? chatMyMessageStyles.menuVisible : chatMyMessageStyles.menuHidden, attached !== 'top' ? chatMyMessageStyles.menuAttached : undefined)
            }, onTouchStart: () => setWasInteractionByTouch(true), onPointerDown: () => setWasInteractionByTouch(false), onKeyDown: () => setWasInteractionByTouch(false), onClick: () => {
                if (!wasInteractionByTouch) {
                    return;
                }
                // If the message was touched via touch we immediately open the menu
                // flyout (when using mouse the 3-dot menu that appears on hover
                // must be clicked to open the flyout).
                // In doing so here we set the target of the flyout to be the message and
                // not the 3-dot menu button to position the flyout correctly.
                setChatMessageActionFlyoutTarget(messageRef);
                if (message.messageType === 'chat') {
                    props.onActionButtonClick(message, setMessageReadBy);
                }
            } }, getContent()) : React.createElement(reactChat.ChatMessage, { attached: attached, key: props.message.messageId, root: {
                className: chatMessageStyles.root,
                // make body not focusable to remove repetitions from narrators.
                // inner components are already focusable
                tabIndex: -1,
                role: 'none'
            }, author: React.createElement(react.Text, { className: chatMessageAuthorStyle }, message.senderDisplayName), body: {
                className: chatItemMessageContainerClassName,
                style: Object.assign({}, createStyleFromV8Style(messageContainerStyle))
            }, "data-ui-id": "chat-composite-message", timestamp: React.createElement(react.Text, { className: chatMessageDateStyle, "data-ui-id": ids.messageTimestamp }, formattedTimestamp), details: getMessageDetails() }, getContent())),
        chatActionsEnabled && React.createElement(ChatMessageActionFlyout, { hidden: !chatMessageActionFlyoutTarget, target: chatMessageActionFlyoutTarget, increaseFlyoutItemSize: wasInteractionByTouch, onDismiss: onActionFlyoutDismiss, onEditClick: onEditClick, onRemoveClick: onRemoveClick, onResendClick: onResendClick, strings: strings, messageReadBy: messageReadBy, messageStatus: messageStatus !== null && messageStatus !== void 0 ? messageStatus : 'failed', remoteParticipantsCount: remoteParticipantsCount, onRenderAvatar: onRenderAvatar, showMessageStatus: showMessageStatus }));
    return chatMessage;
};
/** @private */
const ChatMessageComponentAsMessageBubble = React.memo(MessageBubble);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$x = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const ChatMessageComponent = (props) => {
    const { onDeleteMessage, onSendMessage, message } = props;
    const [isEditing, setIsEditing] = React.useState(false);
    const onEditClick = React.useCallback(() => setIsEditing(true), [setIsEditing]);
    const clientMessageId = 'clientMessageId' in message ? message.clientMessageId : undefined;
    const content = 'content' in message ? message.content : undefined;
    const onRemoveClick = React.useCallback(() => {
        if (onDeleteMessage && message.messageId) {
            onDeleteMessage(message.messageId);
        }
        // when fail to send, message does not have message id, delete message using clientMessageId
        else if (onDeleteMessage && message.messageType === 'chat' && clientMessageId) {
            onDeleteMessage(clientMessageId);
        }
    }, [onDeleteMessage, message.messageId, message.messageType, clientMessageId]);
    const onResendClick = React.useCallback(() => {
        onDeleteMessage && clientMessageId && onDeleteMessage(clientMessageId);
        onSendMessage && onSendMessage(content !== undefined ? content : '');
    }, [clientMessageId, content, onSendMessage, onDeleteMessage]);
    if (isEditing && message.messageType === 'chat') {
        return React.createElement(ChatMessageComponentAsEditBox, { message: message, strings: props.strings, onSubmit: (text, metadata, options) => __awaiter$x(void 0, void 0, void 0, function* () {
                props.onUpdateMessage && message.messageId && (yield props.onUpdateMessage(message.messageId, text, metadata, options));
                setIsEditing(false);
            }), onCancel: messageId => {
                props.onCancelEditMessage && props.onCancelEditMessage(messageId);
                setIsEditing(false);
            } });
    }
    else {
        return React.createElement(ChatMessageComponentAsMessageBubble, Object.assign({}, props, { onRemoveClick: onRemoveClick, onEditClick: onEditClick, onResendClick: onResendClick, onRenderAvatar: props.onRenderAvatar, strings: props.strings, 
            /* @conditional-compile-remove(image-overlay) */ inlineImageOptions: props.inlineImageOptions }));
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * The component for rendering a chat message using Fluent UI components
 * and handling default and custom renderers.
 * This component handles rendering for chat message body, avatar and message status.
 * The chat message body, avatar and message status should be shown for both default and custom renderers.
 *
 * @private
 */
const FluentChatMessageComponentWrapper = (props) => {
    const { message, styles, shouldOverlapAvatarAndMessage, onRenderMessage, onRenderAvatar, showMessageStatus, onRenderMessageStatus, participantCount, readCount, onActionButtonClick, 
    /* @conditional-compile-remove(image-overlay) */
    inlineImageOptions, userId, defaultStatusRenderer, statusToRender } = props;
    const chatMessageRenderStyles = useChatMessageRenderStyles();
    const onRenderFileDownloadsMemo = React.useMemo(() => {
        return undefined;
    }, []);
    // To rerender the defaultChatMessageRenderer if app running across days(every new day chat time stamp
    // needs to be regenerated), the dependency on "new Date().toDateString()"" is added.
    const defaultChatMessageRenderer = React.useCallback((messageProps) => {
        if (messageProps.message.messageType === 'chat') {
            return React.createElement(ChatMessageComponent, Object.assign({}, messageProps, { message: messageProps.message, userId: userId, remoteParticipantsCount: participantCount ? participantCount - 1 : 0, shouldOverlapAvatarAndMessage: shouldOverlapAvatarAndMessage, onRenderAvatar: onRenderAvatar, showMessageStatus: showMessageStatus, messageStatus: messageProps.message.status, onActionButtonClick: onActionButtonClick, inlineImageOptions: inlineImageOptions }));
        }
        return React.createElement(React.Fragment, null);
    }, [onActionButtonClick, onRenderAvatar, onRenderFileDownloadsMemo, participantCount, shouldOverlapAvatarAndMessage, showMessageStatus, userId, /* @conditional-compile-remove(image-overlay) */
        inlineImageOptions,
        // eslint-disable-next-line react-hooks/exhaustive-deps
        new Date().toDateString()]);
    const messageRenderer = React.useCallback((messageProps) => {
        return onRenderMessage === undefined ? defaultChatMessageRenderer(Object.assign({}, messageProps)) : onRenderMessage(messageProps, defaultChatMessageRenderer);
    }, [defaultChatMessageRenderer, onRenderMessage]);
    const messageStatusRenderer = React.useCallback((onRenderMessageStatus, defaultStatusRenderer, showMessageStatus, participantCount, readCount) => {
        return showMessageStatus && statusToRender ? onRenderMessageStatus ? onRenderMessageStatus({
            status: message.status
        }) : defaultStatusRenderer(message, participantCount !== null && participantCount !== void 0 ? participantCount : 0, readCount !== null && readCount !== void 0 ? readCount : 0, message.status) : React.createElement("div", { className: react.mergeStyles(noMessageStatusStyle) });
    }, [message, statusToRender]);
    const shouldShowAvatar = React.useMemo(() => {
        return message.attached === 'top' || message.attached === false;
    }, [message.attached]);
    const attached = React.useMemo(() => {
        return shouldShowAvatar ? 'top' : 'center';
    }, [shouldShowAvatar]);
    const myMessageRootProps = React.useMemo(() => {
        return {
            // myChatItemMessageContainer used in className and style prop as style prop can't handle CSS selectors
            className: reactComponents.mergeClasses(chatMessageRenderStyles.rootMyMessage, chatMessageRenderStyles.rootCommon, react.mergeStyles(styles === null || styles === void 0 ? void 0 : styles.myChatItemMessageContainer)),
            style: (styles === null || styles === void 0 ? void 0 : styles.myChatItemMessageContainer) !== undefined ? createStyleFromV8Style(styles === null || styles === void 0 ? void 0 : styles.myChatItemMessageContainer) : {},
            role: 'none'
        };
    }, [chatMessageRenderStyles.rootCommon, chatMessageRenderStyles.rootMyMessage, styles === null || styles === void 0 ? void 0 : styles.myChatItemMessageContainer]);
    const myMessageBodyProps = React.useMemo(() => {
        return {
            className: reactComponents.mergeClasses(chatMessageRenderStyles.bodyCommon, chatMessageRenderStyles.bodyMyMessage),
            // make body not focusable to remove repetitions from narrators.
            // inner components are already focusable
            tabIndex: -1,
            role: 'none'
        };
    }, [chatMessageRenderStyles.bodyCommon, chatMessageRenderStyles.bodyMyMessage]);
    const myMessageStatusIcon = React.useMemo(() => {
        var _a;
        return React.createElement("div", { className: react.mergeStyles({
                paddingLeft: '0.25rem'
            }, (styles === null || styles === void 0 ? void 0 : styles.messageStatusContainer) ? styles.messageStatusContainer((_a = message.mine) !== null && _a !== void 0 ? _a : false) : '') }, message.status ? messageStatusRenderer(onRenderMessageStatus, defaultStatusRenderer, showMessageStatus, participantCount, readCount) : undefined);
    }, [defaultStatusRenderer, message.mine, message.status, messageStatusRenderer, onRenderMessageStatus, participantCount, readCount, showMessageStatus, styles]);
    const messageRootProps = React.useMemo(() => {
        return {
            className: reactComponents.mergeClasses(chatMessageRenderStyles.rootMessage, chatMessageRenderStyles.rootCommon)
        };
    }, [chatMessageRenderStyles.rootCommon, chatMessageRenderStyles.rootMessage]);
    const messageBodyProps = React.useMemo(() => {
        return {
            // chatItemMessageContainer used in className and style prop as style prop can't handle CSS selectors
            className: reactComponents.mergeClasses(chatMessageRenderStyles.bodyCommon, !shouldShowAvatar ? chatMessageRenderStyles.bodyWithoutAvatar : chatMessageRenderStyles.bodyWithAvatar, shouldOverlapAvatarAndMessage ? chatMessageRenderStyles.avatarOverlap : chatMessageRenderStyles.avatarNoOverlap, react.mergeStyles(styles === null || styles === void 0 ? void 0 : styles.chatItemMessageContainer)),
            style: (styles === null || styles === void 0 ? void 0 : styles.chatItemMessageContainer) !== undefined ? createStyleFromV8Style(styles === null || styles === void 0 ? void 0 : styles.chatItemMessageContainer) : {},
            // make body not focusable to remove repetitions from narrators.
            // inner components are already focusable
            tabIndex: -1,
            role: 'none'
        };
    }, [chatMessageRenderStyles.avatarNoOverlap, chatMessageRenderStyles.avatarOverlap, chatMessageRenderStyles.bodyCommon, chatMessageRenderStyles.bodyWithAvatar, chatMessageRenderStyles.bodyWithoutAvatar, shouldOverlapAvatarAndMessage, shouldShowAvatar, styles === null || styles === void 0 ? void 0 : styles.chatItemMessageContainer]);
    const avatar = React.useMemo(() => {
        const chatAvatarStyle = shouldShowAvatar ? gutterWithAvatar : gutterWithHiddenAvatar;
        const personaOptions = {
            hidePersonaDetails: true,
            size: react.PersonaSize.size32,
            text: message.senderDisplayName,
            showOverflowTooltip: false
        };
        return React.createElement("div", { className: react.mergeStyles(chatAvatarStyle) }, onRenderAvatar ? onRenderAvatar === null || onRenderAvatar === void 0 ? void 0 : onRenderAvatar(message.senderId, personaOptions) : React.createElement(react.Persona, Object.assign({}, personaOptions)));
    }, [message.senderDisplayName, message.senderId, onRenderAvatar, shouldShowAvatar]);
    // Fluent UI message components are used here as for default message renderer,
    // timestamp and author name should be shown but they aren't shown for custom renderer.
    // More investigations are needed to check if this can be simplified with states.
    // Status and avatar should be shown for both custom and default renderers.
    if (message.mine === true) {
        return React.createElement("div", null,
            React.createElement(reactChat.ChatMyMessage, { attached: attached, root: myMessageRootProps, body: myMessageBodyProps, statusIcon: myMessageStatusIcon }, messageRenderer(Object.assign({}, props))));
    }
    else {
        return React.createElement("div", null,
            React.createElement(reactChat.ChatMessage, { attached: attached, root: messageRootProps, body: messageBodyProps, avatar: avatar }, messageRenderer(Object.assign({}, props))));
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const systemMessageIconStyle = react.mergeStyles({
    marginInlineEnd: '0.688rem'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const SystemMessage = (props) => {
    const { iconName, content } = props;
    const Icon = React.createElement(react.FontIcon, { iconName: iconName, className: react.mergeStyles(systemMessageIconStyle) });
    return React.createElement(react.Stack, { horizontal: true, className: react.mergeStyles(props === null || props === void 0 ? void 0 : props.containerStyle), tabIndex: 0 },
        Icon,
        React.createElement(react.Text, { style: {
                wordBreak: 'break-word'
            }, role: "status", title: content, variant: 'small' }, content));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const DefaultSystemMessage = (props) => {
    var _a;
    const message = props.message;
    switch (message.messageType) {
        case 'system':
            switch (message.systemMessageType) {
                case 'content':
                    return React.createElement(SystemMessage, { iconName: (message.iconName ? message.iconName : ''), content: (_a = message.content) !== null && _a !== void 0 ? _a : '', containerStyle: props === null || props === void 0 ? void 0 : props.messageContainerStyle });
                case 'participantAdded':
                case 'participantRemoved':
                    return React.createElement(ParticipantSystemMessageComponent, { message: message, style: props.messageContainerStyle, defaultName: props.strings.noDisplayNameSub });
            }
    }
    return React.createElement(React.Fragment, null);
};
const ParticipantSystemMessageComponent = ({ message, style, defaultName }) => {
    const { strings } = useLocale$1();
    const participantsStr = generateParticipantsStr(message.participants, defaultName);
    const messageSuffix = message.systemMessageType === 'participantAdded' ? strings.messageThread.participantJoined : strings.messageThread.participantLeft;
    if (participantsStr !== '') {
        return React.createElement(SystemMessage, { iconName: (message.iconName ? message.iconName : ''), content: `${participantsStr} ${messageSuffix}`, containerStyle: style });
    }
    return React.createElement(React.Fragment, null);
};
const generateParticipantsStr = (participants, defaultName) => participants.map(participant => `${!participant.displayName || participant.displayName === '' ? defaultName : participant.displayName}`).join(', ');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * The wrapper component to display different types of chat message.
 *
 * @private
 */
const ChatMessageComponentWrapper = (props) => {
    var _a;
    const { message, styles, onRenderMessage, key: messageKey } = props;
    const systemMessageStyle = React.useMemo(() => {
        return {
            paddingTop: '0.5rem'
        };
    }, []);
    const customMessageStyle = React.useMemo(() => {
        return {
            paddingTop: '1rem',
            paddingBottom: '0.25rem'
        };
    }, []);
    switch (message.messageType) {
        case 'chat':
            {
                const myChatMessageStyle = message.status === 'failed' ? (_a = styles === null || styles === void 0 ? void 0 : styles.failedMyChatMessageContainer) !== null && _a !== void 0 ? _a : styles === null || styles === void 0 ? void 0 : styles.myChatMessageContainer : styles === null || styles === void 0 ? void 0 : styles.myChatMessageContainer;
                const chatMessageStyle = styles === null || styles === void 0 ? void 0 : styles.chatMessageContainer;
                const messageContainerStyle = message.mine ? myChatMessageStyle : chatMessageStyle;
                return React.createElement(FluentChatMessageComponentWrapper, Object.assign({}, props, { message: message, messageContainerStyle: messageContainerStyle }));
            }
        case 'system':
            {
                const messageContainerStyle = styles === null || styles === void 0 ? void 0 : styles.systemMessageContainer;
                const systemMessageComponent = onRenderMessage === undefined ? React.createElement(DefaultSystemMessage, Object.assign({}, props)) : onRenderMessage(Object.assign(Object.assign({}, props), { messageContainerStyle }), props => React.createElement(DefaultSystemMessage, Object.assign({}, props)));
                return React.createElement("div", { key: messageKey, style: systemMessageStyle }, systemMessageComponent);
            }
        default:
            {
                // We do not handle custom type message by default, users can handle custom type by using onRenderMessage function.
                const customMessageComponent = onRenderMessage === undefined ? React.createElement(React.Fragment, null) : onRenderMessage(Object.assign({}, props));
                return React.createElement("div", { key: messageKey, style: customMessageStyle }, customMessageComponent);
            }
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 * Announcer component to maker aria announcements on actions
 */
const Announcer = (props) => {
    const { announcementString, ariaLive } = props;
    return React.createElement(react.Stack, { "aria-label": announcementString, "aria-live": ariaLive, styles: announcerStyles });
};
/**
 * Styles to hide the announcer from view but still existing on the DOM tree it so that narration can happen.
 */
const announcerStyles = {
    root: {
        position: 'absolute',
        width: '1px',
        height: '1px',
        padding: 0,
        margin: '-1px',
        overflow: 'hidden',
        clip: 'rect(0,0,0,0)',
        whiteSpace: 'nowrap',
        border: 0
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$w = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const isMessageSame = (first, second) => {
    return first.messageId === second.messageId && first.content === second.content && first.contentType === second.contentType && JSON.stringify(first.createdOn) === JSON.stringify(second.createdOn) && first.senderId === second.senderId && first.senderDisplayName === second.senderDisplayName && JSON.stringify(first.editedOn) === JSON.stringify(second.editedOn);
};
/**
 * Get the latest message from the message array.
 *
 * @param messages
 */
const getLatestChatMessage = (messages) => {
    for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.messageType === 'chat' && !!message.createdOn) {
            return message;
        }
    }
    return undefined;
};
/**
 * Compare latestMessageFromPreviousMessages & latestMessageFromNewMessages to see if the new message is not from
 * current user.
 */
const isThereNewMessageNotFromCurrentUser = (userId, latestMessageFromPreviousMessages, latestMessageFromNewMessages) => {
    if (latestMessageFromNewMessages === undefined) {
        return false;
    }
    if (latestMessageFromPreviousMessages === undefined) {
        return latestMessageFromNewMessages.senderId !== userId;
    }
    return !isMessageSame(latestMessageFromNewMessages, latestMessageFromPreviousMessages) && latestMessageFromNewMessages.senderId !== userId;
};
/**
 * Returns true if the current user sent the latest message and false otherwise. It will ignore messages that have no
 * sender, messages that have failed to send, and messages from the current user that is marked as SEEN. This is meant
 * as an indirect way to detect if user is at bottom of the chat when the component updates with new messages. If we
 * updated this component due to current user sending a message we want to then call scrollToBottom.
 */
const didUserSendTheLatestMessage = (userId, latestMessageFromPreviousMessages, latestMessageFromNewMessages) => {
    if (latestMessageFromNewMessages === undefined) {
        return false;
    }
    if (latestMessageFromPreviousMessages === undefined) {
        return latestMessageFromNewMessages.senderId === userId;
    }
    return !isMessageSame(latestMessageFromNewMessages, latestMessageFromPreviousMessages) && latestMessageFromNewMessages.senderId === userId;
};
const DefaultJumpToNewMessageButton = (props) => {
    const { text, onClick } = props;
    return React.createElement(react.PrimaryButton, { className: newMessageButtonStyle, styles: buttonWithIconStyles$1, text: text, onClick: onClick, onRenderIcon: () => React.createElement(react.Icon, { iconName: "Down", className: DownIconStyle }) });
};
const memoizeAllMessages = memoizeFnAll((message, showMessageDate, showMessageStatus, strings, index, onUpdateMessage, onCancelEditMessage, onDeleteMessage, onSendMessage, disableEditing, lastSeenChatMessage, lastSendingChatMessage, lastDeliveredChatMessage) => {
    let key = message.messageId;
    let statusToRender = undefined;
    if (message.messageType === 'chat') {
        if ((!message.messageId || message.messageId === '') && 'clientMessageId' in message) {
            key = message.clientMessageId;
        }
        if (showMessageStatus && message.mine) {
            switch (message.messageId) {
                case lastSeenChatMessage:
                    {
                        statusToRender = 'seen';
                        break;
                    }
                case lastSendingChatMessage:
                    {
                        statusToRender = 'sending';
                        break;
                    }
                case lastDeliveredChatMessage:
                    {
                        statusToRender = 'delivered';
                        break;
                    }
            }
        }
        if (message.mine && message.status === 'failed') {
            statusToRender = 'failed';
        }
    }
    return {
        key: key !== null && key !== void 0 ? key : 'id_' + index,
        statusToRender,
        message,
        strings,
        showDate: showMessageDate,
        onUpdateMessage,
        onCancelEditMessage,
        onDeleteMessage,
        onSendMessage,
        disableEditing,
        showMessageStatus
    };
});
const getLastChatMessageIdWithStatus = (messages, status) => {
    for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.messageType === 'chat' && message.status === status && message.mine) {
            return message.messageId;
        }
    }
    return undefined;
};
const getLastChatMessageForCurrentUser = (messages) => {
    for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.messageType === 'chat' && message.mine) {
            return message;
        }
    }
    return undefined;
};
/**
 * `MessageThread` allows you to easily create a component for rendering chat messages, handling scrolling behavior of new/old messages and customizing icons & controls inside the chat thread.
 * @param props - of type MessageThreadProps
 *
 * Users will need to provide at least chat messages and userId to render the `MessageThread` component.
 * Users can also customize `MessageThread` by passing in their own Avatar, `MessageStatusIndicator` icon, `JumpToNewMessageButton`, `LoadPreviousMessagesButton` and the behavior of these controls.
 *
 * `MessageThread` internally uses the `Chat` component from `@fluentui-contrib/chat`. You can checkout the details about these components [here](https://microsoft.github.io/fluentui-contrib/react-chat/).
 *
 * @public
 */
const MessageThread = (props) => {
    var _a;
    const theme = useTheme();
    const chatBody = React.useMemo(() => {
        return React.createElement(FluentV9ThemeProvider, { v8Theme: theme },
            React.createElement(MessageThreadWrapper, Object.assign({}, props)));
    }, [theme, props]);
    return React.createElement("div", { className: react.mergeStyles(messageThreadContainerStyle, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root) }, chatBody);
};
/**
 * @private
 */
const MessageThreadWrapper = (props) => {
    var _a;
    const { messages: newMessages, userId, participantCount, readReceiptsBySenderId, styles, disableJumpToNewMessageButton = false, showMessageDate = false, showMessageStatus = false, numberOfChatMessagesToReload = 5, onMessageSeen, onRenderMessageStatus, onRenderAvatar, onLoadPreviousChatMessages, onRenderJumpToNewMessageButton, onRenderMessage, onUpdateMessage, onCancelEditMessage, onDeleteMessage, onSendMessage, 
    /* @conditional-compile-remove(image-overlay) */
    inlineImageOptions } = props;
    // We need this state to wait for one tick and scroll to bottom after messages have been initialized.
    // Otherwise chatScrollDivRef.current.clientHeight is wrong if we scroll to bottom before messages are initialized.
    const [chatMessagesInitialized, setChatMessagesInitialized] = React.useState(false);
    const [isAtBottomOfScroll, setIsAtBottomOfScroll] = React.useState(true);
    const [forceUpdate, setForceUpdate] = React.useState(0);
    // Used to decide if should auto scroll to bottom or show "new message" button
    const [latestPreviousChatMessage, setLatestPreviousChatMessage] = React.useState(undefined);
    const [latestCurrentChatMessage, setLatestCurrentChatMessage] = React.useState(undefined);
    const [existsNewChatMessage, setExistsNewChatMessage] = React.useState(false);
    const [lastSeenChatMessage, setLastSeenChatMessage] = React.useState(undefined);
    const [lastDeliveredChatMessage, setLastDeliveredChatMessage] = React.useState(undefined);
    const [lastSendingChatMessage, setLastSendingChatMessage] = React.useState(undefined);
    // readCount and participantCount will only need to be updated on-fly when user hover on an indicator
    const [readCountForHoveredIndicator, setReadCountForHoveredIndicator] = React.useState(undefined);
    const localeStrings = useLocale$1().strings.messageThread;
    const strings = React.useMemo(() => (Object.assign(Object.assign({}, localeStrings), props.strings)), [localeStrings, props.strings]);
    // it is required to use useState for messages
    // as the scrolling logic requires re - render at a specific point in time
    const [messages, setMessages] = React.useState([]);
    // id for the latest deleted message
    const [latestDeletedMessageId, setLatestDeletedMessageId] = React.useState(undefined);
    // this value is used to check if a message is deleted for the previous value of messages array
    const previousMessagesRef = React.useRef([]);
    // an aria label for Narrator to notify when a message is deleted
    const [deletedMessageAriaLabel, setDeletedMessageAriaLabel] = React.useState(undefined);
    const onDeleteMessageCallback = React.useCallback((messageId) => __awaiter$w(void 0, void 0, void 0, function* () {
        if (!onDeleteMessage) {
            return;
        }
        try {
            // reset deleted message label in case if there was a value already (messages are deleted 1 after another)
            setDeletedMessageAriaLabel(undefined);
            setLatestDeletedMessageId(messageId);
            lastChatMessageStatus.current = 'deleted';
            // we should set up latestDeletedMessageId before the onDeleteMessage call
            // as otherwise in very rare cases the messages array can be updated before latestDeletedMessageId
            yield onDeleteMessage(messageId);
        }
        catch (e) {
            console.log('onDeleteMessage failed: messageId', messageId, 'error', e);
        }
    }), [onDeleteMessage]);
    const isAllChatMessagesLoadedRef = React.useRef(false);
    // isAllChatMessagesLoadedRef needs to be updated every time when a new adapter is set in order to display correct data
    // onLoadPreviousChatMessages is updated when a new adapter is set
    React.useEffect(() => {
        if (onLoadPreviousChatMessages) {
            isAllChatMessagesLoadedRef.current = false;
        }
    }, [onLoadPreviousChatMessages]);
    const previousTopRef = React.useRef(-1);
    const previousHeightRef = React.useRef(-1);
    const messageIdSeenByMeRef = React.useRef('');
    const chatScrollDivRef = React.useRef(null);
    const isLoadingChatMessagesRef = React.useRef(false);
    React.useEffect(() => {
        if (latestDeletedMessageId === undefined) {
            setDeletedMessageAriaLabel(undefined);
        }
        else {
            if (!previousMessagesRef.current.find(message => message.messageId === latestDeletedMessageId)) {
                // the message is deleted in previousMessagesRef
                // no need to update deletedMessageAriaLabel
                setDeletedMessageAriaLabel(undefined);
            }
            else if (!messages.find(message => message.messageId === latestDeletedMessageId)) {
                // the message is deleted in messages array but still exists in previousMessagesRef
                // update deletedMessageAriaLabel
                setDeletedMessageAriaLabel(strings.messageDeletedAnnouncementAriaLabel);
            }
            else {
                // the message exists in both arrays
                // no need to update deletedMessageAriaLabel
                setDeletedMessageAriaLabel(undefined);
            }
        }
        previousMessagesRef.current = messages;
    }, [latestDeletedMessageId, messages, strings.messageDeletedAnnouncementAriaLabel]);
    const messagesRef = React.useRef(messages);
    const setMessagesRef = (messagesWithAttachedValue) => {
        messagesRef.current = messagesWithAttachedValue;
        setMessages(messagesWithAttachedValue);
    };
    const isAtBottomOfScrollRef = React.useRef(isAtBottomOfScroll);
    const setIsAtBottomOfScrollRef = (isAtBottomOfScrollValue) => {
        isAtBottomOfScrollRef.current = isAtBottomOfScrollValue;
        setIsAtBottomOfScroll(isAtBottomOfScrollValue);
    };
    const chatMessagesInitializedRef = React.useRef(chatMessagesInitialized);
    const setChatMessagesInitializedRef = (chatMessagesInitialized) => {
        chatMessagesInitializedRef.current = chatMessagesInitialized;
        setChatMessagesInitialized(chatMessagesInitialized);
    };
    const chatThreadRef = React.useRef(null);
    // When the chat thread is narrow, we perform space optimizations such as overlapping
    // the avatar on top of the chat message and moving the chat accept/reject edit buttons
    // to a new line
    const chatThreadWidth = _useContainerWidth(chatThreadRef);
    const isNarrow = chatThreadWidth ? isNarrowWidth(chatThreadWidth) : false;
    /**
     * ClientHeight controls the number of messages to render. However ClientHeight will not be initialized after the
     * first render (not sure but I guess Fluent is updating it in hook which is after render maybe?) so we need to
     * trigger a re-render until ClientHeight is initialized. This force re-render should only happen once.
     */
    const clientHeight = (_a = chatThreadRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight;
    // we try to only send those message status if user is scrolled to the bottom.
    const sendMessageStatusIfAtBottom = React.useCallback(() => __awaiter$w(void 0, void 0, void 0, function* () {
        if (!isAtBottomOfScrollRef.current || !document.hasFocus() || !messagesRef.current || messagesRef.current.length === 0 || !showMessageStatus) {
            return;
        }
        const messagesWithId = messagesRef.current.filter(message => {
            return message.messageType === 'chat' && !message.mine && !!message.messageId;
        });
        if (messagesWithId.length === 0) {
            return;
        }
        const lastMessage = messagesWithId[messagesWithId.length - 1];
        try {
            if (onMessageSeen && lastMessage && lastMessage.messageId && lastMessage.messageId !== messageIdSeenByMeRef.current) {
                yield onMessageSeen(lastMessage.messageId);
                messageIdSeenByMeRef.current = lastMessage.messageId;
            }
        }
        catch (e) {
            console.log('onMessageSeen Error', lastMessage, e);
        }
    }), [showMessageStatus, onMessageSeen]);
    const scrollToBottom = React.useCallback(() => {
        if (chatScrollDivRef.current) {
            chatScrollDivRef.current.scrollTop = chatScrollDivRef.current.scrollHeight;
        }
        setExistsNewChatMessage(false);
        setIsAtBottomOfScrollRef(true);
        sendMessageStatusIfAtBottom();
    }, [sendMessageStatusIfAtBottom]);
    const handleScrollToTheBottom = React.useCallback(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        const atBottom = Math.ceil(chatScrollDivRef.current.scrollTop) >= chatScrollDivRef.current.scrollHeight - chatScrollDivRef.current.clientHeight;
        if (atBottom) {
            sendMessageStatusIfAtBottom();
            if (!isAtBottomOfScrollRef.current) {
                scrollToBottom();
            }
        }
        setIsAtBottomOfScrollRef(atBottom);
    }, [scrollToBottom, sendMessageStatusIfAtBottom]);
    // Infinite scrolling + threadInitialize function
    const fetchNewMessageWhenAtTop = React.useCallback(() => __awaiter$w(void 0, void 0, void 0, function* () {
        if (!isLoadingChatMessagesRef.current) {
            if (onLoadPreviousChatMessages) {
                isLoadingChatMessagesRef.current = true;
                try {
                    // Fetch message until scrollTop reach the threshold for fetching new message
                    while (!isAllChatMessagesLoadedRef.current && chatScrollDivRef.current && chatScrollDivRef.current.scrollTop <= 500) {
                        isAllChatMessagesLoadedRef.current = yield onLoadPreviousChatMessages(numberOfChatMessagesToReload);
                        yield delay(200);
                    }
                }
                finally {
                    // Set isLoadingChatMessagesRef to false after messages are fetched
                    isLoadingChatMessagesRef.current = false;
                }
            }
        }
    }), [numberOfChatMessagesToReload, onLoadPreviousChatMessages]);
    // The below 2 of useEffects are design for fixing infinite scrolling problem
    // Scrolling element will behave differently when scrollTop = 0(it sticks at the top)
    // we need to get previousTop before it prepend contents
    // Execute order [newMessage useEffect] => get previousTop => dom update => [messages useEffect]
    React.useEffect(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        previousTopRef.current = chatScrollDivRef.current.scrollTop;
        previousHeightRef.current = chatScrollDivRef.current.scrollHeight;
    }, [newMessages]);
    React.useEffect(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        chatScrollDivRef.current.scrollTop = chatScrollDivRef.current.scrollHeight - (previousHeightRef.current - previousTopRef.current);
    }, [messages]);
    // Fetch more messages to make the scroll bar appear, infinity scroll is then handled in the handleScroll function.
    React.useEffect(() => {
        fetchNewMessageWhenAtTop();
    }, [fetchNewMessageWhenAtTop]);
    /**
     * One time run useEffects. Sets up listeners when component is mounted and tears down listeners when component
     * unmounts unless these function changed
     */
    React.useEffect(() => {
        window && window.addEventListener('click', sendMessageStatusIfAtBottom);
        window && window.addEventListener('focus', sendMessageStatusIfAtBottom);
        return () => {
            window && window.removeEventListener('click', sendMessageStatusIfAtBottom);
            window && window.removeEventListener('focus', sendMessageStatusIfAtBottom);
        };
    }, [sendMessageStatusIfAtBottom]);
    React.useEffect(() => {
        const chatScrollDiv = chatScrollDivRef.current;
        chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.addEventListener('scroll', handleScrollToTheBottom);
        chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.addEventListener('scroll', fetchNewMessageWhenAtTop);
        return () => {
            chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.removeEventListener('scroll', handleScrollToTheBottom);
            chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.removeEventListener('scroll', fetchNewMessageWhenAtTop);
        };
    }, [fetchNewMessageWhenAtTop, handleScrollToTheBottom]);
    React.useEffect(() => {
        if (clientHeight === undefined) {
            setForceUpdate(forceUpdate + 1);
            return;
        }
        // Only scroll to bottom if isAtBottomOfScrollRef is true
        isAtBottomOfScrollRef.current && scrollToBottom();
    }, [clientHeight, forceUpdate, scrollToBottom, chatMessagesInitialized]);
    React.useEffect(() => {
        var _a;
        const newStatus = (_a = getLastChatMessageForCurrentUser(newMessages)) === null || _a === void 0 ? void 0 : _a.status;
        if (newStatus !== undefined) {
            if (lastChatMessageStatus.current === 'deleted' && newStatus === 'sending') {
                // enforce message life cycle
                // message status should always be [ sending -> delivered -> seen (optional) -> deleted ] or [sending -> failed -> deleted]
                // not any other way around
                // therefore, if current message status is deleted, we should only update it if newStatus is sending
                lastChatMessageStatus.current = newStatus;
            }
            else if (lastChatMessageStatus.current !== 'deleted') {
                lastChatMessageStatus.current = newStatus;
            }
        }
        // The hook should depend on newMessages not on messages as otherwise it will skip the sending status for a first message
    }, [newMessages]);
    /**
     * This needs to run to update latestPreviousChatMessage & latestCurrentChatMessage.
     * These two states are used to manipulate scrollbar
     */
    React.useEffect(() => {
        setLatestPreviousChatMessage(getLatestChatMessage(messagesRef.current));
        setLatestCurrentChatMessage(getLatestChatMessage(newMessages));
        setMessagesRef(newMessages);
        !chatMessagesInitializedRef.current && setChatMessagesInitializedRef(true);
        setLastDeliveredChatMessage(getLastChatMessageIdWithStatus(newMessages, 'delivered'));
        setLastSeenChatMessage(getLastChatMessageIdWithStatus(newMessages, 'seen'));
        setLastSendingChatMessage(getLastChatMessageIdWithStatus(newMessages, 'sending'));
    }, [newMessages]);
    /**
     * This needs to run after messages are rendered so we can manipulate the scroll bar.
     */
    React.useEffect(() => {
        // If user just sent the latest message then we assume we can move user to bottom of scroll.
        if (isThereNewMessageNotFromCurrentUser(userId, latestPreviousChatMessage, latestCurrentChatMessage) && !isAtBottomOfScrollRef.current) {
            setExistsNewChatMessage(true);
        }
        else if (didUserSendTheLatestMessage(userId, latestPreviousChatMessage, latestCurrentChatMessage) || isAtBottomOfScrollRef.current) {
            scrollToBottom();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [messages]);
    const lastChatMessageStatus = React.useRef(undefined);
    const participantCountRef = React.useRef(participantCount);
    const readReceiptsBySenderIdRef = React.useRef(readReceiptsBySenderId);
    participantCountRef.current = participantCount;
    readReceiptsBySenderIdRef.current = readReceiptsBySenderId;
    const onActionButtonClickMemo = React.useCallback((message, setMessageReadBy) => {
        if (participantCountRef.current && participantCountRef.current - 1 > 1 && readReceiptsBySenderIdRef.current) {
            setMessageReadBy(getParticipantsWhoHaveReadMessage(message, readReceiptsBySenderIdRef.current));
        }
    }, []);
    const defaultStatusRenderer = React.useCallback((message, participantCount, readCount, status) => {
        // we should only announce label if the message status isn't deleted
        // because after message is deleted, we now need to render statusIndicator for previous messages
        // and their status has been announced already and we should not announce them again
        const shouldAnnounce = lastChatMessageStatus.current !== 'deleted';
        const onToggleToolTip = (isToggled) => {
            if (isToggled && readReceiptsBySenderIdRef.current) {
                setReadCountForHoveredIndicator(getParticipantsWhoHaveReadMessage(message, readReceiptsBySenderIdRef.current).length);
            }
            else {
                setReadCountForHoveredIndicator(undefined);
            }
        };
        return React.createElement(MessageStatusIndicatorInternal, { status: status, readCount: readCount, onToggleToolTip: onToggleToolTip, 
            // -1 because participant count does not include myself
            remoteParticipantsCount: participantCount ? participantCount - 1 : 0, shouldAnnounce: shouldAnnounce });
    }, []);
    const theme = useTheme();
    const messagesToDisplay = React.useMemo(() => {
        return memoizeAllMessages(memoizedMessageFn => {
            return messages.map((message, index) => {
                return memoizedMessageFn(message, showMessageDate, showMessageStatus, strings, index, onUpdateMessage, onCancelEditMessage, onDeleteMessageCallback, onSendMessage, props.disableEditing, lastDeliveredChatMessage, lastSeenChatMessage, lastSendingChatMessage);
            });
        });
    }, [lastDeliveredChatMessage, lastSeenChatMessage, lastSendingChatMessage, messages, onCancelEditMessage, onDeleteMessageCallback, onSendMessage, onUpdateMessage, props.disableEditing, showMessageDate, showMessageStatus, strings]);
    const classes = useChatStyles();
    return React.createElement("div", { className: react.mergeStyles(messageThreadWrapperContainerStyle), ref: chatThreadRef },
        existsNewChatMessage && !disableJumpToNewMessageButton && React.createElement("div", { className: react.mergeStyles(newMessageButtonContainerStyle, styles === null || styles === void 0 ? void 0 : styles.newMessageButtonContainer) }, onRenderJumpToNewMessageButton ? onRenderJumpToNewMessageButton({
            text: strings.newMessagesIndicator,
            onClick: scrollToBottom
        }) : React.createElement(DefaultJumpToNewMessageButton, { text: strings.newMessagesIndicator, onClick: scrollToBottom })),
        React.createElement(LiveAnnouncer, null,
            React.createElement(FluentV9ThemeProvider, { v8Theme: theme },
                latestDeletedMessageId && React.createElement(Announcer, { key: latestDeletedMessageId, announcementString: deletedMessageAriaLabel, ariaLive: 'assertive' }),
                React.createElement(reactChat.Chat
                // styles?.chatContainer used in className and style prop as style prop can't handle CSS selectors
                , { 
                    // styles?.chatContainer used in className and style prop as style prop can't handle CSS selectors
                    className: reactComponents.mergeClasses(classes.root, react.mergeStyles(styles === null || styles === void 0 ? void 0 : styles.chatContainer)), ref: chatScrollDivRef, style: Object.assign({}, createStyleFromV8Style(styles === null || styles === void 0 ? void 0 : styles.chatContainer)) }, messagesToDisplay.map((message) => {
                    return React.createElement(MemoChatMessageComponentWrapper, Object.assign({}, message, { userId: userId, key: message.key, styles: styles, shouldOverlapAvatarAndMessage: isNarrow, strings: strings, onRenderAvatar: onRenderAvatar, onRenderMessage: onRenderMessage, onRenderMessageStatus: onRenderMessageStatus, defaultStatusRenderer: defaultStatusRenderer, onActionButtonClick: onActionButtonClickMemo, readCount: readCountForHoveredIndicator, participantCount: participantCount, inlineImageOptions: inlineImageOptions }));
                })))));
};
const MemoChatMessageComponentWrapper = React.memo((obj) => {
    return React.createElement(ChatMessageComponentWrapper, Object.assign({}, obj));
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const container = () => react.mergeStyles({
    position: 'relative',
    // ensures child element's `position: absolute` is relative to this container
    display: 'contents'
});
/**
 * @private
 */
const loadingSpinnerContainer = () => react.mergeStyles({
    // Position centrally on top of content. Parent must have position: relative.
    position: 'absolute',
    top: '50%',
    bottom: '0',
    left: '50%',
    right: '0',
    transform: 'translate(-50%, -50%)'
});
/**
 * @private
 */
const loadSpinnerStyles = {
    root: {
        height: '100%' // ensure height fills container
    },
    circle: {
        maxHeight: '5rem',
        height: '50%',
        width: 'unset',
        // remove default width applied by fluent for spinners
        aspectRatio: '1 / 1',
        // make height match width to ensure a circle shape
        borderWidth: '0.25em'
    }
};
/**
 * @private
 */
const mediaContainer = (theme) => react.mergeStyles({
    position: 'relative',
    height: '100%',
    width: '100%',
    background: 'transparent',
    display: 'flex',
    '& video': {
        borderRadius: theme.effects.roundedCorner4
    }
});
/**
 * @private
 */
const invertedVideoInPipStyle = (theme) => react.mergeStyles(mediaContainer(theme), {
    // The HTMLElement returned by the headless SDK is already inverted.
    // But in picture-in-picture mode, we do not want to invert the host HTMLElement.
    // Instead, we need to target the :picture-in-picture pseudoclass.
    //
    // First reset the host HTMLElement.
    transform: 'rotateY(180deg)',
    // This doesn't work yet on latest Edge.
    // Probably just not implemented yet.
    // picture-in-picture API is not yet stable: https://www.w3.org/TR/picture-in-picture/#css-pseudo-class
    '& video:picture-in-picture': {
        transform: 'rotateY(180deg)'
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Utility component to convert an HTMLElement with a video stream into a JSX element.
 *
 * Use to convert an HTMLElement returned by headless calling API into a component that can be rendered as a {@link VideoTile}.
 *
 * @public
 */
const StreamMedia = (props) => {
    const containerEl = React.useRef(null);
    const theme = useTheme();
    const { isMirrored, videoStreamElement, styles, loadingState = 'none' } = props;
    const [pipEnabled, setPipEnabled] = React.useState(false);
    React.useEffect(() => {
        const container = containerEl.current;
        if (!container) {
            return;
        }
        // If videoStreamElement changes, we clear the container to make sure we don't have duplicate, and replace it with
        // the new videoStreamElement. If videoStreamElement is undefined nothing is appended and container should be empty
        // and we don't render anyting.
        container.innerHTML = '';
        setPipEnabled(false);
        if (videoStreamElement) {
            videoStreamElement.addEventListener('enterpictureinpicture', () => {
                setPipEnabled(true);
            });
            videoStreamElement.addEventListener('leavepictureinpicture', () => {
                setPipEnabled(false);
            });
            container.appendChild(videoStreamElement);
        }
        return () => {
            container.innerHTML = '';
            setPipEnabled(false);
        };
    }, [videoStreamElement]);
    return React.createElement("div", { className: container() },
        React.createElement("div", { "data-ui-id": "stream-media-container", className: react.mergeStyles(isMirrored && pipEnabled ? invertedVideoInPipStyle(theme) : mediaContainer(theme), styles === null || styles === void 0 ? void 0 : styles.root), ref: containerEl }),
        loadingState === 'loading' && React.createElement("div", { className: loadingSpinnerContainer() },
            React.createElement(react.Spinner, { "data-ui-id": "stream-media-loading-spinner", styles: loadSpinnerStyles })));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const participantItemContainerStyle = (options) => {
    return {
        paddingTop: '0.25rem',
        paddingBottom: '0.25rem',
        display: 'flex',
        maxWidth: '100%',
        minWidth: '8rem',
        cursor: options.localparticipant || !options.clickable ? 'default' : 'pointer',
        alignItems: 'center'
    };
};
/**
 * @private
 */
const menuButtonContainerStyle = {
    width: '1.5rem'
};
/**
 * @private
 */
const participantStateMaxWidth = '5rem';
/**
 * @private
 */
const participantStateStringStyles = {
    maxWidth: participantStateMaxWidth,
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    lineHeight: 'normal',
    marginLeft: '0.5rem',
    marginRight: 0
};
/**
 * @private
 */
const iconContainerStyle$1 = {
    display: 'flex',
    alignItems: 'center',
    height: '100%',
    paddingTop: '0.2rem'
};
/**
 * @private
 */
const iconStyles$2 = react.mergeStyles({
    display: 'flex',
    lineHeight: 0,
    // ensure the icon center is on the center line and not slightly above it
    alignItems: 'center'
});
/**
 * @private
 */
const meContainerStyle = {
    paddingRight: '0.5rem'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Component to render a calling or chat participant.
 *
 * Displays the participant's avatar, displayName and status as well as optional icons and context menu.
 *
 * @public
 */
const ParticipantItem = (props) => {
    const { userId, displayName, onRenderAvatar, menuItems, onRenderIcon, presence, styles, me, onClick, showParticipantOverflowTooltip } = props;
    const [itemHovered, setItemHovered] = React.useState(false);
    const [itemFocused, setItemFocused] = React.useState(false);
    const [menuHidden, setMenuHidden] = React.useState(true);
    const containerRef = React.useRef(null);
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.participantItem;
    const ids = useIdentifiers();
    const uniqueId = reactHooks.useId();
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    // For 'me' show empty name so avatar will get 'Person' icon, when there is no name
    const meAvatarText = (displayName === null || displayName === void 0 ? void 0 : displayName.trim()) || '';
    const avatarOptions = {
        text: me ? meAvatarText : (displayName === null || displayName === void 0 ? void 0 : displayName.trim()) || strings.displayNamePlaceholder,
        size: react.PersonaSize.size32,
        presence: presence,
        initialsTextColor: 'white',
        showOverflowTooltip: showParticipantOverflowTooltip,
        showUnknownPersonaCoin: !me && (!(displayName === null || displayName === void 0 ? void 0 : displayName.trim()) || displayName === strings.displayNamePlaceholder)
    };
    const avatar = onRenderAvatar ? onRenderAvatar(userId !== null && userId !== void 0 ? userId : '', avatarOptions) : React.createElement(react.Persona, Object.assign({ className: react.mergeStyles({
            // Prevents persona text from being vertically truncated if a global line height is less than 1.15.
            lineHeight: '1.15rem'
        }, styles === null || styles === void 0 ? void 0 : styles.avatar) }, avatarOptions));
    const meTextStyle = React.useMemo(() => react.mergeStyles(meContainerStyle, {
        color: theme.palette.neutralSecondary
    }, styles === null || styles === void 0 ? void 0 : styles.me), [theme.palette.neutralSecondary, styles === null || styles === void 0 ? void 0 : styles.me]);
    const contextualMenuStyle = React.useMemo(() => react.mergeStyles({
        background: theme.palette.neutralLighterAlt
    }, styles === null || styles === void 0 ? void 0 : styles.menu), [theme.palette.neutralLighterAlt, styles === null || styles === void 0 ? void 0 : styles.menu]);
    const infoContainerStyle = React.useMemo(() => react.mergeStyles(iconContainerStyle$1, {
        color: theme.palette.neutralTertiary,
        marginLeft: 'auto'
    }, styles === null || styles === void 0 ? void 0 : styles.iconContainer), [theme.palette.neutralTertiary, styles === null || styles === void 0 ? void 0 : styles.iconContainer]);
    const onDismissMenu = () => {
        setItemHovered(false);
        setItemFocused(false);
        setMenuHidden(true);
    };
    const menuButton = React.useMemo(() => React.createElement(react.Stack, { horizontal: true, horizontalAlign: "end", className: react.mergeStyles(menuButtonContainerStyle), title: strings.menuTitle, "data-ui-id": ids.participantItemMenuButton },
        React.createElement(react.Icon, { iconName: itemHovered || itemFocused || !menuHidden ? 'ParticipantItemOptionsHovered' : 'ParticipantItemOptions', className: iconStyles$2 })), [strings.menuTitle, ids.participantItemMenuButton, itemHovered, itemFocused, menuHidden]);
    const participantStateString = participantStateStringTrampoline$1();
    return React.createElement("div", { ref: containerRef, role: 'menuitem', "data-is-focusable": true, "data-ui-id": "participant-item", className: react.mergeStyles(participantItemContainerStyle({
            localparticipant: me,
            clickable: !!menuItems && menuItems.length > 0
        }), styles === null || styles === void 0 ? void 0 : styles.root), onMouseEnter: () => setItemHovered(true), onMouseLeave: () => setItemHovered(false), onFocus: () => setItemFocused(true), onBlur: () => setItemFocused(false), onClick: () => {
            {
                setItemHovered(true);
                setItemFocused(false);
                setMenuHidden(false);
                onClick === null || onClick === void 0 ? void 0 : onClick(props);
            }
            if (!menuHidden) {
                onDismissMenu();
            }
        }, tabIndex: 0 },
        React.createElement(react.Stack, { horizontal: true, className: react.mergeStyles({
                width: `calc(100% - ${!me && participantStateString ? participantStateMaxWidth : menuButtonContainerStyle.width})`,
                alignItems: 'center'
            }), id: uniqueId, "aria-labelledby": `${props.ariaLabelledBy} ${uniqueId}` },
            avatar,
            me && React.createElement(react.Text, { className: meTextStyle }, strings.isMeText),
            React.createElement(react.Stack, { horizontal: true, className: react.mergeStyles(infoContainerStyle) }, onRenderIcon && onRenderIcon(props))),
        !me && participantStateString ? React.createElement(react.Text, { "data-ui-id": "participant-item-state-string", className: react.mergeStyles(participantStateStringStyles) }, participantStateString) : React.createElement("div", null, menuItems && menuItems.length > 0 && React.createElement(React.Fragment, null,
            menuButton,
            React.createElement(react.ContextualMenu, { items: menuItems, hidden: menuHidden, target: containerRef, onItemClick: onDismissMenu, onDismiss: onDismissMenu, directionalHint: react.DirectionalHint.bottomRightEdge, className: contextualMenuStyle, calloutProps: {
                    preventDismissOnEvent: _preventDismissOnEvent
                } }))));
};
const participantStateStringTrampoline$1 = (props, strings) => {
    return undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(raise-hand) */
/* @conditional-compile-remove(raise-hand) */
/**
 * Raised hand icon for ParticipantList and VideoTitle.
 *
 * @public
 */
const RaisedHandIcon = () => {
    return React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        React.createElement("defs", null,
            React.createElement("radialGradient", { id: "paint0_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(16.6796 10.8658) rotate(161.935) scale(13.4702 20.3408)" },
                React.createElement("stop", { offset: "0.817521", stopColor: "#E99329", stopOpacity: "0" }),
                React.createElement("stop", { offset: "0.961397", stopColor: "#E99329" })),
            React.createElement("radialGradient", { id: "paint1_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(11.7464 4.86265) rotate(103.662) scale(15.5522 10.8511)" },
                React.createElement("stop", { offset: "0.750766", stopColor: "#F88456", stopOpacity: "0" }),
                React.createElement("stop", { offset: "1", stopColor: "#F88456" })),
            React.createElement("radialGradient", { id: "paint2_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(10.8862 4.86067) rotate(98.3094) scale(14.3189 9.99881)" },
                React.createElement("stop", { offset: "0.937186", stopColor: "#F27A74", stopOpacity: "0" }),
                React.createElement("stop", { offset: "1", stopColor: "#F27A74" })),
            React.createElement("radialGradient", { id: "paint3_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(17.3363 11.238) rotate(-144.906) scale(1.08553 4.6268)" },
                React.createElement("stop", { offset: "0.0636767", stopColor: "#EAB170" }),
                React.createElement("stop", { offset: "1", stopColor: "#F6B44B", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint4_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(17.1484 8.75) rotate(129.452) scale(4.85649 1.57945)" },
                React.createElement("stop", { stopColor: "#FFC748" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFC64A", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint5_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(17.6953 8.75) rotate(135) scale(1.1601 1.07723)" },
                React.createElement("stop", { stopColor: "#FFE964" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFE65F", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint6_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(15.7422 8.47656) rotate(128.853) scale(3.61154 0.774997)" },
                React.createElement("stop", { offset: "0.251132", stopColor: "#EDB019" }),
                React.createElement("stop", { offset: "1", stopColor: "#EEB018", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint7_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(15.6055 8.04687) rotate(125.92) scale(3.06292 0.505665)" },
                React.createElement("stop", { offset: "0.0171863", stopColor: "#D29E4C" }),
                React.createElement("stop", { offset: "1", stopColor: "#DAA23E", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint8_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(14.2578 9.47266) rotate(-56.3099) scale(1.05631 0.227513)" },
                React.createElement("stop", { offset: "0.297381", stopColor: "#FFD260" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFD361", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint9_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(12.4609 9.62891) rotate(107.216) scale(1.45176 3.15212)" },
                React.createElement("stop", { offset: "0.251132", stopColor: "#FFCF48" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFD04B", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint10_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(12.3242 9.02344) rotate(144.638) scale(0.742444 1.38192)" },
                React.createElement("stop", { offset: "0.420068", stopColor: "#F2AA23" }),
                React.createElement("stop", { offset: "1", stopColor: "#F2AA23", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint11_linear_10246_159312", x1: "5.72266", y1: "10.9399", x2: "5.07979", y2: "9.68081", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { offset: "0.376446", stopColor: "#FFC23E" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFC23E", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint12_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(3.32031 8.28125) rotate(85.0032) scale(7.17571 2.51091)" },
                React.createElement("stop", { stopColor: "#E6943A" }),
                React.createElement("stop", { offset: "1", stopColor: "#E7943A", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint13_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(5.46875 6.17188) rotate(87.0391) scale(6.80596 1.61557)" },
                React.createElement("stop", { stopColor: "#FFCF50" }),
                React.createElement("stop", { offset: "0.741378", stopColor: "#FFB847" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFB848", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint14_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(6.69922 6.95312) rotate(85.2393) scale(4.00062 0.583904)" },
                React.createElement("stop", { stopColor: "#E79F08" }),
                React.createElement("stop", { offset: "1", stopColor: "#E79F08", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint15_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(5.82031 7.76306) rotate(83.1071) scale(3.90579 0.814298)" },
                React.createElement("stop", { stopColor: "#FFD14D" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFD04E", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint16_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(6.69922 9.17969) rotate(136.548) scale(1.53355 0.783563)" },
                React.createElement("stop", { offset: "0.426346", stopColor: "#FFD260" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFD361", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint17_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(5.46875 5.48828) rotate(80.3401) scale(0.931172 0.709009)" },
                React.createElement("stop", { stopColor: "#FFDA62" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFDA60", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint18_linear_10246_159312", x1: "6.05957", y1: "7.05618", x2: "7.26562", y2: "7.03125", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { stopColor: "#DE890D" }),
                React.createElement("stop", { offset: "1", stopColor: "#F9B23D" })),
            React.createElement("linearGradient", { id: "paint19_linear_10246_159312", x1: "11.7919", y1: "10.3872", x2: "11.5711", y2: "7.83625", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { offset: "0.405208", stopColor: "#FFC23E" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFC23E", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint20_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.90363 2.31009) rotate(56.3221) scale(2.85335 11.4486)" },
                React.createElement("stop", { stopColor: "#E1AE3F" }),
                React.createElement("stop", { offset: "1", stopColor: "#E8AD3C", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint21_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(8.35938 5.19531) rotate(86.2538) scale(6.57655 1.44733)" },
                React.createElement("stop", { stopColor: "#FFCE4C" }),
                React.createElement("stop", { offset: "0.621882", stopColor: "#FFBA49" }),
                React.createElement("stop", { offset: "1", stopColor: "#FEB848", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint22_linear_10246_159312", x1: "8.0957", y1: "9.0918", x2: "7.91992", y2: "7.06055", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { offset: "0.168836", stopColor: "#FFC23E" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFC23E", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint23_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(5.82031 5.97656) rotate(78.518) scale(5.10211 0.93429)" },
                React.createElement("stop", { offset: "0.425088", stopColor: "#BD6606" }),
                React.createElement("stop", { offset: "1", stopColor: "#C77122", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint24_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(8.24219 5.89844) rotate(83.5653) scale(5.22825 0.629818)" },
                React.createElement("stop", { stopColor: "#FFCB4F" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFCD4C", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint25_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.29687 8.20313) rotate(154.799) scale(1.46784 0.851345)" },
                React.createElement("stop", { offset: "0.426346", stopColor: "#FFD260" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFD361", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint26_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.33594 4.98047) rotate(88.915) scale(5.15717 0.762321)" },
                React.createElement("stop", { offset: "0.342657", stopColor: "#E29E07" }),
                React.createElement("stop", { offset: "1", stopColor: "#DF9906", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint27_linear_10246_159312", x1: "9.14062", y1: "6.25", x2: "8.80978", y2: "6.26984", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { stopColor: "#B76001" }),
                React.createElement("stop", { offset: "0.647059", stopColor: "#E59714", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint28_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(8.125 3.51562) rotate(86.1859) scale(1.17448 1.07205)" },
                React.createElement("stop", { stopColor: "#FFDA62" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFDA60", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint29_linear_10246_159312", x1: "9.0625", y1: "5.68143", x2: "10.5816", y2: "5.72531", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { stopColor: "#D5850A" }),
                React.createElement("stop", { offset: "1", stopColor: "#F9B343", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint30_linear_10246_159312", x1: "9.0625", y1: "5.68143", x2: "9.55093", y2: "5.6712", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { stopColor: "#B76001" }),
                React.createElement("stop", { offset: "1", stopColor: "#E59714", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint31_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(11.3014 4.55861) rotate(90) scale(5.01272 0.983716)" },
                React.createElement("stop", { stopColor: "#FFCB45" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFC44A", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint32_linear_10246_159312", x1: "10.0391", y1: "8.40332", x2: "10.0195", y2: "7.2461", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { offset: "0.210964", stopColor: "#FFC23E" }),
                React.createElement("stop", { offset: "0.80669", stopColor: "#FFC23E", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint33_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(11.7188 8.04687) rotate(166.996) scale(1.16638 0.888873)" },
                React.createElement("stop", { offset: "0.426346", stopColor: "#FFCA5B" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFCF60", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint34_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(11.9922 4.76563) rotate(92.1409) scale(4.18261 0.38546)" },
                React.createElement("stop", { offset: "0.342657", stopColor: "#E29E07" }),
                React.createElement("stop", { offset: "1", stopColor: "#DF9906", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint35_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(10.9766 4.51172) rotate(90) scale(9.27734 1.28906)" },
                React.createElement("stop", { stopColor: "#FFCE4C" }),
                React.createElement("stop", { offset: "0.621882", stopColor: "#FFBA49" }),
                React.createElement("stop", { offset: "1", stopColor: "#FEB848", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint36_linear_10246_159312", x1: "12.3828", y1: "5.9375", x2: "11.6797", y2: "5.93971", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { stopColor: "#E59714" }),
                React.createElement("stop", { offset: "1", stopColor: "#E59714", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint37_linear_10246_159312", x1: "10.0195", y1: "8.82935", x2: "10.2318", y2: "8.00715", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { stopColor: "#FFC23E" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFC23E", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint38_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(12.2847 7.66848) rotate(-113.448) scale(6.85723 7.32906)" },
                React.createElement("stop", { offset: "0.869582", stopColor: "#D8A13D", stopOpacity: "0" }),
                React.createElement("stop", { offset: "1", stopColor: "#D8A13D" })),
            React.createElement("radialGradient", { id: "paint39_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(11.2891 1.91406) rotate(93.0128) scale(1.48643 1.29895)" },
                React.createElement("stop", { stopColor: "#FFE763" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFE55D", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint40_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(11.8164 8.53516) rotate(168.022) scale(1.41758 0.903842)" },
                React.createElement("stop", { offset: "0.426346", stopColor: "#FFD260" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFD361", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint41_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(13.4766 5.89844) rotate(92.6574) scale(9.26778 2.30713)" },
                React.createElement("stop", { stopColor: "#FFCE4C" }),
                React.createElement("stop", { offset: "0.431711", stopColor: "#FFBA49" }),
                React.createElement("stop", { offset: "1", stopColor: "#FEB848", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint42_linear_10246_159312", x1: "11.5863", y1: "6.2696", x2: "13.5726", y2: "6.42645", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { offset: "0.0662431", stopColor: "#E08F13" }),
                React.createElement("stop", { offset: "0.602743", stopColor: "#E7981B", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint43_linear_10246_159312", x1: "11.5863", y1: "6.2696", x2: "13.259", y2: "6.33379", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { offset: "0.0662431", stopColor: "#C2681D" }),
                React.createElement("stop", { offset: "0.602743", stopColor: "#E69717", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint44_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(14.9907 8.54439) rotate(-115.482) scale(6.44971 7.3339)" },
                React.createElement("stop", { offset: "0.869582", stopColor: "#D8A13D", stopOpacity: "0" }),
                React.createElement("stop", { offset: "1", stopColor: "#D8A13D" })),
            React.createElement("radialGradient", { id: "paint45_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(14.0625 5.66406) rotate(91.8841) scale(5.94071 1.40501)" },
                React.createElement("stop", { stopColor: "#FFDC3F" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFDA3C", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint46_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(14.1016 3.51563) rotate(99.1412) scale(1.27667 1.12346)" },
                React.createElement("stop", { stopColor: "#FFE966" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFE966", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint47_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(11.7139 8.84766) rotate(124.509) scale(0.853264 2.02461)" },
                React.createElement("stop", { offset: "0.251132", stopColor: "#F0A623" }),
                React.createElement("stop", { offset: "1", stopColor: "#F2AA23", stopOpacity: "0" })),
            React.createElement("linearGradient", { id: "paint48_linear_10246_159312", x1: "13.877", y1: "10.0293", x2: "13.5547", y2: "9.05273", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { offset: "0.0912498", stopColor: "#FFCD47" }),
                React.createElement("stop", { offset: "1", stopColor: "#FFCD52", stopOpacity: "0" })),
            React.createElement("radialGradient", { id: "paint49_radial_10246_159312", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(14.8059 9.14063) rotate(99.1613) scale(2.21576 0.860587)" },
                React.createElement("stop", { offset: "0.251132", stopColor: "#D69211" }),
                React.createElement("stop", { offset: "1", stopColor: "#DAA23E", stopOpacity: "0" }))),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "#FFC23E" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint0_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint1_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint2_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint3_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint4_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint5_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint6_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint7_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint8_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint9_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4435 1.23817C11.6481 1.06813 12.2265 2.26542 12.08 3.30216C12.3425 2.83259 12.7902 2.56116 13.3593 2.57808C14.1793 2.60246 14.83 3.32606 14.8046 4.15738L14.5986 9.26659L15.4927 8.14205C16.0297 7.46657 17.0049 7.3596 17.6721 7.90298C18.3408 8.44763 18.4466 9.43906 17.9083 10.1161L17.5242 10.5991L17.5205 10.6047C17.1674 11.0632 16.4446 12.0018 15.5377 13.5195C15.2451 13.9644 14.991 14.4396 14.7373 14.9139C14.3755 15.5904 14.0146 16.2651 13.5446 16.8478C12.6103 18.0157 11.2012 18.7207 9.41406 18.7207C7.46969 18.7207 5.96858 17.7407 5.06836 16.2598C4.39645 15.1544 4.09135 13.756 4.01367 12.3535C3.90459 10.384 3.64472 8.30425 3.52479 6.33789C3.46522 5.36133 4.03401 4.62819 4.82415 4.58984C5.43983 4.55997 5.83432 4.75144 6.11318 5.06836C6.11318 5.06836 6.05957 4.77051 6.05957 4.15738C6.05957 3.54425 6.58827 2.73728 7.41201 2.67578C8.7206 2.57808 8.93545 3.65234 9.0624 4.15738C9.08953 3.10816 8.83779 1.46464 10.4435 1.23817Z", fill: "url(#paint10_radial_10246_159312)" }),
        React.createElement("path", { d: "M3.52479 6.33728C3.46522 5.36072 4.03401 4.62758 4.82415 4.58924C5.43983 4.55936 5.83432 4.75084 6.11318 5.06775C6.20599 5.20142 6.40332 5.6084 6.4502 6.16699C6.49707 6.72559 6.63574 8.10547 6.69922 8.72559C6.66584 9.373 6.06222 10.7221 3.91477 10.9394C3.78945 9.4056 3.61634 7.8384 3.52479 6.33728Z", fill: "#FFC23E" }),
        React.createElement("path", { d: "M3.52479 6.33728C3.46522 5.36072 4.03401 4.62758 4.82415 4.58924C5.43983 4.55936 5.83432 4.75084 6.11318 5.06775C6.20599 5.20142 6.40332 5.6084 6.4502 6.16699C6.49707 6.72559 6.63574 8.10547 6.69922 8.72559C6.66584 9.373 6.06222 10.7221 3.91477 10.9394C3.78945 9.4056 3.61634 7.8384 3.52479 6.33728Z", fill: "url(#paint11_linear_10246_159312)" }),
        React.createElement("path", { d: "M3.52479 6.33728C3.46522 5.36072 4.03401 4.62758 4.82415 4.58924C5.43983 4.55936 5.83432 4.75084 6.11318 5.06775C6.20599 5.20142 6.40332 5.6084 6.4502 6.16699C6.49707 6.72559 6.63574 8.10547 6.69922 8.72559C6.66584 9.373 6.06222 10.7221 3.91477 10.9394C3.78945 9.4056 3.61634 7.8384 3.52479 6.33728Z", fill: "url(#paint12_radial_10246_159312)" }),
        React.createElement("path", { d: "M3.52479 6.33728C3.46522 5.36072 4.03401 4.62758 4.82415 4.58924C5.43983 4.55936 5.83432 4.75084 6.11318 5.06775C6.20599 5.20142 6.40332 5.6084 6.4502 6.16699C6.49707 6.72559 6.63574 8.10547 6.69922 8.72559C6.66584 9.373 6.06222 10.7221 3.91477 10.9394C3.78945 9.4056 3.61634 7.8384 3.52479 6.33728Z", fill: "url(#paint13_radial_10246_159312)" }),
        React.createElement("path", { d: "M3.52479 6.33728C3.46522 5.36072 4.03401 4.62758 4.82415 4.58924C5.43983 4.55936 5.83432 4.75084 6.11318 5.06775C6.20599 5.20142 6.40332 5.6084 6.4502 6.16699C6.49707 6.72559 6.63574 8.10547 6.69922 8.72559C6.66584 9.373 6.06222 10.7221 3.91477 10.9394C3.78945 9.4056 3.61634 7.8384 3.52479 6.33728Z", fill: "url(#paint14_radial_10246_159312)" }),
        React.createElement("path", { d: "M3.52479 6.33728C3.46522 5.36072 4.03401 4.62758 4.82415 4.58924C5.43983 4.55936 5.83432 4.75084 6.11318 5.06775C6.20599 5.20142 6.40332 5.6084 6.4502 6.16699C6.49707 6.72559 6.63574 8.10547 6.69922 8.72559C6.66584 9.373 6.06222 10.7221 3.91477 10.9394C3.78945 9.4056 3.61634 7.8384 3.52479 6.33728Z", fill: "url(#paint15_radial_10246_159312)" }),
        React.createElement("path", { d: "M3.52479 6.33728C3.46522 5.36072 4.03401 4.62758 4.82415 4.58924C5.43983 4.55936 5.83432 4.75084 6.11318 5.06775C6.20599 5.20142 6.40332 5.6084 6.4502 6.16699C6.49707 6.72559 6.63574 8.10547 6.69922 8.72559C6.66584 9.373 6.06222 10.7221 3.91477 10.9394C3.78945 9.4056 3.61634 7.8384 3.52479 6.33728Z", fill: "url(#paint16_radial_10246_159312)" }),
        React.createElement("path", { d: "M3.52479 6.33728C3.46522 5.36072 4.03401 4.62758 4.82415 4.58924C5.43983 4.55936 5.83432 4.75084 6.11318 5.06775C6.20599 5.20142 6.40332 5.6084 6.4502 6.16699C6.49707 6.72559 6.63574 8.10547 6.69922 8.72559C6.66584 9.373 6.06222 10.7221 3.91477 10.9394C3.78945 9.4056 3.61634 7.8384 3.52479 6.33728Z", fill: "url(#paint17_radial_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "#FFC23E" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint18_linear_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint19_linear_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint20_radial_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint21_radial_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint22_linear_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint23_radial_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint24_radial_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint25_radial_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint26_radial_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint27_linear_10246_159312)" }),
        React.createElement("path", { d: "M6.11318 5.0685C6.11318 5.0685 6.05957 4.77065 6.05957 4.15752C6.05957 3.54439 6.58827 2.73742 7.41201 2.67592C8.7206 2.57821 8.93545 3.65248 9.0624 4.15752L9.19922 7.71484C9.08203 8.04036 8.67578 8.74219 7.98828 8.94531C7.30078 9.14844 6.82943 8.86068 6.67969 8.69141C6.60156 7.89062 6.4375 6.20312 6.40625 5.85938C6.375 5.51562 6.19785 5.18889 6.11318 5.0685Z", fill: "url(#paint28_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "#FFC23E" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint29_linear_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint30_linear_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint31_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint32_linear_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint33_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint34_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint35_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint36_linear_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint37_linear_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint38_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint39_radial_10246_159312)" }),
        React.createElement("path", { d: "M10.4437 1.23817C11.6483 1.06813 12.2267 2.26542 12.0802 3.30216C11.9943 3.45951 11.9337 3.79649 11.9141 3.94531L11.6992 8.10547C10.8008 9.25781 9.53125 8.96484 9.17969 7.71484L9.0626 4.15738C9.08973 3.10816 8.83799 1.46464 10.4437 1.23817Z", fill: "url(#paint40_radial_10246_159312)" }),
        React.createElement("path", { d: "M11.8994 4.15737C11.9482 2.8956 12.7903 2.56181 13.3594 2.57873C14.1794 2.60311 14.8301 3.32672 14.8047 4.15803L14.5987 8.92578C14.5501 9.1505 14.207 9.94531 13.2227 9.96094C12.2383 9.97656 11.8066 8.711 11.7139 8.07626L11.8994 4.15737Z", fill: "#FFC23E" }),
        React.createElement("path", { d: "M11.8994 4.15737C11.9482 2.8956 12.7903 2.56181 13.3594 2.57873C14.1794 2.60311 14.8301 3.32672 14.8047 4.15803L14.5987 8.92578C14.5501 9.1505 14.207 9.94531 13.2227 9.96094C12.2383 9.97656 11.8066 8.711 11.7139 8.07626L11.8994 4.15737Z", fill: "url(#paint41_radial_10246_159312)" }),
        React.createElement("path", { d: "M11.8994 4.15737C11.9482 2.8956 12.7903 2.56181 13.3594 2.57873C14.1794 2.60311 14.8301 3.32672 14.8047 4.15803L14.5987 8.92578C14.5501 9.1505 14.207 9.94531 13.2227 9.96094C12.2383 9.97656 11.8066 8.711 11.7139 8.07626L11.8994 4.15737Z", fill: "url(#paint42_linear_10246_159312)" }),
        React.createElement("path", { d: "M11.8994 4.15737C11.9482 2.8956 12.7903 2.56181 13.3594 2.57873C14.1794 2.60311 14.8301 3.32672 14.8047 4.15803L14.5987 8.92578C14.5501 9.1505 14.207 9.94531 13.2227 9.96094C12.2383 9.97656 11.8066 8.711 11.7139 8.07626L11.8994 4.15737Z", fill: "url(#paint43_linear_10246_159312)" }),
        React.createElement("path", { d: "M11.8994 4.15737C11.9482 2.8956 12.7903 2.56181 13.3594 2.57873C14.1794 2.60311 14.8301 3.32672 14.8047 4.15803L14.5987 8.92578C14.5501 9.1505 14.207 9.94531 13.2227 9.96094C12.2383 9.97656 11.8066 8.711 11.7139 8.07626L11.8994 4.15737Z", fill: "url(#paint44_radial_10246_159312)" }),
        React.createElement("path", { d: "M11.8994 4.15737C11.9482 2.8956 12.7903 2.56181 13.3594 2.57873C14.1794 2.60311 14.8301 3.32672 14.8047 4.15803L14.5987 8.92578C14.5501 9.1505 14.207 9.94531 13.2227 9.96094C12.2383 9.97656 11.8066 8.711 11.7139 8.07626L11.8994 4.15737Z", fill: "url(#paint45_radial_10246_159312)" }),
        React.createElement("path", { d: "M11.8994 4.15737C11.9482 2.8956 12.7903 2.56181 13.3594 2.57873C14.1794 2.60311 14.8301 3.32672 14.8047 4.15803L14.5987 8.92578C14.5501 9.1505 14.207 9.94531 13.2227 9.96094C12.2383 9.97656 11.8066 8.711 11.7139 8.07626L11.8994 4.15737Z", fill: "url(#paint46_radial_10246_159312)" }),
        React.createElement("path", { d: "M11.8994 4.15737C11.9482 2.8956 12.7903 2.56181 13.3594 2.57873C14.1794 2.60311 14.8301 3.32672 14.8047 4.15803L14.5987 8.92578C14.5501 9.1505 14.207 9.94531 13.2227 9.96094C12.2383 9.97656 11.8066 8.711 11.7139 8.07626L11.8994 4.15737Z", fill: "url(#paint47_radial_10246_159312)" }),
        React.createElement("path", { d: "M11.8994 4.15737C11.9482 2.8956 12.7903 2.56181 13.3594 2.57873C14.1794 2.60311 14.8301 3.32672 14.8047 4.15803L14.5987 8.92578C14.5501 9.1505 14.207 9.94531 13.2227 9.96094C12.2383 9.97656 11.8066 8.711 11.7139 8.07626L11.8994 4.15737Z", fill: "url(#paint48_linear_10246_159312)" }),
        React.createElement("path", { d: "M11.8994 4.15737C11.9482 2.8956 12.7903 2.56181 13.3594 2.57873C14.1794 2.60311 14.8301 3.32672 14.8047 4.15803L14.5987 8.92578C14.5501 9.1505 14.207 9.94531 13.2227 9.96094C12.2383 9.97656 11.8066 8.711 11.7139 8.07626L11.8994 4.15737Z", fill: "url(#paint49_radial_10246_159312)" }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const participantListStyle$1 = react.mergeStyles({
    height: '100%',
    padding: '0.125rem'
});
/**
 * @private
 */
const participantListItemStyle = {
    root: {
        paddingLeft: '1rem',
        paddingRight: '1rem',
        ':focus-visible': {
            margin: '0.125rem'
        }
    }
};
/**
 * @private
 */
const iconStyles$1 = react.mergeStyles({
    display: 'flex',
    lineHeight: 0,
    alignItems: 'center'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const onRenderParticipantDefault = (participant, strings, myUserId, onRenderAvatar, createParticipantMenuItems, styles, onParticipantClick, showParticipantOverflowTooltip, participantAriaLabelledBy, theme) => {
    const callingParticipant = participant;
    let presence = undefined;
    if (callingParticipant) {
        presence = react.PersonaPresence.none;
    }
    const menuItems = createParticipantMenuItems && createParticipantMenuItems(participant);
    let displayName = participant.displayName;
    /* @conditional-compile-remove(raise-hand) */
    const callingPalette = theme.callingPalette;
    const onRenderIcon = (callingParticipant === null || callingParticipant === void 0 ? void 0 : callingParticipant.isScreenSharing) || (callingParticipant === null || callingParticipant === void 0 ? void 0 : callingParticipant.isMuted) || /* @conditional-compile-remove(raise-hand) */ (callingParticipant === null || callingParticipant === void 0 ? void 0 : callingParticipant.raisedHand) ? () => {
        var _a;
        return React.createElement(react.Stack, { horizontal: true, tokens: {
                childrenGap: '0.5rem'
            } }, /* @conditional-compile-remove(raise-hand) */
            callingParticipant.raisedHand && React.createElement(react.Stack, { horizontal: true, tokens: {
                    childrenGap: '0.2rem'
                }, style: {
                    alignItems: 'center',
                    padding: '0.1rem 0.2rem',
                    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.palette.neutralLighter,
                    borderRadius: '0.3rem'
                } },
                callingParticipant.raisedHand.raisedHandOrderPosition && React.createElement(react.Stack.Item, null,
                    React.createElement(react.Text, null, (_a = callingParticipant.raisedHand) === null || _a === void 0 ? void 0 : _a.raisedHandOrderPosition)),
                React.createElement(react.Stack.Item, null,
                    React.createElement(RaisedHandIcon, null))),
            callingParticipant.isScreenSharing && React.createElement(react.Icon, { iconName: "ParticipantItemScreenShareStart", className: iconStyles$1, ariaLabel: strings.sharingIconLabel }),
            callingParticipant.isMuted && React.createElement(react.Icon, { iconName: "ParticipantItemMicOff", className: iconStyles$1, ariaLabel: strings.mutedIconLabel }));
    } : () => null;
    /* @conditional-compile-remove(raise-hand) */
    const onRenderAvatarWithRaiseHand = (callingParticipant === null || callingParticipant === void 0 ? void 0 : callingParticipant.raisedHand) && onRenderAvatar ? (userId, options, defaultOnRender) => onRenderAvatar(userId, Object.assign(Object.assign({}, options), { styles: {
            root: {
                border: callingPalette.raiseHandGold
            }
        } }), defaultOnRender) : onRenderAvatar;
    return React.createElement(ParticipantItem, { styles: styles, key: participant.userId, userId: participant.userId, displayName: displayName, me: myUserId ? participant.userId === myUserId : false, menuItems: menuItems, presence: presence, onRenderIcon: onRenderIcon, onRenderAvatar: onRenderAvatarWithRaiseHand, onClick: () => onParticipantClick === null || onParticipantClick === void 0 ? void 0 : onParticipantClick(participant), showParticipantOverflowTooltip: showParticipantOverflowTooltip, ariaLabelledBy: participantAriaLabelledBy });
};
/**
 * Sort participants by raised hand order position
 */
const sortParticipants = (participants) => {
    /* @conditional-compile-remove(raise-hand) */
    const isParticipantListCallParticipant = function (participant) {
        return 'raisedHand' in participant;
    };
    /* @conditional-compile-remove(raise-hand) */
    participants.sort((a, b) => {
        if (!isParticipantListCallParticipant(a) || !isParticipantListCallParticipant(b)) {
            return 0;
        }
        const callA = a;
        const callB = b;
        if (callA.raisedHand && callB.raisedHand) {
            return callA.raisedHand.raisedHandOrderPosition - callB.raisedHand.raisedHandOrderPosition;
        }
        else if (callA.raisedHand) {
            return -1;
        }
        else if (callB.raisedHand) {
            return 1;
        }
        return 0;
    });
    return participants;
};
const getParticipantsForDefaultRender = (participants, excludeMe, myUserId) => {
    if (!excludeMe || !myUserId) {
        return [...participants];
    }
    const userIndex = participants.map(p => p.userId).indexOf(myUserId);
    if (userIndex === -1) {
        return [...participants];
    }
    const remoteParticipants = [...participants];
    remoteParticipants.splice(userIndex, 1);
    return remoteParticipants;
};
/**
 * Component to render all calling or chat participants.
 *
 * By default, each participant is rendered with {@link ParticipantItem}. See {@link ParticipantListProps.onRenderParticipant} to override.
 *
 * @public
 */
const ParticipantList$k = (props) => {
    var _a, _b, _c, _d;
    const { excludeMe = false, myUserId, participants, onRemoveParticipant, onRenderAvatar, onRenderParticipant, onFetchParticipantMenuItems, showParticipantOverflowTooltip, participantAriaLabelledBy } = props;
    /* @conditional-compile-remove(raise-hand) */
    const theme = useTheme();
    const ids = useIdentifiers();
    const participantItemStrings = useLocale$1().strings.participantItem;
    const displayedParticipants = React.useMemo(() => {
        return onRenderParticipant ? participants : getParticipantsForDefaultRender(participants, excludeMe, myUserId);
    }, [participants, excludeMe, myUserId, onRenderParticipant]);
    sortParticipants(displayedParticipants);
    const createParticipantMenuItems = React.useCallback((participant) => {
        var _a, _b;
        let menuItems = [];
        const participantIsRemovable = participant.isRemovable;
        if (participant.userId !== myUserId && onRemoveParticipant && participantIsRemovable) {
            menuItems.push({
                key: 'remove',
                text: participantItemStrings.removeButtonLabel,
                onClick: () => onRemoveParticipant(participant.userId),
                itemProps: {
                    styles: (_b = (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles) === null || _b === void 0 ? void 0 : _b.participantSubMenuItemsStyles
                },
                'data-ui-id': ids.participantListRemoveParticipantButton
            });
        }
        if (onFetchParticipantMenuItems) {
            menuItems = onFetchParticipantMenuItems(participant.userId, myUserId, menuItems);
        }
        return menuItems;
    }, [ids.participantListRemoveParticipantButton, myUserId, onFetchParticipantMenuItems, onRemoveParticipant, (_b = (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles) === null || _b === void 0 ? void 0 : _b.participantSubMenuItemsStyles, /* @conditional-compile-remove(raise-hand) */ participantItemStrings.removeButtonLabel]);
    const participantItemStyles = React.useMemo(() => { var _a; return react.merge(participantListItemStyle, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles); }, [(_c = props.styles) === null || _c === void 0 ? void 0 : _c.participantItemStyles]);
    return React.createElement(react.Stack, { "data-ui-id": ids.participantList, className: react.mergeStyles(participantListStyle$1, (_d = props.styles) === null || _d === void 0 ? void 0 : _d.root), role: 'menu' }, displayedParticipants.map((participant) => onRenderParticipant ? onRenderParticipant(participant) : onRenderParticipantDefault(participant, participantItemStrings, myUserId, onRenderAvatar, createParticipantMenuItems, participantItemStyles, props.onParticipantClick, showParticipantOverflowTooltip, participantAriaLabelledBy, /* @conditional-compile-remove(raise-hand) */ theme)));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * For keyboard navigation - when this component has active focus, enter key and space keys should have the same behavior as mouse click.
 *
 * @private
 */
const submitWithKeyboard = (e, onSubmit) => {
    if (e.key === 'Enter' || e.key === ' ') {
        onSubmit(e);
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Maps the individual item in menuProps.items passed in the {@link DrawerMenu} into a UI component.
 *
 * @private
 */
const DrawerMenuItem = (props) => {
    var _a;
    const theme = useTheme();
    const onClick = (ev) => props.onItemClick && props.onItemClick(ev, props.itemKey);
    const onKeyPress = (ev) => onClick && submitWithKeyboard(ev, onClick);
    const secondaryIcon = props.secondaryIconProps ? React.createElement(MenuItemIcon, Object.assign({}, props.secondaryIconProps)) : props.subMenuProps ? React.createElement(MenuItemIcon, { iconName: "ChevronRight" }) : undefined;
    return React.createElement(react.FocusZone, { shouldFocusOnMount: props.shouldFocusOnMount },
        React.createElement(react.Stack, { tabIndex: 0, role: "menuitem", horizontal: true, className: react.mergeStyles(drawerMenuItemRootStyles(theme.palette.neutralLight, theme.fonts.small), props.disabled ? disabledDrawerMenuItemRootStyles(theme.palette.neutralQuaternaryAlt) : undefined, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root), onKeyPress: props.disabled ? undefined : onKeyPress, onClick: props.disabled ? undefined : onClick, tokens: menuItemChildrenGap, id: props.id },
            props.iconProps && React.createElement(react.Stack.Item, { role: "presentation", styles: props.disabled ? {
                    root: {
                        color: theme.palette.neutralTertiaryAlt
                    }
                } : undefined },
                React.createElement(MenuItemIcon, Object.assign({}, props.iconProps))),
            React.createElement(react.Stack.Item, { styles: drawerMenuItemTextStyles, grow: true },
                React.createElement(react.Text, { styles: props.disabled ? {
                        root: {
                            color: theme.palette.neutralTertiaryAlt
                        }
                    } : undefined }, props.text)),
            props.secondaryText && React.createElement(react.Stack.Item, { styles: drawerMenuItemTextStyles, className: react.mergeStyles(secondaryTextStyles) },
                React.createElement(react.Text, { styles: {
                        root: {
                            color: props.disabled ? theme.palette.neutralTertiaryAlt : theme.palette.neutralSecondary
                        }
                    } }, props.secondaryText)),
            props.secondaryComponent && React.createElement(react.Stack.Item, null, props.secondaryComponent),
            secondaryIcon && React.createElement(react.Stack.Item, null, secondaryIcon)));
};
const MenuItemIcon = (props) => React.createElement(react.FontIcon, Object.assign({ className: react.mergeStyles(iconStyles) }, props));
const menuItemChildrenGap = {
    childrenGap: '0.5rem'
};
const drawerMenuItemRootStyles = (hoverBackground, fontSize) => (Object.assign(Object.assign({}, fontSize), { height: '3rem', lineHeight: '3rem', padding: '0rem 0.75rem', cursor: 'pointer', ':hover, :focus': {
        background: hoverBackground
    } }));
const disabledDrawerMenuItemRootStyles = (background) => ({
    pointerEvents: 'none',
    background: background,
    ':hover, :focus': {
        background: background
    }
});
/** Ensure long text entries appropriately show ellipsis instead of wrapping to a new line or showing a scrollbar */
const drawerMenuItemTextStyles = {
    root: {
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
    }
};
const iconStyles = {
    // Vertically center icons in the menu item. Using line-height does not work for centering fluent SVG icons.
    display: 'flex',
    alignItems: 'center',
    height: '100%',
    // This can be removed when we upgrade to fluent-react-icons v2 (that removes the inner span element)
    ' span': {
        display: 'flex',
        alignItems: 'center',
        height: '100%'
    }
};
const secondaryTextStyles = {
    // limit width for secondaryText in the menu item so it does not overlap with text on left.
    maxWidth: '50%'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Container that holds the content of the drawer
 *
 * @private
 */
const DrawerContentContainer = (props) => {
    var _a;
    const theme = react.useTheme();
    const backgroundColor = theme.palette.white;
    const borderRadius = theme.effects.roundedCorner4;
    const rootStyles = react.mergeStyles(containerStyles$2(backgroundColor, borderRadius), (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root);
    return React.createElement(react.Stack, { className: rootStyles },
        props.heading && React.createElement(react.Stack, { className: react.mergeStyles(headingContainerStyles) },
            React.createElement(react.Text, { className: react.mergeStyles(headingStyles(theme)) }, props.heading)),
        props.children);
};
const containerStyles$2 = (backgroundColor, borderRadius) => (Object.assign({ background: backgroundColor, borderTopRightRadius: borderRadius, borderTopLeftRadius: borderRadius }, react.AnimationStyles.slideUpIn10));
const headingContainerStyles = {
    textAlign: 'center',
    width: '100%',
    padding: '0.5rem'
};
const headingStyles = (theme) => ({
    color: theme.palette.neutralSecondary,
    fontSize: theme.fonts.smallPlus.fontSize,
    lineHeight: '1rem',
    whiteSpace: 'nowrap',
    overflow: 'hidden',
    textOverflow: 'ellipsis'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * An element that fills the space the DrawerContentContainer does not take up.
 * This is the element that enables the light dismiss feature.
 *
 * @private
 */
const DrawerLightDismiss = (props) => {
    return React.createElement(react.Stack, { className: react.mergeStyles(lightDismissContainerStyles, props.styles), grow: true, onClick: () => props.onDismiss() });
};
const lightDismissContainerStyles = {
    root: {
        height: '100%'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A `Drawer` can be used to reveal lightweight views inside your application.
 * They appear from the bottom of the screen upwards and are light-dismissed.
 *
 * @internal
 */
const _DrawerSurface = (props) => {
    var _a, _b, _c, _d;
    const rootStyles = props.disableMaxHeight ? react.mergeStyles(drawerSurfaceStyles, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root) : react.mergeStyles(drawerSurfaceStyles, focusTrapZoneStyles, (_b = props.styles) === null || _b === void 0 ? void 0 : _b.root);
    const containerStyles = react.mergeStyleSets(drawerContentContainerStyles, (_c = props.styles) === null || _c === void 0 ? void 0 : _c.drawerContentContainer);
    return React.createElement(react.Stack, { className: rootStyles },
        React.createElement(DrawerLightDismiss, { styles: (_d = props.styles) === null || _d === void 0 ? void 0 : _d.lightDismissRoot, onDismiss: props.onLightDismiss }),
        React.createElement(react.FocusTrapZone, { onKeyDown: e => {
                if (e.key === 'Escape' || e.key === 'Esc') {
                    props.onLightDismiss && props.onLightDismiss();
                }
            }, 
            // Ensure when the focus trap has focus, the light dismiss area can still be clicked with mouse to dismiss.
            // Note: this still correctly captures keyboard focus, this just allows mouse click outside of the focus trap.
            isClickableOutsideFocusTrap: true },
            React.createElement(DrawerContentContainer, { styles: containerStyles, heading: props.heading }, props.children)));
};
const drawerSurfaceStyles = {
    width: '100%',
    height: '100%',
    background: 'rgba(0,0,0,0.4)'
};
const focusTrapZoneStyles = {
    // Targets FocusTrapZone in drawer.
    // Setting percentage to Height to transform a container does not work unless the
    // direct parent container also has a Height set other than 'auto'.
    '> div:nth-child(2)': {
        maxHeight: '75%',
        overflow: 'auto'
    }
};
const drawerContentContainerStyles = {
    root: {
        height: 'auto'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Takes a set of menu items and returns a created menu inside a {@link _DrawerSurface}.
 *
 * @internal
 */
const _DrawerMenu = (props) => {
    var _a, _b;
    // This component breaks from a pure component pattern in order to internally support sub menus.
    // When a sub menu item is clicked the menu items displayed is updated to be that of the submenu.
    // To track this state we store a list of the keys clicked up until this point.
    const [selectedKeyPath, setSelectedKeyPath] = React.useState([]);
    // Get the menu items that should be rendered
    const menuItemsToRender = React.useMemo(() => {
        var _a;
        let items = props.items;
        for (const subMenuKey of selectedKeyPath) {
            items = (_a = items === null || items === void 0 ? void 0 : items.find(item => item.itemKey === subMenuKey)) === null || _a === void 0 ? void 0 : _a.subMenuProps;
        }
        return items;
    }, [props.items, selectedKeyPath]);
    // When an item is clicked and it contains a submenu, push the key for the submenu. This will ensure
    // a new render is triggered, menuItemsToRender will be re-calculated and the submenu will render.
    const onItemClick = React.useCallback((item, ev, itemKey) => {
        var _a;
        if (item.subMenuProps) {
            setSelectedKeyPath([...selectedKeyPath, item.itemKey]);
        }
        (_a = item.onItemClick) === null || _a === void 0 ? void 0 : _a.call(item, ev, itemKey);
    }, [selectedKeyPath]);
    // Ensure the first item has a border radius that matches the DrawerSurface
    const borderRadius = useTheme().effects.roundedCorner4;
    const firstItemStyle = menuItemsToRender && ((_a = menuItemsToRender[0]) === null || _a === void 0 ? void 0 : _a.styles);
    const modifiedFirstItemStyle = React.useMemo(() => react.merge(firstItemStyle !== null && firstItemStyle !== void 0 ? firstItemStyle : {}, {
        root: {
            borderTopRightRadius: borderRadius,
            borderTopLeftRadius: borderRadius
        }
    }), [firstItemStyle, borderRadius]);
    return React.createElement(_DrawerSurface, { disableMaxHeight: props.disableMaxHeight, styles: (_b = props.styles) === null || _b === void 0 ? void 0 : _b.drawerSurfaceStyles, onLightDismiss: props.onLightDismiss, heading: props.heading },
        React.createElement(react.Stack, { styles: props.styles, role: "menu", "data-ui-id": "drawer-menu" }, menuItemsToRender === null || menuItemsToRender === void 0 ? void 0 :
            menuItemsToRender.slice(0, 1).map(item => React.createElement(DrawerMenuItem, Object.assign({}, item, { key: `${item.itemKey}` + '0', shouldFocusOnMount: true, styles: modifiedFirstItemStyle, onItemClick: (ev, itemKey) => {
                    onItemClick(item, ev, itemKey);
                } }))), menuItemsToRender === null || menuItemsToRender === void 0 ? void 0 :
            menuItemsToRender.slice(1).map((item, i) => React.createElement(DrawerMenuItem, Object.assign({}, item, { key: `${item.itemKey}` + `${i + 1}`, onItemClick: (ev, itemKey) => {
                    onItemClick(item, ev, itemKey);
                } })))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const remoteVideoTileWrapperStyle = {
    height: '100%',
    width: '100%',
    position: 'relative'
};
/** @private */
const drawerMenuWrapperStyles = {
    root: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        // Any zIndex > 0 will work because this is the only absolutely
        // positioned element in the container.
        zIndex: 2
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Helper hook to maintain the video stream lifecycle. This calls onCreateStreamView and onDisposeStreamView
 * appropriately based on react lifecycle events and prop changes.
 *
 * @remarks
 *
 * Notes on handling changes to scaling mode:
 *
 * Ideally we have access to the original StreamRenderView and can call view.updateScalingMode() and do not need to recreate the stream view.
 * However, to support backwards compat we cannot guarantee this. If we don't have access to the original StreamRenderView we need to dispose
 * the old view and create a new one.
 *
 * Supporting both of these scenarios became too complex and fragile. When we introduce a breaking change this should be update to ensure that
 * onCreateStreamView _must_ return a view object with updateScalingMode and update logic in this hook to call view.updateScalingMode instead
 * of recreating the stream.
 *
 * @private
 */
const useVideoStreamLifecycleMaintainer = (props) => {
    const { isMirrored, isScreenSharingOn, isStreamAvailable, onCreateStreamView, onDisposeStreamView, renderElementExists, scalingMode } = props;
    const [videoStreamViewResult, setVideoStreamViewResult] = React.useState();
    React.useEffect(() => {
        var _a;
        if (isStreamAvailable && !renderElementExists) {
            (_a = onCreateStreamView === null || onCreateStreamView === void 0 ? void 0 : onCreateStreamView({
                isMirrored,
                scalingMode
            })) === null || _a === void 0 ? void 0 : _a.then(result => {
                result && setVideoStreamViewResult(result);
            });
        }
        // Always clean up element to make tile up to date and be able to dispose correctly
        return () => {
            if (renderElementExists) {
                // TODO: Remove `if isScreenSharingOn` when we isolate dispose behavior for screen share
                if (!isScreenSharingOn) {
                    onDisposeStreamView === null || onDisposeStreamView === void 0 ? void 0 : onDisposeStreamView();
                }
            }
        };
    }, [isMirrored, isScreenSharingOn, isStreamAvailable, onCreateStreamView, onDisposeStreamView, renderElementExists, scalingMode]);
    // The execution order for above useEffect is onCreateRemoteStreamView =>(async time gap) RenderElement generated => element disposed => onDisposeRemoteStreamView
    // Element disposed could happen during async time gap, which still cause leaks for unused renderElement.
    // Need to do an entire cleanup when remoteTile gets disposed and make sure element gets correctly disposed
    React.useEffect(() => {
        return () => {
            // TODO: Remove `if isScreenSharingOn` when we isolate dispose behavior for screen share
            if (!isScreenSharingOn) {
                onDisposeStreamView === null || onDisposeStreamView === void 0 ? void 0 : onDisposeStreamView();
            }
        };
    }, [isScreenSharingOn, onDisposeStreamView]);
    return videoStreamViewResult;
};
/**
 * Extension of {@link useVideoStreamLifecycleMaintainer} specifically for local video streams
 *
 * @private
 */
const useLocalVideoStreamLifecycleMaintainer = (props) => {
    const { onCreateLocalStreamView, onDisposeLocalStreamView } = props;
    const onCreateStreamView = React.useMemo(() => (options) => {
        return onCreateLocalStreamView === null || onCreateLocalStreamView === void 0 ? void 0 : onCreateLocalStreamView(options);
    }, [onCreateLocalStreamView]);
    const onDisposeStreamView = React.useMemo(() => () => {
        onDisposeLocalStreamView === null || onDisposeLocalStreamView === void 0 ? void 0 : onDisposeLocalStreamView();
    }, [onDisposeLocalStreamView]);
    return useVideoStreamLifecycleMaintainer(Object.assign(Object.assign({}, props), { onCreateStreamView,
        onDisposeStreamView }));
};
/**
 * Extension of {@link useVideoStreamLifecycleMaintainer} specifically for remote video streams
 *
 * @private
 */
const useRemoteVideoStreamLifecycleMaintainer = (props) => {
    const { remoteParticipantId, onCreateRemoteStreamView, onDisposeRemoteStreamView } = props;
    const onCreateStreamView = React.useMemo(() => (options) => {
        return onCreateRemoteStreamView === null || onCreateRemoteStreamView === void 0 ? void 0 : onCreateRemoteStreamView(remoteParticipantId, options);
    }, [onCreateRemoteStreamView, remoteParticipantId]);
    const onDisposeStreamView = React.useMemo(() => () => {
        onDisposeRemoteStreamView === null || onDisposeRemoteStreamView === void 0 ? void 0 : onDisposeRemoteStreamView(remoteParticipantId);
    }, [onDisposeRemoteStreamView, remoteParticipantId]);
    return useVideoStreamLifecycleMaintainer(Object.assign(Object.assign({}, props), { onCreateStreamView,
        onDisposeStreamView }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const useVideoTileContextualMenuProps = (props) => {
    var _a;
    const { participant, view, strings, isPinned, onPinParticipant, onUnpinParticipant, onUpdateScalingMode, disablePinMenuItem, toggleAnnouncerString } = props;
    const scalingMode = React.useMemo(() => {
        var _a;
        return (_a = props.participant.videoStream) === null || _a === void 0 ? void 0 : _a.scalingMode;
    }, [(_a = props.participant.videoStream) === null || _a === void 0 ? void 0 : _a.scalingMode]);
    const contextualMenuProps = React.useMemo(() => {
        const items = [];
        if (isPinned !== undefined) {
            if (isPinned && onUnpinParticipant && (strings === null || strings === void 0 ? void 0 : strings.unpinParticipantForMe)) {
                let unpinActionString = undefined;
                if (toggleAnnouncerString && strings.unpinParticipantMenuItemAriaLabel && participant.displayName) {
                    unpinActionString = _formatString(strings === null || strings === void 0 ? void 0 : strings.unpinParticipantMenuItemAriaLabel, {
                        participantName: participant.displayName
                    });
                }
                items.push({
                    key: 'unpin',
                    text: strings.unpinParticipantForMe,
                    iconProps: {
                        iconName: 'UnpinParticipant',
                        styles: {
                            root: {
                                lineHeight: '1rem',
                                textAlign: 'center'
                            }
                        }
                    },
                    onClick: () => {
                        onUnpinParticipant(participant.userId);
                        unpinActionString && (toggleAnnouncerString === null || toggleAnnouncerString === void 0 ? void 0 : toggleAnnouncerString(unpinActionString));
                    },
                    'data-ui-id': 'video-tile-unpin-participant-button',
                    ariaLabel: unpinActionString
                });
            }
            if (!isPinned && onPinParticipant && (strings === null || strings === void 0 ? void 0 : strings.pinParticipantForMe)) {
                let pinActionString = undefined;
                if (toggleAnnouncerString && strings.pinnedParticipantAnnouncementAriaLabel && participant.displayName) {
                    pinActionString = _formatString(strings === null || strings === void 0 ? void 0 : strings.pinnedParticipantAnnouncementAriaLabel, {
                        participantName: participant.displayName
                    });
                }
                items.push({
                    key: 'pin',
                    text: disablePinMenuItem ? strings.pinParticipantForMeLimitReached : strings.pinParticipantForMe,
                    iconProps: {
                        iconName: 'PinParticipant',
                        styles: {
                            root: {
                                lineHeight: '1rem',
                                textAlign: 'center'
                            }
                        }
                    },
                    onClick: () => {
                        onPinParticipant(participant.userId);
                        pinActionString && (toggleAnnouncerString === null || toggleAnnouncerString === void 0 ? void 0 : toggleAnnouncerString(pinActionString));
                    },
                    'data-ui-id': 'video-tile-pin-participant-button',
                    disabled: disablePinMenuItem,
                    ariaLabel: pinActionString
                });
            }
        }
        if (scalingMode) {
            if (scalingMode === 'Crop' && (strings === null || strings === void 0 ? void 0 : strings.fitRemoteParticipantToFrame)) {
                items.push({
                    key: 'fitRemoteParticipantToFrame',
                    text: strings.fitRemoteParticipantToFrame,
                    iconProps: {
                        iconName: 'VideoTileScaleFit',
                        styles: {
                            root: {
                                lineHeight: '1rem',
                                textAlign: 'center'
                            }
                        }
                    },
                    onClick: () => {
                        onUpdateScalingMode === null || onUpdateScalingMode === void 0 ? void 0 : onUpdateScalingMode(participant.userId, 'Fit');
                        view === null || view === void 0 ? void 0 : view.updateScalingMode('Fit');
                    },
                    'data-ui-id': 'video-tile-fit-to-frame',
                    ariaLabel: strings.fitRemoteParticipantToFrame
                });
            }
            else if (scalingMode === 'Fit' && (strings === null || strings === void 0 ? void 0 : strings.fillRemoteParticipantFrame)) {
                items.push({
                    key: 'fillRemoteParticipantFrame',
                    text: strings.fillRemoteParticipantFrame,
                    iconProps: {
                        iconName: 'VideoTileScaleFill',
                        styles: {
                            root: {
                                lineHeight: '1rem',
                                textAlign: 'center'
                            }
                        }
                    },
                    onClick: () => {
                        onUpdateScalingMode === null || onUpdateScalingMode === void 0 ? void 0 : onUpdateScalingMode(participant.userId, 'Crop');
                        view === null || view === void 0 ? void 0 : view.updateScalingMode('Crop');
                    },
                    'data-ui-id': 'video-tile-fill-frame',
                    ariaLabel: strings.fillRemoteParticipantFrame
                });
            }
        }
        if (items.length === 0) {
            return undefined;
        }
        return {
            items,
            styles: {},
            calloutProps: {
                preventDismissOnEvent: _preventDismissOnEvent
            }
        };
    }, [scalingMode, strings, view, isPinned, onPinParticipant, onUnpinParticipant, onUpdateScalingMode, participant.userId, participant.displayName, disablePinMenuItem, toggleAnnouncerString]);
    return contextualMenuProps;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const rootStyles = {
    position: 'relative',
    height: '100%',
    width: '100%'
};
/**
 * @private
 */
const videoContainerStyles = {
    position: 'absolute',
    top: '0',
    left: '0',
    width: '100%',
    height: '100%',
    minWidth: '100%',
    minHeight: '100%',
    objectPosition: 'center',
    objectFit: 'cover',
    zIndex: 0
};
/**
 * @private
 */
const overlayContainerStyles = {
    width: '100%',
    height: '100%',
    zIndex: 5
};
/**
 * @private
 */
const tileInfoContainerStyle = react.mergeStyles({
    position: 'absolute',
    bottom: '0',
    left: '0',
    padding: '0.5rem',
    width: '100%'
});
/**
 * @private
 */
const disabledVideoHint = react.mergeStyles({
    backgroundColor: 'inherit',
    boxShadow: 'none',
    textAlign: 'left',
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    alignItems: 'center',
    padding: '0.15rem',
    maxWidth: '100%'
});
/**
 * @private
 */
const videoHint = react.mergeStyles(disabledVideoHint, {
    // This will appear on top of the video stream, so no dependency on theme and explicitly use a translucent white
    backgroundColor: 'rgba(255,255,255,0.8)'
});
/**
 * @private
 */
const displayNameStyle = {
    padding: '0.1rem',
    fontSize: '0.75rem',
    fontWeight: 600,
    // Text component will take body color by default (white in Dark Mode), so forcing it to be parent container color
    color: 'inherit',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    maxWidth: '100%'
};
/**
 * @private
 */
const pinIconStyle = {
    padding: '0.125rem'
};
/**
 * @private
 */
const iconContainerStyle = {
    margin: 'auto',
    alignItems: 'center',
    '& svg': {
        display: 'block',
        // Similar to text color, icon color will be inherited from parent container
        color: 'inherit'
    }
};
/**
 * @private
 */
const moreButtonStyles = {
    root: {
        // To ensure that the button is clickable when there is a floating video tile
        zIndex: 1,
        color: 'inherit',
        top: '-0.125rem',
        height: '100%',
        padding: '0rem'
    },
    rootHovered: {
        background: 'none'
    },
    rootPressed: {
        background: 'none'
    },
    rootExpanded: {
        background: 'none'
    }
};
/**
 * @private
 */
const raiseHandContainerStyles = (theme, limitedSpace) => react.mergeStyles({
    alignItems: 'center',
    padding: '0.2rem 0.3rem',
    backgroundColor: theme.palette.white,
    opacity: 0.9,
    borderRadius: '1rem',
    margin: '0.5rem',
    width: 'fit-content',
    position: 'absolute'
}, limitedSpace && raiseHandLimitedSpaceStyles);
/**
 * @private
 */
const raiseHandLimitedSpaceStyles = {
    // position centrally
    marginLeft: 'auto',
    marginRight: 'auto',
    left: 0,
    right: 0,
    // position at the bottom
    bottom: 0
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const getVideoTileOverrideColor = (isVideoRendered, theme, color) => {
    // when video is being rendered, the info has a grey-ish background, so no use of theme
    return {
        color: isVideoRendered ? react.DefaultPalette[color] : theme.palette[color]
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
function useLongPress(props) {
    const { onClick, onLongPress, touchEventsOnly = false } = props;
    const timerRef = React.useRef();
    const [isLongPress, setIsLongPress] = React.useState(false);
    const [action, setAction] = React.useState(false);
    React.useEffect(() => {
        if (timerRef.current) {
            clearTimeout(timerRef.current);
        }
        return () => {
            if (timerRef.current) {
                clearTimeout(timerRef.current);
            }
        };
    }, [onClick, onLongPress, touchEventsOnly]);
    const startPressTimer = React.useCallback(() => {
        setIsLongPress(false);
        timerRef.current = setTimeout(() => {
            setIsLongPress(true);
            onLongPress();
        }, 500);
    }, [onLongPress]);
    const handleOnClick = React.useCallback(() => {
        if (touchEventsOnly || !onClick) {
            return;
        }
        if (!isLongPress) {
            onClick();
        }
    }, [isLongPress, onClick, touchEventsOnly]);
    const handleOnKeyDown = React.useCallback(() => {
        if (touchEventsOnly) {
            return;
        }
        if (action) {
            setAction(false);
            startPressTimer();
        }
    }, [action, startPressTimer, touchEventsOnly]);
    const handleOnKeyUp = React.useCallback(() => {
        if (touchEventsOnly) {
            return;
        }
        setAction(true);
        timerRef.current && clearTimeout(timerRef.current);
    }, [touchEventsOnly]);
    const handleOnMouseDown = React.useCallback(() => {
        if (touchEventsOnly) {
            return;
        }
        startPressTimer();
    }, [startPressTimer, touchEventsOnly]);
    const handleOnMouseUp = React.useCallback(() => {
        if (touchEventsOnly) {
            return;
        }
        timerRef.current && clearTimeout(timerRef.current);
    }, [touchEventsOnly]);
    const handleOnTouchStart = React.useCallback(() => {
        startPressTimer();
    }, [startPressTimer]);
    const handleOnTouchEnd = React.useCallback(() => {
        if (!isLongPress && onClick) {
            onClick();
        }
        timerRef.current && clearTimeout(timerRef.current);
    }, [onClick, isLongPress]);
    const handleOnTouchMove = React.useCallback(() => {
        timerRef.current && clearTimeout(timerRef.current);
    }, []);
    return React.useMemo(() => ({
        onClick: handleOnClick,
        onMouseDown: handleOnMouseDown,
        onMouseUp: handleOnMouseUp,
        onTouchStart: handleOnTouchStart,
        onTouchEnd: handleOnTouchEnd,
        onKeyDown: handleOnKeyDown,
        onKeyUp: handleOnKeyUp,
        onTouchMove: handleOnTouchMove
    }), [handleOnClick, handleOnKeyDown, handleOnKeyUp, handleOnMouseDown, handleOnMouseUp, handleOnTouchEnd, handleOnTouchStart, handleOnTouchMove]);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// Coin max size is set to PersonaSize.size100
const DEFAULT_PERSONA_MAX_SIZE_PX = 100;
// Coin min size is set PersonaSize.size32
const DEFAULT_PERSONA_MIN_SIZE_PX = 32;
const DefaultPlaceholder = (props) => {
    const { text, noVideoAvailableAriaLabel, coinSize, hidePersonaDetails } = props;
    return React.createElement(react.Stack, { className: react.mergeStyles({
            position: 'absolute',
            height: '100%',
            width: '100%'
        }) },
        React.createElement(react.Stack, { styles: defaultPersonaStyles$1 }, coinSize && React.createElement(react.Persona, { coinSize: coinSize, hidePersonaDetails: hidePersonaDetails, text: text !== null && text !== void 0 ? text : '', initialsTextColor: "white", "aria-label": noVideoAvailableAriaLabel !== null && noVideoAvailableAriaLabel !== void 0 ? noVideoAvailableAriaLabel : '', showOverflowTooltip: false })));
};
const defaultPersonaStyles$1 = {
    root: {
        margin: 'auto',
        maxHeight: '100%'
    }
};
const videoTileMoreMenuIconProps = {
    iconName: undefined,
    style: {
        display: 'none'
    }
};
const videoTileMoreMenuProps = {
    directionalHint: react.DirectionalHint.topLeftEdge,
    isBeakVisible: false,
    styles: {
        container: {
            maxWidth: '8rem'
        }
    }
};
const VideoTileMoreOptionsButton = (props) => {
    const { contextualMenu, canShowContextMenuButton } = props;
    if (!contextualMenu) {
        return React.createElement(React.Fragment, null);
    }
    const optionsIcon = canShowContextMenuButton ? 'VideoTileMoreOptions' : undefined;
    return React.createElement(react.IconButton, { "data-ui-id": "video-tile-more-options-button", styles: moreButtonStyles, menuIconProps: videoTileMoreMenuIconProps, menuProps: Object.assign(Object.assign({}, videoTileMoreMenuProps), contextualMenu), iconProps: {
            iconName: optionsIcon
        } });
};
/**
 * A component to render the video stream for a single call participant.
 *
 * Use with {@link GridLayout} in a {@link VideoGallery}.
 *
 * @public
 */
const VideoTile = (props) => {
    const { children, displayName, initialsName, isMirrored, isMuted, isPinned, onRenderPlaceholder, renderElement, showLabel = true, showMuteIndicator = true, styles, userId, noVideoAvailableAriaLabel, isSpeaking, 
    /* @conditional-compile-remove(raise-hand) */
    raisedHand, personaMinSize = DEFAULT_PERSONA_MIN_SIZE_PX, personaMaxSize = DEFAULT_PERSONA_MAX_SIZE_PX, contextualMenu } = props;
    const [isHovered, setIsHovered] = React.useState(false);
    const [isFocused, setIsFocused] = React.useState(false);
    // need to set a default otherwise the resizeObserver will get stuck in an infinite loop.
    const [personaSize, setPersonaSize] = React.useState(1);
    const videoTileRef = React.useRef(null);
    useLocale$1();
    const theme = useTheme();
    const isVideoRendered = !!renderElement;
    const observer = React.useRef(new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        const personaCalcSize = Math.min(width, height) / 3;
        // we only want to set the persona size if it has changed
        if (personaCalcSize !== personaSize) {
            setPersonaSize(Math.max(Math.min(personaCalcSize, personaMaxSize), personaMinSize));
        }
    }));
    React.useLayoutEffect(() => {
        if (videoTileRef.current) {
            observer.current.observe(videoTileRef.current);
        }
        const currentObserver = observer.current;
        return () => currentObserver.disconnect();
    }, [videoTileRef]);
    const useLongPressProps = React.useMemo(() => {
        return {
            onLongPress: () => {
                var _a;
                (_a = props.onLongTouch) === null || _a === void 0 ? void 0 : _a.call(props);
            },
            touchEventsOnly: true
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [props.onLongTouch]);
    const longPressHandlers = useLongPress(useLongPressProps);
    const hoverHandlers = React.useMemo(() => {
        return {
            onMouseEnter: () => setIsHovered(true),
            onMouseLeave: () => setIsHovered(false),
            onFocus: () => setIsFocused(true),
            onBlur: () => setIsFocused(false)
        };
    }, []);
    const placeholderOptions = {
        userId,
        text: initialsName !== null && initialsName !== void 0 ? initialsName : displayName,
        noVideoAvailableAriaLabel,
        coinSize: personaSize,
        styles: defaultPersonaStyles$1,
        hidePersonaDetails: true
    };
    const videoHintWithBorderRadius = react.mergeStyles(videoHint, {
        borderRadius: theme.effects.roundedCorner4
    });
    const tileInfoStyle = React.useMemo(() => react.mergeStyles(isVideoRendered ? videoHintWithBorderRadius : disabledVideoHint, getVideoTileOverrideColor(isVideoRendered, theme, 'neutralPrimary'), styles === null || styles === void 0 ? void 0 : styles.displayNameContainer), [isVideoRendered, videoHintWithBorderRadius, theme, styles === null || styles === void 0 ? void 0 : styles.displayNameContainer]);
    const ids = useIdentifiers();
    const canShowLabel = showLabel && (displayName || showMuteIndicator && isMuted);
    const participantStateString = participantStateStringTrampoline();
    const canShowContextMenuButton = isHovered || isFocused;
    let raisedHandBackgroundColor = '';
    /* @conditional-compile-remove(raise-hand) */
    const callingPalette = theme.callingPalette;
    /* @conditional-compile-remove(raise-hand) */
    raisedHandBackgroundColor = callingPalette.raiseHandGold;
    return React.createElement(react.Stack, Object.assign({ "data-ui-id": ids.videoTile, className: react.mergeStyles(rootStyles, {
            background: theme.palette.neutralLighter,
            borderRadius: theme.effects.roundedCorner4
        }, (isSpeaking || /* @conditional-compile-remove(raise-hand) */ raisedHand) && {
            '&::after': {
                content: `''`,
                position: 'absolute',
                border: `0.25rem solid ${isSpeaking ? theme.palette.themePrimary : raisedHandBackgroundColor}`,
                borderRadius: theme.effects.roundedCorner4,
                width: '100%',
                height: '100%',
                pointerEvents: 'none'
            }
        }, styles === null || styles === void 0 ? void 0 : styles.root) }, longPressHandlers),
        React.createElement("div", Object.assign({ ref: videoTileRef, style: {
                width: '100%',
                height: '100%'
            } }, hoverHandlers, { "data-is-focusable": true }),
            isVideoRendered ? React.createElement(react.Stack, { className: react.mergeStyles(videoContainerStyles, isMirrored && {
                    transform: 'scaleX(-1)'
                }, styles === null || styles === void 0 ? void 0 : styles.videoContainer) }, renderElement) : React.createElement(react.Stack, { className: react.mergeStyles(videoContainerStyles, {
                    opacity: 1
                }) }, onRenderPlaceholder ? onRenderPlaceholder(userId !== null && userId !== void 0 ? userId : '', placeholderOptions, DefaultPlaceholder) : React.createElement(DefaultPlaceholder, Object.assign({}, placeholderOptions))),
            (canShowLabel || participantStateString) && React.createElement(react.Stack, { horizontal: true, className: tileInfoContainerStyle, tokens: tileInfoContainerTokens },
                React.createElement(react.Stack, { horizontal: true, className: tileInfoStyle },
                    canShowLabel && React.createElement(react.Text, { className: react.mergeStyles(displayNameStyle), title: displayName, style: {
                            color: 'inherit'
                        }, "data-ui-id": "video-tile-display-name" }, displayName),
                    participantStateString ,
                    showMuteIndicator && isMuted && React.createElement(react.Stack, { className: react.mergeStyles(iconContainerStyle) },
                        React.createElement(react.Icon, { iconName: "VideoTileMicOff" })),
                    isPinned && React.createElement(react.Stack, { className: react.mergeStyles(iconContainerStyle) },
                        React.createElement(react.Icon, { iconName: "VideoTilePinned", className: react.mergeStyles(pinIconStyle) })),
                    React.createElement(VideoTileMoreOptionsButton, { contextualMenu: contextualMenu, canShowContextMenuButton: canShowContextMenuButton }))),
            children && React.createElement(react.Stack, { className: react.mergeStyles(overlayContainerStyles, styles === null || styles === void 0 ? void 0 : styles.overlayContainer) }, children), /* @conditional-compile-remove(raise-hand) */
            raisedHand && React.createElement(react.Stack, { horizontal: true, tokens: {
                    childrenGap: '0.2rem'
                }, className: raiseHandContainerStyles(theme, !canShowLabel) },
                React.createElement(react.Stack.Item, null,
                    React.createElement(react.Text, null, raisedHand.raisedHandOrderPosition)),
                React.createElement(react.Stack.Item, null,
                    React.createElement(RaisedHandIcon, null)))));
};
const participantStateStringTrampoline = (props, locale) => {
    return undefined;
};
const tileInfoContainerTokens = {
    // A horizontal Stack sets the left margin to 0 for all it's children.
    // We need to allow the children to set their own margins
    childrenGap: 'none'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A memoized version of VideoTile for rendering remote participants. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering a VideoTile when its position in the
 * array changes causing a rerender in the parent component. https://reactjs.org/docs/react-api.html#reactmemo
 *
 * @internal
 */
const _RemoteVideoTile = React.memo((props) => {
    var _a;
    const { isAvailable, isReceiving = true, 
    // default to true to prevent any breaking change
    isScreenSharingOn, onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions, renderElement, userId, onRenderAvatar, showMuteIndicator, remoteParticipant, participantState, menuKind, isPinned, onPinParticipant, onUnpinParticipant, onUpdateScalingMode, disablePinMenuItem, toggleAnnouncerString, strings } = props;
    const remoteVideoStreamProps = React.useMemo(() => ({
        isMirrored: remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.isMirrored,
        isScreenSharingOn,
        isStreamAvailable: isAvailable,
        isStreamReceiving: isReceiving,
        onCreateRemoteStreamView,
        onDisposeRemoteStreamView,
        remoteParticipantId: userId,
        renderElementExists: !!renderElement,
        scalingMode: remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.scalingMode
    }), [isAvailable, isReceiving, isScreenSharingOn, onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.isMirrored, remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.scalingMode, renderElement, userId]);
    // Handle creating, destroying and updating the video stream as necessary
    const createVideoStreamResult = useRemoteVideoStreamLifecycleMaintainer(remoteVideoStreamProps);
    const contextualMenuProps = useVideoTileContextualMenuProps({
        participant: remoteParticipant,
        view: createVideoStreamResult === null || createVideoStreamResult === void 0 ? void 0 : createVideoStreamResult.view,
        strings: Object.assign({}, props.strings),
        isPinned,
        onPinParticipant,
        onUnpinParticipant,
        onUpdateScalingMode,
        disablePinMenuItem,
        toggleAnnouncerString
    });
    const videoTileContextualMenuProps = React.useMemo(() => {
        if (menuKind !== 'contextual' || !contextualMenuProps) {
            return {};
        }
        return {
            contextualMenu: contextualMenuProps
        };
    }, [contextualMenuProps, menuKind]);
    const showLoadingIndicator = isAvailable && isReceiving === false && participantState !== 'Disconnected';
    const [drawerMenuItemProps, setDrawerMenuItemProps] = React.useState([]);
    const renderVideoStreamElement = React.useMemo(() => {
        // Checking if renderElement is well defined or not as calling SDK has a number of video streams limitation which
        // implies that, after their threshold, all streams have no child (blank video)
        if (!renderElement || !renderElement.childElementCount) {
            // Returning `undefined` results in the placeholder with avatar being shown
            return undefined;
        }
        return React.createElement(StreamMedia, { videoStreamElement: renderElement, loadingState: showLoadingIndicator ? 'loading' : 'none' });
    }, [renderElement, showLoadingIndicator]);
    const onKeyDown = React.useCallback((e) => {
        if (e.key === 'Enter') {
            setDrawerMenuItemProps(convertContextualMenuItemsToDrawerMenuItemProps(contextualMenuProps, () => setDrawerMenuItemProps([])));
        }
    }, [setDrawerMenuItemProps, contextualMenuProps]);
    let displayName = remoteParticipant.displayName || strings.displayNamePlaceholder;
    return React.createElement(react.Stack, { tabIndex: menuKind === 'drawer' ? 0 : undefined, onKeyDown: menuKind === 'drawer' ? onKeyDown : undefined, style: remoteVideoTileWrapperStyle },
        React.createElement(VideoTile, Object.assign({ key: userId, userId: userId, initialsName: (_a = remoteParticipant.displayName) !== null && _a !== void 0 ? _a : '', renderElement: renderVideoStreamElement, displayName: displayName, onRenderPlaceholder: onRenderAvatar, isMuted: remoteParticipant.isMuted, 
            /* @conditional-compile-remove(raise-hand) */ raisedHand: remoteParticipant.raisedHand, isSpeaking: remoteParticipant.isSpeaking, showMuteIndicator: showMuteIndicator, personaMinSize: props.personaMinSize, showLabel: props.showLabel }, videoTileContextualMenuProps, { isPinned: props.isPinned, onLongTouch: () => setDrawerMenuItemProps(convertContextualMenuItemsToDrawerMenuItemProps(contextualMenuProps, () => setDrawerMenuItemProps([]))) })),
        drawerMenuItemProps.length > 0 && React.createElement(react.Layer, { hostId: props.drawerMenuHostId },
            React.createElement(react.Stack, { styles: drawerMenuWrapperStyles },
                React.createElement(_DrawerMenu, { onLightDismiss: () => setDrawerMenuItemProps([]), items: drawerMenuItemProps, heading: remoteParticipant.displayName }))));
});
const convertContextualMenuItemsToDrawerMenuItemProps = (contextualMenuProps, onLightDismiss) => {
    if (!contextualMenuProps) {
        return [];
    }
    return contextualMenuProps.items.map(item => {
        return {
            itemKey: item.key,
            text: item.text,
            iconProps: item.iconProps,
            disabled: item.disabled,
            onItemClick: () => {
                var _a;
                (_a = item.onClick) === null || _a === void 0 ? void 0 : _a.call(item);
                onLightDismiss === null || onLightDismiss === void 0 ? void 0 : onLightDismiss();
            }
        };
    });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const screenSharingContainerStyle = react.mergeStyles({
    width: '100%',
    height: '100%'
});
/**
 * @private
 */
const screenSharingNotificationContainerStyle = (theme) => react.mergeStyles({
    backgroundColor: 'inherit',
    padding: '1rem',
    maxWidth: '95%',
    borderRadius: theme.effects.roundedCorner4,
    color: theme.palette.neutralSecondary
});
/**
 * @private
 */
const screenSharingNotificationIconContainerStyle = react.mergeStyles({
    height: '2rem',
    lineHeight: 0
});
/**
 * @private
 */
const screenSharingNotificationIconStyle = (theme) => react.mergeStyles({
    // svg is (20px x 20px) but path is only (16px x 12px), so need to scale at 2.5 to get 40px
    transform: 'scale(2.5)',
    color: theme.palette.neutralTertiary
});
/**
 * @private
 */
const screenSharingNotificationTextStyle = react.mergeStyles({
    fontSize: '1rem',
    // Text component will take body color by default (white in Dark Mode), so forcing it to be parent container color
    color: 'inherit'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A memoized version of local screen share component. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering this when the parent component rerenders.
 * https://reactjs.org/docs/react-api.html#reactmemo
 */
const LocalScreenShare = React.memo((props) => {
    const { localParticipant } = props;
    const theme = useTheme();
    const locale = useLocale$1();
    if (!localParticipant || !localParticipant.isScreenSharingOn) {
        return null;
    }
    const localScreenSharingNotification = React.createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: screenSharingContainerStyle },
        React.createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: screenSharingNotificationContainerStyle(theme), tokens: {
                childrenGap: '1rem'
            } },
            React.createElement(react.Stack, { horizontal: true, verticalAlign: "center", className: screenSharingNotificationIconContainerStyle },
                React.createElement(react.Icon, { iconName: "ControlButtonScreenShareStart", className: screenSharingNotificationIconStyle(theme) })),
            React.createElement(react.Text, { className: screenSharingNotificationTextStyle, "aria-live": "polite" }, locale.strings.videoGallery.screenIsBeingSharedMessage)));
    const displayName = !(localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.displayName) ? locale.strings.videoGallery.displayNamePlaceholder : localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.displayName;
    return React.createElement(VideoTile, { displayName: displayName, isMuted: localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isMuted, onRenderPlaceholder: () => React.createElement(React.Fragment, null) }, localScreenSharingNotification);
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const loadingStyle = react.mergeStyles({
    height: '100%',
    width: '100%'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A memoized version of VideoTile for rendering the remote screen share stream. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering this when the parent component rerenders.
 * https://reactjs.org/docs/react-api.html#reactmemo
 */
const RemoteScreenShare = React.memo((props) => {
    const { userId, displayName, isMuted, renderElement, onCreateRemoteStreamView, onDisposeRemoteStreamView, isReceiving, participantVideoScalingMode } = props;
    const locale = useLocale$1();
    if (!renderElement) {
        /**
         * TODO: We need to pass in the scaling mode of the screen share participant to this function because when we
         * call this it will recreate both streams (video and screen share) and we need to make sure that the scaling
         * mode is the same as before we started the screen share.
         *
         * We should deprecate the current function and replace it with a
         * createRemoteScreenShareStreamView and createRemoteVideoStreamView.
         */
        onCreateRemoteStreamView && onCreateRemoteStreamView(userId, participantVideoScalingMode);
    }
    React.useEffect(() => {
        return () => {
            // TODO: Isolate disposing behaviors for screenShare and videoStream
            onDisposeRemoteStreamView && onDisposeRemoteStreamView(userId);
        };
    }, [onDisposeRemoteStreamView, userId]);
    const loadingMessage = displayName ? _formatString(locale.strings.videoGallery.screenShareLoadingMessage, {
        participant: displayName
    }) : '';
    return React.createElement(VideoTile, { displayName: displayName, isMuted: isMuted, renderElement: renderElement ? React.createElement(StreamMedia, { videoStreamElement: renderElement, loadingState: isReceiving === false ? 'loading' : 'none' }) : undefined, onRenderPlaceholder: () => React.createElement(LoadingSpinner, { loadingMessage: loadingMessage }) });
});
const LoadingSpinner = (props) => {
    return React.createElement(react.Stack, { verticalAlign: "center", className: loadingStyle },
        React.createElement(react.Spinner, { label: props.loadingMessage, size: react.SpinnerSize.xSmall, "aria-live": 'assertive' }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const videoGalleryOuterDivStyle = react.mergeStyles({
    position: 'relative',
    width: '100%',
    height: '100%'
});
/**
 * @private
 */
const localVideoCameraCycleButtonStyles = (theme, size) => {
    return {
        root: {
            position: 'absolute',
            width: size === 'large' ? _pxToRem(40) : _pxToRem(32),
            height: size === 'large' ? _pxToRem(40) : _pxToRem(32),
            right: '0rem',
            top: '0rem',
            color: '#FFFFFF',
            // only shows up on running video feed to we want to force specific colours.
            zIndex: 2,
            // shows the button directly over the local video feed.
            background: 'rgba(0,0,0,0.4)',
            borderRadius: theme.effects.roundedCorner2
        },
        rootFocused: {
            // styles to remove the unwanted white highlight and blue colour after tapping on button.
            color: '#FFFFFF',
            background: 'rgba(0,0,0,0.4)' // sets opacity of background to be visible on all backdrops in video stream.
        },
        rootDisabled: {
            // In the disabled state, FluentUI sets the position to relative. We need to override this to keep the button correctly positioned.
            position: 'absolute'
        },
        icon: {
            paddingLeft: _pxToRem(3),
            paddingRight: _pxToRem(3),
            margin: 0
        },
        flexContainer: {
            paddingBottom: _pxToRem(8),
            height: 'unset'
        }
    };
};
/**
 * @private
 */
const localVideoTileContainerStyles = {
    root: {
        width: '100%',
        height: '100%'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$v = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * local video tile camera cycle button - for use on mobile screens only.
 * @internal
 */
const LocalVideoCameraCycleButton = (props) => {
    const { cameras, selectedCamera, onSelectCamera, label, ariaDescription, size } = props;
    const theme = react.useTheme();
    const [waitForCamera, setWaitForCamera] = React.useState(false);
    const onChangeCameraClick = React.useCallback((device) => __awaiter$v(void 0, void 0, void 0, function* () {
        // Throttle changing camera to prevent too many callbacks
        if (onSelectCamera) {
            setWaitForCamera(true);
            try {
                yield onSelectCamera(device);
            }
            finally {
                setWaitForCamera(false);
            }
        }
    }), [onSelectCamera]);
    const disabled = !!waitForCamera;
    const cameraLoadingString = useLocale$1().strings.cameraButton.tooltipVideoLoadingContent;
    return React.createElement(react.IconButton, { "data-ui-id": 'local-camera-switcher-button', styles: localVideoCameraCycleButtonStyles(theme, size), disabled: disabled, iconProps: {
            iconName: 'LocalCameraSwitch'
        }, ariaLabel: label, ariaDescription: disabled ? cameraLoadingString : ariaDescription, "aria-live": 'polite', onClick: () => {
            if (cameras && cameras.length > 1 && selectedCamera !== undefined) {
                const index = cameras.findIndex(camera => selectedCamera.id === camera.id);
                const newCamera = cameras[(index + 1) % cameras.length];
                onChangeCameraClick(newCamera);
            }
        } });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A memoized version of VideoTile for rendering local participant.
 *
 * @internal
 */
const _LocalVideoTile = React.memo((props) => {
    const { isAvailable, isMuted, onCreateLocalStreamView, onDisposeLocalStreamView, localVideoViewOptions, renderElement, userId, showLabel, displayName, initialsName, onRenderAvatar, showMuteIndicator, styles, showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel, localVideoSelectedDescription, 
    /* @conditional-compile-remove(raise-hand) */
    raisedHand } = props;
    const localVideoStreamProps = React.useMemo(() => ({
        isMirrored: localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.isMirrored,
        isStreamAvailable: isAvailable,
        onCreateLocalStreamView,
        onDisposeLocalStreamView,
        renderElementExists: !!renderElement,
        scalingMode: localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.scalingMode
    }), [isAvailable, localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.isMirrored, localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.scalingMode, onCreateLocalStreamView, onDisposeLocalStreamView, renderElement]);
    // Handle creating, destroying and updating the video stream as necessary
    useLocalVideoStreamLifecycleMaintainer(localVideoStreamProps);
    const videoTileContextualMenuProps = React.useMemo(() => {
        return {};
    }, []);
    const videoTileStyles = React.useMemo(() => {
        return styles;
    }, [styles]);
    const renderVideoStreamElement = React.useMemo(() => {
        // Checking if renderElement is well defined or not as calling SDK has a number of video streams limitation which
        // implies that, after their threshold, all streams have no child (blank video)
        if (!renderElement || !renderElement.childElementCount) {
            // Returning `undefined` results in the placeholder with avatar being shown
            return undefined;
        }
        return React.createElement(React.Fragment, null,
            React.createElement(FloatingLocalCameraCycleButton, { showCameraSwitcherInLocalPreview: showCameraSwitcherInLocalPreview !== null && showCameraSwitcherInLocalPreview !== void 0 ? showCameraSwitcherInLocalPreview : false, localVideoCameraCycleButtonProps: localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel: localVideoCameraSwitcherLabel, localVideoSelectedDescription: localVideoSelectedDescription }),
            React.createElement(StreamMedia, { videoStreamElement: renderElement, isMirrored: true }));
    }, [localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel, localVideoSelectedDescription, renderElement, showCameraSwitcherInLocalPreview]);
    return React.createElement(react.Stack, { className: react.mergeStyles({
            width: '100%',
            height: '100%'
        }) },
        React.createElement(VideoTile, Object.assign({ key: userId !== null && userId !== void 0 ? userId : 'local-video-tile', userId: userId, renderElement: renderVideoStreamElement, showLabel: showLabel, displayName: displayName, initialsName: initialsName, styles: videoTileStyles, onRenderPlaceholder: onRenderAvatar, isMuted: isMuted, showMuteIndicator: showMuteIndicator, personaMinSize: props.personaMinSize, 
            /* @conditional-compile-remove(raise-hand) */ raisedHand: raisedHand }, videoTileContextualMenuProps)));
});
const FloatingLocalCameraCycleButton = (props) => {
    const { showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel, localVideoSelectedDescription } = props;
    const ariaDescription = (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.selectedCamera) && localVideoSelectedDescription && _formatString(localVideoSelectedDescription, {
        cameraName: localVideoCameraCycleButtonProps.selectedCamera.name
    });
    return React.createElement(react.Stack, { horizontalAlign: "end" }, showCameraSwitcherInLocalPreview && (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.cameras) !== undefined && (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.selectedCamera) !== undefined && (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.onSelectCamera) !== undefined && React.createElement(LocalVideoCameraCycleButton, { cameras: localVideoCameraCycleButtonProps.cameras, selectedCamera: localVideoCameraCycleButtonProps.selectedCamera, onSelectCamera: localVideoCameraCycleButtonProps.onSelectCamera, label: localVideoCameraSwitcherLabel, ariaDescription: ariaDescription }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const rootLayoutStyle$1 = {
    root: {
        position: 'relative',
        height: '100%',
        width: '100%',
        padding: '0.5rem'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const videoGalleryLayoutGap = {
    childrenGap: '0.5rem'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Calculates the participants that should be rendered based on the list of dominant
 * speakers and currently rendered participants in a call.
 * @param args - SmartDominantSpeakerParticipantsArgs
 * @returns VideoGalleryRemoteParticipant[] {@link @azure/communication-react#VideoGalleryRemoteParticipant}
 */
const smartDominantSpeakerParticipants = (args) => {
    const { participants, dominantSpeakers = [], lastVisibleParticipants = [], maxDominantSpeakers } = args;
    // Don't apply any logic if total number of video streams is less than max dominant speakers.
    if (participants.length <= maxDominantSpeakers) {
        return participants;
    }
    const participantsMap = participantsById(participants);
    // Only use the Max allowed dominant speakers that exist in participants
    const dominantSpeakerIds = dominantSpeakers.filter(id => !!participantsMap[id]).slice(0, maxDominantSpeakers);
    const newVisibleParticipantIds = lastVisibleParticipants.map(p => p.userId).slice(0, maxDominantSpeakers);
    const newDominantSpeakerIds = dominantSpeakerIds.filter(id => !newVisibleParticipantIds.includes(id));
    // Remove participants that are no longer dominant and replace them with new dominant speakers.
    for (let index = 0; index < maxDominantSpeakers; index++) {
        const newVisibleParticipantId = newVisibleParticipantIds[index];
        if (newVisibleParticipantId === undefined || !dominantSpeakerIds.includes(newVisibleParticipantId)) {
            const replacement = newDominantSpeakerIds.shift();
            if (!replacement) {
                break;
            }
            newVisibleParticipantIds[index] = replacement;
        }
    }
    let newVisibleParticipants = newVisibleParticipantIds.map(participantId => participantsMap[participantId]).filter(p => p !== undefined);
    const newVisibleParticipantIdsSet = new Set(newVisibleParticipantIds);
    const remainingParticipants = participants.filter(p => !newVisibleParticipantIdsSet.has(p.userId));
    newVisibleParticipants = newVisibleParticipants.concat(remainingParticipants);
    return newVisibleParticipants;
};
/**
 * maps the participants array to an object with userId as key
 * @private
 */
const participantsById = (participants) => {
    const response = {};
    participants.forEach(p => response[p.userId] = p);
    return response;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const DEFAULT_MAX_OVERFLOW_GALLERY_DOMINANT_SPEAKERS = 6;
const DEFAULT_MAX_VIDEO_SREAMS = 4;
const MAX_GRID_PARTICIPANTS_NOT_LARGE_GALLERY = 9;
const _useOrganizedParticipants = (props) => {
    const visibleGridParticipants = React.useRef([]);
    const visibleOverflowGalleryParticipants = React.useRef([]);
    const { remoteParticipants = [], dominantSpeakers = [], maxRemoteVideoStreams = DEFAULT_MAX_VIDEO_SREAMS, maxOverflowGalleryDominantSpeakers = DEFAULT_MAX_OVERFLOW_GALLERY_DOMINANT_SPEAKERS, isScreenShareActive = false, pinnedParticipantUserIds = [], layout } = props;
    const calculateMaxRemoteVideoStreams = () => {
        if (maxRemoteVideoStreams > MAX_GRID_PARTICIPANTS_NOT_LARGE_GALLERY) {
            return MAX_GRID_PARTICIPANTS_NOT_LARGE_GALLERY;
        }
        else {
            return maxRemoteVideoStreams;
        }
    };
    const maxRemoteVideoStreamsToUse = calculateMaxRemoteVideoStreams();
    const videoParticipants = remoteParticipants.filter(p => { var _a; return (_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable; });
    const participantsToSortTrampoline = () => {
        return layout !== 'floatingLocalVideo' ? putVideoParticipantsFirst(remoteParticipants) : videoParticipants;
    };
    visibleGridParticipants.current = pinnedParticipantUserIds.length > 0 || isScreenShareActive ? [] : smartDominantSpeakerParticipants({
        participants: participantsToSortTrampoline(),
        dominantSpeakers,
        lastVisibleParticipants: visibleGridParticipants.current,
        maxDominantSpeakers: maxRemoteVideoStreamsToUse
    }).slice(0, maxRemoteVideoStreamsToUse);
    const dominantSpeakerToGrid = layout === 'speaker' ? dominantSpeakers && dominantSpeakers[0] ? visibleGridParticipants.current.filter(p => p.userId === dominantSpeakers[0]) : [visibleGridParticipants.current[0]] : [];
    if (dominantSpeakerToGrid[0]) {
        visibleGridParticipants.current = dominantSpeakerToGrid;
    }
    const visibleGridParticipantsSet = new Set(visibleGridParticipants.current.map(p => p.userId));
    const remoteParticipantsOrdered = putVideoParticipantsFirst(remoteParticipants);
    visibleOverflowGalleryParticipants.current = smartDominantSpeakerParticipants({
        participants: remoteParticipantsOrdered.filter(p => !visibleGridParticipantsSet.has(p.userId)),
        dominantSpeakers: dominantSpeakers,
        lastVisibleParticipants: visibleOverflowGalleryParticipants.current,
        maxDominantSpeakers: maxOverflowGalleryDominantSpeakers
    });
    const getGridParticipants = React.useCallback(() => {
        if (isScreenShareActive) {
            return [];
        }
        // if we have no grid participants we need to cap the max number of overflowGallery participants in the grid
        // we will use the max streams provided to the function to find the max participants that can go in the grid
        // if there are less participants than max streams then we will use all participants including joining in the grid
        return visibleGridParticipants.current.length > 0 ? visibleGridParticipants.current : visibleOverflowGalleryParticipants.current.slice(0, maxRemoteVideoStreamsToUse);
    }, [isScreenShareActive, maxRemoteVideoStreamsToUse]);
    const gridParticipants = getGridParticipants();
    const getOverflowGalleryRemoteParticipants = React.useCallback(() => {
        if (isScreenShareActive) {
            // If screen sharing is active, assign video and audio participants as overflow gallery participants
            return visibleGridParticipants.current.concat(visibleOverflowGalleryParticipants.current);
        }
        else {
            // If screen sharing is not active, then assign all video tiles as grid tiles.
            // If there are no video tiles, then assign audio tiles as grid tiles.
            // if there are more overflow tiles than max streams then find the tiles that don't fit in the grid and put them in overflow
            // overflow should be empty if total participants including calling participants is less than max streams
            return visibleGridParticipants.current.length > 0 ? visibleOverflowGalleryParticipants.current : visibleOverflowGalleryParticipants.current.slice(maxRemoteVideoStreamsToUse);
        }
    }, [isScreenShareActive, maxRemoteVideoStreamsToUse]);
    const overflowGalleryParticipants = getOverflowGalleryRemoteParticipants();
    return {
        gridParticipants,
        overflowGalleryParticipants: overflowGalleryParticipants
    };
};
const _useOrganizedParticipantsWithFocusedParticipants = (props) => {
    var _a, _b;
    // map remote participants by userId
    const remoteParticipantMap = props.remoteParticipants.reduce((map, remoteParticipant) => {
        map[remoteParticipant.userId] = remoteParticipant;
        return map;
    }, {});
    const spotlightedParticipantUserIds = (_a = props.spotlightedParticipantUserIds) !== null && _a !== void 0 ? _a : [];
    // declare focused participant user ids as spotlighted participants user ids followed by
    // pinned participants user ids
    const focusedParticipantUserIds = [...new Set(spotlightedParticipantUserIds.concat((_b = props.pinnedParticipantUserIds) !== null && _b !== void 0 ? _b : []))];
    // get focused participants from map of remote participants in the order of the user ids
    const focusedParticipants = [];
    focusedParticipantUserIds.forEach(id => {
        const pinnedParticipant = remoteParticipantMap[id];
        if (pinnedParticipant) {
            focusedParticipants.push(pinnedParticipant);
        }
    });
    // get unfocused participants by filtering out set of focused participant user ids from all remote participants
    const focusedParticipantUserIdSet = new Set(focusedParticipantUserIds);
    const unfocusedParticipants = props.remoteParticipants.filter(p => !focusedParticipantUserIdSet.has(p.userId));
    const useOrganizedParticipantsProps = Object.assign(Object.assign({}, props), { 
        // if there are pinned participants then we should only consider unpinned participants
        remoteParticipants: unfocusedParticipants });
    const useOrganizedParticipantsResult = _useOrganizedParticipants(useOrganizedParticipantsProps);
    if (focusedParticipants.length === 0) {
        return useOrganizedParticipantsResult;
    }
    return {
        gridParticipants: props.isScreenShareActive ? [] : focusedParticipants,
        overflowGalleryParticipants: props.isScreenShareActive ? focusedParticipants.concat(useOrganizedParticipantsResult.overflowGalleryParticipants) : useOrganizedParticipantsResult.gridParticipants.concat(useOrganizedParticipantsResult.overflowGalleryParticipants)
    };
};
const putVideoParticipantsFirst = (remoteParticipants) => {
    const videoParticipants = [];
    const audioParticipants = [];
    remoteParticipants.forEach(p => {
        var _a;
        if ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) {
            videoParticipants.push(p);
        }
        else {
            audioParticipants.push(p);
        }
    });
    const remoteParticipantSortedByVideo = videoParticipants.concat(audioParticipants);
    return remoteParticipantSortedByVideo;
};
/**
 * Hook to determine which participants should be in grid and overflow gallery and their order respectively
 * @private
 */
const useOrganizedParticipants = (args) => {
    return _useOrganizedParticipantsWithFocusedParticipants(args);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Horizontal Gallery button width in rem
 */
const HORIZONTAL_GALLERY_BUTTON_WIDTH = 1.75;
/**
 * @private
 */
const leftRightButtonStyles$1 = (theme) => {
    return {
        background: 'none',
        padding: 0,
        height: 'auto',
        minWidth: `${HORIZONTAL_GALLERY_BUTTON_WIDTH}rem`,
        maxWidth: `${HORIZONTAL_GALLERY_BUTTON_WIDTH}rem`,
        border: `1px solid ${theme.palette.neutralLight}`,
        borderRadius: theme.effects.roundedCorner4
    };
};
/**
 * Horizontal Gallery gap size in rem between tiles and buttons
 */
const HORIZONTAL_GALLERY_GAP = 0.5;
/**
 * @private
 */
const rootStyle$1 = {
    height: '100%',
    width: '100%',
    gap: `${HORIZONTAL_GALLERY_GAP}rem`
};
/**
 * @private
 */
const childrenContainerStyle$1 = {
    height: '100%',
    width: '100%',
    gap: `${HORIZONTAL_GALLERY_GAP}rem`
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Helper function to bucketize a given array of items into buckets of a specified size.
 *
 * @param arr array to bucketize
 * @param bucketSize number of children for each bucket
 * @returns nested array of given children
 *
 * @private
 */
function bucketize(arr, bucketSize) {
    const bucketArray = [];
    if (bucketSize <= 0) {
        return bucketArray;
    }
    for (let i = 0; i < arr.length; i += bucketSize) {
        bucketArray.push(arr.slice(i, i + bucketSize));
    }
    return bucketArray;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * {@link HorizontalGallery} default children per page
 */
const DEFAULT_CHILDREN_PER_PAGE = 5;
/**
 * Renders a horizontal gallery that parents children horizontally. Handles pagination based on the childrenPerPage prop.
 * @param props - HorizontalGalleryProps {@link @azure/communication-react#HorizontalGalleryProps}
 * @returns
 */
const HorizontalGallery = (props) => {
    var _a;
    const { children, childrenPerPage = DEFAULT_CHILDREN_PER_PAGE, styles, onFetchTilesToRender } = props;
    const ids = useIdentifiers();
    const [page, setPage] = React.useState(0);
    const numberOfChildren = React.Children.count(children);
    const lastPage = Math.ceil(numberOfChildren / childrenPerPage) - 1;
    const indexesArray = React.useMemo(() => {
        return bucketize([...Array(numberOfChildren).keys()], childrenPerPage);
    }, [numberOfChildren, childrenPerPage]);
    React.useEffect(() => {
        if (onFetchTilesToRender && indexesArray) {
            onFetchTilesToRender(indexesArray[page]);
        }
    }, [indexesArray, onFetchTilesToRender, page]);
    const firstIndexOfCurrentPage = page * childrenPerPage;
    const clippedPage = firstIndexOfCurrentPage < numberOfChildren - 1 ? page : lastPage;
    const childrenOnCurrentPage = React.useMemo(() => {
        if (indexesArray[0] !== undefined) {
            return indexesArray[clippedPage].map(index => {
                return React.Children.toArray(children)[index];
            });
        }
        return [];
    }, [indexesArray, clippedPage, children]);
    const showButtons = numberOfChildren > childrenPerPage;
    const disablePreviousButton = page === 0;
    const disableNextButton = page === lastPage;
    const childrenStyles = React.useMemo(() => {
        return {
            root: styles === null || styles === void 0 ? void 0 : styles.children
        };
    }, [styles === null || styles === void 0 ? void 0 : styles.children]);
    // If children per page is 0 or less return empty element
    if (childrenPerPage <= 0) {
        return React.createElement(React.Fragment, null);
    }
    return React.createElement(react.Stack, { horizontal: true, className: react.mergeStyles(rootStyle$1, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root) },
        showButtons && React.createElement(HorizontalGalleryNavigationButton, { key: "previous-nav-button", icon: React.createElement(react.Icon, { iconName: "HorizontalGalleryLeftButton" }), styles: styles === null || styles === void 0 ? void 0 : styles.previousButton, onClick: () => setPage(Math.max(0, Math.min(lastPage, page - 1))), disabled: disablePreviousButton, identifier: ids.overflowGalleryLeftNavButton }),
        React.createElement(react.Stack, { horizontal: true, className: react.mergeStyles(childrenContainerStyle$1) }, childrenOnCurrentPage.map((child, i) => {
            return React.createElement(react.Stack.Item, { styles: childrenStyles, key: i, "data-ui-id": ids.horizontalGalleryVideoTile }, child);
        })),
        showButtons && React.createElement(HorizontalGalleryNavigationButton, { key: "next-nav-button", icon: React.createElement(react.Icon, { iconName: "HorizontalGalleryRightButton" }), styles: styles === null || styles === void 0 ? void 0 : styles.nextButton, onClick: () => setPage(Math.min(lastPage, page + 1)), disabled: disableNextButton, identifier: ids.overflowGalleryRightNavButton }));
};
const HorizontalGalleryNavigationButton = (props) => {
    const theme = useTheme();
    return React.createElement(react.DefaultButton, { className: react.mergeStyles(leftRightButtonStyles$1(theme), props.styles), onClick: props.onClick, disabled: props.disabled, "data-ui-id": props.identifier }, props.icon);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
react.mergeStyles({
    position: 'relative',
    width: '100%',
    height: '100%'
});
/**
 * Small floating modal width and height in rem for small screen
 */
const SMALL_FLOATING_MODAL_SIZE_REM = {
    width: 3.625,
    height: 6.5
};
/**
 * Large floating modal width and height in rem for large screen
 * Aspect ratio: 16:9
 */
const LARGE_FLOATING_MODAL_SIZE_REM = {
    width: 13.438,
    height: 7.5
};
/**
 * Vertical gallery floating modal width and height in rem
 * Aspect ratio: 16:9
 */
const SHORT_VERTICAL_GALLERY_FLOATING_MODAL_SIZE_REM = {
    width: 9,
    height: 5.063
};
/**
 * Vertical gallery floating modal width and height in rem
 * Aspect ratio: 16:9
 */
const VERTICAL_GALLERY_FLOATING_MODAL_SIZE_REM = {
    width: 11,
    height: 6.25
};
/**
 * @private
 * z-index to ensure that the local video tile is above the video gallery.
 */
const LOCAL_VIDEO_TILE_ZINDEX = 2;
/**
 * @private
 */
const localVideoTileContainerStyle = (theme, localVideoTileSizeRem, screenSharePresent, overflowGalleryPosition) => {
    return {
        width: screenSharePresent ? `${localVideoTileSizeRem.width}rem` : '',
        height: screenSharePresent ? `${localVideoTileSizeRem.height}rem` : '',
        minWidth: screenSharePresent ? '' : `${localVideoTileSizeRem.width}rem`,
        minHeight: screenSharePresent ? '' : `${localVideoTileSizeRem.height}rem`,
        position: 'absolute',
        bottom: overflowGalleryPosition !== 'horizontalTop' ? `${dockedlocalVideoTileContainerPaddingRem}rem` : 'unset',
        top: overflowGalleryPosition === 'horizontalTop' ? `${dockedlocalVideoTileContainerPaddingRem}rem` : 'unset',
        borderRadius: theme.effects.roundedCorner4,
        overflow: 'hidden',
        right: `${dockedlocalVideoTileContainerPaddingRem}rem`
    };
};
/**
 * @private
 */
const localVideoTileWithControlsContainerStyle = (theme, localVideoTileSizeRem) => {
    return react.concatStyleSets(localVideoTileContainerStyle(theme, localVideoTileSizeRem), {
        root: {
            boxShadow: theme.effects.elevation8
        }
    });
};
/**
 * @private
 */
const floatingLocalVideoModalStyle = (theme, modalSizeRem) => {
    return react.concatStyleSets({
        main: react.mergeStyles(localVideoTileContainerStyle(theme, modalSizeRem), {
            bottom: `${floatinglocalVideoModalInitialPositionGapRem}rem`,
            right: `${floatinglocalVideoModalInitialPositionGapRem}rem`
        })
    }, {
        main: {
            boxShadow: theme.effects.elevation8,
            ':focus-within': {
                boxShadow: theme.effects.elevation16,
                border: `${_pxToRem(2)} solid ${theme.palette.neutralPrimary}`
            }
        }
    }, localVideoModalStyles);
};
/**
 * Initial position gap of the floating local video modal.
 * ie. if this is 1rem, then floating local video modal would initially be positioned 1rem from
 * the bottom and 1rem from the right.
 * @private
 */
const floatinglocalVideoModalInitialPositionGapRem = 1;
/**
 * Padding of the docked local video tile container.
 * @private
 */
const dockedlocalVideoTileContainerPaddingRem = 0.5;
/**
 * @private
 */
const floatingLocalVideoTileStyle = {
    root: {
        position: 'absolute',
        zIndex: LOCAL_VIDEO_TILE_ZINDEX,
        height: '100%',
        width: '100%'
    }
};
/**
 * Styles for the local video tile modal when it is focused, will cause keyboard move icon to appear over video
 * @private
 */
const localVideoModalStyles = {
    keyboardMoveIconContainer: {
        zIndex: LOCAL_VIDEO_TILE_ZINDEX + 1 // zIndex to set the keyboard movement Icon above the other layers in the video tile.
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const horizontalGalleryContainerStyle = (shouldFloatLocalVideo, isNarrow) => {
    return {
        minHeight: isNarrow ? `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem` : `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
        width: shouldFloatLocalVideo ? isNarrow ? `calc(100% - ${SMALL_FLOATING_MODAL_SIZE_REM.width}rem)` : `calc(100% - ${LARGE_FLOATING_MODAL_SIZE_REM.width}rem)` : '100%',
        paddingRight: '0.5rem'
    };
};
/**
 * @private
 */
const horizontalGalleryStyle = (isNarrow) => {
    return {
        children: isNarrow ? SMALL_HORIZONTAL_GALLERY_TILE_STYLE : LARGE_HORIZONTAL_GALLERY_TILE_STYLE
    };
};
/**
 * Small horizontal gallery tile size in rem
 * @private
 */
const SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM = {
    height: 6.5,
    width: 6.5
};
/**
 * Large horizontal gallery tile size in rem
 * @private
 */
const LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM = {
    height: 7.5,
    minWidth: 7.5,
    maxWidth: 13.43
};
/**
 * @private
 */
const SMALL_HORIZONTAL_GALLERY_TILE_STYLE = {
    minHeight: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    minWidth: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`,
    maxHeight: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    maxWidth: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`
};
/**
 * @private
 */
const LARGE_HORIZONTAL_GALLERY_TILE_STYLE = {
    minHeight: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    minWidth: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.minWidth}rem`,
    maxHeight: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    maxWidth: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.maxWidth}rem`,
    width: '100%',
    height: '100%'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * VerticalGallery tile size in rem:
 *
 * min - smallest possible size of the tile (90px)
 * max - Largest size we want the vertical tiles (144px)
 *
 * @private
 */
const SHORT_VERTICAL_GALLERY_TILE_SIZE_REM = {
    minHeight: 5.625,
    maxHeight: 9,
    width: 9
};
/**
 * VerticalGallery tile size in rem:
 *
 * min - smallest possible size of the tile (90px)
 * max - Largest size we want the vertical tiles (144px)
 *
 * @private
 */
const VERTICAL_GALLERY_TILE_SIZE_REM = {
    minHeight: 6.75,
    maxHeight: 11,
    width: 11
};
/**
 * Styles for the VerticalGallery's container set in parent.
 *
 * width is being increased by 1rem to account for the gap width desired for the VerticalGallery.
 *
 * @param shouldFloatLocalVideo whether rendered in floating layout or not
 * @returns Style set for VerticalGallery container.
 */
const verticalGalleryContainerStyle = (shouldFloatLocalVideo, isNarrow, isShort) => {
    return isNarrow && isShort ? {
        width: `${SHORT_VERTICAL_GALLERY_TILE_SIZE_REM.width}rem`,
        height: shouldFloatLocalVideo ? `calc(100% - ${SMALL_FLOATING_MODAL_SIZE_REM.height}rem)` : '100%',
        paddingBottom: '0.5rem'
    } : !isNarrow && isShort ? {
        width: `${SHORT_VERTICAL_GALLERY_TILE_SIZE_REM.width}rem`,
        height: shouldFloatLocalVideo ? `calc(100% - ${SHORT_VERTICAL_GALLERY_FLOATING_MODAL_SIZE_REM.height}rem)` : '100%',
        paddingBottom: '0.5rem'
    } : {
        width: `${VERTICAL_GALLERY_TILE_SIZE_REM.width}rem`,
        height: shouldFloatLocalVideo ? `calc(100% - ${VERTICAL_GALLERY_FLOATING_MODAL_SIZE_REM.height}rem)` : '100%',
        paddingBottom: '0.5rem'
    };
};
/**
 * @private
 */
const SHORT_VERTICAL_GALLERY_TILE_STYLE = {
    minHeight: `${SHORT_VERTICAL_GALLERY_TILE_SIZE_REM.minHeight}rem`,
    minWidth: `${SHORT_VERTICAL_GALLERY_TILE_SIZE_REM.width}rem`,
    maxHeight: `${SHORT_VERTICAL_GALLERY_TILE_SIZE_REM.maxHeight}rem`,
    maxWidth: `${SHORT_VERTICAL_GALLERY_TILE_SIZE_REM.width}rem`,
    width: '100%',
    height: '100%'
};
/**
 * @private
 */
const VERTICAL_GALLERY_TILE_STYLE = {
    minHeight: `${VERTICAL_GALLERY_TILE_SIZE_REM.minHeight}rem`,
    minWidth: `${VERTICAL_GALLERY_TILE_SIZE_REM.width}rem`,
    maxHeight: `${VERTICAL_GALLERY_TILE_SIZE_REM.maxHeight}rem`,
    maxWidth: `${VERTICAL_GALLERY_TILE_SIZE_REM.width}rem`,
    width: '100%',
    height: '100%'
};
/**
 * @private
 */
const verticalGalleryStyle = (isShort) => {
    return isShort ? {
        children: SHORT_VERTICAL_GALLERY_TILE_STYLE
    } : {
        children: VERTICAL_GALLERY_TILE_STYLE
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Helper function to calculate children per page for HorizontalGallery based on width of container, child, buttons, and
 * gaps in between
 *
 * @private
 */
const calculateHorizontalChildrenPerPage = (args) => {
    const { numberOfChildren, containerWidth, buttonWidthRem, gapWidthRem } = args;
    const childMinWidth = _convertRemToPx(LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.minWidth);
    const gapWidth = _convertRemToPx(gapWidthRem);
    /** First check how many children can fit in containerWidth.
     *    __________________________________
     *   |                ||                |
     *   |                ||                |
     *   |________________||________________|
     *   <-----------containerWidth--------->
     *  containerWidth = n * childWidth + (n - 1) * gapWidth. Isolate n and take the floor.
     */
    const numberOfChildrenInContainer = Math.floor((containerWidth + gapWidth) / (childMinWidth + gapWidth));
    // If all children fit then return numberOfChildrenInContainer
    if (numberOfChildren <= numberOfChildrenInContainer) {
        return numberOfChildrenInContainer;
    }
    const buttonWidth = _convertRemToPx(buttonWidthRem);
    /** We know we need to paginate. So we need to subtract the buttonWidth twice and gapWidth twice from
     * containerWidth to compute childrenSpace
     *   <-----------containerWidth--------->
     *    __________________________________
     *   | ||             ||             || |
     *   |<||             ||             ||>|
     *   |_||_____________||_____________||_|
     *       <-------childrenSpace------>
     */
    const childrenSpace = containerWidth - 2 * buttonWidth - 2 * gapWidth;
    // Now that we have childrenSpace width we can figure out how many children can fit in childrenSpace.
    // childrenSpace = n * childWidth + (n - 1) * gapWidth. Isolate n and take the floor.
    return Math.max(Math.floor((childrenSpace + gapWidth) / (childMinWidth + gapWidth)), 1);
};
/**
 * Helper function to find the number of children for the VerticalGallery on each page.
 *
 * @private
 */
const calculateVerticalChildrenPerPage = (args) => {
    const { numberOfChildren, containerHeight, gapHeightRem, controlBarHeight, isShort } = args;
    const childMinHeightPx = _convertRemToPx(isShort ? SHORT_VERTICAL_GALLERY_TILE_SIZE_REM.minHeight : VERTICAL_GALLERY_TILE_SIZE_REM.minHeight);
    const gapHeightPx = _convertRemToPx(gapHeightRem);
    const controlBarHeightPx = _convertRemToPx(controlBarHeight);
    /** First check how many children can fit in containerHeight.
     *
     *   _________________
     *   |                |
     *   |                |
     *   |________________|
     *    _________________
     *   |                |
     *   |                |
     *   |________________|
     *
     *      <   n/m   >
     *
     * number of children = container height - (2* gap height + button height) / childMinHeight
     *
     * we want to find the maximum number of children at the smallest size we can fit in the gallery and then resize them
     * to fill in the space as much as possible
     *
     * First we will find the max number of children without any controls we can fit.
     */
    const maxNumberOfChildrenInContainer = Math.floor((containerHeight + gapHeightPx) / (childMinHeightPx + gapHeightPx));
    // if all of the children fit in the container just return the number of children
    if (numberOfChildren <= maxNumberOfChildrenInContainer) {
        return maxNumberOfChildrenInContainer;
    }
    /**
     * For the pagination we know the container height, the height of the button bar and the 2 times the gap
     * height, top tile and bottom tile above control bar. So the child space is calculated as:
     *
     *      space = height - controlbar - (2 * gap)
     */
    const childSpace = containerHeight - controlBarHeightPx - 2 * gapHeightPx;
    /**
     * Now that we have the childrenSpace height we can figure out how many Children can fir in the childrenSpace.
     * childrenSpace = n * childHeightMin + (n - 1) * gapHeight. isolate n and take the floor.
     *
     * We want to always return at least one video tile if there are children present.So we take the max.
     */
    return Math.max(Math.floor((childSpace + gapHeightPx) / (childMinHeightPx + gapHeightPx)), 1);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Wrapped HorizontalGallery that adjusts the number of items per page based on the
 * available width obtained from a ResizeObserver, width per child, gap width, and button width
 */
const ResponsiveHorizontalGallery = (props) => {
    const { gapWidthRem, buttonWidthRem = 0, onFetchTilesToRender, onChildrenPerPageChange } = props;
    const containerRef = React.useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const leftPadding = containerRef.current ? parseFloat(getComputedStyle(containerRef.current).paddingLeft) : 0;
    const rightPadding = containerRef.current ? parseFloat(getComputedStyle(containerRef.current).paddingRight) : 0;
    const childrenPerPage = calculateHorizontalChildrenPerPage({
        numberOfChildren: React.Children.count(props.children),
        containerWidth: (containerWidth !== null && containerWidth !== void 0 ? containerWidth : 0) - leftPadding - rightPadding,
        gapWidthRem,
        buttonWidthRem
    });
    onChildrenPerPageChange === null || onChildrenPerPageChange === void 0 ? void 0 : onChildrenPerPageChange(childrenPerPage);
    return React.createElement("div", { "data-ui-id": "responsive-horizontal-gallery", ref: containerRef, className: react.mergeStyles(props.containerStyles) },
        React.createElement(HorizontalGallery, { childrenPerPage: childrenPerPage, styles: props.horizontalGalleryStyles, onFetchTilesToRender: onFetchTilesToRender }, props.children));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Vertical Gallery gap size in rem between tiles and buttons
 *
 * @private
 */
const VERTICAL_GALLERY_GAP = 0.5;
/**
 * @private
 */
const childrenContainerStyle = (pageControlBarHeight) => {
    return {
        width: '100%',
        height: `calc(100% - ${pageControlBarHeight + VERTICAL_GALLERY_GAP}rem)`,
        gap: `${VERTICAL_GALLERY_GAP}rem`
    };
};
/**
 * @private
 */
const rootStyle = {
    height: '100%',
    width: 'inherit',
    // this needs to inherit its parent's width otherwise will collapse if there are no children.
    gap: `${VERTICAL_GALLERY_GAP}rem`,
    position: 'relative'
};
/**
 * @private
 */
const pageNavigationControlBarContainerStyle = {
    height: '2rem',
    width: '100%',
    position: 'absolute',
    bottom: '0'
};
/**
 * @private
 */
const leftRightButtonStyles = (theme) => {
    return {
        background: 'none',
        padding: 0,
        height: 'auto',
        borderRadius: theme.effects.roundedCorner4,
        border: 'none',
        minWidth: '2rem'
    };
};
/**
 * @private
 */
const participantPageCounter = {
    lineHeight: '2rem',
    width: '100%',
    textAlign: 'center'
};
/**
 * @private
 */
const navIconStyles = {
    root: {
        lineHeight: '0'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * VerticalGallery is a overflow gallery for participants in the {@link VideoGallery} component. Stacks
 * participants on the Y-axis of the VideoGallery for better use of horizontal space.
 *
 * @public
 */
const VerticalGallery = (props) => {
    const { children, styles, childrenPerPage, onFetchTilesToRender } = props;
    const [page, setPage] = React.useState(1);
    const [buttonState, setButtonState] = React.useState({
        previous: true,
        next: true
    });
    /* @conditional-compile-remove(vertical-gallery) */
    const ids = useIdentifiers();
    const numberOfChildren = React.Children.count(children);
    const lastPage = Math.ceil(numberOfChildren / childrenPerPage);
    const indexesArray = React.useMemo(() => {
        return bucketize([...Array(numberOfChildren).keys()], childrenPerPage);
    }, [numberOfChildren, childrenPerPage]);
    React.useEffect(() => {
        if (onFetchTilesToRender && indexesArray) {
            onFetchTilesToRender(indexesArray[page - 1]);
        }
    }, [indexesArray, onFetchTilesToRender, page]);
    const firstIndexOfCurrentPage = (page - 1) * childrenPerPage;
    const clippedPage = firstIndexOfCurrentPage < numberOfChildren - 1 ? page : lastPage;
    const childrenOnCurrentPage = React.useMemo(() => {
        if (indexesArray[0] !== undefined) {
            return indexesArray[clippedPage - 1].map(index => {
                return React.Children.toArray(children)[index];
            });
        }
        return;
    }, [indexesArray, clippedPage, children]);
    const showButtons = numberOfChildren > childrenPerPage;
    const onPreviousButtonClick = () => {
        setPage(page - 1);
    };
    const onNextButtonClick = () => {
        setPage(page + 1);
    };
    if (page > lastPage && lastPage > 0) {
        setPage(lastPage);
    }
    React.useEffect(() => {
        if (page > 1 && page < lastPage && showButtons) {
            // we are somewhere in between first and last pages.
            setButtonState({
                previous: false,
                next: false
            });
        }
        else if (page === 1 && showButtons) {
            // we are on the first page.
            setButtonState({
                previous: true,
                next: false
            });
        }
        else if (page === lastPage && showButtons) {
            // we are on the last page.
            setButtonState({
                previous: false,
                next: true
            });
        }
    }, [page, numberOfChildren, lastPage, showButtons]);
    const childContainerStyle = React.useMemo(() => {
        return {
            root: childrenContainerStyle(2)
        };
    }, []);
    const childrenStyles = React.useMemo(() => {
        return {
            root: styles === null || styles === void 0 ? void 0 : styles.children
        };
    }, [styles === null || styles === void 0 ? void 0 : styles.children]);
    if (childrenPerPage <= 0) {
        return React.createElement(React.Fragment, null);
    }
    return React.createElement(react.Stack, { className: react.mergeStyles(rootStyle, styles === null || styles === void 0 ? void 0 : styles.root) },
        React.createElement(react.Stack, { styles: childContainerStyle }, childrenOnCurrentPage === null || childrenOnCurrentPage === void 0 ? void 0 : childrenOnCurrentPage.map((child, i) => {
            return React.createElement(react.Stack.Item, { key: i, styles: childrenStyles, "data-ui-id": ids.verticalGalleryVideoTile }, child);
        })),
        showButtons && React.createElement(VerticalGalleryControlBar, { buttonsDisabled: buttonState, onPreviousButtonClick: onPreviousButtonClick, onNextButtonClick: onNextButtonClick, totalPages: lastPage, currentPage: page }));
};
const VerticalGalleryControlBar = (props) => {
    const { onNextButtonClick, onPreviousButtonClick, buttonsDisabled, currentPage, totalPages, styles } = props;
    const theme = useTheme();
    /* @conditional-compile-remove(vertical-gallery) */
    const ids = useIdentifiers();
    /* @conditional-compile-remove(vertical-gallery) */
    const strings = useLocale$1().strings.verticalGallery;
    const pageCounterContainerStyles = React.useMemo(() => {
        return react.mergeStyles(pageNavigationControlBarContainerStyle, styles === null || styles === void 0 ? void 0 : styles.root);
    }, [styles === null || styles === void 0 ? void 0 : styles.root]);
    const previousButtonSyles = React.useMemo(() => {
        return react.mergeStyles(leftRightButtonStyles(theme), styles === null || styles === void 0 ? void 0 : styles.previousButton);
    }, [styles === null || styles === void 0 ? void 0 : styles.previousButton, theme]);
    const pageCounterStyles = React.useMemo(() => {
        return react.mergeStyles(participantPageCounter, styles === null || styles === void 0 ? void 0 : styles.counter);
    }, [styles === null || styles === void 0 ? void 0 : styles.counter]);
    const nextButtonsStyles = React.useMemo(() => {
        return react.mergeStyles(leftRightButtonStyles(theme), styles === null || styles === void 0 ? void 0 : styles.nextButton);
    }, [styles === null || styles === void 0 ? void 0 : styles.nextButton, theme]);
    const controlBarSpacing = {
        childrenGap: '0.5rem'
    };
    return React.createElement(react.Stack, { horizontalAlign: "center", tokens: controlBarSpacing, horizontal: true, className: pageCounterContainerStyles },
        React.createElement(react.DefaultButton, { className: previousButtonSyles, onClick: onPreviousButtonClick, disabled: buttonsDisabled === null || buttonsDisabled === void 0 ? void 0 : buttonsDisabled.previous, 
            /* @conditional-compile-remove(vertical-gallery) */ ariaLabel: strings.leftNavButtonAriaLabel, "data-ui-id": ids.overflowGalleryLeftNavButton },
            React.createElement(react.Icon, { iconName: "VerticalGalleryLeftButton", styles: navIconStyles })),
        React.createElement(react.Text
        /* @conditional-compile-remove(vertical-gallery) */ , { "data-ui-id": ids.verticalGalleryPageCounter, className: pageCounterStyles }, `${currentPage} / ${totalPages}`),
        React.createElement(react.DefaultButton, { className: nextButtonsStyles, onClick: onNextButtonClick, disabled: buttonsDisabled === null || buttonsDisabled === void 0 ? void 0 : buttonsDisabled.next, 
            /* @conditional-compile-remove(vertical-gallery) */ ariaLabel: strings.rightNavButtonAriaLabel, "data-ui-id": ids.overflowGalleryRightNavButton },
            React.createElement(react.Icon, { iconName: "VerticalGalleryRightButton", styles: navIconStyles })));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Responsive container for the VerticalGallery Component. Performs calculations for number of children
 * for the VerticalGallery
 * @param props
 *
 * @beta
 */
const ResponsiveVerticalGallery = (props) => {
    var _a;
    const { children, containerStyles, verticalGalleryStyles, gapHeightRem, controlBarHeightRem, isShort, onFetchTilesToRender, onChildrenPerPageChange } = props;
    const containerRef = React.useRef(null);
    const containerHeight = _useContainerHeight(containerRef);
    const topPadding = containerRef.current ? parseFloat(getComputedStyle(containerRef.current).paddingTop) : 0;
    const bottomPadding = containerRef.current ? parseFloat(getComputedStyle(containerRef.current).paddingBottom) : 0;
    const childrenPerPage = calculateVerticalChildrenPerPage({
        numberOfChildren: (_a = React.Children.count(children)) !== null && _a !== void 0 ? _a : 0,
        containerHeight: (containerHeight !== null && containerHeight !== void 0 ? containerHeight : 0) - topPadding - bottomPadding,
        gapHeightRem,
        controlBarHeight: controlBarHeightRem !== null && controlBarHeightRem !== void 0 ? controlBarHeightRem : 2,
        isShort: isShort !== null && isShort !== void 0 ? isShort : false
    });
    onChildrenPerPageChange === null || onChildrenPerPageChange === void 0 ? void 0 : onChildrenPerPageChange(childrenPerPage);
    return React.createElement("div", { "data-ui-id": "responsive-vertical-gallery", ref: containerRef, className: react.mergeStyles(containerStyles) },
        React.createElement(VerticalGallery, { childrenPerPage: childrenPerPage, styles: verticalGalleryStyles, onFetchTilesToRender: onFetchTilesToRender }, children));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const scrollableHorizontalGalleryStyles = {
    root: {
        width: '100%',
        minHeight: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
        paddingRight: '0.5rem',
        '> *': SMALL_HORIZONTAL_GALLERY_TILE_STYLE
    }
};
/**
 * @private
 */
const scrollableHorizontalGalleryContainerStyles = {
    display: 'flex',
    minHeight: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    overflow: 'scroll',
    '-ms-overflow-style': 'none',
    'scrollbar-width': 'none',
    '::-webkit-scrollbar': {
        display: 'none'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Component to display elements horizontally in a scrollable container
 * @private
 */
const ScrollableHorizontalGallery = (props) => {
    const { horizontalGalleryElements, onFetchTilesToRender, containerStyles } = props;
    React.useEffect(() => {
        const indexesArray = [...Array(horizontalGalleryElements === null || horizontalGalleryElements === void 0 ? void 0 : horizontalGalleryElements.length).keys()];
        if (onFetchTilesToRender && indexesArray) {
            onFetchTilesToRender(indexesArray);
        }
    }, [onFetchTilesToRender, horizontalGalleryElements === null || horizontalGalleryElements === void 0 ? void 0 : horizontalGalleryElements.length]);
    const ref = React.useRef();
    const { events: dragabbleEvents } = reactUseDraggableScroll.useDraggable(ref);
    return React.createElement("div", Object.assign({ ref: ref }, dragabbleEvents, { className: react.mergeStyles(scrollableHorizontalGalleryContainerStyles, containerStyles) }),
        React.createElement(react.Stack, { "data-ui-id": "scrollable-horizontal-gallery", horizontal: true, styles: scrollableHorizontalGalleryStyles, tokens: {
                childrenGap: '0.5rem'
            } }, horizontalGalleryElements));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A ResponsiveHorizontalGallery styled for the {@link VideoGallery}
 *
 * @private
 */
const OverflowGallery = (props) => {
    const { shouldFloatLocalVideo = false, onFetchTilesToRender, isNarrow = false, 
    /* @conditional-compile-remove(vertical-gallery) */
    isShort = false, overflowGalleryElements, horizontalGalleryStyles, 
    /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition = 'horizontalBottom', 
    /* @conditional-compile-remove(vertical-gallery) */ verticalGalleryStyles, onChildrenPerPageChange, parentWidth } = props;
    const containerStyles = React.useMemo(() => {
        /* @conditional-compile-remove(vertical-gallery) */
        if (overflowGalleryPosition === 'verticalRight') {
            return verticalGalleryContainerStyle(shouldFloatLocalVideo, isNarrow, isShort);
        }
        return horizontalGalleryContainerStyle(shouldFloatLocalVideo, isNarrow);
    }, [shouldFloatLocalVideo, /* @conditional-compile-remove(vertical-gallery) */ isShort, isNarrow, /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition]);
    const galleryStyles = React.useMemo(() => {
        /* @conditional-compile-remove(vertical-gallery) */
        if (overflowGalleryPosition === 'verticalRight') {
            return react.concatStyleSets(verticalGalleryStyle(isShort), verticalGalleryStyles);
        }
        return react.concatStyleSets(horizontalGalleryStyle(isNarrow), horizontalGalleryStyles);
    }, [isNarrow, /* @conditional-compile-remove(vertical-gallery) */ isShort, horizontalGalleryStyles, /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition, /* @conditional-compile-remove(vertical-gallery) */ verticalGalleryStyles]);
    const scrollableHorizontalGalleryContainerStyles = React.useMemo(() => {
        if (isNarrow && parentWidth) {
            return {
                width: shouldFloatLocalVideo ? `${_convertPxToRem(parentWidth) - SMALL_FLOATING_MODAL_SIZE_REM.width - 1}rem` : `${_convertPxToRem(parentWidth) - 1}rem`
            };
        }
        return undefined;
    }, [isNarrow, parentWidth, shouldFloatLocalVideo]);
    /* @conditional-compile-remove(vertical-gallery) */
    if (overflowGalleryPosition === 'verticalRight') {
        return React.createElement(ResponsiveVerticalGallery, { key: "responsive-vertical-gallery", containerStyles: containerStyles, verticalGalleryStyles: galleryStyles, controlBarHeightRem: HORIZONTAL_GALLERY_BUTTON_WIDTH, gapHeightRem: HORIZONTAL_GALLERY_GAP, isShort: isShort, onFetchTilesToRender: onFetchTilesToRender, onChildrenPerPageChange: onChildrenPerPageChange }, overflowGalleryElements ? overflowGalleryElements : [React.createElement(React.Fragment, null)]);
    }
    if (isNarrow) {
        // There are no pages for ScrollableHorizontalGallery so we will approximate the first 3 remote
        // participant tiles are visible
        onChildrenPerPageChange === null || onChildrenPerPageChange === void 0 ? void 0 : onChildrenPerPageChange(3);
        return React.createElement(ScrollableHorizontalGallery, { horizontalGalleryElements: overflowGalleryElements ? overflowGalleryElements : [React.createElement(React.Fragment, null)], onFetchTilesToRender: onFetchTilesToRender, key: "scrollable-horizontal-gallery", containerStyles: scrollableHorizontalGalleryContainerStyles });
    }
    return React.createElement(ResponsiveHorizontalGallery, { key: "responsive-horizontal-gallery", containerStyles: containerStyles, onFetchTilesToRender: onFetchTilesToRender, horizontalGalleryStyles: galleryStyles, buttonWidthRem: HORIZONTAL_GALLERY_BUTTON_WIDTH, gapWidthRem: HORIZONTAL_GALLERY_GAP, onChildrenPerPageChange: onChildrenPerPageChange }, overflowGalleryElements ? overflowGalleryElements : [React.createElement(React.Fragment, null)]);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * DefaultLayout displays remote participants, local video component, and screen sharing component in
 * a grid an overflow gallery.
 *
 * @private
 */
const DefaultLayout = (props) => {
    const { remoteParticipants = [], localParticipant, dominantSpeakers, localVideoComponent, screenShareComponent, onRenderRemoteParticipant, styles, maxRemoteVideoStreams, parentWidth, 
    /* @conditional-compile-remove(vertical-gallery) */
    parentHeight, pinnedParticipantUserIds = [], 
    /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition = 'horizontalBottom' } = props;
    const isNarrow = parentWidth ? isNarrowWidth(parentWidth) : false;
    /* @conditional-compile-remove(vertical-gallery) */
    const isShort = parentHeight ? isShortHeight(parentHeight) : false;
    // This is for tracking the number of children in the first page of overflow gallery.
    // This number will be used for the maxOverflowGalleryDominantSpeakers when organizing the remote participants.
    // We need to add the local participant to the pinned participant count so we are placing the speakers correctly.
    const childrenPerPage = React.useRef(4);
    const { gridParticipants, overflowGalleryParticipants } = useOrganizedParticipants({
        remoteParticipants,
        localParticipant,
        dominantSpeakers,
        maxRemoteVideoStreams,
        isScreenShareActive: !!screenShareComponent,
        maxOverflowGalleryDominantSpeakers: screenShareComponent ? childrenPerPage.current - (pinnedParticipantUserIds.length + 1) % childrenPerPage.current : childrenPerPage.current,
        pinnedParticipantUserIds,
        layout: 'default'
    });
    let activeVideoStreams = 0;
    let gridTiles = gridParticipants.map(p => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    /**
     * instantiate indexes available to render with indexes available that would be on first page
     *
     * For some components which do not strictly follow the order of the array, we might
     * re-render the initial tiles -> dispose them -> create new tiles, we need to take care of
     * this case when those components are here
     */
    const [indexesToRender, setIndexesToRender] = React.useState([]);
    let overflowGalleryTiles = overflowGalleryParticipants.map((p, i) => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && indexesToRender.includes(i) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    if (localVideoComponent) {
        if (screenShareComponent) {
            overflowGalleryTiles = [localVideoComponent].concat(overflowGalleryTiles);
        }
        else {
            gridTiles = [localVideoComponent].concat(gridTiles);
        }
    }
    const overflowGallery = React.useMemo(() => {
        if (overflowGalleryTiles.length === 0) {
            return null;
        }
        return React.createElement(OverflowGallery, { isNarrow: isNarrow, 
            /* @conditional-compile-remove(vertical-gallery) */ isShort: isShort, shouldFloatLocalVideo: false, overflowGalleryElements: overflowGalleryTiles, horizontalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, 
            /* @conditional-compile-remove(vertical-gallery) */ verticalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.verticalGallery, 
            /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition: overflowGalleryPosition, onFetchTilesToRender: setIndexesToRender, onChildrenPerPageChange: (n) => {
                childrenPerPage.current = n;
            }, parentWidth: parentWidth });
    }, [isNarrow, /* @conditional-compile-remove(vertical-gallery) */ isShort, overflowGalleryTiles, styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition, setIndexesToRender, /* @conditional-compile-remove(vertical-gallery) */ styles === null || styles === void 0 ? void 0 : styles.verticalGallery, parentWidth]);
    return React.createElement(react.Stack
    /* @conditional-compile-remove(vertical-gallery) */ , { 
        /* @conditional-compile-remove(vertical-gallery) */ horizontal: overflowGalleryPosition === 'verticalRight', styles: rootLayoutStyle$1, tokens: videoGalleryLayoutGap },
        props.overflowGalleryPosition === 'horizontalTop' ? overflowGallery : React.createElement(React.Fragment, null),
        screenShareComponent ? screenShareComponent : React.createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles),
        overflowGalleryTrampoline$2(overflowGallery, props.overflowGalleryPosition));
};
const overflowGalleryTrampoline$2 = (gallery, galleryPosition) => {
    return galleryPosition !== 'horizontalTop' ? gallery : React.createElement(React.Fragment, null);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint-disable react/prop-types */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
const animationDuration = react.AnimationVariables.durationValue2;
const ZERO = {
    x: 0,
    y: 0
};
const DEFAULT_PROPS = {
    isOpen: false,
    isDarkOverlay: true,
    className: '',
    containerClassName: '',
    enableAriaHiddenSiblings: true
};
const getModalClassNames = react.classNamesFunction();
const getMoveDelta = (ev) => {
    let delta = 10;
    if (ev.shiftKey) {
        if (!ev.ctrlKey) {
            delta = 50;
        }
    }
    else if (ev.ctrlKey) {
        delta = 1;
    }
    return delta;
};
const useComponentRef = (props, focusTrapZone) => {
    React__namespace.useImperativeHandle(props.componentRef, () => ({
        focus() {
            if (focusTrapZone.current) {
                focusTrapZone.current.focus();
            }
        }
    }), [focusTrapZone]);
};
const ModalBase = React__namespace.forwardRef((propsWithoutDefaults, ref) => {
    const props = react.getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
    const { allowTouchBodyScroll, className, children, containerClassName, scrollableContentClassName, elementToFocusOnDismiss, firstFocusableSelector, forceFocusInsideTrap, ignoreExternalFocusing, isBlocking, isAlert, isClickableOutsideFocusTrap, isDarkOverlay, onDismiss, layerProps, overlay, isOpen, titleAriaId, styles, subtitleAriaId, theme, topOffsetFixed, responsiveMode, onLayerDidMount, isModeless, dragOptions, onDismissed, minDragPosition, maxDragPosition } = props;
    const rootRef = React__namespace.useRef(null);
    const focusTrapZone = React__namespace.useRef(null);
    const focusTrapZoneElm = React__namespace.useRef(null);
    const mergedRef = reactHooks.useMergedRefs(rootRef, ref);
    const modalResponsiveMode = react.useResponsiveMode(mergedRef);
    const focusTrapZoneId = reactHooks.useId('ModalFocusTrapZone');
    const win = reactWindowProvider.useWindow();
    const { setTimeout, clearTimeout } = reactHooks.useSetTimeout();
    const [isModalOpen, setIsModalOpen] = React__namespace.useState(isOpen);
    const [isVisible, setIsVisible] = React__namespace.useState(isOpen);
    const [coordinates, setCoordinates] = React__namespace.useState(ZERO);
    const [modalRectangleTop, setModalRectangleTop] = React__namespace.useState();
    const [isModalMenuOpen, { toggle: toggleModalMenuOpen, setFalse: setModalMenuClose }] = reactHooks.useBoolean(false);
    const internalState = reactHooks.useConst(() => ({
        onModalCloseTimer: 0,
        allowTouchBodyScroll,
        scrollableContent: null,
        lastSetCoordinates: ZERO,
        events: new react.EventGroup({})
    }));
    const { keepInBounds } = dragOptions || {};
    const isAlertRole = isAlert !== null && isAlert !== void 0 ? isAlert : (isBlocking && !isModeless);
    const layerClassName = layerProps === undefined ? '' : layerProps.className;
    const classNames = getModalClassNames(styles, {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        theme: theme,
        className,
        containerClassName,
        scrollableContentClassName,
        isOpen,
        isVisible,
        hasBeenOpened: internalState.hasBeenOpened,
        modalRectangleTop,
        topOffsetFixed,
        isModeless,
        layerClassName,
        windowInnerHeight: win === null || win === void 0 ? void 0 : win.innerHeight,
        isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector
    });
    const mergedLayerProps = Object.assign(Object.assign({ eventBubblingEnabled: false }, layerProps), { onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount, insertFirst: isModeless, className: classNames.layer });
    // Allow the user to scroll within the modal but not on the body
    const allowScrollOnModal = React__namespace.useCallback((elt) => {
        if (elt) {
            if (internalState.allowTouchBodyScroll) {
                react.allowOverscrollOnElement(elt, internalState.events);
            }
            else {
                react.allowScrollOnElement(elt, internalState.events);
            }
        }
        else {
            internalState.events.off(internalState.scrollableContent);
        }
        internalState.scrollableContent = elt;
    }, [internalState]);
    const registerInitialModalPosition = () => {
        const dialogMain = focusTrapZoneElm.current;
        const modalRectangle = dialogMain === null || dialogMain === void 0 ? void 0 : dialogMain.getBoundingClientRect();
        if (modalRectangle) {
            if (topOffsetFixed) {
                setModalRectangleTop(modalRectangle.top);
            }
            if (keepInBounds) {
                // x/y are unavailable in IE, so use the equivalent left/top
                internalState.minPosition = minDragPosition !== null && minDragPosition !== void 0 ? minDragPosition : {
                    x: -modalRectangle.left,
                    y: -modalRectangle.top
                };
                internalState.maxPosition = maxDragPosition !== null && maxDragPosition !== void 0 ? maxDragPosition : {
                    x: modalRectangle.left,
                    y: modalRectangle.top
                };
                // Make sure the initial co-ordinates are within clamp bounds.
                setCoordinates({
                    x: getClampedAxis('x', coordinates.x),
                    y: getClampedAxis('y', coordinates.y)
                });
            }
        }
    };
    /**
     * Clamps an axis to a specified min and max position.
     *
     * @param axis A string that represents the axis (x/y).
     * @param position The position on the axis.
     */
    const getClampedAxis = React__namespace.useCallback((axis, position) => {
        const { minPosition, maxPosition } = internalState;
        if (keepInBounds && minPosition && maxPosition) {
            position = Math.max(minPosition[axis], position);
            position = Math.min(maxPosition[axis], position);
        }
        return position;
    }, [keepInBounds, internalState]);
    const handleModalClose = () => {
        var _a;
        internalState.lastSetCoordinates = ZERO;
        setModalMenuClose();
        internalState.isInKeyboardMoveMode = false;
        setIsModalOpen(false);
        setCoordinates(ZERO);
        (_a = internalState.disposeOnKeyUp) === null || _a === void 0 ? void 0 : _a.call(internalState);
        onDismissed === null || onDismissed === void 0 ? void 0 : onDismissed();
    };
    const handleDragStart = React__namespace.useCallback(() => {
        setModalMenuClose();
        internalState.isInKeyboardMoveMode = false;
    }, [internalState, setModalMenuClose]);
    const handleDrag = React__namespace.useCallback(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (ev, dragData) => {
        setCoordinates(prevValue => ({
            x: getClampedAxis('x', prevValue.x + dragData.delta.x),
            y: getClampedAxis('y', prevValue.y + dragData.delta.y)
        }));
    }, [getClampedAxis]);
    const handleDragStop = React__namespace.useCallback(() => {
        if (focusTrapZone.current) {
            focusTrapZone.current.focus();
        }
    }, []);
    const handleEnterKeyboardMoveMode = () => {
        // We need a global handleKeyDown event when we are in the move mode so that we can
        // handle the key presses and the components inside the modal do not get the events
        const handleKeyDown = (ev) => {
            if (ev.altKey && ev.ctrlKey && ev.keyCode === react.KeyCodes.space) {
                // CTRL + ALT + SPACE is handled during keyUp
                ev.preventDefault();
                ev.stopPropagation();
                return;
            }
            const newLocal = ev.altKey || ev.keyCode === react.KeyCodes.escape;
            if (isModalMenuOpen && newLocal) {
                setModalMenuClose();
            }
            if (internalState.isInKeyboardMoveMode && (ev.keyCode === react.KeyCodes.escape || ev.keyCode === react.KeyCodes.enter)) {
                internalState.isInKeyboardMoveMode = false;
                ev.preventDefault();
                ev.stopPropagation();
            }
            if (internalState.isInKeyboardMoveMode) {
                let handledEvent = true;
                const delta = getMoveDelta(ev);
                switch (ev.keyCode) {
                    /* eslint-disable no-fallthrough */
                    case react.KeyCodes.escape:
                        setCoordinates(internalState.lastSetCoordinates);
                    case react.KeyCodes.enter:
                        {
                            // TODO: determine if fallthrough was intentional
                            /* eslint-enable no-fallthrough */
                            internalState.lastSetCoordinates = ZERO;
                            // setIsInKeyboardMoveMode(false);
                            break;
                        }
                    case react.KeyCodes.up:
                        {
                            setCoordinates(prevValue => ({
                                x: prevValue.x,
                                y: getClampedAxis('y', prevValue.y - delta)
                            }));
                            break;
                        }
                    case react.KeyCodes.down:
                        {
                            setCoordinates(prevValue => ({
                                x: prevValue.x,
                                y: getClampedAxis('y', prevValue.y + delta)
                            }));
                            break;
                        }
                    case react.KeyCodes.left:
                        {
                            setCoordinates(prevValue => ({
                                x: getClampedAxis('x', prevValue.x - delta),
                                y: prevValue.y
                            }));
                            break;
                        }
                    case react.KeyCodes.right:
                        {
                            setCoordinates(prevValue => ({
                                x: getClampedAxis('x', prevValue.x + delta),
                                y: prevValue.y
                            }));
                            break;
                        }
                    default:
                        {
                            handledEvent = false;
                        }
                }
                if (handledEvent) {
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        internalState.lastSetCoordinates = coordinates;
        setModalMenuClose();
        internalState.isInKeyboardMoveMode = true;
        internalState.events.on(win, 'keydown', handleKeyDown, true /* useCapture */);
        internalState.disposeOnKeyDown = () => {
            internalState.events.off(win, 'keydown', handleKeyDown, true /* useCapture */);
            internalState.disposeOnKeyDown = undefined;
        };
    };
    const handleExitKeyboardMoveMode = () => {
        var _a;
        internalState.lastSetCoordinates = ZERO;
        internalState.isInKeyboardMoveMode = false;
        (_a = internalState.disposeOnKeyDown) === null || _a === void 0 ? void 0 : _a.call(internalState);
    };
    const registerForKeyUp = () => {
        const handleKeyUp = (ev) => {
            // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143
            if (ev.altKey && ev.ctrlKey && ev.keyCode === react.KeyCodes.space) {
                if (react.elementContains(internalState.scrollableContent, ev.target)) {
                    toggleModalMenuOpen();
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        if (!internalState.disposeOnKeyUp) {
            internalState.events.on(win, 'keyup', handleKeyUp, true /* useCapture */);
            internalState.disposeOnKeyUp = () => {
                internalState.events.off(win, 'keyup', handleKeyUp, true /* useCapture */);
                internalState.disposeOnKeyUp = undefined;
            };
        }
    };
    React__namespace.useEffect(() => {
        clearTimeout(internalState.onModalCloseTimer);
        // Opening the dialog
        if (isOpen) {
            // This must be done after the modal content has rendered
            requestAnimationFrame(() => setTimeout(registerInitialModalPosition, 0));
            setIsModalOpen(true);
            // Add a keyUp handler for all key up events once the dialog is open.
            if (dragOptions) {
                registerForKeyUp();
            }
            internalState.hasBeenOpened = true;
            setIsVisible(true);
        }
        // Closing the dialog
        if (!isOpen && isModalOpen) {
            internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);
            setIsVisible(false);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates or if min/max drag bounds are updated.
    }, [isModalOpen, isOpen, minDragPosition, maxDragPosition]);
    reactHooks.useUnmount(() => {
        internalState.events.dispose();
    });
    useComponentRef(props, focusTrapZone);
    const modalContent = React__namespace.createElement(react.FocusTrapZone, { disabled: true, id: focusTrapZoneId, ref: focusTrapZoneElm, componentRef: focusTrapZone, className: classNames.main, elementToFocusOnDismiss: elementToFocusOnDismiss, isClickableOutsideFocusTrap: isModeless || isClickableOutsideFocusTrap || !isBlocking, ignoreExternalFocusing: ignoreExternalFocusing, forceFocusInsideTrap: forceFocusInsideTrap && !isModeless, firstFocusableSelector: firstFocusableSelector, focusPreviouslyFocusedInnerElement: true, onBlur: internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined, "data-ui-id": props['data-ui-id'] },
        dragOptions && internalState.isInKeyboardMoveMode && React__namespace.createElement("div", { className: classNames.keyboardMoveIconContainer }, dragOptions.keyboardMoveIconProps ? React__namespace.createElement(react.Icon, Object.assign({}, dragOptions.keyboardMoveIconProps)) : React__namespace.createElement(react.Icon, { iconName: "move", className: classNames.keyboardMoveIcon })),
        React__namespace.createElement("div", { ref: allowScrollOnModal, className: classNames.scrollableContent, "data-is-scrollable": true },
            dragOptions && isModalMenuOpen && React__namespace.createElement(dragOptions.menu, { items: [{
                        key: 'move',
                        text: dragOptions.moveMenuItemText,
                        onClick: handleEnterKeyboardMoveMode
                    }, {
                        key: 'close',
                        text: dragOptions.closeMenuItemText,
                        onClick: handleModalClose
                    }], onDismiss: setModalMenuClose, alignTargetEdge: true, coverTarget: true, directionalHint: react.DirectionalHint.topLeftEdge, directionalHintFixed: true, shouldFocusOnMount: true, target: internalState.scrollableContent }),
            children));
    return (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    isModalOpen && modalResponsiveMode >= (responsiveMode || react.ResponsiveMode.small) && React__namespace.createElement(react.Layer, Object.assign({ ref: mergedRef }, mergedLayerProps),
        React__namespace.createElement(react.Popup, { role: isAlertRole ? 'alertdialog' : 'dialog', ariaLabelledBy: titleAriaId, ariaDescribedBy: subtitleAriaId, 
            // onDismiss={onDismiss}
            shouldRestoreFocus: !ignoreExternalFocusing, "aria-modal": !isModeless },
            React__namespace.createElement("div", { className: classNames.root, role: !isModeless ? 'document' : undefined },
                !isModeless && React__namespace.createElement(react.Overlay, Object.assign({ "aria-hidden": true, isDarkThemed: isDarkOverlay, onClick: isBlocking ? undefined : onDismiss, allowTouchBodyScroll: allowTouchBodyScroll }, overlay)),
                dragOptions ? React__namespace.createElement(DraggableZone, { handleSelector: dragOptions.dragHandleSelector || `#${focusTrapZoneId}`, preventDragSelector: "button", onStart: handleDragStart, onDragChange: handleDrag, onStop: handleDragStop, position: coordinates }, modalContent) : modalContent))) || null);
});
ModalBase.displayName = 'ModalBase';
const getDraggableZoneClassNames = react.memoizeFunction((className, isDragging) => {
    return {
        root: react.mergeStyles(className, isDragging && {
            touchAction: 'none',
            selectors: {
                '& *': {
                    userSelect: 'none'
                }
            }
        })
    };
});
const eventMapping = {
    touch: {
        start: 'touchstart',
        move: 'touchmove',
        stop: 'touchend'
    },
    mouse: {
        start: 'mousedown',
        move: 'mousemove',
        stop: 'mouseup'
    }
};
class DraggableZone extends React__namespace.Component {
    constructor(props) {
        super(props);
        this._currentEventType = eventMapping.mouse;
        this._events = [];
        this._onMouseDown = (event) => {
            const onMouseDown = React__namespace.Children.only(this.props.children).props.onMouseDown;
            if (onMouseDown) {
                onMouseDown(event);
            }
            this._currentEventType = eventMapping.mouse;
            return this._onDragStart(event);
        };
        this._onMouseUp = (event) => {
            const onMouseUp = React__namespace.Children.only(this.props.children).props.onMouseUp;
            if (onMouseUp) {
                onMouseUp(event);
            }
            this._currentEventType = eventMapping.mouse;
            return this._onDragStop(event);
        };
        this._onTouchStart = (event) => {
            const onTouchStart = React__namespace.Children.only(this.props.children).props.onTouchStart;
            if (onTouchStart) {
                onTouchStart(event);
            }
            this._currentEventType = eventMapping.touch;
            return this._onDragStart(event);
        };
        this._onTouchEnd = (event) => {
            const onTouchEnd = React__namespace.Children.only(this.props.children).props.onTouchEnd;
            if (onTouchEnd) {
                onTouchEnd(event);
            }
            this._currentEventType = eventMapping.touch;
            this._onDragStop(event);
        };
        this._onDragStart = (event) => {
            // Only handle left click for dragging
            if (typeof event.button === 'number' && event.button !== 0) {
                return false;
            }
            // If the target doesn't match the handleSelector OR
            // if the target does match the preventDragSelector, bail out
            if (this.props.handleSelector && !this._matchesSelector(event.target, this.props.handleSelector) || this.props.preventDragSelector && this._matchesSelector(event.target, this.props.preventDragSelector)) {
                return;
            }
            // Remember the touch identifier if this is a touch event so we can
            // distinguish between individual touches in multitouch scenarios
            // by remembering which touch point we were given
            this._touchId = this._getTouchId(event);
            const position = this._getControlPosition(event);
            if (position === undefined) {
                return;
            }
            const dragData = this._createDragDataFromPosition(position);
            this.props.onStart && this.props.onStart(event, dragData);
            this.setState({
                isDragging: true,
                lastPosition: position
            });
            // hook up the appropriate mouse/touch events to the body to ensure
            // smooth dragging
            this._events = [react.on(document.body, this._currentEventType.move, this._onDrag, true /* use capture phase */), react.on(document.body, this._currentEventType.stop, this._onDragStop, true /* use capture phase */)];
            return;
        };
        this._onDrag = (event) => {
            // Prevent scrolling on mobile devices
            if (event.type === 'touchmove') {
                event.preventDefault();
            }
            const position = this._getControlPosition(event);
            if (!position) {
                return;
            }
            // create the updated drag data from the position data
            const updatedData = this._createUpdatedDragData(this._createDragDataFromPosition(position));
            const updatedPosition = updatedData.position;
            this.props.onDragChange && this.props.onDragChange(event, updatedData);
            this.setState({
                position: updatedPosition,
                lastPosition: position
            });
        };
        this._onDragStop = (event) => {
            if (!this.state.isDragging) {
                return;
            }
            const position = this._getControlPosition(event);
            if (!position) {
                return;
            }
            const baseDragData = this._createDragDataFromPosition(position);
            // Set dragging to false and reset the lastPosition
            this.setState({
                isDragging: false,
                lastPosition: undefined
            });
            this.props.onStop && this.props.onStop(event, baseDragData);
            if (this.props.position) {
                this.setState({
                    position: this.props.position
                });
            }
            // Remove event handlers
            this._events.forEach(dispose => dispose());
        };
        this.state = {
            isDragging: false,
            position: this.props.position || {
                x: 0,
                y: 0
            },
            lastPosition: undefined
        };
    }
    componentDidUpdate(prevProps) {
        if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {
            this.setState({
                position: this.props.position
            });
        }
    }
    componentWillUnmount() {
        this._events.forEach(dispose => dispose());
    }
    render() {
        const child = React__namespace.Children.only(this.props.children);
        const { props } = child;
        const { position } = this.props;
        const { position: statePosition, isDragging } = this.state;
        let x = statePosition.x;
        let y = statePosition.y;
        if (position && !isDragging) {
            x = position.x;
            y = position.y;
        }
        return React__namespace.cloneElement(child, {
            style: Object.assign(Object.assign({}, props.style), { transform: `translate(${x}px, ${y}px)` }),
            className: getDraggableZoneClassNames(props.className, this.state.isDragging).root,
            onMouseDown: this._onMouseDown,
            onMouseUp: this._onMouseUp,
            onTouchStart: this._onTouchStart,
            onTouchEnd: this._onTouchEnd
        });
    }
    /**
     * Get the control position based off the event that fired
     * @param event - The event to get offsets from
     */
    _getControlPosition(event) {
        const touchObj = this._getActiveTouch(event);
        // did we get the right touch?
        if (this._touchId !== undefined && !touchObj) {
            return undefined;
        }
        const eventToGetOffset = touchObj || event;
        return {
            x: eventToGetOffset.clientX,
            y: eventToGetOffset.clientY
        };
    }
    /**
     * Get the active touch point that we have saved from the event's TouchList
     * @param event - The event used to get the TouchList for the active touch point
     */
    _getActiveTouch(event) {
        return event.targetTouches && this._findTouchInTouchList(event.targetTouches) || event.changedTouches && this._findTouchInTouchList(event.changedTouches);
    }
    /**
     * Get the initial touch identifier associated with the given event
     * @param event - The event that contains the TouchList
     */
    _getTouchId(event) {
        const touch = event.targetTouches && event.targetTouches[0] || event.changedTouches && event.changedTouches[0];
        if (touch) {
            return touch.identifier;
        }
        return;
    }
    /**
     * Returns if an element (or any of the element's parents) match the given selector
     */
    _matchesSelector(element, selector) {
        if (!element || element === document.body) {
            return false;
        }
        // eslint-disable-next-line @typescript-eslint/ban-types
        const matchesSelectorFn = element.matches || element.webkitMatchesSelector || element.msMatchesSelector; /* for IE */
        if (!matchesSelectorFn) {
            return false;
        }
        return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);
    }
    /**
     * Attempts to find the Touch that matches the identifier  we stored in dragStart
     * @param touchList The TouchList to look for the stored identifier from dragStart
     */
    _findTouchInTouchList(touchList) {
        if (this._touchId === undefined) {
            return;
        }
        for (let i = 0; i < touchList.length; i++) {
            if (touchList[i].identifier === this._touchId) {
                return touchList[i];
            }
        }
        return undefined;
    }
    /**
     * Create DragData based off of the last known position and the new position passed in
     * @param position The new position as part of the drag
     */
    _createDragDataFromPosition(position) {
        const { lastPosition } = this.state;
        // If we have no lastPosition, use the given position
        // for last position
        if (lastPosition === undefined) {
            return {
                delta: {
                    x: 0,
                    y: 0
                },
                lastPosition: position,
                position
            };
        }
        return {
            delta: {
                x: position.x - lastPosition.x,
                y: position.y - lastPosition.y
            },
            lastPosition,
            position
        };
    }
    /**
     * Creates an updated DragData based off the current position and given baseDragData
     * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions
     */
    _createUpdatedDragData(baseDragData) {
        const { position } = this.state;
        return {
            position: {
                x: position.x + baseDragData.delta.x,
                y: position.y + baseDragData.delta.y
            },
            delta: baseDragData.delta,
            lastPosition: position
        };
    }
}
const globalClassNames = {
    root: 'ms-Modal',
    main: 'ms-Dialog-main',
    scrollableContent: 'ms-Modal-scrollableContent',
    isOpen: 'is-open',
    layer: 'ms-Modal-Layer'
};
const getStyles = (props) => {
    const { className, containerClassName, scrollableContentClassName, isOpen, isVisible, hasBeenOpened, modalRectangleTop, theme, topOffsetFixed, isModeless, layerClassName, isDefaultDragHandle, windowInnerHeight } = props;
    const { palette, effects, fonts } = theme;
    const classNames = react.getGlobalClassNames(globalClassNames, theme);
    return {
        root: [classNames.root, fonts.medium, {
                backgroundColor: 'transparent',
                position: isModeless ? 'absolute' : 'fixed',
                height: '100%',
                width: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                opacity: 0,
                pointerEvents: 'none',
                transition: `opacity ${animationDuration}`
            }, topOffsetFixed && typeof modalRectangleTop === 'number' && hasBeenOpened && {
                alignItems: 'flex-start'
            }, isOpen && classNames.isOpen, isVisible && {
                opacity: 1,
                pointerEvents: 'auto'
            }, className],
        main: [classNames.main, {
                boxShadow: effects.elevation64,
                borderRadius: effects.roundedCorner2,
                backgroundColor: palette.white,
                boxSizing: 'border-box',
                position: 'relative',
                textAlign: 'left',
                outline: '3px solid transparent',
                maxHeight: 'calc(100% - 32px)',
                maxWidth: 'calc(100% - 32px)',
                minHeight: '176px',
                minWidth: '288px',
                overflowY: 'auto',
                zIndex: isModeless ? react.ZIndexes.Layer : undefined
            }, topOffsetFixed && typeof modalRectangleTop === 'number' && hasBeenOpened && {
                top: modalRectangleTop
            }, isDefaultDragHandle && {
                cursor: 'move'
            }, containerClassName],
        scrollableContent: [classNames.scrollableContent, {
                overflowY: 'auto',
                flexGrow: 1,
                maxHeight: '100vh',
                selectors: {
                    ['@supports (-webkit-overflow-scrolling: touch)']: {
                        maxHeight: windowInnerHeight
                    }
                }
            }, scrollableContentClassName],
        layer: isModeless && [layerClassName, classNames.layer, {
                position: 'static',
                width: 'unset',
                height: 'unset'
            }],
        keyboardMoveIconContainer: {
            position: 'absolute',
            display: 'flex',
            justifyContent: 'center',
            width: '100%',
            padding: '3px 0px'
        },
        keyboardMoveIcon: {
            fontSize: fonts.xLargePlus.fontSize,
            width: '24px'
        }
    };
};
/** @internal */
const _ModalClone = react.styled(ModalBase, getStyles, undefined, {
    scope: 'Modal',
    fields: ['theme', 'styles', 'enableAriaHiddenSiblings']
});
_ModalClone.displayName = 'Modal';

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const DRAG_OPTIONS$1 = {
    moveMenuItemText: 'Move',
    closeMenuItemText: 'Close',
    menu: react.ContextualMenu,
    keepInBounds: true
};
// Manually override the max position used to keep the modal in the bounds of its container.
// This is a workaround for: https://github.com/microsoft/fluentui/issues/20122
// Because our modal starts in the bottom right corner, we can say that this is the max (i.e. rightmost and bottomost)
// position the modal can be dragged to.
const modalMaxDragPosition = {
    x: _convertRemToPx(floatinglocalVideoModalInitialPositionGapRem),
    y: _convertRemToPx(floatinglocalVideoModalInitialPositionGapRem)
};
/**
 * @private
 */
const FloatingLocalVideo = (props) => {
    const { localVideoComponent, layerHostId, localVideoSizeRem, parentWidth, parentHeight } = props;
    const theme = useTheme();
    // The minimum drag position is the top left of the video gallery. i.e. the modal (PiP) should not be able
    // to be dragged offscreen and these are the top and left bounds of that calculation.
    const modalMinDragPosition = React.useMemo(() => parentWidth && parentHeight ? {
        // We use -parentWidth/Height because our modal is positioned to start in the bottom right,
        // hence (0,0) is the bottom right of the video gallery.
        x: -parentWidth + _convertRemToPx(localVideoSizeRem.width) + _convertRemToPx(floatinglocalVideoModalInitialPositionGapRem),
        y: -parentHeight + _convertRemToPx(localVideoSizeRem.height) + _convertRemToPx(floatinglocalVideoModalInitialPositionGapRem)
    } : undefined, [parentHeight, parentWidth, localVideoSizeRem.width, localVideoSizeRem.height]);
    const modalStyles = React.useMemo(() => floatingLocalVideoModalStyle(theme, localVideoSizeRem), [theme, localVideoSizeRem]);
    const layerProps = React.useMemo(() => ({
        hostId: layerHostId
    }), [layerHostId]);
    return React.createElement(_ModalClone, { isOpen: true, isModeless: true, dragOptions: DRAG_OPTIONS$1, styles: modalStyles, layerProps: layerProps, maxDragPosition: modalMaxDragPosition, minDragPosition: modalMinDragPosition, "data-ui-id": "floating-local-video-host" }, localVideoComponent);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const rootLayoutStyle = {
    root: {
        position: 'relative',
        height: '100%',
        width: '100%'
    }
};
/**
 * @private
 */
const innerLayoutStyle = {
    root: {
        position: 'relative',
        height: '100%',
        width: '100%',
        padding: '0.5rem'
    }
};
/**
 * @private
 */
const layerHostStyle = {
    position: 'absolute',
    left: 0,
    top: 0,
    width: '100%',
    height: '100%',
    overflow: 'hidden',
    // pointer events for layerHost set to none to make descendants interactive
    pointerEvents: 'none'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * FloatingLocalVideoLayout displays remote participants and a screen sharing component in
 * a grid and overflow gallery while floating the local video
 *
 * @private
 */
const FloatingLocalVideoLayout = (props) => {
    const { remoteParticipants = [], dominantSpeakers, localVideoComponent, screenShareComponent, onRenderRemoteParticipant, styles, maxRemoteVideoStreams, showCameraSwitcherInLocalPreview, parentWidth, parentHeight, 
    /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition = 'horizontalBottom', pinnedParticipantUserIds = [], 
    /* @conditional-compile-remove(click-to-call) */ localVideoTileSize } = props;
    const theme = useTheme();
    const isNarrow = parentWidth ? isNarrowWidth(parentWidth) : false;
    /* @conditional-compile-remove(vertical-gallery) */
    const isShort = parentHeight ? isShortHeight(parentHeight) : false;
    // This is for tracking the number of children in the first page of overflow gallery.
    // This number will be used for the maxOverflowGalleryDominantSpeakers when organizing the remote participants.
    const childrenPerPage = React.useRef(4);
    const { gridParticipants, overflowGalleryParticipants } = useOrganizedParticipants({
        remoteParticipants,
        dominantSpeakers,
        maxRemoteVideoStreams,
        isScreenShareActive: !!screenShareComponent,
        maxOverflowGalleryDominantSpeakers: screenShareComponent ? childrenPerPage.current - pinnedParticipantUserIds.length % childrenPerPage.current : childrenPerPage.current,
        pinnedParticipantUserIds,
        layout: 'floatingLocalVideo'
    });
    let activeVideoStreams = 0;
    const gridTiles = gridParticipants.map(p => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    const shouldFloatLocalVideo = remoteParticipants.length > 0;
    if (!shouldFloatLocalVideo && localVideoComponent) {
        gridTiles.push(localVideoComponent);
    }
    /**
     * instantiate indexes available to render with indexes available that would be on first page
     *
     * For some components which do not strictly follow the order of the array, we might
     * re-render the initial tiles -> dispose them -> create new tiles, we need to take care of
     * this case when those components are here
     */
    const [indexesToRender, setIndexesToRender] = React.useState([]);
    const overflowGalleryTiles = overflowGalleryParticipants.map((p, i) => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && indexesToRender && indexesToRender.includes(i) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    const layerHostId = reactHooks.useId('layerhost');
    const localVideoSizeRem = React.useMemo(() => {
        if (isNarrow || /*@conditional-compile-remove(click-to-call) */ localVideoTileSize === '9:16') {
            return SMALL_FLOATING_MODAL_SIZE_REM;
        }
        /* @conditional-compile-remove(vertical-gallery) */
        if ((overflowGalleryTiles.length > 0 || screenShareComponent) && overflowGalleryPosition === 'verticalRight') {
            return isNarrow ? SMALL_FLOATING_MODAL_SIZE_REM : isShort ? SHORT_VERTICAL_GALLERY_FLOATING_MODAL_SIZE_REM : VERTICAL_GALLERY_FLOATING_MODAL_SIZE_REM;
        }
        /*@conditional-compile-remove(click-to-call) */
        if ((overflowGalleryTiles.length > 0 || screenShareComponent) && overflowGalleryPosition === 'horizontalBottom') {
            return localVideoTileSize === '16:9' || !isNarrow ? LARGE_FLOATING_MODAL_SIZE_REM : SMALL_FLOATING_MODAL_SIZE_REM;
        }
        return LARGE_FLOATING_MODAL_SIZE_REM;
    }, [overflowGalleryTiles.length, isNarrow, screenShareComponent, /* @conditional-compile-remove(vertical-gallery) */ isShort, /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition, /* @conditional-compile-remove(click-to-call) */ localVideoTileSize]);
    const wrappedLocalVideoComponent = localVideoComponent && shouldFloatLocalVideo || screenShareComponent && localVideoComponent ?
        // When we use showCameraSwitcherInLocalPreview it disables dragging to allow keyboard navigation.
        showCameraSwitcherInLocalPreview ? React.createElement(react.Stack, { className: react.mergeStyles(localVideoTileWithControlsContainerStyle(theme, localVideoSizeRem), {
                boxShadow: theme.effects.elevation8,
                zIndex: LOCAL_VIDEO_TILE_ZINDEX
            }) }, localVideoComponent) : overflowGalleryTiles.length > 0 || screenShareComponent ? React.createElement(react.Stack, { className: react.mergeStyles(localVideoTileContainerStyle(theme, localVideoSizeRem, !!screenShareComponent, overflowGalleryPosition)) }, localVideoComponent) : React.createElement(FloatingLocalVideo, { localVideoComponent: localVideoComponent, layerHostId: layerHostId, localVideoSizeRem: localVideoSizeRem, parentWidth: parentWidth, parentHeight: parentHeight }) : undefined;
    const overflowGallery = React.useMemo(() => {
        if (overflowGalleryTiles.length === 0 && !screenShareComponent) {
            return null;
        }
        return React.createElement(OverflowGallery
        /* @conditional-compile-remove(vertical-gallery) */ , { 
            /* @conditional-compile-remove(vertical-gallery) */ isShort: isShort, onFetchTilesToRender: setIndexesToRender, isNarrow: isNarrow, shouldFloatLocalVideo: !!localVideoComponent, overflowGalleryElements: overflowGalleryTiles, horizontalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, 
            /* @conditional-compile-remove(vertical-gallery) */ verticalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.verticalGallery, 
            /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition: overflowGalleryPosition, onChildrenPerPageChange: (n) => {
                childrenPerPage.current = n;
            }, parentWidth: parentWidth });
    }, [isNarrow, /* @conditional-compile-remove(vertical-gallery) */ isShort, screenShareComponent, overflowGalleryTiles, styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition, setIndexesToRender, /* @conditional-compile-remove(vertical-gallery) */ styles === null || styles === void 0 ? void 0 : styles.verticalGallery, parentWidth, localVideoComponent]);
    return React.createElement(react.Stack, { styles: rootLayoutStyle },
        wrappedLocalVideoComponent,
        React.createElement(react.LayerHost, { id: layerHostId, className: react.mergeStyles(layerHostStyle) }),
        React.createElement(react.Stack
        /* @conditional-compile-remove(vertical-gallery) */ , { 
            /* @conditional-compile-remove(vertical-gallery) */ horizontal: overflowGalleryPosition === 'verticalRight', styles: innerLayoutStyle, tokens: videoGalleryLayoutGap },
            props.overflowGalleryPosition === 'horizontalTop' ? overflowGallery : React.createElement(React.Fragment, null),
            screenShareComponent ? screenShareComponent : React.createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles),
            overflowGalleryTrampoline$1(overflowGallery, props.overflowGalleryPosition)));
};
const overflowGalleryTrampoline$1 = (gallery, galleryPosition) => {
    return galleryPosition !== 'horizontalTop' ? gallery : React.createElement(React.Fragment, null);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Layout for the gallery mode to highlight the current dominant speaker
 *
 * @private
 */
const SpeakerVideoLayout = (props) => {
    const { remoteParticipants = [], dominantSpeakers, localVideoComponent, screenShareComponent, onRenderRemoteParticipant, styles, maxRemoteVideoStreams, parentWidth, 
    /* @conditional-compile-remove(vertical-gallery) */ parentHeight, 
    /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition = 'horizontalBottom', pinnedParticipantUserIds = [], 
    /* @conditional-compile-remove(click-to-call) */ localVideoTileSize } = props;
    const theme = react.useTheme();
    const isNarrow = parentWidth ? isNarrowWidth(parentWidth) : false;
    /* @conditional-compile-remove(vertical-gallery) */
    const isShort = parentHeight ? isShortHeight(parentHeight) : false;
    // This is for tracking the number of children in the first page of overflow gallery.
    // This number will be used for the maxOverflowGalleryDominantSpeakers when organizing the remote participants.
    const childrenPerPage = React.useRef(4);
    const { gridParticipants, overflowGalleryParticipants } = useOrganizedParticipants({
        remoteParticipants,
        dominantSpeakers,
        maxRemoteVideoStreams,
        isScreenShareActive: !!screenShareComponent,
        maxOverflowGalleryDominantSpeakers: screenShareComponent ? childrenPerPage.current - pinnedParticipantUserIds.length % childrenPerPage.current : childrenPerPage.current,
        pinnedParticipantUserIds,
        layout: 'speaker'
    });
    let activeVideoStreams = 0;
    const gridTiles = gridParticipants.map(p => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    const shouldFloatLocalVideo = remoteParticipants.length > 0;
    if (!shouldFloatLocalVideo && localVideoComponent) {
        gridTiles.push(localVideoComponent);
    }
    /**
     * instantiate indexes available to render with indexes available that would be on first page
     *
     * For some components which do not strictly follow the order of the array, we might
     * re-render the initial tiles -> dispose them -> create new tiles, we need to take care of
     * this case when those components are here
     */
    const [indexesToRender, setIndexesToRender] = React.useState([]);
    const overflowGalleryTiles = overflowGalleryParticipants.map((p, i) => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && indexesToRender && indexesToRender.includes(i) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    const layerHostId = reactHooks.useId('layerhost');
    const localVideoSizeRem = React.useMemo(() => {
        if (isNarrow || /*@conditional-compile-remove(click-to-call) */ localVideoTileSize === '9:16') {
            return SMALL_FLOATING_MODAL_SIZE_REM;
        }
        /* @conditional-compile-remove(vertical-gallery) */
        if ((overflowGalleryTiles.length > 0 || screenShareComponent) && overflowGalleryPosition === 'verticalRight') {
            return isNarrow ? SMALL_FLOATING_MODAL_SIZE_REM : isShort ? SHORT_VERTICAL_GALLERY_FLOATING_MODAL_SIZE_REM : VERTICAL_GALLERY_FLOATING_MODAL_SIZE_REM;
        }
        /*@conditional-compile-remove(click-to-call) */
        if ((overflowGalleryTiles.length > 0 || screenShareComponent) && overflowGalleryPosition === 'horizontalBottom') {
            return localVideoTileSize === '16:9' || !isNarrow ? LARGE_FLOATING_MODAL_SIZE_REM : SMALL_FLOATING_MODAL_SIZE_REM;
        }
        return LARGE_FLOATING_MODAL_SIZE_REM;
    }, [overflowGalleryTiles.length, isNarrow, screenShareComponent, /* @conditional-compile-remove(vertical-gallery) */ isShort, /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition, /* @conditional-compile-remove(click-to-call) */ localVideoTileSize]);
    const wrappedLocalVideoComponent = localVideoComponent || screenShareComponent && localVideoComponent ? React.createElement(react.Stack, { className: react.mergeStyles(localVideoTileContainerStyle(theme, localVideoSizeRem, !!screenShareComponent, overflowGalleryPosition)) }, localVideoComponent) : undefined;
    const overflowGallery = React.useMemo(() => {
        if (overflowGalleryTiles.length === 0 && !screenShareComponent) {
            return null;
        }
        return React.createElement(OverflowGallery
        /* @conditional-compile-remove(vertical-gallery) */ , { 
            /* @conditional-compile-remove(vertical-gallery) */ isShort: isShort, onFetchTilesToRender: setIndexesToRender, isNarrow: isNarrow, shouldFloatLocalVideo: !!localVideoComponent, overflowGalleryElements: overflowGalleryTiles, horizontalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, 
            /* @conditional-compile-remove(vertical-gallery) */ verticalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.verticalGallery, 
            /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition: overflowGalleryPosition, onChildrenPerPageChange: (n) => {
                childrenPerPage.current = n;
            }, parentWidth: parentWidth });
    }, [isNarrow, /* @conditional-compile-remove(vertical-gallery) */ isShort, screenShareComponent, overflowGalleryTiles, styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition, setIndexesToRender, /* @conditional-compile-remove(vertical-gallery) */ styles === null || styles === void 0 ? void 0 : styles.verticalGallery, parentWidth, localVideoComponent]);
    return React.createElement(react.Stack, { styles: rootLayoutStyle },
        wrappedLocalVideoComponent,
        React.createElement(react.LayerHost, { id: layerHostId, className: react.mergeStyles(layerHostStyle) }),
        React.createElement(react.Stack
        /* @conditional-compile-remove(vertical-gallery) */ , { 
            /* @conditional-compile-remove(vertical-gallery) */ horizontal: overflowGalleryPosition === 'verticalRight', styles: innerLayoutStyle, tokens: videoGalleryLayoutGap },
            props.overflowGalleryPosition === 'horizontalTop' ? overflowGallery : React.createElement(React.Fragment, null),
            screenShareComponent ? screenShareComponent : React.createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles),
            overflowGalleryTrampoline(overflowGallery, props.overflowGalleryPosition)));
};
const overflowGalleryTrampoline = (gallery, galleryPosition) => {
    return galleryPosition !== 'horizontalTop' ? gallery : React.createElement(React.Fragment, null);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Video gallery layout to focus on the screenshare stream that is present in the call.
 */
const FocusedContentLayout = (props) => {
    const { screenShareComponent } = props;
    const layerHostId = reactHooks.useId('layerhost');
    return React.createElement(react.Stack, { styles: rootLayoutStyle },
        React.createElement(react.LayerHost, { id: layerHostId, className: react.mergeStyles(layerHostStyle) }),
        React.createElement(react.Stack, { styles: innerLayoutStyle, tokens: videoGalleryLayoutGap }, screenShareComponent ? screenShareComponent : React.createElement(React.Fragment, null)));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 * Currently the Calling JS SDK supports up to 4 remote video streams
 */
const DEFAULT_MAX_REMOTE_VIDEO_STREAMS = 4;
/**
 * @private
 * Styles to disable the selectivity of a text in video gallery
 */
const unselectable = {
    '-webkit-user-select': 'none',
    '-webkit-touch-callout': 'none',
    '-moz-user-select': 'none',
    '-ms-user-select': 'none',
    'user-select': 'none'
};
/**
 * @private
 * Default remote video tile menu options
 */
const DEFAULT_REMOTE_VIDEO_TILE_MENU_OPTIONS = {
    kind: 'contextual'
};
/**
 * @private
 * Maximum number of remote video tiles that can be pinned
 */
const MAX_PINNED_REMOTE_VIDEO_TILES = 4;
/**
 * VideoGallery represents a layout of video tiles for a specific call.
 * It displays a {@link VideoTile} for the local user as well as for each remote participant who has joined the call.
 *
 * @public
 */
const VideoGallery = (props) => {
    var _a, _b, _c;
    const { localParticipant, remoteParticipants = [], localVideoViewOptions, remoteVideoViewOptions, dominantSpeakers, onRenderLocalVideoTile, onRenderRemoteVideoTile, onCreateLocalStreamView, onDisposeLocalStreamView, onCreateRemoteStreamView, onDisposeRemoteScreenShareStreamView, onDisposeRemoteVideoStreamView, styles, layout, onRenderAvatar, showMuteIndicator, maxRemoteVideoStreams = DEFAULT_MAX_REMOTE_VIDEO_STREAMS, showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps, onPinParticipant: onPinParticipantHandler, onUnpinParticipant: onUnpinParticipantHandler, remoteVideoTileMenu = DEFAULT_REMOTE_VIDEO_TILE_MENU_OPTIONS, 
    /* @conditional-compile-remove(vertical-gallery) */
    overflowGalleryPosition = 'horizontalBottom', 
    /* @conditional-compile-remove(rooms) */
    localVideoTileSize = 'followDeviceOrientation' } = props;
    const ids = useIdentifiers();
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.videoGallery;
    const strings = React.useMemo(() => (Object.assign(Object.assign({}, localeStrings), props.strings)), [localeStrings, props.strings]);
    const drawerMenuHostIdFromProp = remoteVideoTileMenu && remoteVideoTileMenu.kind === 'drawer' ? remoteVideoTileMenu.hostId : undefined;
    const drawerMenuHostId = reactHooks.useId('drawerMenuHost', drawerMenuHostIdFromProp);
    const localTileNotInGrid = (layout === 'floatingLocalVideo' || layout === 'speaker') && remoteParticipants.length > 0;
    const containerRef = React.useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const containerHeight = _useContainerHeight(containerRef);
    const isNarrow = containerWidth ? isNarrowWidth(containerWidth) : false;
    const [pinnedParticipantsState, setPinnedParticipantsState] = React.useState([]);
    const [selectedScalingModeState, setselectedScalingModeState] = React.useState({});
    const onUpdateScalingMode = React.useCallback((remoteUserId, scalingMode) => {
        setselectedScalingModeState(current => (Object.assign(Object.assign({}, current), { [remoteUserId]: {
                scalingMode,
                isMirrored: remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.isMirrored
            } })));
    }, [remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.isMirrored]);
    React.useEffect(() => {
        var _a;
        (_a = props.pinnedParticipants) === null || _a === void 0 ? void 0 : _a.forEach(pinParticipant => {
            var _a;
            if (!((_a = props.remoteParticipants) === null || _a === void 0 ? void 0 : _a.find(t => t.userId === pinParticipant))) {
                // warning will be logged in the console when invalid participant id is passed in pinned participants
                console.warn('Invalid pinned participant UserId :' + pinParticipant);
            }
        });
    }, [props.pinnedParticipants, props.remoteParticipants]);
    // Use pinnedParticipants from props but if it is not defined use the maintained state of pinned participants
    const pinnedParticipants = (_a = props.pinnedParticipants) !== null && _a !== void 0 ? _a : pinnedParticipantsState;
    const showLocalVideoTileLabel = !(localTileNotInGrid && isNarrow || /*@conditional-compile-remove(click-to-call) */ /* @conditional-compile-remove(rooms) */ localVideoTileSize === '9:16') || layout === 'default';
    /**
     * Utility function for memoized rendering of LocalParticipant.
     */
    const localVideoTile = React.useMemo(() => {
        var _a, _b;
        /* @conditional-compile-remove(click-to-call) */
        if (localVideoTileSize === 'hidden') {
            return undefined;
        }
        if (onRenderLocalVideoTile) {
            return onRenderLocalVideoTile(localParticipant);
        }
        const localVideoTileStyles = react.concatStyleSets(localTileNotInGrid ? floatingLocalVideoTileStyle : {}, {
            root: {
                borderRadius: theme.effects.roundedCorner4
            }
        }, styles === null || styles === void 0 ? void 0 : styles.localVideo);
        const initialsName = !localParticipant.displayName ? '' : localParticipant.displayName;
        const showDisplayNameTrampoline = () => {
            return layout === 'default' ? strings.localVideoLabel : isNarrow ? '' : strings.localVideoLabel;
        };
        return React.createElement(react.Stack, { styles: localVideoTileContainerStyles, key: "local-video-tile-key", tabIndex: 0, "aria-label": strings.localVideoMovementLabel, role: 'dialog' },
            React.createElement(_LocalVideoTile, { userId: localParticipant.userId, onCreateLocalStreamView: onCreateLocalStreamView, onDisposeLocalStreamView: onDisposeLocalStreamView, isAvailable: (_a = localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable, isMuted: localParticipant.isMuted, renderElement: (_b = localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.renderElement, displayName: showDisplayNameTrampoline(), initialsName: initialsName, localVideoViewOptions: localVideoViewOptions, onRenderAvatar: onRenderAvatar, showLabel: showLocalVideoTileLabel, showMuteIndicator: showMuteIndicator, showCameraSwitcherInLocalPreview: showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps: localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel: strings.localVideoCameraSwitcherLabel, localVideoSelectedDescription: strings.localVideoSelectedDescription, styles: localVideoTileStyles, 
                /* @conditional-compile-remove(raise-hand) */ raisedHand: localParticipant.raisedHand }));
    }, [isNarrow, localParticipant, localVideoCameraCycleButtonProps, localVideoViewOptions, onCreateLocalStreamView, onDisposeLocalStreamView, onRenderAvatar, onRenderLocalVideoTile, localTileNotInGrid, showCameraSwitcherInLocalPreview, showMuteIndicator, styles === null || styles === void 0 ? void 0 : styles.localVideo, theme.effects.roundedCorner4, /*@conditional-compile-remove(click-to-call) */
        localVideoTileSize, layout, showLocalVideoTileLabel]);
    const onPinParticipant = React.useCallback((userId) => {
        if (pinnedParticipants.length >= MAX_PINNED_REMOTE_VIDEO_TILES) {
            return;
        }
        if (!pinnedParticipantsState.includes(userId)) {
            setPinnedParticipantsState(pinnedParticipantsState.concat(userId));
        }
        onPinParticipantHandler === null || onPinParticipantHandler === void 0 ? void 0 : onPinParticipantHandler(userId);
    }, [pinnedParticipants.length, pinnedParticipantsState, setPinnedParticipantsState, onPinParticipantHandler]);
    const onUnpinParticipant = React.useCallback((userId) => {
        setPinnedParticipantsState(pinnedParticipantsState.filter(p => p !== userId));
        onUnpinParticipantHandler === null || onUnpinParticipantHandler === void 0 ? void 0 : onUnpinParticipantHandler(userId);
    }, [pinnedParticipantsState, setPinnedParticipantsState, onUnpinParticipantHandler]);
    const [announcementString, setAnnouncementString] = React.useState('');
    /**
     * sets the announcement string for VideoGallery actions so that the screenreader will trigger
     */
    const toggleAnnouncerString = React.useCallback((announcement) => {
        setAnnouncementString(announcement);
        /**
         * Clears the announcer string after VideoGallery action allowing it to be re-announced.
         */
        setTimeout(() => {
            setAnnouncementString('');
        }, 3000);
    }, [setAnnouncementString]);
    const defaultOnRenderVideoTile = React.useCallback((participant, isVideoParticipant) => {
        const remoteVideoStream = participant.videoStream;
        const selectedScalingMode = remoteVideoStream ? selectedScalingModeState[participant.userId] : undefined;
        let isPinned = pinnedParticipants === null || pinnedParticipants === void 0 ? void 0 : pinnedParticipants.includes(participant.userId);
        const createViewOptions = () => {
            var _a, _b;
            if (selectedScalingMode) {
                return selectedScalingMode;
            }
            return (remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.streamSize) && ((_a = remoteVideoStream.streamSize) === null || _a === void 0 ? void 0 : _a.height) > ((_b = remoteVideoStream.streamSize) === null || _b === void 0 ? void 0 : _b.width) ? {
                scalingMode: 'Fit',
                isMirrored: remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.isMirrored
            } : remoteVideoViewOptions;
        };
        return React.createElement(_RemoteVideoTile, { key: participant.userId, userId: participant.userId, remoteParticipant: participant, onCreateRemoteStreamView: isVideoParticipant ? onCreateRemoteStreamView : undefined, onDisposeRemoteStreamView: isVideoParticipant ? onDisposeRemoteVideoStreamView : undefined, isAvailable: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.isAvailable : false, isReceiving: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.isReceiving : false, renderElement: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.renderElement : undefined, remoteVideoViewOptions: createViewOptions(), onRenderAvatar: onRenderAvatar, showMuteIndicator: showMuteIndicator, strings: strings, menuKind: participant.userId === localParticipant.userId ? undefined : remoteVideoTileMenu ? remoteVideoTileMenu.kind === 'drawer' ? 'drawer' : 'contextual' : undefined, drawerMenuHostId: drawerMenuHostId, onPinParticipant: onPinParticipant, onUnpinParticipant: onUnpinParticipant, onUpdateScalingMode: onUpdateScalingMode, isPinned: isPinned, disablePinMenuItem: pinnedParticipants.length >= MAX_PINNED_REMOTE_VIDEO_TILES, toggleAnnouncerString: toggleAnnouncerString });
    }, [onCreateRemoteStreamView, onDisposeRemoteVideoStreamView, remoteVideoViewOptions, localParticipant, onRenderAvatar, showMuteIndicator, strings, drawerMenuHostId, remoteVideoTileMenu, selectedScalingModeState, pinnedParticipants, onPinParticipant, onUnpinParticipant, toggleAnnouncerString, onUpdateScalingMode]);
    const screenShareParticipant = remoteParticipants.find(participant => { var _a; return (_a = participant.screenShareStream) === null || _a === void 0 ? void 0 : _a.isAvailable; });
    const localScreenShareStreamComponent = React.createElement(LocalScreenShare, { localParticipant: localParticipant });
    const remoteScreenShareComponent = screenShareParticipant && React.createElement(RemoteScreenShare, Object.assign({}, screenShareParticipant, { renderElement: (_b = screenShareParticipant.screenShareStream) === null || _b === void 0 ? void 0 : _b.renderElement, onCreateRemoteStreamView: onCreateRemoteStreamView, onDisposeRemoteStreamView: onDisposeRemoteScreenShareStreamView, isReceiving: (_c = screenShareParticipant.screenShareStream) === null || _c === void 0 ? void 0 : _c.isReceiving, participantVideoScalingMode: selectedScalingModeState[screenShareParticipant.userId] }));
    const screenShareComponent = remoteScreenShareComponent ? remoteScreenShareComponent : localParticipant.isScreenSharingOn ? localScreenShareStreamComponent : undefined;
    const layoutProps = React.useMemo(() => ({
        remoteParticipants,
        localParticipant,
        screenShareComponent,
        showCameraSwitcherInLocalPreview,
        maxRemoteVideoStreams,
        dominantSpeakers,
        styles,
        onRenderRemoteParticipant: onRenderRemoteVideoTile !== null && onRenderRemoteVideoTile !== void 0 ? onRenderRemoteVideoTile : defaultOnRenderVideoTile,
        localVideoComponent: localVideoTile,
        parentWidth: containerWidth,
        parentHeight: containerHeight,
        pinnedParticipantUserIds: pinnedParticipants,
        /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition,
        /* @conditional-compile-remove(click-to-call) */ localVideoTileSize
    }), [remoteParticipants, localParticipant, screenShareComponent, showCameraSwitcherInLocalPreview, maxRemoteVideoStreams, dominantSpeakers, styles, localVideoTile, containerWidth, containerHeight, onRenderRemoteVideoTile, defaultOnRenderVideoTile, pinnedParticipants, /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition, /* @conditional-compile-remove(click-to-call) */ localVideoTileSize]);
    const videoGalleryLayout = React.useMemo(() => {
        if (screenShareParticipant && layout === 'focusedContent') {
            return React.createElement(FocusedContentLayout, Object.assign({}, layoutProps));
        }
        if (layout === 'floatingLocalVideo') {
            return React.createElement(FloatingLocalVideoLayout, Object.assign({}, layoutProps));
        }
        if (layout === 'speaker') {
            return React.createElement(SpeakerVideoLayout, Object.assign({}, layoutProps));
        }
        return React.createElement(DefaultLayout, Object.assign({}, layoutProps));
    }, [layout, layoutProps, screenShareParticipant]);
    return React.createElement("div", { 
        // We don't assign an drawer menu host id to the VideoGallery when a drawerMenuHostId is assigned from props
        id: drawerMenuHostIdFromProp ? undefined : drawerMenuHostId, "data-ui-id": ids.videoGallery, ref: containerRef, className: react.mergeStyles(videoGalleryOuterDivStyle, styles === null || styles === void 0 ? void 0 : styles.root, unselectable) },
        videoGalleryLayout,
        React.createElement(Announcer, { announcementString: announcementString, ariaLive: "polite" }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const controlBarStyles$1 = {
    horizontal: {
        flexFlow: 'row nowrap'
    },
    vertical: {
        flexFlow: 'column nowrap',
        width: 'fit-content',
        maxWidth: '8rem'
    },
    dockedTop: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        minWidth: 'fit-content'
    },
    dockedBottom: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        bottom: 0,
        left: 0,
        width: '100%',
        minWidth: 'fit-content'
    },
    dockedLeft: {
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        left: 0,
        height: '100%'
    },
    dockedRight: {
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        right: 0,
        height: '100%'
    },
    floatingTop: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '1rem',
        left: '50%',
        transform: 'translateX(-50%)',
        minWidth: 'fit-content',
        zIndex: 10
    },
    floatingBottom: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        bottom: '1rem',
        left: '50%',
        transform: 'translateX(-50%)',
        minWidth: 'fit-content',
        zIndex: 10
    },
    floatingLeft: {
        flexFlow: 'column nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '50%',
        left: '1rem',
        transform: 'translateY(-50%)',
        zIndex: 10
    },
    floatingRight: {
        flexFlow: 'column nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '50%',
        right: '1rem',
        transform: 'translateY(-50%)',
        zIndex: 10
    }
};
/**
 * @private
 */
const controlButtonStyles = {
    root: {
        background: 'none',
        border: 'none',
        borderRadius: 0,
        minHeight: '3.5rem',
        minWidth: '3.5rem',
        width: '100%',
        maxWidth: '8rem',
        svg: {
            verticalAlign: 'text-top'
        }
    },
    splitButtonMenuButton: {
        border: 'none'
    },
    flexContainer: {
        flexFlow: 'column',
        display: 'contents'
    },
    label: {
        fontSize: '0.625rem',
        fontWeight: '400',
        lineHeight: '1rem',
        cursor: 'pointer',
        display: 'block',
        margin: '0rem 0.25rem',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
    }
};
/**
 * making it Partial as IContextualMenuStyles has all its props non-optional and we only need title to be defined here.
 *
 * @private
 */
const participantsButtonMenuPropsStyle = {
    title: {
        background: 'initial',
        paddingLeft: '.5rem',
        fontWeight: 600,
        fontSize: '.75rem'
    }
};
/**
 * Default styles for button flyout items
 *
 * @private
 */
const buttonFlyoutItemStyles = {
    icon: {
        lineHeight: 0
    },
    checkmarkIcon: {
        lineHeight: 0
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// The TooltipHost root uses display: inline by default.
// To prevent sizing issues or tooltip positioning issues, we override to inline-block.
// For more details see "Icon Button with Tooltip" on https://developer.microsoft.com/en-us/fluentui#/controls/web/button
const hostStyles = {
    root: {
        display: 'inline-block'
    }
};
/**
 * Tooltip that should wrap control bar buttons.
 *
 * @private
 */
const ControlButtonTooltip = (props) => {
    const theme = react.useTheme();
    const calloutStyle = {
        root: {
            padding: 0
        },
        calloutMain: {
            padding: '0.5rem'
        }
    };
    const calloutProps = {
        gapSpace: 4,
        styles: calloutStyle,
        backgroundColor: isDarkThemed(theme) ? theme.palette.neutralLighter : ''
    };
    return React.createElement(react.TooltipHost, Object.assign({}, props, { "data-ui-id": props.id, calloutProps: Object.assign(Object.assign({}, calloutProps), props.calloutProps), styles: react.mergeStyleSets(hostStyles, props.styles) }), props.children);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const DefaultRenderIcon = (props) => {
    return (props === null || props === void 0 ? void 0 : props.checked) ? (props === null || props === void 0 ? void 0 : props.onRenderOnIcon) ? props === null || props === void 0 ? void 0 : props.onRenderOnIcon() : null : (props === null || props === void 0 ? void 0 : props.onRenderOffIcon) ? props === null || props === void 0 ? void 0 : props.onRenderOffIcon() : null;
};
/**
 * Default button styled for the {@link ControlBar}.
 *
 * Use this component create custom buttons that are styled the same as other buttons provided by the UI Library.
 *
 * @public
 */
const ControlBarButton = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    const componentStyles = react.concatStyleSets(controlButtonStyles, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    const labelText = (_d = (_b = props === null || props === void 0 ? void 0 : props.text) !== null && _b !== void 0 ? _b : (_c = props === null || props === void 0 ? void 0 : props.strings) === null || _c === void 0 ? void 0 : _c.label) !== null && _d !== void 0 ? _d : ((props === null || props === void 0 ? void 0 : props.checked) ? (_e = props === null || props === void 0 ? void 0 : props.strings) === null || _e === void 0 ? void 0 : _e.onLabel : (_f = props === null || props === void 0 ? void 0 : props.strings) === null || _f === void 0 ? void 0 : _f.offLabel);
    const tooltipContent = (_h = (_g = props === null || props === void 0 ? void 0 : props.strings) === null || _g === void 0 ? void 0 : _g.tooltipContent) !== null && _h !== void 0 ? _h : ((props === null || props === void 0 ? void 0 : props.disabled) ? (_j = props === null || props === void 0 ? void 0 : props.strings) === null || _j === void 0 ? void 0 : _j.tooltipDisabledContent : (props === null || props === void 0 ? void 0 : props.checked) ? (_k = props === null || props === void 0 ? void 0 : props.strings) === null || _k === void 0 ? void 0 : _k.tooltipOnContent : (_l = props === null || props === void 0 ? void 0 : props.strings) === null || _l === void 0 ? void 0 : _l.tooltipOffContent);
    const tooltipId = ((_m = props.tooltipId) !== null && _m !== void 0 ? _m : props.labelKey) ? props.labelKey + '-tooltip' : undefined;
    return React.createElement(ControlButtonTooltip, { hidden: props.disableTooltip, content: tooltipContent, id: tooltipId },
        React.createElement(react.DefaultButton, Object.assign({}, props, { styles: componentStyles, onRenderText: props.showLabel && props.onRenderText ? props.onRenderText : undefined, onRenderIcon: (_o = props.onRenderIcon) !== null && _o !== void 0 ? _o : DefaultRenderIcon, ariaLabel: (_r = (_q = (_p = props.splitButtonAriaLabel) !== null && _p !== void 0 ? _p : props.ariaLabel) !== null && _q !== void 0 ? _q : tooltipContent) !== null && _r !== void 0 ? _r : labelText, allowDisabledFocus: (_s = props.allowDisabledFocus) !== null && _s !== void 0 ? _s : true, menuTriggerKeyCode: react.KeyCodes.down, text: undefined }), props.showLabel ? labelText : React.createElement(React.Fragment, null)));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * This is a helper component to define and unify icon colors
 *
 * @internal
 */
const _HighContrastAwareIcon = (props) => {
    const { iconName, disabled } = props;
    const theme = useTheme();
    // setting colors for the icons using color from theme, so in dark mode or other accessibility modes, they have pre-defined contrast colors
    // the media query is for when in specific window accessibility mode, change the svg colors
    return React.createElement(react.Icon, { iconName: iconName, className: react.mergeStyles({
            svg: {
                fill: disabled ? theme.palette.neutralTertiary : theme.palette.neutralPrimaryAlt,
                '@media (forced-colors: active) and (prefers-color-scheme: dark)': {
                    fill: disabled ? theme.palette.neutralPrimaryAlt : theme.palette.neutralTertiary
                }
            }
        }) });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Generates default {@link IContextualMenuProps} for buttons that
 * show a drop-down to select devices to use.
 *
 * @internal
 */
const generateDefaultDeviceMenuProps = (props, strings, primaryActionItem, isSelectCamAllowed = true, isSelectMicAllowed = true) => {
    var _a, _b;
    const { microphones, speakers, cameras, selectedMicrophone, selectedSpeaker, selectedCamera, onSelectCamera, onSelectMicrophone, onSelectSpeaker } = props;
    const defaultMenuProps = {
        items: [],
        styles: props.styles,
        calloutProps: {
            styles: {
                root: {
                    // Confine the menu to the parents bounds.
                    // More info: https://github.com/microsoft/fluentui/issues/18835
                    // NB: 95% to keep some space for margin, drop shadow etc around the Callout.
                    maxWidth: '95%'
                }
            },
            preventDismissOnEvent: _preventDismissOnEvent
        }
    };
    const menuItemStyles = react.merge(buttonFlyoutItemStyles, (_b = (_a = props.styles) === null || _a === void 0 ? void 0 : _a.menuItemStyles) !== null && _b !== void 0 ? _b : {});
    if (cameras && selectedCamera && onSelectCamera && isSelectCamAllowed) {
        defaultMenuProps.items.push({
            key: 'cameras',
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.cameraMenuTitle,
                items: [{
                        key: 'sectionCamera',
                        title: strings.cameraMenuTooltip,
                        subMenuProps: {
                            calloutProps: {
                                preventDismissOnEvent: _preventDismissOnEvent
                            },
                            items: cameras.map(camera => ({
                                key: camera.id,
                                text: camera.name,
                                title: camera.name,
                                iconProps: {
                                    iconName: 'ContextMenuCameraIcon',
                                    styles: {
                                        root: {
                                            lineHeight: 0
                                        }
                                    }
                                },
                                itemProps: {
                                    styles: menuItemStyles
                                },
                                canCheck: true,
                                isChecked: camera.id === (selectedCamera === null || selectedCamera === void 0 ? void 0 : selectedCamera.id),
                                onClick: () => {
                                    if (camera.id !== (selectedCamera === null || selectedCamera === void 0 ? void 0 : selectedCamera.id)) {
                                        onSelectCamera(camera);
                                    }
                                }
                            }))
                        },
                        text: selectedCamera.name
                    }]
            }
        });
        if (primaryActionItem) {
            defaultMenuProps.items.push(primaryActionItem);
        }
    }
    if (microphones && selectedMicrophone && onSelectMicrophone && isSelectMicAllowed) {
        // Set props as Microphone if speakers can be enumerated else set as Audio Device
        const speakersAvailable = speakers && speakers.length > 0;
        const key = speakersAvailable ? 'sectionMicrophone' : 'sectionAudioDevice';
        const title = speakersAvailable ? strings.microphoneMenuTooltip : strings.audioDeviceMenuTooltip;
        defaultMenuProps.items.push({
            key: 'microphones',
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.microphoneMenuTitle,
                items: [{
                        key: key,
                        title: title,
                        subMenuProps: {
                            calloutProps: {
                                preventDismissOnEvent: _preventDismissOnEvent
                            },
                            items: microphones.map(microphone => ({
                                key: microphone.id,
                                text: microphone.name,
                                title: microphone.name,
                                itemProps: {
                                    styles: menuItemStyles
                                },
                                iconProps: {
                                    iconName: 'ContextMenuMicIcon',
                                    styles: {
                                        root: {
                                            lineHeight: 0
                                        }
                                    }
                                },
                                canCheck: true,
                                isChecked: microphone.id === (selectedMicrophone === null || selectedMicrophone === void 0 ? void 0 : selectedMicrophone.id),
                                onClick: () => {
                                    if (microphone.id !== (selectedMicrophone === null || selectedMicrophone === void 0 ? void 0 : selectedMicrophone.id)) {
                                        onSelectMicrophone(microphone);
                                    }
                                }
                            }))
                        },
                        text: selectedMicrophone.name
                    }]
            }
        });
    }
    if (speakers && selectedSpeaker && onSelectSpeaker) {
        defaultMenuProps.items.push({
            key: 'speakers',
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.speakerMenuTitle,
                items: [{
                        key: 'sectionSpeaker',
                        subMenuProps: {
                            calloutProps: {
                                preventDismissOnEvent: _preventDismissOnEvent
                            },
                            items: speakers.map(speaker => ({
                                key: speaker.id,
                                text: speaker.name,
                                title: speaker.name,
                                itemProps: {
                                    styles: menuItemStyles
                                },
                                iconProps: {
                                    iconName: 'ContextMenuSpeakerIcon',
                                    styles: {
                                        root: {
                                            lineHeight: 0
                                        }
                                    }
                                },
                                canCheck: true,
                                isChecked: speaker.id === (selectedSpeaker === null || selectedSpeaker === void 0 ? void 0 : selectedSpeaker.id),
                                onClick: () => {
                                    if (speaker.id !== (selectedSpeaker === null || selectedSpeaker === void 0 ? void 0 : selectedSpeaker.id)) {
                                        onSelectSpeaker(speaker);
                                    }
                                }
                            }))
                        },
                        text: selectedSpeaker.name
                    }]
            }
        });
    }
    if (microphones && selectedMicrophone && onSelectMicrophone && isSelectMicAllowed && primaryActionItem) {
        defaultMenuProps.items.push(primaryActionItem);
    }
    if (defaultMenuProps.items.length === 0) {
        // Avoids creating an empty context menu.
        return undefined;
    }
    return defaultMenuProps;
};
/**
 * A button to open a menu that controls device options.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const DevicesButton = (props) => {
    var _a, _b, _c;
    const { onRenderIcon } = props;
    const localeStrings = useLocale$1().strings.devicesButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const devicesButtonMenu = (_a = props.menuProps) !== null && _a !== void 0 ? _a : generateDefaultDeviceMenuProps(Object.assign(Object.assign({}, props), { styles: (_b = props.styles) === null || _b === void 0 ? void 0 : _b.menuStyles }), strings);
    const onRenderOptionsIcon = () => {
        return React.createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonOptions" });
    };
    return React.createElement(ControlBarButton, Object.assign({}, props, { menuProps: devicesButtonMenu, menuIconProps: {
            hidden: true
        }, onRenderIcon: onRenderIcon !== null && onRenderIcon !== void 0 ? onRenderIcon : onRenderOptionsIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'devicesButtonLabel' }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$u = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const defaultLocalVideoViewOptions = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * A button to turn camera on / off.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const CameraButton = (props) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const { localVideoViewOptions, onToggleCamera, onSelectCamera } = props;
    const [waitForCamera, setWaitForCamera] = React.useState(false);
    const localeStrings = useLocale$1().strings.cameraButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const [announcerString, setAnnouncerString] = React.useState(undefined);
    const disabled = props.disabled || waitForCamera;
    const onRenderCameraOnIcon = () => React.createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonCameraOn" });
    const onRenderCameraOffIcon = () => React.createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonCameraOff" });
    if (waitForCamera && strings.tooltipVideoLoadingContent) {
        strings.tooltipDisabledContent = strings.tooltipVideoLoadingContent;
    }
    const cameraOn = props.checked;
    const splitButtonAriaString = cameraOn ? strings.onSplitButtonAriaLabel : strings.offSplitButtonAriaLabel;
    const toggleAnnouncerString = React.useCallback((isCameraOn) => {
        setAnnouncerString(!isCameraOn ? strings.cameraActionTurnedOffAnnouncement : strings.cameraActionTurnedOnAnnouncement);
    }, [strings.cameraActionTurnedOffAnnouncement, strings.cameraActionTurnedOnAnnouncement]);
    const onToggleClick = React.useCallback(() => __awaiter$u(void 0, void 0, void 0, function* () {
        // Throttle click on camera, need to await onToggleCamera then allow another click
        if (onToggleCamera) {
            setWaitForCamera(true);
            try {
                yield onToggleCamera(localVideoViewOptions !== null && localVideoViewOptions !== void 0 ? localVideoViewOptions : defaultLocalVideoViewOptions);
                // allows for the setting of narrator strings triggering the announcer when camera is turned on or off.
                toggleAnnouncerString(!cameraOn);
            }
            finally {
                setWaitForCamera(false);
            }
        }
    }), [cameraOn, localVideoViewOptions, onToggleCamera, toggleAnnouncerString]);
    const onChangeCameraClick = React.useCallback((device) => __awaiter$u(void 0, void 0, void 0, function* () {
        // Throttle changing camera to prevent too many callbacks
        if (onSelectCamera) {
            setWaitForCamera(true);
            try {
                yield onSelectCamera(device);
            }
            finally {
                setWaitForCamera(false);
            }
        }
    }), [onSelectCamera]);
    const splitButtonMenuItems = [];
    /* @conditional-compile-remove(video-background-effects) */
    if (props.onClickVideoEffects) {
        splitButtonMenuItems.push({
            key: 'effects',
            'data-ui-id': 'camera-split-button-video-effects',
            text: strings.videoEffectsMenuItemTitle,
            iconProps: {
                iconName: 'ControlButtonVideoEffectsOption',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            onClick: () => {
                if (props.onClickVideoEffects) {
                    props.onClickVideoEffects(true);
                }
            }
        });
    }
    splitButtonMenuItems.push({
        key: 'cameraPrimaryAction',
        text: props.checked ? strings.onSplitButtonPrimaryActionCamera : strings.offSplitButtonPrimaryActionCamera,
        onClick: () => {
            onToggleClick();
        },
        iconProps: {
            iconName: props.checked ? 'SplitButtonPrimaryActionCameraOn' : 'SplitButtonPrimaryActionCameraOff',
            styles: {
                root: {
                    lineHeight: 0
                }
            }
        }
    });
    const splitButtonPrimaryAction = {
        key: 'primaryAction',
        title: 'toggle camera',
        itemType: react.ContextualMenuItemType.Section,
        sectionProps: {
            topDivider: true,
            items: splitButtonMenuItems
        }
    };
    const splitButtonMenuProps = React.useMemo(() => (Object.assign(Object.assign({}, props.splitButtonMenuProps), { className: 'camera-split-button' })), [props.splitButtonMenuProps]);
    return React.createElement(React.Fragment, null,
        React.createElement(Announcer, { announcementString: announcerString, ariaLive: 'polite' }),
        React.createElement(ControlBarButton, Object.assign({}, props, { disabled: disabled, onClick: onToggleCamera ? onToggleClick : props.onClick, onRenderOnIcon: (_a = props.onRenderOnIcon) !== null && _a !== void 0 ? _a : onRenderCameraOnIcon, onRenderOffIcon: (_b = props.onRenderOffIcon) !== null && _b !== void 0 ? _b : onRenderCameraOffIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'cameraButtonLabel', menuProps: (_d = props.menuProps) !== null && _d !== void 0 ? _d : (props.enableDeviceSelectionMenu ? generateDefaultDeviceMenuProps(Object.assign(Object.assign({}, props), { onSelectCamera: onChangeCameraClick, styles: (_e = props.styles) === null || _e === void 0 ? void 0 : _e.menuStyles }), strings, splitButtonPrimaryAction) : undefined), menuIconProps: ((_f = props.menuIconProps) !== null && _f !== void 0 ? _f : !props.enableDeviceSelectionMenu) ? {
                hidden: true
            } : undefined, split: (_g = props.split) !== null && _g !== void 0 ? _g : props.enableDeviceSelectionMenu, "aria-roledescription": props.enableDeviceSelectionMenu ? strings.cameraButtonSplitRoleDescription : undefined, splitButtonAriaLabel: props.enableDeviceSelectionMenu ? splitButtonAriaString : undefined, splitButtonMenuProps: splitButtonMenuProps })));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const mainDivStyle = {
    position: 'relative',
    height: '100%',
    width: '100%'
};
/**
 * A container for various buttons for call controls.
 *
 * Use with various call control buttons in this library, e.g., {@link CameraButton}, or your own instances of
 * {@link ControlBarButton} directly.
 *
 * @public
 */
const ControlBar = (props) => {
    const { styles, layout } = props;
    const theme = useTheme();
    const controlBarClassName = React.useMemo(() => {
        const controlBarStyle = controlBarStyles$1[layout !== null && layout !== void 0 ? layout : 'horizontal'];
        // if theme is dark and layout is floating then use palette.neutralQuaternaryAlt as background, otherwise use theme.palette.white
        const backgroundStyle = {
            background: isDarkThemed(theme) && (layout === null || layout === void 0 ? void 0 : layout.startsWith('floating')) ? theme.palette.neutralQuaternaryAlt : theme.palette.white
        };
        const borderAndBoxShadowStyle = (layout === null || layout === void 0 ? void 0 : layout.startsWith('floating')) ? {
            boxShadow: theme.effects.elevation16,
            borderRadius: theme.effects.roundedCorner6
        } : {};
        // if rtl is true and layout is either floatingTop or floatingBottom then we need to override the transform-style property
        // to translate 50% to right instead of the left
        const transformOverrideStyle = theme.rtl && (layout === 'floatingTop' || layout === 'floatingBottom') ? {
            transform: 'translateX(50%)'
        } : {};
        return react.mergeStyles(controlBarStyle, backgroundStyle, borderAndBoxShadowStyle, transformOverrideStyle, styles === null || styles === void 0 ? void 0 : styles.root);
    }, [layout, styles === null || styles === void 0 ? void 0 : styles.root, theme]);
    return React.createElement("div", { className: react.mergeStyles(mainDivStyle) },
        React.createElement(react.Stack, { className: controlBarClassName }, props.children));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var _a, _b;
const onRenderEndCallIcon = () => React.createElement(react.Icon, { iconName: "ControlButtonEndCall" });
/**
 * A button to end an ongoing call.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const EndCallButton = (props) => {
    var _a, _b, _c;
    const { styles } = props;
    const localeStrings = useLocale$1().strings.endCallButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = useTheme();
    const isDarkTheme = isDarkThemed(theme);
    const componentStyles = react.concatStyleSets(isDarkTheme ? darkThemeCallButtonStyles : lightThemeCallButtonStyles, styles !== null && styles !== void 0 ? styles : {});
    return React.createElement(ControlBarButton, Object.assign({}, props, { onClick: (_a = props.onHangUp) !== null && _a !== void 0 ? _a : props.onClick, styles: componentStyles, onRenderIcon: (_b = props.onRenderIcon) !== null && _b !== void 0 ? _b : onRenderEndCallIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'endCallButtonLabel' }));
};
// using media query to prevent windows from overwriting the button color
const darkThemeCallButtonStyles = {
    root: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'auto',
            border: `1px ${(_a = lightTheme.palette) === null || _a === void 0 ? void 0 : _a.neutralQuaternaryAlt} solid`
        },
        ':focus::after': {
            outlineColor: `${darkTheme.callingPalette.iconWhite} !important`
        } // added !important to avoid override by FluentUI button styles
    },
    rootHovered: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'auto'
        }
    },
    rootPressed: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'auto'
        }
    },
    label: {
        color: darkTheme.callingPalette.iconWhite
    }
};
const lightThemeCallButtonStyles = {
    root: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'auto',
            border: `1px ${(_b = lightTheme.palette) === null || _b === void 0 ? void 0 : _b.neutralQuaternaryAlt} solid`
        },
        ':focus::after': {
            outlineColor: `${lightTheme.callingPalette.iconWhite} !important`
        } // added !important to avoid override by FluentUI button styles
    },
    rootHovered: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'auto'
        }
    },
    rootPressed: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'auto'
        }
    },
    label: {
        color: lightTheme.callingPalette.iconWhite
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$t = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * A button to turn microphone on / off.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const MicrophoneButton = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const { onToggleMicrophone } = props;
    const localeStrings = useLocale$1().strings.microphoneButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const [announcerString, setAnnouncerString] = React.useState(undefined);
    const isSplit = (_a = props.split) !== null && _a !== void 0 ? _a : props.enableDeviceSelectionMenu;
    // The button should be disabled when there are no mics. However if the button is a split button, if there are
    // no mics but there are speakers, then only the primary part of the button should be disabled to allow for
    // speaker change.
    const primaryDisabled = props.primaryDisabled || (isSplit && !((_b = props.microphones) === null || _b === void 0 ? void 0 : _b.length) ? true : undefined);
    const disabled = props.disabled || isSplit && !((_c = props.microphones) === null || _c === void 0 ? void 0 : _c.length) && !((_d = props.speakers) === null || _d === void 0 ? void 0 : _d.length) || !isSplit && props.microphones && ((_e = props.microphones) === null || _e === void 0 ? void 0 : _e.length) === 0;
    const onRenderMicOnIcon = () => {
        return React.createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonMicOn" });
    };
    const onRenderMicOffIcon = () => {
        return React.createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonMicOff" });
    };
    const isMicOn = props.checked;
    const splitButtonAriaString = isMicOn ? strings.onSplitButtonAriaLabel : strings.offSplitButtonAriaLabel;
    const toggleAnnouncerString = React.useCallback((isMicOn) => {
        setAnnouncerString(!isMicOn ? strings.microphoneActionTurnedOffAnnouncement : strings.microphoneActionTurnedOnAnnouncement);
    }, [strings.microphoneActionTurnedOffAnnouncement, strings.microphoneActionTurnedOnAnnouncement]);
    const onToggleClick = React.useCallback(() => __awaiter$t(void 0, void 0, void 0, function* () {
        if (onToggleMicrophone) {
            try {
                yield onToggleMicrophone();
                // allows for the setting of narrator strings triggering the announcer when microphone is turned on or off.
                toggleAnnouncerString(!isMicOn);
                // eslint-disable-next-line no-empty
            }
            finally { }
        }
    }), [isMicOn, onToggleMicrophone, toggleAnnouncerString]);
    /**
     * We need to also include the primary action of the button to the
     * split button for mobile devices.
     */
    const splitButtonPrimaryAction = {
        key: 'primaryAction',
        title: 'toggle mic',
        itemType: react.ContextualMenuItemType.Section,
        sectionProps: {
            topDivider: true,
            items: [{
                    key: 'microphonePrimaryAction',
                    text: props.checked ? strings.onSplitButtonMicrophonePrimaryAction : strings.offSplitButtonMicrophonePrimaryAction,
                    onClick: () => {
                        onToggleClick();
                    },
                    iconProps: {
                        iconName: props.checked ? 'SplitButtonPrimaryActionMicUnmuted' : 'SplitButtonPrimaryActionMicMuted',
                        styles: {
                            root: {
                                lineHeight: 0
                            }
                        }
                    }
                }]
        }
    };
    return React.createElement(React.Fragment, null,
        React.createElement(Announcer, { announcementString: announcerString, ariaLive: 'polite' }),
        React.createElement(ControlBarButton, Object.assign({}, props, { onClick: props.onToggleMicrophone ? onToggleClick : props.onClick, onRenderOnIcon: (_f = props.onRenderOnIcon) !== null && _f !== void 0 ? _f : onRenderMicOnIcon, onRenderOffIcon: (_g = props.onRenderOffIcon) !== null && _g !== void 0 ? _g : onRenderMicOffIcon, strings: strings, labelKey: (_h = props.labelKey) !== null && _h !== void 0 ? _h : 'microphoneButtonLabel', menuProps: (_j = props.menuProps) !== null && _j !== void 0 ? _j : (props.enableDeviceSelectionMenu ? generateDefaultDeviceMenuProps(Object.assign(Object.assign({}, props), { styles: (_k = props.styles) === null || _k === void 0 ? void 0 : _k.menuStyles }), strings, splitButtonPrimaryAction) : undefined), menuIconProps: ((_l = props.menuIconProps) !== null && _l !== void 0 ? _l : !props.enableDeviceSelectionMenu) ? {
                hidden: true
            } : undefined, split: (_m = props.split) !== null && _m !== void 0 ? _m : props.enableDeviceSelectionMenu, "aria-roledescription": props.enableDeviceSelectionMenu ? strings.microphoneButtonSplitRoleDescription : undefined, splitButtonAriaLabel: props.enableDeviceSelectionMenu ? splitButtonAriaString : undefined, disabled: disabled, primaryDisabled: primaryDisabled })));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A button to show a menu with calling or chat participants.
 *
 * Can be used with {@link ControlBar}.
 *
 * This button contains dropdown menu items defined through its property `menuProps`. By default, it can display the number of remote participants with the full list
 * as sub-menu and an option to mute all participants, as well as a copy-to-clipboard button to copy the call invitation URL.
 * This `menuProps` can be fully redefined and its property is of type [IContextualMenuProps](https://developer.microsoft.com/fluentui#/controls/web/contextualmenu#IContextualMenuProps).
 *
 * @public
 */
const ParticipantsButton = (props) => {
    var _a, _b, _c, _d;
    const { callInvitationURL, styles, onMuteAll, onRenderIcon, onRenderParticipantList, participants, myUserId, excludeMe, onRenderParticipant, onRenderAvatar, onRemoveParticipant, onFetchParticipantMenuItems, showParticipantOverflowTooltip } = props;
    const disabled = props.disabled;
    const [copyInviteLinkAnnouncerStrings, setCopyInviteLinkAnnouncerStrings] = React.useState('');
    const onRenderPeopleIcon = () => React.createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonParticipants" });
    const ids = useIdentifiers();
    const onMuteAllCallback = React.useCallback(() => {
        if (onMuteAll) {
            onMuteAll();
        }
    }, [onMuteAll]);
    const defaultParticipantList = React.useCallback(() => {
        var _a;
        return React.createElement(ParticipantList$k, { participants: participants, myUserId: myUserId, excludeMe: excludeMe, onRenderParticipant: onRenderParticipant, onRenderAvatar: onRenderAvatar, onRemoveParticipant: onRemoveParticipant, onFetchParticipantMenuItems: onFetchParticipantMenuItems, styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.participantListStyles, showParticipantOverflowTooltip: showParticipantOverflowTooltip });
    }, [excludeMe, myUserId, onRemoveParticipant, onRenderAvatar, onRenderParticipant, participants, (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.participantListStyles, onFetchParticipantMenuItems, showParticipantOverflowTooltip]);
    const onCopyCallback = React.useCallback(() => {
        if (callInvitationURL) {
            return copy(callInvitationURL);
        }
        return false;
    }, [callInvitationURL]);
    const localeStrings = useLocale$1().strings.participantsButton;
    const strings = React.useMemo(() => (Object.assign(Object.assign({}, localeStrings), props.strings)), [localeStrings, props.strings]);
    const participantCount = participants.length;
    /**
     * sets the announcement string for when the link is copied.
     */
    const toggleAnnouncerString = React.useCallback(() => {
        setCopyInviteLinkAnnouncerStrings(strings.copyInviteLinkActionedAriaLabel);
        /**
         * Clears the announcer string after the user clicks the
         * copyInviteLink button allowing it to be re-announced.
         */
        setTimeout(() => {
            setCopyInviteLinkAnnouncerStrings('');
        }, 3000);
    }, [strings.copyInviteLinkActionedAriaLabel]);
    const generateDefaultParticipantsSubMenuProps = React.useCallback(() => {
        var _a;
        const items = [];
        if (participantCount > 0) {
            items.push({
                key: 'participantListMenuItemKey',
                onRender: onRenderParticipantList !== null && onRenderParticipantList !== void 0 ? onRenderParticipantList : defaultParticipantList
            });
            items.push({
                key: 'participantsDivider1',
                itemType: react.ContextualMenuItemType.Divider
            });
            if (onMuteAll) {
                items.push({
                    key: 'muteAllKey',
                    text: strings.muteAllButtonLabel,
                    title: strings.muteAllButtonLabel,
                    styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.menuItemStyles,
                    iconProps: {
                        iconName: 'MicOff2'
                    },
                    onClick: onMuteAllCallback
                });
            }
        }
        return items;
    }, [participantCount, onRenderParticipantList, defaultParticipantList, onMuteAll, strings.muteAllButtonLabel, (_b = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _b === void 0 ? void 0 : _b.menuItemStyles, onMuteAllCallback]);
    const defaultMenuProps = React.useMemo(() => {
        var _a, _b;
        const menuProps = {
            title: strings.menuHeader,
            ariaLabel: strings.menuHeader,
            styles: react.merge(participantsButtonMenuPropsStyle, styles === null || styles === void 0 ? void 0 : styles.menuStyles),
            items: [],
            calloutProps: {
                preventDismissOnEvent: _preventDismissOnEvent
            }
        };
        if (participantCount > 0) {
            const participantIds = participants.map(p => p.userId);
            let participantCountWithoutMe = participantIds.length;
            if (excludeMe) {
                participantCountWithoutMe -= 1;
            }
            menuProps.items.push({
                key: 'participantCountKey',
                name: _formatString(strings.participantsListButtonLabel, {
                    numParticipants: `${participantCountWithoutMe}`
                }),
                itemProps: {
                    styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.menuItemStyles
                },
                iconProps: {
                    iconName: 'People'
                },
                subMenuProps: {
                    items: generateDefaultParticipantsSubMenuProps(),
                    calloutProps: {
                        styles: {
                            root: {
                                // Confine the menu to the parents bounds.
                                // More info: https://github.com/microsoft/fluentui/issues/18835
                                maxWidth: '100%'
                            }
                        },
                        style: {
                            maxHeight: '20rem'
                        },
                        // Disable dismiss on resize to work around a couple Fluent UI bugs
                        // See reasoning in the props for the parent menu.
                        preventDismissOnEvent: _preventDismissOnEvent
                    }
                },
                'data-ui-id': ids.participantButtonPeopleMenuItem
            });
        }
        if (callInvitationURL) {
            menuProps.items.push({
                key: 'InviteLinkKey',
                name: strings.copyInviteLinkButtonLabel,
                title: strings.copyInviteLinkButtonLabel,
                itemProps: {
                    styles: (_b = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _b === void 0 ? void 0 : _b.menuItemStyles
                },
                iconProps: {
                    iconName: 'Link'
                },
                onClick: () => {
                    onCopyCallback();
                    toggleAnnouncerString();
                }
            });
        }
        return menuProps;
    }, [strings.menuHeader, strings.participantsListButtonLabel, strings.copyInviteLinkButtonLabel, styles === null || styles === void 0 ? void 0 : styles.menuStyles, participantCount, callInvitationURL, participants, excludeMe, ids.participantButtonPeopleMenuItem, generateDefaultParticipantsSubMenuProps, onCopyCallback, toggleAnnouncerString]);
    return React.createElement(React.Fragment, null,
        React.createElement(Announcer, { announcementString: copyInviteLinkAnnouncerStrings, ariaLive: 'polite' }),
        React.createElement(ControlBarButton, Object.assign({}, props, { disabled: disabled, menuProps: (_c = props.menuProps) !== null && _c !== void 0 ? _c : defaultMenuProps, menuIconProps: {
                hidden: true
            }, onRenderIcon: onRenderIcon !== null && onRenderIcon !== void 0 ? onRenderIcon : onRenderPeopleIcon, strings: strings, labelKey: (_d = props.labelKey) !== null && _d !== void 0 ? _d : 'participantsButtonLabel' })));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A button to start / stop screen sharing.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const ScreenShareButton = (props) => {
    var _a, _b, _c, _d;
    const localeStrings = useLocale$1().strings.screenShareButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = react.useTheme();
    const styles = screenshareButtonStyles(theme);
    const onRenderScreenShareOnIcon = () => React.createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonScreenShareStop" });
    const onRenderScreenShareOffIcon = () => React.createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonScreenShareStart" });
    return React.createElement(ControlBarButton, Object.assign({}, props, { className: react.mergeStyles(styles, props.styles), onClick: (_a = props.onToggleScreenShare) !== null && _a !== void 0 ? _a : props.onClick, onRenderOnIcon: (_b = props.onRenderOnIcon) !== null && _b !== void 0 ? _b : onRenderScreenShareOnIcon, onRenderOffIcon: (_c = props.onRenderOffIcon) !== null && _c !== void 0 ? _c : onRenderScreenShareOffIcon, strings: strings, labelKey: (_d = props.labelKey) !== null && _d !== void 0 ? _d : 'screenShareButtonLabel', disabled: props.disabled }));
};
const screenshareButtonStyles = (theme) => ({
    rootChecked: {
        background: theme.palette.themePrimary,
        color: react.DefaultPalette.white,
        ':focus::after': {
            outlineColor: `${react.DefaultPalette.white} !important`
        },
        // added !important to avoid override by FluentUI button styles
        '@media (forced-colors: active)': {
            border: '1px solid',
            borderColor: theme.palette.black
        }
    },
    rootCheckedHovered: {
        background: theme.palette.themePrimary,
        color: react.DefaultPalette.white,
        ':focus::after': {
            outlineColor: `${react.DefaultPalette.white} !important`
        },
        // added !important to avoid override by FluentUI button styles
        '@media (forced-colors: active)': {
            border: '1px solid',
            borderColor: theme.palette.black
        }
    },
    labelChecked: {
        color: react.DefaultPalette.white
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(raise-hand) */
/* @conditional-compile-remove(raise-hand) */
/**
 * A button to start / stop screen sharing.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const RaiseHandButton = (props) => {
    var _a, _b, _c, _d;
    const localeStrings = useLocale$1().strings.raiseHandButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = react.useTheme();
    const styles = raiseHandButtonStyles(theme);
    const onRenderRaiseHandIcon = () => React.createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonRaiseHand" });
    const onRenderLowerHandIcon = () => React.createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonLowerHand" });
    return React.createElement(ControlBarButton, Object.assign({}, props, { className: react.mergeStyles(styles, props.styles), onClick: (_a = props.onToggleRaiseHand) !== null && _a !== void 0 ? _a : props.onClick, onRenderOnIcon: (_b = props.onRenderOnIcon) !== null && _b !== void 0 ? _b : onRenderLowerHandIcon, onRenderOffIcon: (_c = props.onRenderOffIcon) !== null && _c !== void 0 ? _c : onRenderRaiseHandIcon, strings: strings, labelKey: (_d = props.labelKey) !== null && _d !== void 0 ? _d : 'raiseHandButtonLabel', disabled: props.disabled }));
};
/* @conditional-compile-remove(raise-hand) */
const raiseHandButtonStyles = (theme) => ({
    rootChecked: {
        background: theme.palette.themePrimary,
        color: react.DefaultPalette.white,
        ':focus::after': {
            outlineColor: `${react.DefaultPalette.white}`
        }
    },
    rootCheckedHovered: {
        background: theme.palette.themePrimary,
        color: react.DefaultPalette.white,
        ':focus::after': {
            outlineColor: `${react.DefaultPalette.white}`
        }
    },
    labelChecked: {
        color: react.DefaultPalette.white
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const PictureInPictureInPicturePrimaryTile = (props) => {
    const boxShadow = useTheme().effects.elevation8;
    return React.createElement(PictureInPictureInPictureTile, { styles: primaryTileStyles(props.orientation, boxShadow) }, props.children);
};
/** @private */
const PictureInPictureInPictureSecondaryTile = (props) => React.createElement(PictureInPictureInPictureTile, { styles: secondaryTileStyles(props.orientation) }, props.children);
const PictureInPictureInPictureTile = (props) => React.createElement(react.Stack, { styles: props.styles }, props.children);
const primaryTileStyles = react.memoizeFunction((orientation, themeElevation) => ({
    root: {
        borderRadius: '0.25rem',
        height: orientation === 'landscape' ? '5.5rem' : '8rem',
        width: orientation === 'landscape' ? '8rem' : '5.5rem',
        boxShadow: themeElevation,
        // PiPiP tiles were not designed to host scrollable content. If removed check no scrollbar is showing in e2e tests
        overflow: 'hidden'
    }
}));
const secondaryTileStyles = react.memoizeFunction((orientation) => ({
    root: {
        borderRadius: '0.25rem',
        height: orientation === 'landscape' ? '1.625rem' : '2rem',
        width: orientation === 'landscape' ? '2rem' : '1.625rem',
        // PiPiP tiles were not designed to host scrollable content. If removed check no scrollbar is showing in e2e tests
        overflow: 'hidden'
    }
}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Component that displays a video feed for use as a Picture-in-Picture style component.
 * It contains a secondary video feed resulting in an inner Picture-in-Picture style feed.
 *
 * @remarks
 * The double nature of the Picture-in-Picture styles is where this component gets its name; Picture-in-Picture-in-Picture.
 *
 * @internal
 */
const _PictureInPictureInPicture = (props) => {
    return React.createElement(PictureInPictureInPictureContainer, { onClick: props.onClick, primaryView: React.createElement(PictureInPictureInPicturePrimaryTile, Object.assign({}, props.primaryTile)), secondaryView: props.secondaryTile && React.createElement(PictureInPictureInPictureSecondaryTile, Object.assign({}, props.secondaryTile)), ariaLabel: props.strings.rootAriaLabel });
};
/**
 * Container for the picture in picture in picture component.
 * This governs positioning and floating of the secondary PiP.
 */
const PictureInPictureInPictureContainer = (props) => {
    const onKeyPress = (e) => props.onClick && submitWithKeyboard(e, props.onClick);
    return React.createElement("aside", { style: tileContainerStyles$1, onClick: props.onClick, onKeyPress: onKeyPress, "aria-label": props.ariaLabel, tabIndex: props.onClick ? 0 : -1, "data-ui-id": "picture-in-picture-in-picture-root" },
        props.primaryView,
        React.createElement("div", { style: secondaryTileFloatingStyles }, props.secondaryView));
};
const tileContainerStyles$1 = {
    display: 'flex',
    width: 'min-content',
    position: 'relative',
    cursor: 'pointer'
};
const secondaryTileFloatingStyles = {
    // The secondary tile should float above the primary tile, aligned to the bottom right.
    position: 'absolute',
    bottom: '0.125rem',
    right: '0.125rem'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Note: If we use stack tokens.childrenGap, when child elements are wrapped and moved to the next line,
 * an extra margin is added to the left of each line.
 * This is a workaround to avoid this issue.
 */
react.mergeStyles({
    flexFlow: 'row wrap',
    '& > *': {
        margin: _pxToRem(2)
    },
    /**
     * margin for children is overriden by parent stack, so adding left margin for each child
     */
    '& > *:not(:first-child)': {
        marginLeft: _pxToRem(2)
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
react.mergeStyles({
    color: 'unset',
    width: '1rem',
    height: '1rem',
    background: 'transparent',
    ':hover': {
        color: 'unset',
        background: 'transparent'
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
(window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Return different conditions based on the current and previous state of recording and transcribing
 *
 * @param callRecordState - The current call record state: on, off, stopped
 * @param callTranscribeState - The current call transcribe state: on, off, stopped
 *
 * @remarks - The stopped state means: previously on but currently off
 *
 * @private
 */
const computeVariant = (callRecordState, callTranscribeState) => {
    if (callRecordState === 'on' && callTranscribeState === 'on') {
        return 'RECORDING_AND_TRANSCRIPTION_STARTED';
    }
    else if (callRecordState === 'on' && callTranscribeState === 'off') {
        return 'RECORDING_STARTED';
    }
    else if (callRecordState === 'off' && callTranscribeState === 'on') {
        return 'TRANSCRIPTION_STARTED';
    }
    else if (callRecordState === 'on' && callTranscribeState === 'stopped') {
        return 'TRANSCRIPTION_STOPPED_STILL_RECORDING';
    }
    else if (callRecordState === 'stopped' && callTranscribeState === 'on') {
        return 'RECORDING_STOPPED_STILL_TRANSCRIBING';
    }
    else if (callRecordState === 'off' && callTranscribeState === 'stopped') {
        return 'TRANSCRIPTION_STOPPED';
    }
    else if (callRecordState === 'stopped' && callTranscribeState === 'off') {
        return 'RECORDING_STOPPED';
    }
    else if (callRecordState === 'stopped' && callTranscribeState === 'stopped') {
        return 'RECORDING_AND_TRANSCRIPTION_STOPPED';
    }
    else {
        return 'NO_STATE';
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
function BannerMessage(props) {
    const { variant, strings } = props;
    switch (variant) {
        case 'TRANSCRIPTION_STOPPED_STILL_RECORDING':
            return React.createElement(React.Fragment, null,
                React.createElement("b", null, strings.complianceBannerTranscriptionStopped),
                ` ${strings.complianceBannerNowOnlyRecording}`,
                React.createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'RECORDING_STOPPED_STILL_TRANSCRIBING':
            return React.createElement(React.Fragment, null,
                React.createElement("b", null, strings.complianceBannerRecordingStopped),
                ` ${strings.complianceBannerNowOnlyTranscription}`,
                React.createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'RECORDING_AND_TRANSCRIPTION_STOPPED':
            return React.createElement(React.Fragment, null,
                React.createElement("b", null, strings.complianceBannerRecordingAndTranscriptionSaved),
                ` ${strings.complianceBannerRecordingAndTranscriptionStopped}`,
                React.createElement(LearnMore, { linkText: strings.learnMore }));
        case 'RECORDING_AND_TRANSCRIPTION_STARTED':
            return React.createElement(React.Fragment, null,
                React.createElement("b", null, strings.complianceBannerRecordingAndTranscriptionStarted),
                ` ${strings.complianceBannerTranscriptionConsent}`,
                React.createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'TRANSCRIPTION_STARTED':
            return React.createElement(React.Fragment, null,
                React.createElement("b", null, strings.complianceBannerTranscriptionStarted),
                ` ${strings.complianceBannerTranscriptionConsent}`,
                React.createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'RECORDING_STOPPED':
            return React.createElement(React.Fragment, null,
                React.createElement("b", null, strings.complianceBannerRecordingSaving),
                ` ${strings.complianceBannerRecordingStopped}`,
                React.createElement(LearnMore, { linkText: strings.learnMore }));
        case 'RECORDING_STARTED':
            return React.createElement(React.Fragment, null,
                React.createElement("b", null, strings.complianceBannerRecordingStarted),
                ` ${strings.complianceBannerTranscriptionConsent}`,
                React.createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'TRANSCRIPTION_STOPPED':
            return React.createElement(React.Fragment, null,
                React.createElement("b", null, strings.complianceBannerTranscriptionSaving),
                ` ${strings.complianceBannerTranscriptionStopped}`,
                React.createElement(LearnMore, { linkText: strings.learnMore }));
    }
    return React.createElement(React.Fragment, null);
}
function PrivacyPolicy(props) {
    return React.createElement(react.Link, { href: "https://privacy.microsoft.com/privacystatement#mainnoticetoendusersmodule", target: "_blank", underline: true }, props.linkText);
}
function LearnMore(props) {
    return React.createElement(react.Link, { href: "https://support.microsoft.com/office/record-a-meeting-in-teams-34dfbe7f-b07d-4a27-b4c6-de62f1348c24", target: "_blank", underline: true }, props.linkText);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const BANNER_OVERWRITE_DELAY_MS = 3000;
/**
 * Shows a {@link BannerMessage} in a {@link MessageBar} tracking `variant` internally.
 *
 * This component delays and combines frequent updates to `variant` such that:
 * - Updates that happen within {@link BANNER_OVERWRITE_DELAY_MS} are delayed.
 * - Once {@link BANNER_OVERWRITE_DELAY_MS} has passed since the last update, the _latest_ pending update is shown.
 *
 * This ensures that there is enough time for the user to see a banner message before it is overwritten.
 * In case of multiple delayed messages, the user always sees the final message as it reflects the final state
 * of recording and transcription.
 *
 * @private
 */
function DelayedUpdateBanner(props) {
    const { variant, lastUpdated: variantLastUpdated } = props.variant;
    // Tracks the variant that is currently visible in the UI.
    const [visible, setVisible] = React.useState({
        variant,
        lastUpdated: Date.now()
    });
    const pendingUpdateHandle = React.useRef(null);
    if (variant !== visible.variant && variantLastUpdated > visible.lastUpdated) {
        // Always clear pending updates.
        // We'll either update now, or schedule an update for later.
        if (pendingUpdateHandle.current) {
            clearTimeout(pendingUpdateHandle.current);
        }
        const now = Date.now();
        const timeToNextUpdate = BANNER_OVERWRITE_DELAY_MS - (now - visible.lastUpdated);
        if (variant === 'NO_STATE' || timeToNextUpdate <= 0) {
            setVisible({
                variant,
                lastUpdated: now
            });
        }
        else {
            pendingUpdateHandle.current = setTimeout(() => {
                // Set the actual update time, not the computed time when the update should happen.
                // The actual update might be later than we planned.
                setVisible({
                    variant,
                    lastUpdated: Date.now()
                });
            }, timeToNextUpdate);
        }
    }
    if (visible.variant === 'NO_STATE') {
        return React.createElement(React.Fragment, null);
    }
    return React.createElement(react.MessageBar, { messageBarType: react.MessageBarType.warning, onDismiss: () => {
            // when closing the banner, change variant to nostate and change stopped state to off state.
            // Reason: on banner close, going back to the default state.
            setVisible({
                variant: 'NO_STATE',
                lastUpdated: Date.now()
            });
            props.onDismiss();
        }, dismissButtonAriaLabel: props.strings.close },
        React.createElement(BannerMessage, { variant: visible.variant, strings: props.strings }));
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A component that displays banners to notify the user when call recording and
 * transcription is enabled or disabled in a call.
 *
 * This component implements a state machine that tracks the changes to call
 * recording and transcription state and shows the corresponding message.
 *
 * @internal
 */
const _ComplianceBanner = (props) => {
    const cachedProps = React.useRef({
        latestBooleanState: {
            callTranscribeState: false,
            callRecordState: false
        },
        latestStringState: {
            callTranscribeState: 'off',
            callRecordState: 'off'
        },
        lastUpdated: Date.now()
    });
    // Only update cached props and variant if there is _some_ change in the latest props.
    // This ensures that state machine is only updated if there is an actual change in the props.
    const shouldUpdateCached = props.callRecordState !== cachedProps.current.latestBooleanState.callRecordState || props.callTranscribeState !== cachedProps.current.latestBooleanState.callTranscribeState;
    // The following three operations must be performed in this exact order:
    // [1]: Update cached state to transition the state machine.
    if (shouldUpdateCached) {
        cachedProps.current = {
            latestBooleanState: props,
            latestStringState: {
                callRecordState: determineStates(cachedProps.current.latestStringState.callRecordState, props.callRecordState),
                callTranscribeState: determineStates(cachedProps.current.latestStringState.callTranscribeState, props.callTranscribeState)
            },
            lastUpdated: Date.now()
        };
    }
    // [2]: Compute the variant, using the transitioned state machine.
    const variant = computeVariant(cachedProps.current.latestStringState.callRecordState, cachedProps.current.latestStringState.callTranscribeState);
    // [3]: Transition the state machine again to deal with some end-states.
    if (shouldUpdateCached && cachedProps.current.latestStringState.callRecordState === 'stopped' && cachedProps.current.latestStringState.callTranscribeState === 'stopped') {
        // When both states are stopped, after displaying message "RECORDING_AND_TRANSCRIPTION_STOPPED", change both states to off (going back to the default state).
        cachedProps.current.latestStringState.callRecordState = 'off';
        cachedProps.current.latestStringState.callTranscribeState = 'off';
    }
    return React.createElement(DelayedUpdateBanner, { variant: {
            variant,
            lastUpdated: cachedProps.current.lastUpdated
        }, strings: props.strings, onDismiss: () => {
            if (cachedProps.current.latestStringState.callRecordState === 'stopped') {
                cachedProps.current.latestStringState.callRecordState = 'off';
            }
            if (cachedProps.current.latestStringState.callTranscribeState === 'stopped') {
                cachedProps.current.latestStringState.callTranscribeState = 'off';
            }
        } });
};
function determineStates(previous, current) {
    // if current state is on, then return on
    if (current) {
        return 'on';
    }
    // if current state is off
    else {
        // if previous state is on and current state is off, return stopped (on -> off)
        if (previous === 'on') {
            return 'stopped';
        }
        // otherwise remain previous state unchanged
        else {
            return previous;
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const containerStyles$1 = (theme) => {
    return {
        maxWidth: '16rem',
        textAlign: 'center',
        background: `${theme.palette.white}`,
        borderRadius: '0.75rem',
        margin: 'auto'
    };
};
/**
 * @private
 */
const buttonStyles$1 = (theme) => ({
    root: {
        background: 'none',
        fontWeight: 600,
        fontSize: `${_pxToRem(20)}`,
        border: 'none',
        borderRadius: 0,
        width: '3rem',
        height: '3rem',
        padding: `${_pxToRem(16)}, ${_pxToRem(5)}, ${_pxToRem(16)}, ${_pxToRem(5)}`,
        minWidth: 0,
        minHeight: 0
    }
});
/**
 * @private
 */
const digitStyles = (theme) => {
    return {
        fontSize: '1.25rem',
        fontWeight: theme.fonts.medium.fontWeight,
        color: `${theme.palette.themePrimary}`
    };
};
/**
 * @private
 */
const textFieldStyles = (theme, buttonPresent) => ({
    field: {
        padding: 0,
        textAlign: 'center',
        fontSize: `${_pxToRem(18)}`,
        fontWeight: 400,
        width: `${buttonPresent ? '10rem' : '12rem'}`,
        height: '3rem',
        borderRadius: '0.5rem',
        position: 'relative',
        overflowX: 'hidden',
        textOverflow: 'clip'
    },
    root: {
        backgroundColor: `${theme.palette.neutralLighter}`,
        marginBottom: '0.625rem',
        height: '3rem',
        borderRadius: '0.5rem'
    },
    fieldGroup: {
        border: 'none',
        borderRadius: '0.5rem',
        width: '12rem',
        height: '3rem',
        backgroundColor: `${theme.palette.neutralLighter}`,
        ':after': {
            borderRadius: '0.5rem'
        }
    },
    errorMessage: {
        color: theme.semanticColors.errorText
    },
    suffix: {
        padding: 0,
        position: 'absolute',
        right: '0.25rem',
        top: '0.55rem',
        transform: 'scale(1.15)',
        background: 'unset'
    }
});
/**
 * @private
 */
const letterStyles = (theme) => {
    return {
        fontSize: '0.625rem',
        color: `${theme.palette.neutralSecondary}`,
        fontWeight: 400,
        margin: '0.125rem',
        minHeight: '0.75rem'
    };
};
/**
 * @private
 */
const iconButtonStyles = (theme) => {
    return {
        root: {
            color: `${theme.palette.black}`,
            padding: 0,
            background: 'transparent'
        },
        icon: {
            height: 'auto',
            background: 'transparent',
            // Needed to keep the icon vertically centered.
            '> span': {
                display: 'flex'
            }
        }
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const formatPhoneNumber = (phoneNumber) => {
    // if input value is falsy eg if the user deletes the input, then just return
    if (!phoneNumber) {
        return phoneNumber;
    }
    // if phone number starts with 1, format like 1 (xxx)xxx-xxxx.
    // if phone number starts with +, we format like +x (xxx)xxx-xxxx.
    // For now we are only supporting NA phone number formatting with country code +x
    // first we chop off the countrycode then we add it on when returning
    let countryCodeNA = '';
    if (phoneNumber[0] === '1') {
        countryCodeNA = '1 ';
        phoneNumber = phoneNumber.slice(1, phoneNumber.length);
    }
    else if (phoneNumber[0] === '+') {
        countryCodeNA = phoneNumber.slice(0, 2) + ' ';
        phoneNumber = phoneNumber.slice(2, phoneNumber.length);
    }
    // phoneNumberLength is used to know when to apply our formatting for the phone number
    const phoneNumberLength = phoneNumber.length;
    // we need to return the value with no formatting if its less then four digits
    // this is to avoid weird behavior that occurs if you  format the area code too early
    // if phoneNumberLength is greater than 10 we don't do any formatting
    if (phoneNumberLength < 4 || phoneNumberLength > 10) {
        // no formatting in this case, remove ' ' behind countrycode
        return countryCodeNA.replace(' ', '') + phoneNumber;
    }
    // if phoneNumberLength is greater than 4 and less the 7 we start to return
    // the formatted number
    if (phoneNumberLength < 7) {
        return `${countryCodeNA}(${phoneNumber.slice(0, 3)}) ${phoneNumber.slice(3)}`;
    }
    // finally, if the phoneNumberLength is greater then seven, we add the last
    // bit of formatting and return it.
    return `${countryCodeNA}(${phoneNumber.slice(0, 3)}) ${phoneNumber.slice(3, 6)}-${phoneNumber.slice(6, phoneNumber.length)}`;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Class for playing individual DTMF Tones.
 *
 * @internal
 */
class Tone {
    constructor(context, frequency1, frequency2) {
        this.isPlaying = false;
        /**
         * Function to play the tone. will create new ocillators because they are one use objects so we need to make
         * new ones every time we play a tone.
         */
        this.play = () => {
            if (this.isPlaying) {
                return;
            }
            const gainNode = this.context.createGain();
            gainNode.gain.value = 0.1;
            gainNode.connect(this.context.destination);
            this.oscillatorNode1 = this.context.createOscillator();
            this.oscillatorNode1.frequency.value = this.frequency1;
            this.oscillatorNode1.connect(gainNode);
            this.oscillatorNode2 = this.context.createOscillator();
            this.oscillatorNode2.frequency.value = this.frequency2;
            this.oscillatorNode2.connect(gainNode);
            this.oscillatorNode1.start();
            this.oscillatorNode2.start();
            this.isPlaying = true;
        };
        /**
         * Function to stop the tone.
         */
        this.stop = () => {
            if (this.oscillatorNode1 && this.oscillatorNode2) {
                this.oscillatorNode1.stop();
                this.oscillatorNode2.stop();
                this.oscillatorNode1.disconnect();
                this.oscillatorNode2.disconnect();
                this.isPlaying = false;
            }
        };
        this.context = context;
        this.frequency1 = frequency1;
        this.frequency2 = frequency2;
    }
}
/**
 * Mapping of the different dtmf frequencies that are needed for the creation of sound that
 * matches the dtmf tones.
 *
 * @internal
 */
const dtmfFrequencies = {
    '1': {
        f1: 697,
        f2: 1209
    },
    '2': {
        f1: 697,
        f2: 1336
    },
    '3': {
        f1: 697,
        f2: 1477
    },
    '4': {
        f1: 770,
        f2: 1209
    },
    '5': {
        f1: 770,
        f2: 1336
    },
    '6': {
        f1: 770,
        f2: 1477
    },
    '7': {
        f1: 852,
        f2: 1209
    },
    '8': {
        f1: 852,
        f2: 1336
    },
    '9': {
        f1: 852,
        f2: 1477
    },
    '*': {
        f1: 941,
        f2: 1209
    },
    '0': {
        f1: 941,
        f2: 1336
    },
    '#': {
        f1: 941,
        f2: 1477
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$s = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const dialPadButtonsDefault = [[{
            digit: '1'
        }, {
            digit: '2',
            letter: 'ABC'
        }, {
            digit: '3',
            letter: 'DEF'
        }], [{
            digit: '4',
            letter: 'GHI'
        }, {
            digit: '5',
            letter: 'JKL'
        }, {
            digit: '6',
            letter: 'MNO'
        }], [{
            digit: '7',
            letter: 'PQRS'
        }, {
            digit: '8',
            letter: 'TUV'
        }, {
            digit: '9',
            letter: 'WXYZ'
        }], [{
            digit: '*'
        }, {
            digit: '0',
            letter: '+'
        }, {
            digit: '#'
        }]];
const DtmfTones = ['Num1', 'Num2', 'Num3', 'Num4', 'Num5', 'Num6', 'Num7', 'Num8', 'Num9', 'Star', 'Num0', 'Pound'];
const DialpadButton = (props) => {
    var _a, _b, _c, _d;
    const theme = react.useTheme();
    const { digit, index, onClick, onLongPress, longPressTrigger, dtmfToneAudioContext, disableDtmfPlayback } = props;
    const [buttonPressed, setButtonPressed] = React.useState(false);
    const dtmfToneSound = React.useRef(new Tone(dtmfToneAudioContext, dtmfFrequencies[digit].f1, dtmfFrequencies[digit].f2));
    const useLongPressProps = React.useMemo(() => ({
        onClick: () => __awaiter$s(void 0, void 0, void 0, function* () {
            onClick(digit, index);
        }),
        onLongPress: () => __awaiter$s(void 0, void 0, void 0, function* () {
            onLongPress(digit, index);
        }),
        touchEventsOnly: longPressTrigger === 'touch'
    }), [digit, index, longPressTrigger, onClick, onLongPress]);
    const longPressHandlers = useLongPress(useLongPressProps);
    return React.createElement(react.DefaultButton, Object.assign({ "data-test-id": `dialpad-button-${props.index}`, styles: react.concatStyleSets(buttonStyles$1(), (_a = props.styles) === null || _a === void 0 ? void 0 : _a.button) }, longPressHandlers, { onKeyDown: e => {
            if ((e.key === 'Enter' || e.key === ' ') && !buttonPressed) {
                if (!disableDtmfPlayback) {
                    dtmfToneSound.current.play();
                }
                longPressHandlers.onKeyDown();
                setButtonPressed(true);
                return;
            }
            if (e.key === 'Tab' || e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                dtmfToneSound.current.stop();
            }
            longPressHandlers.onKeyDown();
        }, onKeyUp: e => {
            if ((e.key === 'Enter' || e.key === ' ') && buttonPressed) {
                dtmfToneSound.current.stop();
                longPressHandlers.onKeyUp();
                setButtonPressed(false);
            }
            longPressHandlers.onKeyUp();
        }, onMouseDown: () => {
            if (!disableDtmfPlayback) {
                dtmfToneSound.current.play();
            }
            longPressHandlers.onMouseDown();
        }, onMouseUp: () => {
            dtmfToneSound.current.stop();
            longPressHandlers.onMouseUp();
        }, onMouseLeave: () => {
            dtmfToneSound.current.stop();
        }, onTouchStart: () => {
            if (!disableDtmfPlayback) {
                dtmfToneSound.current.play();
            }
            longPressHandlers.onTouchStart();
        }, onTouchEnd: () => {
            dtmfToneSound.current.stop();
            longPressHandlers.onTouchEnd();
        } }),
        React.createElement(react.Stack, null,
            React.createElement(react.Text, { className: react.mergeStyles(digitStyles(theme), (_b = props.styles) === null || _b === void 0 ? void 0 : _b.digit) }, props.digit),
            React.createElement(react.Text, { className: react.mergeStyles(letterStyles(theme), (_c = props.styles) === null || _c === void 0 ? void 0 : _c.letter) }, (_d = props.letter) !== null && _d !== void 0 ? _d : ' ')));
};
const DialpadContainer = (props) => {
    var _a, _b;
    const theme = react.useTheme();
    const { onSendDtmfTone, onClickDialpadButton, textFieldValue, onChange, showDeleteButton = true, longPressTrigger = 'mouseAndTouch', disableDtmfPlayback, dialpadMode = 'dialer' } = props;
    const dtmfToneAudioContext = React.useRef(new AudioContext());
    const [plainTextValue, setPlainTextValue] = React.useState(textFieldValue !== null && textFieldValue !== void 0 ? textFieldValue : '');
    const plainTextValuePreviousRenderValue = React.useRef(plainTextValue);
    React.useEffect(() => {
        if (plainTextValuePreviousRenderValue.current !== plainTextValue) {
            onChange === null || onChange === void 0 ? void 0 : onChange(plainTextValue);
        }
        plainTextValuePreviousRenderValue.current = plainTextValue;
    }, [plainTextValuePreviousRenderValue, plainTextValue, onChange]);
    React.useEffect(() => {
        setText(textFieldValue !== null && textFieldValue !== void 0 ? textFieldValue : '');
    }, [textFieldValue]);
    const onClickDialpad = (input, index) => {
        setText(plainTextValue + input);
        if (onSendDtmfTone) {
            onSendDtmfTone(DtmfTones[index]);
        }
        if (onClickDialpadButton) {
            onClickDialpadButton(input, index);
        }
    };
    const onLongPressDialpad = (input, index) => {
        if (input === '0' && index === 10) {
            setText(plainTextValue + '+');
        }
        else {
            setText(plainTextValue + input);
        }
        if (onSendDtmfTone) {
            onSendDtmfTone(DtmfTones[index]);
        }
        if (onClickDialpadButton) {
            onClickDialpadButton(input, index);
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const setText = (input) => {
        // remove non-valid characters from input: letters,special characters excluding +, *,#
        const plainInput = sanitizeInput(input);
        setPlainTextValue(plainInput);
    };
    const deleteNumbers = () => {
        const modifiedInput = plainTextValue.substring(0, plainTextValue.length - 1);
        setText(modifiedInput);
    };
    return React.createElement(react.Stack, { className: react.mergeStyles(containerStyles$1(theme), (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root), "data-test-id": "dialpadContainer", "data-ui-id": "dialpadContainer", horizontalAlign: 'center' },
        dialpadMode === 'dialer' && React.createElement(react.TextField, { styles: react.concatStyleSets(textFieldStyles(theme, plainTextValue !== ''), (_b = props.styles) === null || _b === void 0 ? void 0 : _b.textField), value: textFieldValue ? textFieldValue : formatPhoneNumber(plainTextValue), 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onChange: (e) => {
                setText(e.target.value);
            }, onClick: e => {
                e.preventDefault();
            }, placeholder: props.strings.placeholderText, "data-test-id": "dialpad-input", onRenderSuffix: () => {
                var _a;
                return React.createElement(React.Fragment, null, showDeleteButton && plainTextValue.length !== 0 && React.createElement(react.IconButton, { ariaLabel: props.strings.deleteButtonAriaLabel, onClick: deleteNumbers, styles: react.concatStyleSets(iconButtonStyles(theme), (_a = props.styles) === null || _a === void 0 ? void 0 : _a.deleteIcon), iconProps: {
                        iconName: 'DialpadBackspace'
                    } }));
            } }),
        React.createElement(react.FocusZone, null, dialPadButtonsDefault.map((rows, rowIndex) => {
            return React.createElement(react.Stack, { horizontal: true, key: `row_${rowIndex}`, horizontalAlign: "stretch", tokens: {
                    childrenGap: '1rem'
                } }, rows.map((button, columnIndex) => React.createElement(DialpadButton, { key: `button_${columnIndex}`, 
                /* row index = 0
                columnIndex: (0,1,2) => (0,1,2)
                row index = 1
                columnIndex: (0,1,2)=> (3,4,5)
                row index = 2
                columnIndex: (0,1,2)=> (6,7,8)
                row index = 3
                columnIndex: (0,1,2)=> (9,10,11)
                columnIndex + rowIndex*rows.length calculates the corresponding index for each button
                dialpad index:
                0 1 2
                3 4 5
                6 7 8
                9 10 11
                then use this index to locate the corresponding dtmf tones
                DtmfTones[index]
                */ index: columnIndex + rowIndex * rows.length, digit: button.digit, letter: button.letter, styles: props.styles, onClick: onClickDialpad, onLongPress: onLongPressDialpad, longPressTrigger: longPressTrigger, dtmfToneAudioContext: dtmfToneAudioContext.current, disableDtmfPlayback: disableDtmfPlayback })));
        })));
};
/**
 * A component to allow users to enter phone number through clicking on dialpad/using keyboard
 * It will return empty component for stable builds
 *
 * @public
 */
const Dialpad = (props) => {
    /* @conditional-compile-remove(dialpad) */ /* @conditional-compile-remove(PSTN-calls) */
    const localeStrings = useLocale$1().strings.dialpad;
    const dialpadLocaleStringsTrampoline = () => {
        /* @conditional-compile-remove(dialpad) */ /* @conditional-compile-remove(PSTN-calls) */
        return localeStrings;
    };
    const strings = Object.assign(Object.assign({}, dialpadLocaleStringsTrampoline()), props.strings);
    return React.createElement(DialpadContainer, Object.assign({ strings: strings }, props));
};
const sanitizeInput = (input) => {
    // remove non-valid characters from input: letters,special characters excluding +, *,#
    return input.replace(/[^\d*#+]/g, '');
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const VideoEffectsItemContainerHeight = '3.375rem';
const VideoEffectsItemContainerWidth = '4.83rem';
const VideoEffectsItemContainerBorderHeight = '3.373rem';
const VideoEffectsItemContainerBorderWidth = '4.85rem';
const VideoEffectsItemContainerBorderSize = '2px';
/** @private */
const hiddenVideoEffectsItemContainerStyles = {
    root: {
        visibility: 'hidden',
        height: VideoEffectsItemContainerHeight,
        width: VideoEffectsItemContainerWidth,
        border: VideoEffectsItemContainerBorderSize
    }
};
/** @private */
const videoEffectsItemContainerStyles = (args) => {
    const borderDefaultThickness = '1px';
    const borderActiveThickness = '2px';
    return {
        root: {
            background: args.disabled ? args.theme.palette.neutralQuaternaryAlt : undefined,
            backgroundImage: args.backgroundImage ? `url(${args.backgroundImage})` : undefined,
            backgroundPosition: 'center',
            backgroundSize: 'cover',
            borderRadius: '0.25rem',
            color: args.theme.palette.neutralPrimary,
            cursor: args.disabled ? 'default' : 'pointer',
            height: VideoEffectsItemContainerHeight,
            width: VideoEffectsItemContainerWidth,
            outlineOffset: '-1px',
            outline: args.isSelected ? `${borderActiveThickness} solid ${args.theme.palette.themePrimary}` : `${borderDefaultThickness} solid ${args.theme.palette.neutralQuaternaryAlt}`,
            ':hover': {
                boxSizing: 'border-box',
                width: VideoEffectsItemContainerBorderWidth,
                height: VideoEffectsItemContainerBorderHeight,
                outlineOffset: '-1px',
                outline: args.disabled && !args.isSelected ? `${borderDefaultThickness} solid ${args.theme.palette.neutralQuaternaryAlt}` : `${borderActiveThickness} solid ${args.theme.palette.themePrimary}`
            }
        }
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A component for displaying a Video Background Effect Option.
 *
 * @internal
 */
const _VideoEffectsItem = (props) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const theme = react.useTheme();
    const isSelected = (_a = props.isSelected) !== null && _a !== void 0 ? _a : false;
    const disabled = (_b = props.disabled) !== null && _b !== void 0 ? _b : false;
    const backgroundImage = (_c = props.backgroundProps) === null || _c === void 0 ? void 0 : _c.url;
    const containerStyles = React.useCallback(() => videoEffectsItemContainerStyles({
        theme,
        isSelected,
        disabled,
        backgroundImage
    }), [backgroundImage, disabled, isSelected, theme]);
    const componentRef = React.createRef();
    React.useEffect(() => {
        if (props.focusOnMount && componentRef.current) {
            componentRef.current.focus();
        }
    }, [componentRef, props.focusOnMount]);
    return React.createElement(react.TooltipHost, Object.assign({}, props.tooltipProps),
        React.createElement(react.Stack, { key: props.itemKey, className: react.mergeStyles((_d = props.styles) === null || _d === void 0 ? void 0 : _d.root), verticalAlign: "center", horizontalAlign: "center", "data-ui-id": `video-effects-item`, "aria-label": (_e = props.ariaLabel) !== null && _e !== void 0 ? _e : props.itemKey, "aria-disabled": props.disabled },
            React.createElement(react.DefaultButton, { styles: containerStyles(), onClick: disabled ? undefined : () => { var _a; return (_a = props.onSelect) === null || _a === void 0 ? void 0 : _a.call(props, props.itemKey); }, componentRef: componentRef, autoFocus: props.focusOnMount },
                React.createElement(react.Stack, { horizontalAlign: 'center', tokens: {
                        childrenGap: '0.15rem'
                    } },
                    props.iconProps && React.createElement(react.Stack.Item, { styles: {
                            root: (_f = props.styles) === null || _f === void 0 ? void 0 : _f.iconContainer
                        } },
                        React.createElement(react.Icon, Object.assign({}, props.iconProps))),
                    props.title && React.createElement(react.Stack.Item, { styles: {
                            root: (_g = props.styles) === null || _g === void 0 ? void 0 : _g.textContainer
                        } },
                        React.createElement(react.Text, { variant: "small" }, props.title))))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Picker for choosing a Video Background Effect.
 *
 * @remarks
 * This functions similar to a radio group of buttons, where the user can select one of the options.
 *
 * @internal
 */
const _VideoBackgroundEffectsPicker = (props) => {
    var _a, _b, _c;
    const [componentControlledSelectedEffectKey, setComponentControlledSelectedEffectKey] = React.useState(props.defaultSelectedEffectKey);
    // Warn the developer if they use the component in an incorrect controlled way.
    reactHooks.useWarnings({
        name: 'VideoBackgroundEffectsPicker',
        props,
        controlledUsage: {
            onChangeProp: 'onChange',
            valueProp: 'selectedEffectKey',
            defaultValueProp: 'defaultSelectedEffectKey'
        }
    });
    const selectedEffect = (_a = props.selectedEffectKey) !== null && _a !== void 0 ? _a : componentControlledSelectedEffectKey;
    const setSelectedEffect = (selectedEffectKey) => {
        var _a;
        setComponentControlledSelectedEffectKey(selectedEffectKey);
        (_a = props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, selectedEffectKey);
    };
    const convertedOptions = props.options.map(option => (Object.assign({ isSelected: option.itemKey === selectedEffect, onSelect: () => setSelectedEffect(option.itemKey) }, option)));
    const itemsPerRow = (_b = props.itemsPerRow) !== null && _b !== void 0 ? _b : 3;
    const optionsByRow = itemsPerRow === 'wrap' ? [convertedOptions] : chunk(convertedOptions, itemsPerRow);
    // If the final row is not full, fill it with hidden items to ensure layout.
    const fillCount = itemsPerRow === 'wrap' ? 0 : itemsPerRow - optionsByRow[optionsByRow.length - 1].length;
    return React.createElement(react.Stack, { tokens: {
            childrenGap: '0.5rem'
        } },
        React.createElement(react.Label, { className: react.mergeStyles((_c = props.styles) === null || _c === void 0 ? void 0 : _c.label) }, props.label),
        optionsByRow.map((options, rowIndex) => {
            var _a;
            return React.createElement(react.Stack, { className: react.mergeStyles((_a = props.styles) === null || _a === void 0 ? void 0 : _a.rowRoot), wrap: props.itemsPerRow === 'wrap', horizontal: true, key: rowIndex, tokens: {
                    childrenGap: '0.5rem'
                }, "data-ui-id": "video-effects-picker-row" },
                options.map((option, i) => {
                    if (i === 0 && rowIndex === 0) {
                        return React.createElement(_VideoEffectsItem, Object.assign({}, option, { itemKey: option.itemKey, key: option.itemKey, focusOnMount: true }));
                    }
                    return React.createElement(_VideoEffectsItem, Object.assign({}, option, { itemKey: option.itemKey, key: option.itemKey }));
                }),
                fillCount > 0 && rowIndex === optionsByRow.length - 1 && Array.from({
                    length: fillCount
                }).map((_, index) => React.createElement(react.Stack, { key: index, styles: hiddenVideoEffectsItemContainerStyles, "data-ui-id": "video-effects-hidden-item" })));
        }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const scrollbarStyles = {
    '::-webkit-scrollbar, *::-webkit-scrollbar': {
        width: '0.3rem',
        height: '0.3rem'
    },
    '::-webkit-scrollbar-thumb, *::-webkit-scrollbar-thumb': {
        borderRadius: '10px',
        background: 'rgba(150, 150, 150)'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const iconClassName = react.mergeStyles({
    marginRight: _pxToRem(8)
});
/**
 * @private
 */
const displayNameClassName = react.mergeStyles({
    fontWeight: 400,
    fontSize: _pxToRem(12),
    lineHeight: _pxToRem(16)
});
/**
 * @private
 */
const captionClassName = react.mergeStyles({
    fontWeight: 400,
    fontSize: _pxToRem(16),
    lineHeight: _pxToRem(22),
    width: '100%'
});
/**
 * @private
 */
const captionsContainerClassName = react.mergeStyles({
    height: '100%',
    margin: 0,
    overflow: 'auto',
    padding: 0
});
/**
 * @private
 */
const captionContainerClassName = react.mergeStyles({
    marginTop: _pxToRem(6),
    marginBottom: _pxToRem(6),
    overflowAnchor: 'auto'
});
/**
 * @private
 */
const captionsBannerClassName = (formFactor) => {
    return react.mergeStyles(Object.assign({ overflowX: 'hidden', height: formFactor === 'compact' ? '4.5rem' : '8.75rem', overflowY: 'auto' }, scrollbarStyles));
};
/**
 * @private
 */
const loadingBannerStyles = (formFactor) => {
    return {
        root: {
            height: formFactor === 'compact' ? '4.5rem' : '8.75rem'
        }
    };
};
/**
 * @private
 */
const captionsContentContainerClassName = react.mergeStyles({
    width: '100%'
});
/**
 * @private
 */
const displayNameContainerClassName = react.mergeStyles({
    overflow: 'hidden',
    textOverflow: 'ellipsis'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 * A component for displaying a single line of caption
 */
const _Caption = (props) => {
    const { displayName, userId, captionText, onRenderAvatar } = props;
    const personaOptions = {
        hidePersonaDetails: true,
        size: react.PersonaSize.size32,
        text: displayName,
        showOverflowTooltip: false,
        imageShouldStartVisible: true,
        initialsTextColor: 'white',
        styles: {
            root: {
                margin: '0.25rem'
            }
        }
    };
    const userIcon = onRenderAvatar ? onRenderAvatar(userId !== null && userId !== void 0 ? userId : '', personaOptions) : React.createElement(react.Persona, Object.assign({}, personaOptions));
    return React.createElement(react.Stack, { horizontal: true, verticalAlign: "start", horizontalAlign: "start" },
        React.createElement(react.Stack.Item, { className: iconClassName }, userIcon),
        React.createElement(react.Stack, { verticalAlign: "start", className: captionsContentContainerClassName },
            React.createElement(react.Stack.Item, { className: displayNameContainerClassName },
                React.createElement(react.Text, { className: displayNameClassName }, displayName)),
            React.createElement(react.Stack.Item, { className: captionClassName, dir: "auto" }, captionText)));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 * A component for displaying a CaptionsBanner with user icon, displayName and captions text.
 */
const _CaptionsBanner = (props) => {
    const { captions, isCaptionsOn, startCaptionsInProgress, onRenderAvatar, strings, formFactor = 'default' } = props;
    const captionsScrollDivRef = React.useRef(null);
    const [isAtBottomOfScroll, setIsAtBottomOfScroll] = React.useState(true);
    const scrollToBottom = () => {
        if (captionsScrollDivRef.current) {
            captionsScrollDivRef.current.scrollTop = captionsScrollDivRef.current.scrollHeight;
        }
    };
    const handleScrollToTheBottom = React.useCallback(() => {
        if (!captionsScrollDivRef.current) {
            return;
        }
        const atBottom = Math.ceil(captionsScrollDivRef.current.scrollTop) >= captionsScrollDivRef.current.scrollHeight - captionsScrollDivRef.current.clientHeight;
        setIsAtBottomOfScroll(atBottom);
    }, []);
    React.useEffect(() => {
        const captionsScrollDiv = captionsScrollDivRef.current;
        captionsScrollDiv === null || captionsScrollDiv === void 0 ? void 0 : captionsScrollDiv.addEventListener('scroll', handleScrollToTheBottom);
        return () => {
            captionsScrollDiv === null || captionsScrollDiv === void 0 ? void 0 : captionsScrollDiv.removeEventListener('scroll', handleScrollToTheBottom);
        };
    }, [handleScrollToTheBottom, isCaptionsOn]);
    React.useEffect(() => {
        // only auto scroll to bottom is already is at bottom of scroll before new caption comes in
        if (isAtBottomOfScroll) {
            scrollToBottom();
        }
    }, [captions, isAtBottomOfScroll]);
    return React.createElement(React.Fragment, null, startCaptionsInProgress && React.createElement(react.FocusZone, { as: "ul", className: captionsContainerClassName },
        isCaptionsOn && React.createElement("div", { ref: captionsScrollDivRef, className: captionsBannerClassName(formFactor) }, captions.map(caption => {
            return React.createElement("div", { key: caption.id, className: captionContainerClassName, "data-is-focusable": true },
                React.createElement(_Caption, Object.assign({}, caption, { onRenderAvatar: onRenderAvatar })));
        })),
        !isCaptionsOn && React.createElement(react.Stack, { verticalAlign: "center", styles: loadingBannerStyles(formFactor), "data-is-focusable": true },
            React.createElement(react.Spinner, { label: strings === null || strings === void 0 ? void 0 : strings.captionsBannerSpinnerText, ariaLive: "assertive", labelPosition: "right" }))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
(window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const themedCaptionsSettingsModalStyle = (theme) => ({
    main: {
        borderRadius: theme.effects.roundedCorner6,
        padding: _pxToRem(24),
        width: _pxToRem(440),
        height: 'fit-content',
        overflow: 'hidden'
    }
});
/**
 * @private
 */
const titleClassName = react.mergeStyles({
    fontWeight: 600,
    fontSize: _pxToRem(20),
    lineHeight: _pxToRem(28)
});
/**
 * @private
 */
const titleContainerClassName = react.mergeStyles({
    paddingBottom: _pxToRem(20)
});
/**
 * @private
 */
const dropdownContainerClassName = react.mergeStyles({
    paddingTop: _pxToRem(16)
});
/**
 * @private
 */
const dropdownInfoTextStyle = (theme) => react.mergeStyles({
    fontWeight: 400,
    fontSize: _pxToRem(12),
    lineHeight: _pxToRem(16),
    color: theme.palette.neutralSecondary,
    paddingBottom: _pxToRem(24)
});
/**
 * @private
 */
const buttonsContainerClassName = react.mergeStyles({
    paddingTop: _pxToRem(16)
});
/**
 * @private
 */
const buttonStyles = (theme) => {
    return {
        root: {
            borderRadius: _pxToRem(2),
            margin: _pxToRem(8)
        },
        rootHovered: {
            backgroundColor: theme.palette.themePrimary,
            borderColor: theme.palette.themePrimary,
            color: theme.palette.white
        },
        rootFocused: {
            backgroundColor: theme.palette.themePrimary,
            borderColor: theme.palette.themePrimary,
            color: theme.palette.white
        },
        rootPressed: {
            backgroundColor: theme.palette.themePrimary,
            borderColor: theme.palette.themePrimary,
            color: theme.palette.white
        }
    };
};
/**
 * @private
 */
const dropdownStyles = {
    callout: Object.assign({ height: _pxToRem(300), overflow: 'auto' }, scrollbarStyles)
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 * mapping between caption language and spoken language codes
 */
const _spokenLanguageToCaptionLanguage = {
    'ar-ae': 'ar',
    'ar-sa': 'ar',
    'da-dk': 'da',
    'de-de': 'de',
    'en-au': 'en',
    'en-ca': 'en',
    'en-gb': 'en',
    'en-in': 'en',
    'en-nz': 'en',
    'en-us': 'en',
    'es-es': 'es',
    'es-mx': 'es',
    'fi-fi': 'fi',
    'fr-ca': 'fr-ca',
    'fr-fr': 'fr',
    'hi-in': 'hi',
    'it-it': 'it',
    'ja-jp': 'ja',
    'ko-kr': 'ko',
    'nb-no': 'nb',
    'nl-be': 'nl',
    'nl-nl': 'nl',
    'pl-pl': 'pl',
    'pt-br': 'pt',
    'ru-ru': 'ru',
    'sv-se': 'sv',
    'zh-cn': 'zh-Hans',
    'zh-hk': 'zh-Hant',
    'cs-cz': 'cs',
    'pt-pt': 'pt-pt',
    'tr-tr': 'tr',
    'vi-vn': 'vi',
    'th-th': 'th',
    'he-il': 'he',
    'cy-gb': 'cy',
    'uk-ua': 'uk',
    'el-gr': 'el',
    'hu-hu': 'hu',
    'ro-ro': 'ro',
    'sk-sk': 'sk',
    'zh-tw': 'zh-Hant'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$r = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @internal
 * a component for setting spoken languages
 */
const _CaptionsSettingsModal = (props) => {
    const { supportedSpokenLanguages, supportedCaptionLanguages, currentSpokenLanguage, currentCaptionLanguage, isCaptionsFeatureActive, showModal, onSetSpokenLanguage, onSetCaptionLanguage, onDismissCaptionsSettings, onStartCaptions, strings, spokenLanguageStrings, captionLanguageStrings, changeCaptionLanguage = false } = props;
    const theme = react.useTheme();
    const [hasSetSpokenLanguage, setHasSetSpokenLanguage] = React.useState(false);
    const [selectedSpokenLanguage, setSelectedSpokenLanguage] = React.useState({
        key: currentSpokenLanguage || defaultSpokenLanguage,
        text: currentSpokenLanguage || defaultSpokenLanguage
    });
    const [selectedCaptionLanguage, setSelectedCaptionLanguage] = React.useState({
        key: currentCaptionLanguage || _spokenLanguageToCaptionLanguage[selectedSpokenLanguage.key],
        text: currentCaptionLanguage || _spokenLanguageToCaptionLanguage[selectedSpokenLanguage.key]
    });
    React.useEffect(() => {
        // set spoken language when start captions with a spoken language specified.
        // this is to fix the bug when a second user starts captions with a new spoken language, captions bot ignore that spoken language
        if (isCaptionsFeatureActive && !hasSetSpokenLanguage) {
            onSetSpokenLanguage(selectedSpokenLanguage.key);
            // we only need to call set spoken language once when first starting captions
            setHasSetSpokenLanguage(true);
        }
    }, [isCaptionsFeatureActive, onSetSpokenLanguage, selectedSpokenLanguage.key, hasSetSpokenLanguage]);
    const onDismiss = React.useCallback(() => {
        if (onDismissCaptionsSettings) {
            onDismissCaptionsSettings();
        }
    }, [onDismissCaptionsSettings]);
    const onConfirm = React.useCallback(() => __awaiter$r(void 0, void 0, void 0, function* () {
        const spokenLanguageCode = selectedSpokenLanguage.key;
        const captionLanguageCode = selectedCaptionLanguage.key;
        if (isCaptionsFeatureActive) {
            onSetSpokenLanguage(spokenLanguageCode);
            onSetCaptionLanguage(captionLanguageCode);
        }
        else {
            yield onStartCaptions({
                spokenLanguage: spokenLanguageCode
            });
        }
        onDismiss();
    }), [onDismiss, isCaptionsFeatureActive, onSetSpokenLanguage, onSetCaptionLanguage, onStartCaptions, selectedSpokenLanguage.key, selectedCaptionLanguage.key]);
    const spokenLanguageDropdownOptions = React.useMemo(() => {
        return supportedSpokenLanguages.map(languageCode => {
            return {
                key: languageCode,
                text: spokenLanguageStrings ? spokenLanguageStrings[languageCode] : languageCode
            };
        });
    }, [supportedSpokenLanguages, spokenLanguageStrings]);
    const captionLanguageDropdownOptions = React.useMemo(() => {
        return supportedCaptionLanguages.map(languageCode => {
            return {
                key: languageCode,
                text: captionLanguageStrings ? captionLanguageStrings[languageCode] : languageCode
            };
        });
    }, [supportedCaptionLanguages, captionLanguageStrings]);
    const sortedSpokenLanguageDropdownOptions = React.useMemo(() => {
        const copy = [...spokenLanguageDropdownOptions];
        return copy.sort((a, b) => a.text > b.text ? 1 : -1);
    }, [spokenLanguageDropdownOptions]);
    const sortedCaptionLanguageDropdownOptions = React.useMemo(() => {
        const copy = [...captionLanguageDropdownOptions];
        return copy.sort((a, b) => a.text > b.text ? 1 : -1);
    }, [captionLanguageDropdownOptions]);
    const onSpokenLanguageChange = (event, option) => {
        if (option) {
            setSelectedSpokenLanguage(option);
        }
    };
    const onCaptionLanguageChange = (event, option) => {
        if (option) {
            setSelectedCaptionLanguage(option);
        }
    };
    const calloutProps = React.useMemo(() => ({
        preventDismissOnEvent: _preventDismissOnEvent
    }), []);
    const CaptionsSettingsComponent = React.useCallback(() => {
        const placeholderSpokenLanguage = currentSpokenLanguage !== null && currentSpokenLanguage !== void 0 ? currentSpokenLanguage : defaultSpokenLanguage;
        const placeholderCaptionLanguage = currentCaptionLanguage !== null && currentCaptionLanguage !== void 0 ? currentCaptionLanguage : _spokenLanguageToCaptionLanguage[placeholderSpokenLanguage];
        return React.createElement(react.Stack, null,
            React.createElement(react.Dropdown, { label: strings === null || strings === void 0 ? void 0 : strings.captionsSettingsSpokenLanguageDropdownLabel, selectedKey: selectedSpokenLanguage ? selectedSpokenLanguage.key : undefined, onChange: (ev, option) => onSpokenLanguageChange(ev, option), calloutProps: calloutProps, placeholder: placeholderSpokenLanguage, options: sortedSpokenLanguageDropdownOptions, styles: dropdownStyles }),
            React.createElement(react.Text, { className: dropdownInfoTextStyle(theme) }, strings === null || strings === void 0 ? void 0 : strings.captionsSettingsSpokenLanguageDropdownInfoText),
            changeCaptionLanguage && React.createElement(React.Fragment, null,
                React.createElement(react.Dropdown, { label: strings === null || strings === void 0 ? void 0 : strings.captionsSettingsCaptionLanguageDropdownLabel, selectedKey: selectedCaptionLanguage ? selectedCaptionLanguage.key : undefined, onChange: (ev, option) => onCaptionLanguageChange(ev, option), calloutProps: calloutProps, placeholder: placeholderCaptionLanguage, options: sortedCaptionLanguageDropdownOptions, styles: dropdownStyles }),
                React.createElement(react.Text, { className: dropdownInfoTextStyle(theme) }, strings === null || strings === void 0 ? void 0 : strings.captionsSettingsCaptionLanguageDropdownInfoText)));
    }, [calloutProps, currentSpokenLanguage, currentCaptionLanguage, sortedSpokenLanguageDropdownOptions, sortedCaptionLanguageDropdownOptions, selectedCaptionLanguage, selectedSpokenLanguage, strings === null || strings === void 0 ? void 0 : strings.captionsSettingsSpokenLanguageDropdownInfoText, strings === null || strings === void 0 ? void 0 : strings.captionsSettingsCaptionLanguageDropdownLabel, strings === null || strings === void 0 ? void 0 : strings.captionsSettingsSpokenLanguageDropdownLabel, strings === null || strings === void 0 ? void 0 : strings.captionsSettingsCaptionLanguageDropdownInfoText, theme, changeCaptionLanguage]);
    const CaptionsSettingsModalStyle = React.useMemo(() => themedCaptionsSettingsModalStyle(theme), [theme]);
    return React.createElement(React.Fragment, null, React.createElement(react.Modal, { titleAriaId: strings === null || strings === void 0 ? void 0 : strings.captionsSettingsModalAriaLabel, isOpen: showModal, onDismiss: onDismiss, isBlocking: true, styles: CaptionsSettingsModalStyle },
        React.createElement(react.Stack, { horizontal: true, horizontalAlign: "space-between", verticalAlign: "center", className: titleContainerClassName },
            React.createElement(react.Text, { className: titleClassName }, strings === null || strings === void 0 ? void 0 : strings.captionsSettingsModalTitle),
            React.createElement(react.IconButton, { iconProps: {
                    iconName: 'Cancel'
                }, ariaLabel: strings === null || strings === void 0 ? void 0 : strings.captionsSettingsCloseModalButtonAriaLabel, onClick: onDismiss, style: {
                    color: theme.palette.black
                } })),
        React.createElement(react.Stack, { className: dropdownContainerClassName }, CaptionsSettingsComponent()),
        React.createElement(react.Stack, { horizontal: true, horizontalAlign: "end", className: buttonsContainerClassName },
            React.createElement(react.PrimaryButton, { styles: buttonStyles(theme), onClick: onConfirm },
                React.createElement("span", null, strings === null || strings === void 0 ? void 0 : strings.captionsSettingsConfirmButtonLabel)),
            React.createElement(react.DefaultButton, { onClick: onDismiss, styles: buttonStyles(theme) },
                React.createElement("span", null, strings === null || strings === void 0 ? void 0 : strings.captionsSettingsCancelButtonLabel)))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 *
 * @private
 */
const createComponentStrings = (localizedStrings) => {
    const strings = Object.assign({}, en_US$1);
    _getKeys(localizedStrings).forEach(key => {
        // mark the value as unknown because the type changes based on the key.
        // this is unsafe at runtime as we could assign the wrong type based on the key here.
        // but typescript isn't smart enough to know that the key used across each access will result in the same type
        strings[key] = Object.assign(Object.assign({}, strings[key]), localizedStrings[key]);
    });
    return strings;
};

var participantItem$j={isMeText:"(you)",menuTitle:"More Options",removeButtonLabel:"Remove",sharingIconLabel:"Sharing",mutedIconLabel:"Muted",displayNamePlaceholder:"Unnamed participant",participantStateRinging:"Calling...",participantStateHold:"On hold",attendeeRole:"Attendee"};var ParticipantList$j={overflowParticipantCount:"+{overflowCount} more"};var typingIndicator$j={singleUser:"{user} is typing ...",multipleUsers:"{users} are typing ...",multipleUsersAbbreviateOne:"{users} and 1 other are typing ...",multipleUsersAbbreviateMany:"{users} and {numOthers} others are typing ...",delimiter:", "};var sendBox$j={placeholderText:"Enter a message",textTooLong:"Your message length is over the maximum limit.",sendButtonAriaLabel:"Send message",fileUploadsPendingError:"Uploading... Please wait.",removeFile:"Remove file",uploading:"Uploading",uploadCompleted:"Upload completed"};var richTextSendBox$j={placeholderText:"Enter a message",textTooLong:"Your message length is over the maximum limit.",sendButtonAriaLabel:"Send message",fileUploadsPendingError:"Uploading... Please wait.",removeFile:"Remove file",uploading:"Uploading",uploadCompleted:"Upload completed",boldTooltip:"Bold",italicTooltip:"Italic",underlineTooltip:"Underline",bulletListTooltip:"Bulleted list",numberListTooltip:"Numbered list",increaseIndentTooltip:"Increase indent",decreaseIndentTooltip:"Decrease indent",richTextFormatButtonTooltip:"Format"};var mentionPopover$j={mentionPopoverHeader:"Suggestions"};var imageOverlay$j={downloadButtonLabel:"Download",dismissButtonAriaLabel:"Close"};var messageStatusIndicator$j={deliveredAriaLabel:"Message sent",deliveredTooltipText:"Sent",seenAriaLabel:"Message seen by others",seenTooltipText:"Seen",readByTooltipText:"Read by {messageThreadReadCount} of {remoteParticipantsCount}",sendingAriaLabel:"Message sending",sendingTooltipText:"Sending",failedToSendAriaLabel:"Message failed to send",failedToSendTooltipText:"Failed to send"};var endCallButton$j={label:"Leave",tooltipContent:"Leave call"};var cameraButton$j={onLabel:"Camera",offLabel:"Camera",tooltipDisabledContent:"Camera is disabled",tooltipOnContent:"Turn off camera",tooltipOffContent:"Turn on camera",tooltipVideoLoadingContent:"Video is loading",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",cameraButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Turn off camera and camera options",offSplitButtonAriaLabel:"Turn on camera and camera options",cameraActionTurnedOnAnnouncement:"Your camera has been turned on",cameraActionTurnedOffAnnouncement:"Your camera has been turned off",onSplitButtonPrimaryActionCamera:"Turn off camera",offSplitButtonPrimaryActionCamera:"Turn on camera",cameraPrimaryActionSplitButtonTitle:"Use camera",videoEffectsMenuItemTitle:"Effects"};var microphoneButton$j={onLabel:"Mic",offLabel:"Mic",tooltipDisabledContent:"Microphone is disabled",tooltipOnContent:"Mute microphone",tooltipOffContent:"Unmute microphone",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker",microphoneButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Mute microphone and audio options",offSplitButtonAriaLabel:"Unmute microphone and audio options",microphoneActionTurnedOnAnnouncement:"Your microphone has been turned on",microphoneActionTurnedOffAnnouncement:"Your microphone has been turned off",offSplitButtonMicrophonePrimaryAction:"Unmute microphone",onSplitButtonMicrophonePrimaryAction:"Mute microphone",microphonePrimaryActionSplitButtonTitle:"Use microphone"};var devicesButton$j={label:"Devices",tooltipContent:"Manage devices",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",audioDeviceMenuTitle:"Audio Device",audioDeviceMenuTooltip:"Choose audio device",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker"};var participantsButton$j={label:"People",tooltipContent:"Show participants",menuHeader:"In this call",participantsListButtonLabel:"{numParticipants} people",muteAllButtonLabel:"Mute all",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied"};var screenShareButton$j={onLabel:"Stop presenting",offLabel:"Present",tooltipDisabledContent:"Presenting is disabled",tooltipOnContent:"Presenting your screen",tooltipOffContent:"Present your screen"};var raiseHandButton$j={offLabel:"Raise",onLabel:"Lower",tooltipDisabledContent:"Raise Hand action is disabled",tooltipOnContent:"Lower Hand",tooltipOffContent:"Raise Hand"};var reactionButton$j={label:"React",ariaLabel:"React Button, Send a reaction",tooltipDisabledContent:"Reaction action is disabled",tooltipContent:"Send a reaction",likeReactionTooltipContent:"Like",heartReactionTooltipContent:"Love",laughReactionTooltipContent:"Laugh",applauseReactionTooltipContent:"Applause",surprisedReactionTooltipContent:"Surprised"};var messageThread$j={yesterday:"Yesterday",sunday:"Sunday",monday:"Monday",tuesday:"Tuesday",wednesday:"Wednesday",thursday:"Thursday",friday:"Friday",saturday:"Saturday",participantJoined:"joined the chat.",participantLeft:"left the chat.",editMessage:"Edit",removeMessage:"Delete",resendMessage:"Try sending again",failToSendTag:"Failed to send",editedTag:"Edited",liveAuthorIntro:"{author} says",messageContentAriaText:"{author} said {message}",messageContentMineAriaText:"You said {message}",editBoxTextLimit:"Your message is over the limit of {limitNumber} characters",editBoxPlaceholderText:"Edit your message",newMessagesIndicator:"New messages",noDisplayNameSub:"No name",editBoxCancelButton:"Cancel",editBoxSubmitButton:"Done",messageReadCount:"Read by {messageReadByCount} of {remoteParticipantsCount}",actionMenuMoreOptions:"More Options",downloadFile:"Download file",blockedWarningText:"This message was deleted due to organisational policy.",blockedWarningLinkText:"Details",fileCardGroupMessage:"The message has {fileCount} attachment",messageDeletedAnnouncementAriaLabel:"The message is deleted"};var errorBar$j={unableToReachChatService:"You are offline",accessDenied:"Unable to access chat services - please check the user credentials provided",userNotInChatThread:"You are no longer in this chat thread",sendMessageNotInChatThread:"Failed to send message because you are no longer in this chat thread",sendMessageGeneric:"Failed to send message",callingNetworkFailure:"Troubling connecting call - you seem to be offline",startVideoGeneric:"Failed to start video",stopVideoGeneric:"Failed to stop video",muteGeneric:"Failed to mute microphone",unmuteGeneric:"Failed to unmute microphone",speakingWhileMuted:"Your microphone is muted",startScreenShareGeneric:"There was an issue starting screen share.",stopScreenShareGeneric:"Failed to stop screen sharing",callNetworkQualityLow:"Network quality is low.",callNoSpeakerFound:"No speakers or headphones found. Connect an audio device to hear the call.",callNoMicrophoneFound:"No microphones found. Connect an audio input device.",callMicrophoneAccessDenied:"Unable to access microphone. Click the lock in the address bar to grant permission to this webpage.",callMicrophoneAccessDeniedSafari:"Unable to access microphone. Refresh the page to allow permissions, or check this browsers settings and verify permissions are enabled for this website.",callMicrophoneMutedBySystem:"You are muted by your system.",callMicrophoneUnmutedBySystem:"Your microphone recovered and you were unmuted by your system.",callMacOsMicrophoneAccessDenied:"Unable to access microphone. Grant microphone permission in your macOS privacy settings.",callLocalVideoFreeze:"Network bandwidth is poor. Your video may appear paused for others on the call.",callCameraAccessDenied:"Unable to access camera. Click the lock in the address bar to grant permission to this webpage.",callCameraAccessDeniedSafari:"Unable to access camera. Refresh the page to allow permissions, or check this browsers settings and verify permissions are enabled for this website.",callCameraAlreadyInUse:"Unable to access camera. It may already be in use by another application.",callVideoStoppedBySystem:"Your video has been stopped by your system.",callVideoRecoveredBySystem:"Your video has resumed.",callMacOsCameraAccessDenied:"MacOS is blocking access to your camera. Update your privacy settings to allow this browser to access your camera.",callMacOsScreenShareAccessDenied:"MacOS is blocking screen sharing. Update your privacy settings to allow this browser to record your screen.",dismissButtonAriaLabel:"Close",failedToJoinCallGeneric:"Failed to join call.",failedToJoinCallInvalidMeetingLink:"Unable to join Meeting. Invalid Link.",cameraFrozenForRemoteParticipants:"Users in the call are having issues seeing your video. Please check your devices and network.",unableToStartVideoEffect:"Unable to apply video effect.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Cannot start spotlight on participant(s) because the maximum number of participants are already spotlighted."};var videoGallery$j={screenIsBeingSharedMessage:"You are sharing your screen",screenShareLoadingMessage:"Loading {participant}'s screen",localVideoLabel:"You",localVideoCameraSwitcherLabel:"Switch camera",localVideoMovementLabel:"Movable Local Video Tile",localVideoSelectedDescription:"{cameraName} selected",displayNamePlaceholder:"Unnamed participant",fitRemoteParticipantToFrame:"Fit to frame",fillRemoteParticipantFrame:"Fill frame",pinParticipantForMe:"Pin for me",pinParticipantForMeLimitReached:"Pin (limit reached)",unpinParticipantForMe:"Unpin",pinParticipantMenuItemAriaLabel:"Pin {participantName}",unpinParticipantMenuItemAriaLabel:"Unpin {participantName}",pinnedParticipantAnnouncementAriaLabel:"Pinned {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Unpinned {participantName}",startSpotlightVideoTileMenuLabel:"Spotlight for everyone",addSpotlightVideoTileMenuLabel:"Add spotlight",spotlightLimitReachedMenuTitle:"Spotlight limit reached",stopSpotlightVideoTileMenuLabel:"Stop spotlighting",stopSpotlightOnSelfVideoTileMenuLabel:"Exit spotlight",attendeeRole:"Attendee"};var dialpad$j={placeholderText:"Enter phone number",deleteButtonAriaLabel:"Delete"};var holdButton$j={onLabel:"Resume",offLabel:"Hold",tooltipOnContent:"Resume call",tooltipOffContent:"Hold call"};var videoTile$j={participantStateRinging:"Calling...",participantStateHold:"On hold"};var CameraAndMicrophoneSitePermissionsRequest$j={primaryText:"Allow {appName} to use your camera and microphone",secondaryText:"This is so participants can see and hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera and microphone",ariaLabel:"Allow camera and microphone access"};var CameraSitePermissionsRequest$j={primaryText:"Allow {appName} to use your camera",secondaryText:"This is so participants can see you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera",ariaLabel:"Allow camera access"};var MicrophoneSitePermissionsRequest$j={primaryText:"Allow {appName} to use your microphone",secondaryText:"This is so participants can hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without microphone",ariaLabel:"Allow microphone access"};var CameraAndMicrophoneSitePermissionsCheck$j={primaryText:"Checking for camera and microphone access",secondaryText:"Allow access if prompted. This is so participants can see and hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera and microphone",ariaLabel:"Checking for camera and microphone access. Allow access if prompted."};var CameraSitePermissionsCheck$j={primaryText:"Checking for camera access",secondaryText:"Allow access if prompted. This is so participants can see you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera",ariaLabel:"Checking for camera access. Allow access if prompted."};var MicrophoneSitePermissionsCheck$j={primaryText:"Checking for microphone access",secondaryText:"Allow access if prompted. This is so participants can hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without microphone",ariaLabel:"Checking for microphone access. Allow access if prompted."};var CameraAndMicrophoneSitePermissionsDenied$j={primaryText:"Unable to access camera and microphone",secondaryText:"Click the lock icon in the address bar to grant microphone permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without camera and microphone",linkText:"Need help? Get troubleshooting help"};var CameraAndMicrophoneSitePermissionsDeniedSafari$j={primaryText:"Unable to access camera and microphone",secondaryText:"Refresh the page to allow permissions, or check this browsers settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without camera and microphone",linkText:"Need help? Get troubleshooting help"};var CameraSitePermissionsDenied$j={primaryText:"Unable to access camera",secondaryText:"Click the lock icon in the address bar to grant camera permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without camera",linkText:"Need help? Get troubleshooting help"};var MicrophoneSitePermissionsDenied$j={primaryText:"Unable to access microphone",secondaryText:"Click the lock icon in the address bar to grant microphone permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without microphone",linkText:"Need help? Get troubleshooting help"};var CameraSitePermissionsDeniedSafari$j={primaryText:"Unable to access camera",secondaryText:"Refresh the page to allow permissions, or check this browsers settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without camera",linkText:"Need help? Get troubleshooting help"};var MicrophoneSitePermissionsDeniedSafari$j={primaryText:"Unable to access microphone",secondaryText:"Refresh the page to allow permissions, or check this browsers settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without microphone",linkText:"Need help? Get troubleshooting help"};var UnsupportedBrowser$j={primaryText:"Browser not supported",secondaryText:"Please join this call using a compatible browser.",moreHelpLinkText:"See compatibility requirements"};var UnsupportedBrowserVersion$j={primaryText:"Browser update needed",secondaryText:"To ensure the best call possible, please update your browser and then try joining the call again.",moreHelpLinkText:"See compatibility requirements",continueAnywayButtonText:"Start call without updating"};var UnsupportedOperatingSystem$j={primaryText:"Operating system not supported",secondaryText:"Please join this call using a device with a compatible operating system.",moreHelpLinkText:"See compatibility requirements"};var BrowserPermissionDenied$j={primaryText:"Can't use your camera or microphone",secondaryText:"Your browser might not have access to your camera or microphone. To fix this, open System Preferences.",primaryButtonText:"Try again",linkText:"Need help? Get troubleshooting help"};var BrowserPermissionDeniedIOS$j={primaryText:"Allow microphone access to continue",secondaryText:"So other participants can hear you.",primaryButtonText:"Try again",imageAltText:"Microphone and camera device permission location for iOS",linkText:"Need help? Get troubleshooting help",step1Text:"Go to the Settings app",step2Text:"Scroll down to settings for this browser",step3Text:"Turn on Microphone (Camera optional)",step4Text:"Try joining the call again",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$j={leftNavButtonAriaLabel:"previous page",rightNavButtonAriaLabel:"next page"};var en_GB$1 = {participantItem:participantItem$j,ParticipantList:ParticipantList$j,typingIndicator:typingIndicator$j,sendBox:sendBox$j,richTextSendBox:richTextSendBox$j,mentionPopover:mentionPopover$j,imageOverlay:imageOverlay$j,messageStatusIndicator:messageStatusIndicator$j,endCallButton:endCallButton$j,cameraButton:cameraButton$j,microphoneButton:microphoneButton$j,devicesButton:devicesButton$j,participantsButton:participantsButton$j,screenShareButton:screenShareButton$j,raiseHandButton:raiseHandButton$j,reactionButton:reactionButton$j,messageThread:messageThread$j,errorBar:errorBar$j,videoGallery:videoGallery$j,dialpad:dialpad$j,holdButton:holdButton$j,videoTile:videoTile$j,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$j,CameraSitePermissionsRequest:CameraSitePermissionsRequest$j,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$j,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$j,CameraSitePermissionsCheck:CameraSitePermissionsCheck$j,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$j,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$j,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$j,CameraSitePermissionsDenied:CameraSitePermissionsDenied$j,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$j,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$j,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$j,UnsupportedBrowser:UnsupportedBrowser$j,UnsupportedBrowserVersion:UnsupportedBrowserVersion$j,UnsupportedOperatingSystem:UnsupportedOperatingSystem$j,BrowserPermissionDenied:BrowserPermissionDenied$j,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$j,verticalGallery:verticalGallery$j};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for English (GB).
 *
 * @public
 */
const COMPONENT_LOCALE_EN_GB = {
    strings: createComponentStrings(en_GB$1)
};

var participantItem$i={isMeText:"()",menuTitle:"  ",removeButtonLabel:"",sharingIconLabel:" ",mutedIconLabel:"  ",displayNamePlaceholder:"  ",participantStateRinging:"  ...",participantStateHold:" ",attendeeRole:""};var ParticipantList$i={overflowParticipantCount:"+{overflowCount}   "};var typingIndicator$i={singleUser:"{user} ",multipleUsers:" {users} ...",multipleUsersAbbreviateOne:"   {users}  ",multipleUsersAbbreviateMany:"{users}  {numOthers}  ...",delimiter:" "};var sendBox$i={placeholderText:" ",textTooLong:"    .",sendButtonAriaLabel:" ",fileUploadsPendingError:" ...  .",removeFile:" ",uploading:" ",uploadCompleted:" "};var richTextSendBox$i={placeholderText:" ",textTooLong:"    .",sendButtonAriaLabel:" ",fileUploadsPendingError:" ...  .",removeFile:" ",uploading:"  ",uploadCompleted:" ",boldTooltip:"",italicTooltip:"",underlineTooltip:"",bulletListTooltip:"   ",numberListTooltip:" ",increaseIndentTooltip:"  ",decreaseIndentTooltip:"  ",richTextFormatButtonTooltip:""};var mentionPopover$i={mentionPopoverHeader:""};var imageOverlay$i={downloadButtonLabel:"",dismissButtonAriaLabel:""};var messageStatusIndicator$i={deliveredAriaLabel:"  ",deliveredTooltipText:" ",seenAriaLabel:"     .",seenTooltipText:" ",readByTooltipText:"   {messageThreadReadCount}  {remoteParticipantsCount}",sendingAriaLabel:" ",sendingTooltipText:" ",failedToSendAriaLabel:"  ",failedToSendTooltipText:" "};var endCallButton$i={label:"",tooltipContent:" "};var cameraButton$i={onLabel:"",offLabel:"",tooltipDisabledContent:" ",tooltipOnContent:"  ",tooltipOffContent:" ",tooltipVideoLoadingContent:"  ",cameraMenuTitle:"",cameraMenuTooltip:" ",cameraButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"   ",offSplitButtonAriaLabel:"  ",cameraActionTurnedOnAnnouncement:"  ",cameraActionTurnedOffAnnouncement:"   ",onSplitButtonPrimaryActionCamera:"  ",offSplitButtonPrimaryActionCamera:" ",cameraPrimaryActionSplitButtonTitle:" ",videoEffectsMenuItemTitle:""};var microphoneButton$i={onLabel:"",offLabel:"",tooltipDisabledContent:"  ",tooltipOnContent:"  ",tooltipOffContent:"   ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:" ",speakerMenuTooltip:"  ",microphoneButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"    ",offSplitButtonAriaLabel:"     ",microphoneActionTurnedOnAnnouncement:"  ",microphoneActionTurnedOffAnnouncement:"  ",offSplitButtonMicrophonePrimaryAction:"   ",onSplitButtonMicrophonePrimaryAction:"  ",microphonePrimaryActionSplitButtonTitle:" "};var devicesButton$i={label:"",tooltipContent:" ",cameraMenuTitle:"",cameraMenuTooltip:" ",audioDeviceMenuTitle:" ",audioDeviceMenuTooltip:"   ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:" ",speakerMenuTooltip:"  "};var participantsButton$i={label:"",tooltipContent:" ",menuHeader:"  ",participantsListButtonLabel:"{numParticipants}  ",muteAllButtonLabel:"  ",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"   "};var screenShareButton$i={onLabel:" ",offLabel:"",tooltipDisabledContent:"  ",tooltipOnContent:"   .",tooltipOffContent:" "};var raiseHandButton$i={offLabel:"",onLabel:"",tooltipDisabledContent:"    ",tooltipOnContent:" ",tooltipOffContent:" "};var reactionButton$i={label:"",ariaLabel:" \"\"  ",tooltipDisabledContent:"   ",tooltipContent:" ",likeReactionTooltipContent:"",heartReactionTooltipContent:"",laughReactionTooltipContent:"",applauseReactionTooltipContent:"",surprisedReactionTooltipContent:""};var messageThread$i={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:"  .",participantLeft:"  .",editMessage:"",removeMessage:"",resendMessage:"   ",failToSendTag:" ",editedTag:" ",liveAuthorIntro:" {author}",messageContentAriaText:"{author}  {message}",messageContentMineAriaText:"  {message}",editBoxTextLimit:"      {limitNumber}",editBoxPlaceholderText:" ",newMessagesIndicator:" ",noDisplayNameSub:"  ",editBoxCancelButton:" ",editBoxSubmitButton:"",messageReadCount:"   {messageReadByCount}  {remoteParticipantsCount}",actionMenuMoreOptions:"  ",downloadFile:" ",blockedWarningText:"      .",blockedWarningLinkText:"",fileCardGroupMessage:"    {fileCount}",messageDeletedAnnouncementAriaLabel:"  "};var errorBar$i={unableToReachChatService:"  ",accessDenied:"     -       ",userNotInChatThread:"       ",sendMessageNotInChatThread:"          ",sendMessageGeneric:"  ",callingNetworkFailure:"  -    ",startVideoGeneric:"  ",stopVideoGeneric:"  ",muteGeneric:"   ",unmuteGeneric:"    ",speakingWhileMuted:"   ",startScreenShareGeneric:"     .",stopScreenShareGeneric:"   ",callNetworkQualityLow:"  .",callNoSpeakerFound:"       .      .",callNoMicrophoneFound:"    .     .",callMicrophoneAccessDenied:"   .           .",callMicrophoneAccessDeniedSafari:"   .                  .",callMicrophoneMutedBySystem:"    .",callMicrophoneUnmutedBySystem:"         .",callMacOsMicrophoneAccessDenied:"   .       macOS.",callLocalVideoFreeze:"   .        .",callCameraAccessDenied:"   .           .",callCameraAccessDeniedSafari:"   .                  .",callCameraAlreadyInUse:"   .        .",callVideoStoppedBySystem:"       .",callVideoRecoveredBySystem:"    .",callMacOsCameraAccessDenied:" MacOS      .          .",callMacOsScreenShareAccessDenied:" MacOS   .         .",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"    .",failedToJoinCallInvalidMeetingLink:"   .   .",cameraFrozenForRemoteParticipants:"         .     .",unableToStartVideoEffect:"   .",startSpotlightWhileMaxParticipantsAreSpotlighted:"       ()          ."};var videoGallery$i={screenIsBeingSharedMessage:"  ",screenShareLoadingMessage:"    {participant}",localVideoLabel:"",localVideoCameraSwitcherLabel:" ",localVideoMovementLabel:"    ",localVideoSelectedDescription:"  {cameraName}",displayNamePlaceholder:"  ",fitRemoteParticipantToFrame:"  ",fillRemoteParticipantFrame:" ",pinParticipantForMe:"  ",pinParticipantForMeLimitReached:" (   )",unpinParticipantForMe:" ",pinParticipantMenuItemAriaLabel:" {participantName}",unpinParticipantMenuItemAriaLabel:"  {participantName}",pinnedParticipantAnnouncementAriaLabel:"  {participantName}",unpinnedParticipantAnnouncementAriaLabel:"   {participantName}",startSpotlightVideoTileMenuLabel:"   ",addSpotlightVideoTileMenuLabel:"  ",spotlightLimitReachedMenuTitle:"      ",stopSpotlightVideoTileMenuLabel:"   ",stopSpotlightOnSelfVideoTileMenuLabel:"    ",attendeeRole:""};var dialpad$i={placeholderText:"  ",deleteButtonAriaLabel:""};var holdButton$i={onLabel:"",offLabel:"",tooltipOnContent:" ",tooltipOffContent:" "};var videoTile$i={participantStateRinging:"  ...",participantStateHold:" "};var CameraAndMicrophoneSitePermissionsRequest$i={primaryText:" {appName}    ",secondaryText:"       .",linkText:"         ",primaryButtonText:"   ",ariaLabel:"    "};var CameraSitePermissionsRequest$i={primaryText:" {appName}  ",secondaryText:"       .",linkText:"         ",primaryButtonText:"  ",ariaLabel:"   "};var MicrophoneSitePermissionsRequest$i={primaryText:" {appName}  ",secondaryText:"      .",linkText:"         ",primaryButtonText:"  ",ariaLabel:"   "};var CameraAndMicrophoneSitePermissionsCheck$i={primaryText:"     ",secondaryText:"     .        .",linkText:"         ",primaryButtonText:"   ",ariaLabel:"     .      ."};var CameraSitePermissionsCheck$i={primaryText:"    ",secondaryText:"     .      .",linkText:"         ",primaryButtonText:"  ",ariaLabel:"    .      ."};var MicrophoneSitePermissionsCheck$i={primaryText:"    ",secondaryText:"     .       .",linkText:"         ",primaryButtonText:"  ",ariaLabel:"    .      ."};var CameraAndMicrophoneSitePermissionsDenied$i={primaryText:"    ",secondaryText:"            .     .",primaryButtonText:"   ",linkText:"         "};var CameraAndMicrophoneSitePermissionsDeniedSafari$i={primaryText:"    ",secondaryText:"                 .",primaryButtonText:"   ",linkText:"         "};var CameraSitePermissionsDenied$i={primaryText:"   ",secondaryText:"            .     .",primaryButtonText:"  ",linkText:"         "};var MicrophoneSitePermissionsDenied$i={primaryText:"   ",secondaryText:"            .     .",primaryButtonText:"  ",linkText:"         "};var CameraSitePermissionsDeniedSafari$i={primaryText:"   ",secondaryText:"                 .",primaryButtonText:"  ",linkText:"         "};var MicrophoneSitePermissionsDeniedSafari$i={primaryText:"   ",secondaryText:"                 .",primaryButtonText:"  ",linkText:"         "};var UnsupportedBrowser$i={primaryText:"  ",secondaryText:"       .",moreHelpLinkText:"   "};var UnsupportedBrowserVersion$i={primaryText:"  ",secondaryText:"               .",moreHelpLinkText:"   ",continueAnywayButtonText:"   "};var UnsupportedOperatingSystem$i={primaryText:"   ",secondaryText:"         .",moreHelpLinkText:"   "};var BrowserPermissionDenied$i={primaryText:"    ",secondaryText:"           .     \" \".",primaryButtonText:"  ",linkText:"         "};var BrowserPermissionDeniedIOS$i={primaryText:"    ",secondaryText:"     .",primaryButtonText:"  ",imageAltText:"      iOS",linkText:"         ",step1Text:"   ",step2Text:"      ",step3Text:"  ( )",step4Text:"     ",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$i={leftNavButtonAriaLabel:" ",rightNavButtonAriaLabel:" "};var ar_SA$1 = {participantItem:participantItem$i,ParticipantList:ParticipantList$i,typingIndicator:typingIndicator$i,sendBox:sendBox$i,richTextSendBox:richTextSendBox$i,mentionPopover:mentionPopover$i,imageOverlay:imageOverlay$i,messageStatusIndicator:messageStatusIndicator$i,endCallButton:endCallButton$i,cameraButton:cameraButton$i,microphoneButton:microphoneButton$i,devicesButton:devicesButton$i,participantsButton:participantsButton$i,screenShareButton:screenShareButton$i,raiseHandButton:raiseHandButton$i,reactionButton:reactionButton$i,messageThread:messageThread$i,errorBar:errorBar$i,videoGallery:videoGallery$i,dialpad:dialpad$i,holdButton:holdButton$i,videoTile:videoTile$i,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$i,CameraSitePermissionsRequest:CameraSitePermissionsRequest$i,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$i,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$i,CameraSitePermissionsCheck:CameraSitePermissionsCheck$i,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$i,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$i,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$i,CameraSitePermissionsDenied:CameraSitePermissionsDenied$i,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$i,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$i,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$i,UnsupportedBrowser:UnsupportedBrowser$i,UnsupportedBrowserVersion:UnsupportedBrowserVersion$i,UnsupportedOperatingSystem:UnsupportedOperatingSystem$i,BrowserPermissionDenied:BrowserPermissionDenied$i,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$i,verticalGallery:verticalGallery$i};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Arabic (Saudi Arabia).
 *
 * @public
 */
const COMPONENT_LOCALE_AR_SA = {
    strings: createComponentStrings(ar_SA$1)
};

var participantItem$h={isMeText:"(vy)",menuTitle:"Dal monosti",removeButtonLabel:"Odebrat",sharingIconLabel:"Sdlen",mutedIconLabel:"Ztlumeno",displayNamePlaceholder:"Nepojmenovan astnk",participantStateRinging:"Voln",participantStateHold:"Pozastaven hovor",attendeeRole:"astnk"};var ParticipantList$h={overflowParticipantCount:"+{overflowCount} dal(ch)"};var typingIndicator$h={singleUser:"{user} pe...",multipleUsers:"{users} p...",multipleUsersAbbreviateOne:"{users} a 1 dal p...",multipleUsersAbbreviateMany:"{users} a {numOthers} ostatn p...",delimiter:", "};var sendBox$h={placeholderText:"Zadejte zprvu",textTooLong:"Dlka va zprvy pekrauje maximln limit.",sendButtonAriaLabel:"Poslat zprvu",fileUploadsPendingError:"Probh nahrvn... Pokejte prosm.",removeFile:"Odebrat soubor",uploading:"Nahrvn",uploadCompleted:"Nahrvn se dokonilo"};var richTextSendBox$h={placeholderText:"Zadejte zprvu",textTooLong:"Dlka va zprvy pekrauje maximln limit.",sendButtonAriaLabel:"Poslat zprvu",fileUploadsPendingError:"Nahrvn Pokejte prosm.",removeFile:"Odebrat soubor",uploading:"Nahrvn",uploadCompleted:"Nahrvn se dokonilo",boldTooltip:"Tun",italicTooltip:"Kurzva",underlineTooltip:"Podtren",bulletListTooltip:"Seznam s odrkami",numberListTooltip:"slovan seznam",increaseIndentTooltip:"Zvtit odsazen",decreaseIndentTooltip:"Zmenit odsazen",richTextFormatButtonTooltip:"Formt"};var mentionPopover$h={mentionPopoverHeader:"Nvrhy"};var imageOverlay$h={downloadButtonLabel:"Sthnout",dismissButtonAriaLabel:"Zavt"};var messageStatusIndicator$h={deliveredAriaLabel:"Zprva byla odeslna",deliveredTooltipText:"Odeslno",seenAriaLabel:"Zprva zobrazena pjemci",seenTooltipText:"Zobrazeno",readByTooltipText:"Peetl(a) {messageThreadReadCount} z {remoteParticipantsCount}",sendingAriaLabel:"Odesln zprvy",sendingTooltipText:"Odesln",failedToSendAriaLabel:"Zprvu se nepodailo odeslat",failedToSendTooltipText:"Odesln se nezdailo"};var endCallButton$h={label:"Opustit",tooltipContent:"Opustit hovor"};var cameraButton$h={onLabel:"Kamera",offLabel:"Kamera",tooltipDisabledContent:"Kamera je zakzan",tooltipOnContent:"Vypnout kameru",tooltipOffContent:"Zapnout kameru",tooltipVideoLoadingContent:"Video se nat",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Zvolit kameru",cameraButtonSplitRoleDescription:"Tlatko rozdlen",onSplitButtonAriaLabel:"Vypnout kameru a monosti kamery",offSplitButtonAriaLabel:"Zapnout kameru a monosti kamery",cameraActionTurnedOnAnnouncement:"Vae kamera je zapnut",cameraActionTurnedOffAnnouncement:"Vae kamera je vypnut",onSplitButtonPrimaryActionCamera:"Vypnout kameru",offSplitButtonPrimaryActionCamera:"Zapnout kameru",cameraPrimaryActionSplitButtonTitle:"Pout kameru",videoEffectsMenuItemTitle:"Efekty"};var microphoneButton$h={onLabel:"Mikrofon",offLabel:"Mikrofon",tooltipDisabledContent:"Mikrofon je zakzan",tooltipOnContent:"Ztlumit mikrofon",tooltipOffContent:"Zruit ztlumen mikrofonu",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Zvolit mikrofon",speakerMenuTitle:"Reproduktor",speakerMenuTooltip:"Zvolit reproduktor",microphoneButtonSplitRoleDescription:"Tlatko rozdlen",onSplitButtonAriaLabel:"Ztlumit mikrofon a monosti zvuku",offSplitButtonAriaLabel:"Zruit ztlumen mikrofonu a monost zvuku",microphoneActionTurnedOnAnnouncement:"V mikrofon je zapnut",microphoneActionTurnedOffAnnouncement:"V mikrofon je vypnut",offSplitButtonMicrophonePrimaryAction:"Zruit ztlumen mikrofonu",onSplitButtonMicrophonePrimaryAction:"Ztlumit mikrofon",microphonePrimaryActionSplitButtonTitle:"Pout mikrofon"};var devicesButton$h={label:"Zazen",tooltipContent:"Spravovat zazen",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Zvolit kameru",audioDeviceMenuTitle:"Zvukov zazen",audioDeviceMenuTooltip:"Zvolit zvukov zazen",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Zvolit mikrofon",speakerMenuTitle:"Reproduktor",speakerMenuTooltip:"Zvolit reproduktor"};var participantsButton$h={label:"Lid",tooltipContent:"Zobrazit astnky",menuHeader:"V tomto hovoru",participantsListButtonLabel:"Poet lid: {numParticipants}",muteAllButtonLabel:"Ztlumit vechny",copyInviteLinkButtonLabel:"Koprovat odkaz pro pozvn",copyInviteLinkActionedAriaLabel:"Odkaz pozvnky se zkoproval"};var screenShareButton$h={onLabel:"Zastavit prezentaci",offLabel:"Prezentovat",tooltipDisabledContent:"Sdlen je zakzno",tooltipOnContent:"Sdl se vae obrazovka",tooltipOffContent:"Sdlet obrazovku"};var raiseHandButton$h={offLabel:"Zvednout",onLabel:"Dol",tooltipDisabledContent:"Akce Zvednout ruku je zakzan",tooltipOnContent:"Dt ruku dol",tooltipOffContent:"Zvednout ruku"};var reactionButton$h={label:"Reagovat",ariaLabel:"Tlatko Reagovat, odeslat reakci",tooltipDisabledContent:"Akce reakce je zakzan",tooltipContent:"Odesln reakce",likeReactionTooltipContent:"To se mi lb",heartReactionTooltipContent:"Lska",laughReactionTooltipContent:"Smch",applauseReactionTooltipContent:"Aplaus",surprisedReactionTooltipContent:"Pekvapen"};var messageThread$h={yesterday:"Vera",sunday:"Nedle",monday:"Pondl",tuesday:"ter",wednesday:"Steda",thursday:"tvrtek",friday:"Ptek",saturday:"Sobota",participantJoined:"se pipojil(a) k chatu.",participantLeft:"opustil(a) chat.",editMessage:"Upravit",removeMessage:"Odstranit",resendMessage:"Zkusit odeslat znovu",failToSendTag:"Odesln se nezdailo",editedTag:"Upraveno",liveAuthorIntro:"{author} k",messageContentAriaText:"{author} ekl(a) {message}",messageContentMineAriaText:"ekli jste {message}",editBoxTextLimit:"Vae zprva pekroila limit {limitNumber} znak.",editBoxPlaceholderText:"Upravit zprvu",newMessagesIndicator:"Nov zprvy",noDisplayNameSub:"Bez jmna",editBoxCancelButton:"Zruit",editBoxSubmitButton:"Hotovo",messageReadCount:"Peetl(a) {messageReadByCount} z {remoteParticipantsCount}",actionMenuMoreOptions:"Dal monosti",downloadFile:"Sthnout soubor",blockedWarningText:"Tato zprva se odstranila kvli zsadm organizace.",blockedWarningLinkText:"Podrobnosti",fileCardGroupMessage:"Zprva obsahuje poet ploh: {fileCount}",messageDeletedAnnouncementAriaLabel:"Zprva se odstranila."};var errorBar$h={unableToReachChatService:"Jste offline",accessDenied:"Nepovedlo se zskat pstup ke slubm chatu. Zkontrolujte prosm zadan pihlaovac daje uivatele.",userNotInChatThread:"U nejste v tomto vlkn chatu",sendMessageNotInChatThread:"Zprvu se nepovedlo poslat, protoe u nejste v tomto vlknu chatu.",sendMessageGeneric:"Zprvu se nepovedlo odeslat",callingNetworkFailure:"Mte problmy s pipojenm hovoru  vypad to, e jste offline",startVideoGeneric:"Video se nepovedlo spustit",stopVideoGeneric:"Video se nepovedlo zastavit",muteGeneric:"Nepovedlo se ztlumit mikrofon",unmuteGeneric:"Nepovedlo se zruit ztlumen mikrofonu",speakingWhileMuted:"V mikrofon je ztlumen",startScreenShareGeneric:"Pi spoutn sdlen obrazovky dolo k problmu.",stopScreenShareGeneric:"Nepovedlo se zastavit sdlen obrazovky",callNetworkQualityLow:"Kvalita st je nzk.",callNoSpeakerFound:"Nenaly se dn reproduktory ani sluchtka. Pipojte zvukov zazen, abyste slyeli hovor.",callNoMicrophoneFound:"Nenaly se dn mikrofony. Pipojte vstupn zvukov zazen.",callMicrophoneAccessDenied:"Nepovedlo se zskat pstup k mikrofonu. Kliknutm na zmek na panelu Adresa udlte oprvnn k tto webov strnce.",callMicrophoneAccessDeniedSafari:"Nepovedlo se zskat pstup k mikrofonu. Aktualizujte strnku, abyste povolili oprvnn, nebo zkontrolujte nastaven tohoto prohlee a ovte, jestli jsou pro tento web povolen oprvnn.",callMicrophoneMutedBySystem:"Systm vs ztlumil.",callMicrophoneUnmutedBySystem:"V mikrofon se obnovil a systm vm zruil ztlumen.",callMacOsMicrophoneAccessDenied:"Nepovedlo se zskat pstup k mikrofonu. Udlte v nastaven ochrany osobnch daj pro macOS oprvnn k mikrofonu.",callLocalVideoFreeze:"ka psma st je nekvalitn. Vae video se me zobrazovat jako pozastaven pro ostatn astnky hovoru.",callCameraAccessDenied:"Nepovedlo se zskat pstup ke kamee. Kliknutm na zmek na panelu Adresa udlte oprvnn k tto webov strnce.",callCameraAccessDeniedSafari:"Nejde zskat pstup ke kamee. Aktualizujte strnku, abyste povolili oprvnn, nebo zkontrolujte nastaven tohoto prohlee a ovte, jestli jsou pro tento web povolen oprvnn.",callCameraAlreadyInUse:"Nejde zskat pstup ke kamee. Je mon, e ji u pouv jin aplikace.",callVideoStoppedBySystem:"Vae video bylo zastaveno systmem.",callVideoRecoveredBySystem:"Vae video se obnovilo.",callMacOsCameraAccessDenied:"MacOS blokuje pstup k va kamee. Aktualizujte si nastaven ochrany osobnch daj, aby tento prohle ml pstup k va kamee.",callMacOsScreenShareAccessDenied:"MacOS blokuje sdlen obrazovky. Aktualizujte nastaven ochrany osobnch daj, aby tento prohle mohl nahrvat vai obrazovku.",dismissButtonAriaLabel:"Zavt",failedToJoinCallGeneric:"K hovoru se nepovedlo pipojit.",failedToJoinCallInvalidMeetingLink:"Ke schzce se nelze pipojit. Neplatn odkaz.",cameraFrozenForRemoteParticipants:"Uivatel v hovoru maj problmy s zobrazenm vaeho videa. Zkontrolujte prosm sv zazen a s.",unableToStartVideoEffect:"Nelze pout efekt videa.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Nelze zahjit vytven hlavnho vbru astnk, protoe je ji v hlavnm vbru maximln poet astnk."};var videoGallery$h={screenIsBeingSharedMessage:"Sdlte obrazovku",screenShareLoadingMessage:"Natn obrazovky {participant}",localVideoLabel:"Vy",localVideoCameraSwitcherLabel:"Pepnout kameru",localVideoMovementLabel:"Dladice s mstnm videem s monost pesunut",localVideoSelectedDescription:"{cameraName} vybrno",displayNamePlaceholder:"Nepojmenovan astnk",fitRemoteParticipantToFrame:"Pizpsobit rmeku",fillRemoteParticipantFrame:"Vyplnit rmeek",pinParticipantForMe:"Pipnout pro m",pinParticipantForMeLimitReached:"Pipnout (doshlo se limitu)",unpinParticipantForMe:"Odepnout",pinParticipantMenuItemAriaLabel:"Pipnout {participantName}",unpinParticipantMenuItemAriaLabel:"Odepnout {participantName}",pinnedParticipantAnnouncementAriaLabel:"Pipnut astnk {participantName}",unpinnedParticipantAnnouncementAriaLabel:"{participantName} odepnut",startSpotlightVideoTileMenuLabel:"Pidat do hlavnho vbru vem",addSpotlightVideoTileMenuLabel:"Pidat do hlavnho vbru",spotlightLimitReachedMenuTitle:"Doshlo se limitu hlavnho vbru",stopSpotlightVideoTileMenuLabel:"Zastavit pidvn do hlavnho vbru",stopSpotlightOnSelfVideoTileMenuLabel:"Ukonit hlavn vbr",attendeeRole:"astnk"};var dialpad$h={placeholderText:"Zadejte telefonn slo",deleteButtonAriaLabel:"Odstranit"};var holdButton$h={onLabel:"Pokraovat",offLabel:"Pozastavit",tooltipOnContent:"Pokraovat v hovoru",tooltipOffContent:"Pozastavit hovor"};var videoTile$h={participantStateRinging:"Voln",participantStateHold:"Pozastaven hovor"};var CameraAndMicrophoneSitePermissionsRequest$h={primaryText:"Povolit aplikaci {appName} pouvat kameru a mikrofon",secondaryText:"Toto je proto, aby vs astnci vidli a slyeli.",linkText:"Potebujete pomoc? Zskat npovdu k een pot",primaryButtonText:"Pokraovat bez kamery a mikrofonu",ariaLabel:"Povolit pstup ke kamee a mikrofonu"};var CameraSitePermissionsRequest$h={primaryText:"Povolit aplikaci {appName} pouvat vai kameru",secondaryText:"Toto je proto, aby vs astnci vidli.",linkText:"Potebujete pomoc? Zskat npovdu k een pot",primaryButtonText:"Pokraovat bez kamery",ariaLabel:"Povolit pstup ke kamee"};var MicrophoneSitePermissionsRequest$h={primaryText:"Povolit aplikaci {appName} pouvat v mikrofon",secondaryText:"To je proto, aby vs astnci mohli slyet.",linkText:"Potebujete pomoc? Zskat npovdu k een pot",primaryButtonText:"Pokraovat bez mikrofonu",ariaLabel:"Povolte pstup k mikrofonu"};var CameraAndMicrophoneSitePermissionsCheck$h={primaryText:"Kontrola pstupu ke kamee a mikrofonu",secondaryText:"Pokud se zobraz vzva, povolte pstup. To je proto, aby vs astnci slyeli a vidli.",linkText:"Potebujete pomoc? Zskat npovdu k een pot",primaryButtonText:"Pokraovat bez kamery a mikrofonu",ariaLabel:"Kontroluje se pstup k mikrofonu a kamee. Povolit pstup, pokud se zobraz vzva."};var CameraSitePermissionsCheck$h={primaryText:"Kontroluje se pstup ke kamee",secondaryText:"Pokud se zobraz vzva, povolte pstup. To je proto, aby vs astnci vidli.",linkText:"Potebujete pomoc? Zskat npovdu k een pot",primaryButtonText:"Pokraovat bez kamery",ariaLabel:"Kontroluje se pstup ke kamee. Povolit pstup, pokud se zobraz vzva."};var MicrophoneSitePermissionsCheck$h={primaryText:"Kontroluje se pstup k mikrofonu",secondaryText:"Pokud se zobraz vzva, povolte pstup. To je proto, aby vs astnci slyeli.",linkText:"Potebujete pomoc? Zskat npovdu k een pot",primaryButtonText:"Pokraovat bez mikrofonu",ariaLabel:"Kontroluje se pstup k mikrofonu. Povolit pstup, pokud se zobraz vzva."};var CameraAndMicrophoneSitePermissionsDenied$h={primaryText:"Nejde zskat pstup ke kamee a mikrofonu",secondaryText:"Kliknutm na ikonu zmku na panelu Adresa udlte mikrofonu oprvnn k tto webov strnce. Me bt vyadovna aktualizace strnky.",primaryButtonText:"Pokraovat bez kamery a mikrofonu",linkText:"Potebujete pomoc? Zskat npovdu k een pot"};var CameraAndMicrophoneSitePermissionsDeniedSafari$h={primaryText:"Nejde zskat pstup ke kamee a mikrofonu.",secondaryText:"Aktualizujte strnku, abyste povolili oprvnn, nebo zkontrolujte nastaven tohoto prohlee a ovte, jestli jsou pro tento web povolen oprvnn.",primaryButtonText:"Pokraovat bez kamery a mikrofonu",linkText:"Potebujete pomoc? Zskat npovdu k een pot"};var CameraSitePermissionsDenied$h={primaryText:"Nejde zskat pstup ke kamee",secondaryText:"Kliknutm na ikonu zmku na panelu Adresa udlte kamee oprvnn k tto webov strnce. Me bt vyadovna aktualizace strnky.",primaryButtonText:"Pokraovat bez kamery",linkText:"Potebujete pomoc? Zskat npovdu k een pot"};var MicrophoneSitePermissionsDenied$h={primaryText:"Nepovedlo se zskat pstup k mikrofonu",secondaryText:"Kliknutm na ikonu zmku na panelu Adresa udlte mikrofonu oprvnn k tto webov strnce. Me bt vyadovna aktualizace strnky.",primaryButtonText:"Pokraovat bez mikrofonu",linkText:"Potebujete pomoc? Zskat npovdu k een pot"};var CameraSitePermissionsDeniedSafari$h={primaryText:"Nejde zskat pstup ke kamee",secondaryText:"Aktualizujte strnku, abyste povolili oprvnn, nebo zkontrolujte nastaven tohoto prohlee a ovte, jestli jsou pro tento web povolen oprvnn.",primaryButtonText:"Pokraovat bez kamery",linkText:"Potebujete pomoc? Zskat npovdu k een pot"};var MicrophoneSitePermissionsDeniedSafari$h={primaryText:"Nepovedlo se zskat pstup k mikrofonu",secondaryText:"Aktualizujte strnku, abyste povolili oprvnn, nebo zkontrolujte nastaven tohoto prohlee a ovte, jestli jsou pro tento web povolen oprvnn.",primaryButtonText:"Pokraovat bez mikrofonu",linkText:"Potebujete pomoc? Zskat npovdu k een pot"};var UnsupportedBrowser$h={primaryText:"Prohle nen podporovan",secondaryText:"Pipojte se k tomuto hovoru pomoc kompatibilnho prohlee.",moreHelpLinkText:"Zobrazit poadavky na kompatibilitu"};var UnsupportedBrowserVersion$h={primaryText:"Je nutn aktualizovat prohle",secondaryText:"Abyste zajistili nejlep mon hovor, aktualizujte si prosm prohle a zkuste se k hovoru pipojit znovu.",moreHelpLinkText:"Zobrazit poadavky na kompatibilitu",continueAnywayButtonText:"Zahjit hovor bez aktualizace"};var UnsupportedOperatingSystem$h={primaryText:"Nepodporovan operan systm",secondaryText:"Pipojte se k tomuto hovoru pomoc zazen s kompatibilnm operanm systmem.",moreHelpLinkText:"Zobrazit poadavky na kompatibilitu"};var BrowserPermissionDenied$h={primaryText:"Kameru nebo mikrofon nejde pout",secondaryText:"V prohle mon nem pstup ke kamee nebo mikrofonu. Tento problm vyete tak, e otevete Pedvolby systmu.",primaryButtonText:"Zkusit znovu",linkText:"Potebujete pomoc? Zskat npovdu k een pot"};var BrowserPermissionDeniedIOS$h={primaryText:"Povolit pstup k mikrofonu, aby bylo mon pokraovat",secondaryText:"Aby vs ostatn astnci slyeli.",primaryButtonText:"Zkusit znovu",imageAltText:"Umstn oprvnn mikrofonu a kamery pro iOS",linkText:"Potebujete pomoc? Zskat npovdu k een pot",step1Text:"Pejt do aplikace Nastaven",step2Text:"Pesute se dol k nastaven tohoto prohlee",step3Text:"Zapnout mikrofon (kamera je voliteln)",step4Text:"Zkuste se pipojit k hovoru znovu",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$h={leftNavButtonAriaLabel:"pedchoz strnka",rightNavButtonAriaLabel:"dal strnka"};var cs_CZ$1 = {participantItem:participantItem$h,ParticipantList:ParticipantList$h,typingIndicator:typingIndicator$h,sendBox:sendBox$h,richTextSendBox:richTextSendBox$h,mentionPopover:mentionPopover$h,imageOverlay:imageOverlay$h,messageStatusIndicator:messageStatusIndicator$h,endCallButton:endCallButton$h,cameraButton:cameraButton$h,microphoneButton:microphoneButton$h,devicesButton:devicesButton$h,participantsButton:participantsButton$h,screenShareButton:screenShareButton$h,raiseHandButton:raiseHandButton$h,reactionButton:reactionButton$h,messageThread:messageThread$h,errorBar:errorBar$h,videoGallery:videoGallery$h,dialpad:dialpad$h,holdButton:holdButton$h,videoTile:videoTile$h,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$h,CameraSitePermissionsRequest:CameraSitePermissionsRequest$h,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$h,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$h,CameraSitePermissionsCheck:CameraSitePermissionsCheck$h,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$h,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$h,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$h,CameraSitePermissionsDenied:CameraSitePermissionsDenied$h,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$h,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$h,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$h,UnsupportedBrowser:UnsupportedBrowser$h,UnsupportedBrowserVersion:UnsupportedBrowserVersion$h,UnsupportedOperatingSystem:UnsupportedOperatingSystem$h,BrowserPermissionDenied:BrowserPermissionDenied$h,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$h,verticalGallery:verticalGallery$h};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Czech (Czech Republic).
 *
 * @public
 */
const COMPONENT_LOCALE_CS_CZ = {
    strings: createComponentStrings(cs_CZ$1)
};

var participantItem$g={isMeText:"(Sie)",menuTitle:"Weitere Optionen",removeButtonLabel:"Entfernen",sharingIconLabel:"Teilen",mutedIconLabel:"Stumm geschaltet",displayNamePlaceholder:"Teilnehmer ohne Namen",participantStateRinging:"Anrufen...",participantStateHold:"In der Warteschleife",attendeeRole:"Teilnehmer"};var ParticipantList$g={overflowParticipantCount:"+{overflowCount} weitere"};var typingIndicator$g={singleUser:"{user} schreibt ...",multipleUsers:"{users} schreiben ...",multipleUsersAbbreviateOne:"{users} und 1 andere Person schreiben ...",multipleUsersAbbreviateMany:"{users} und {numOthers} andere schreiben ...",delimiter:", "};var sendBox$g={placeholderText:"Nachricht eingeben",textTooLong:"Ihre Nachrichtenlnge berschreitet den maximalen Grenzwert.",sendButtonAriaLabel:"Nachricht senden",fileUploadsPendingError:"Wird hochgeladen... Bitte warten.",removeFile:"Datei entfernen",uploading:"Hochladen",uploadCompleted:"Upload abgeschlossen"};var richTextSendBox$g={placeholderText:"Nachricht eingeben",textTooLong:"Ihre Nachrichtenlnge berschreitet den maximalen Grenzwert.",sendButtonAriaLabel:"Nachricht senden",fileUploadsPendingError:"Wird hochgeladen... Bitte warten.",removeFile:"Datei entfernen",uploading:"Wird hochgeladen",uploadCompleted:"Upload abgeschlossen",boldTooltip:"Fett",italicTooltip:"Kursiv",underlineTooltip:"Unterstreichen",bulletListTooltip:"Aufzhlungsliste",numberListTooltip:"Nummerierte Liste",increaseIndentTooltip:"Einzug vergrern",decreaseIndentTooltip:"Einzug verringern",richTextFormatButtonTooltip:"Formatieren"};var mentionPopover$g={mentionPopoverHeader:"Vorschlge"};var imageOverlay$g={downloadButtonLabel:"Herunterladen",dismissButtonAriaLabel:"Schlieen"};var messageStatusIndicator$g={deliveredAriaLabel:"Nachricht gesendet",deliveredTooltipText:"Gesendet",seenAriaLabel:"Nachricht von anderen gesehen",seenTooltipText:"Gesehen",readByTooltipText:"Gelesen von {messageThreadReadCount} von {remoteParticipantsCount}",sendingAriaLabel:"Nachricht wird gesendet",sendingTooltipText:"Wird gesendet",failedToSendAriaLabel:"Nachricht konnte nicht gesendet werden",failedToSendTooltipText:"Fehler beim Senden"};var endCallButton$g={label:"Verlassen",tooltipContent:"Anruf verlassen"};var cameraButton$g={onLabel:"Kamera",offLabel:"Kamera",tooltipDisabledContent:"Kamera ist deaktiviert",tooltipOnContent:"Kamera ausschalten",tooltipOffContent:"Kamera einschalten",tooltipVideoLoadingContent:"Video wird geladen",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera auswhlen",cameraButtonSplitRoleDescription:"Unterteilte Schaltflche",onSplitButtonAriaLabel:"Kamera und Kameraoptionen deaktivieren",offSplitButtonAriaLabel:"Kamera und Kameraoptionen aktivieren",cameraActionTurnedOnAnnouncement:"Ihre Kamera wurde eingeschaltet.",cameraActionTurnedOffAnnouncement:"Ihre Kamera wurde ausgeschaltet.",onSplitButtonPrimaryActionCamera:"Kamera ausschalten",offSplitButtonPrimaryActionCamera:"Kamera einschalten",cameraPrimaryActionSplitButtonTitle:"Kamera verwenden",videoEffectsMenuItemTitle:"Effekte"};var microphoneButton$g={onLabel:"Mikrofon",offLabel:"Mikrofon",tooltipDisabledContent:"Mikrofon ist deaktiviert",tooltipOnContent:"Mikrofon stummschalten",tooltipOffContent:"Mikrofonstummschaltung aufheben",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon auswhlen",speakerMenuTitle:"Lautsprecher",speakerMenuTooltip:"Lautsprecher auswhlen",microphoneButtonSplitRoleDescription:"Unterteilte Schaltflche",onSplitButtonAriaLabel:"Mikrofon- und Audiooptionen stummschalten",offSplitButtonAriaLabel:"Stummschaltung von Mikrofon- und Audiooptionen aufheben",microphoneActionTurnedOnAnnouncement:"Ihr Mikrofon wurde eingeschaltet.",microphoneActionTurnedOffAnnouncement:"Ihr Mikrofon wurde ausgeschaltet.",offSplitButtonMicrophonePrimaryAction:"Mikrofonstummschaltung aufheben",onSplitButtonMicrophonePrimaryAction:"Mikrofon stummschalten",microphonePrimaryActionSplitButtonTitle:"Mikrofon verwenden"};var devicesButton$g={label:"Gerte",tooltipContent:"Gerte verwalten",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera auswhlen",audioDeviceMenuTitle:"Audiogert",audioDeviceMenuTooltip:"Audiogert auswhlen",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon auswhlen",speakerMenuTitle:"Lautsprecher",speakerMenuTooltip:"Lautsprecher auswhlen"};var participantsButton$g={label:"Personen",tooltipContent:"Teilnehmende anzeigen",menuHeader:"In diesem Anruf",participantsListButtonLabel:"{numParticipants}Personen",muteAllButtonLabel:"Alle stumm schalten",copyInviteLinkButtonLabel:"Einladungslink kopieren",copyInviteLinkActionedAriaLabel:"Einladungslink kopiert"};var screenShareButton$g={onLabel:"Prsentation beenden",offLabel:"Prsentieren",tooltipDisabledContent:"Prsentieren ist deaktiviert",tooltipOnContent:"Ihr Bildschirm wird prsentiert",tooltipOffContent:"Prsentieren Sie Ihren Bildschirm"};var raiseHandButton$g={offLabel:"Heben",onLabel:"Senken",tooltipDisabledContent:"Aktion Hand heben ist deaktiviert",tooltipOnContent:"Hand senken",tooltipOffContent:"Hand heben"};var reactionButton$g={label:"Reagieren",ariaLabel:"Reaktionsschaltflche, Reaktion senden",tooltipDisabledContent:"Reaktionsaktion ist deaktiviert",tooltipContent:"Reaktion senden",likeReactionTooltipContent:"Gefllt mir",heartReactionTooltipContent:"Liebe",laughReactionTooltipContent:"Lachen",applauseReactionTooltipContent:"Applaus",surprisedReactionTooltipContent:"berrascht"};var messageThread$g={yesterday:"Gestern",sunday:"Sonntag",monday:"Montag",tuesday:"Dienstag",wednesday:"Mittwoch",thursday:"Donnerstag",friday:"Freitag",saturday:"Samstag",participantJoined:"ist dem Chat beigetreten.",participantLeft:"hat den Chat verlassen.",editMessage:"Bearbeiten",removeMessage:"Lschen",resendMessage:"Erneut senden",failToSendTag:"Fehler beim Senden",editedTag:"Bearbeitet",liveAuthorIntro:"{author} sagt",messageContentAriaText:"{author} hat {message} gesagt",messageContentMineAriaText:"Sie sagten {message}",editBoxTextLimit:"Ihre Nachricht berschreitet das Limit von {limitNumber} Zeichen.",editBoxPlaceholderText:"Bearbeiten Sie Ihre Nachricht",newMessagesIndicator:"Neue Nachrichten",noDisplayNameSub:"Kein Name",editBoxCancelButton:"Abbrechen",editBoxSubmitButton:"Fertig",messageReadCount:"Gelesen von {messageReadByCount} von {remoteParticipantsCount}",actionMenuMoreOptions:"Weitere Optionen",downloadFile:"Datei herunterladen",blockedWarningText:"Diese Nachricht wurde aufgrund einer Organisationsrichtlinie gelscht.",blockedWarningLinkText:"Details",fileCardGroupMessage:"Die Nachricht weist eine {fileCount}-Anlage auf",messageDeletedAnnouncementAriaLabel:"Die Nachricht wurde gelscht"};var errorBar$g={unableToReachChatService:"Sie sind offline.",accessDenied:"Auf die Chatdienste kann nicht zugegriffen werden. berprfen Sie die angegebenen Benutzeranmeldeinformationen.",userNotInChatThread:"Sie sind nicht mehr in diesem Chatthread vertreten.",sendMessageNotInChatThread:"Fehler beim Senden der Nachricht, weil Sie sich nicht mehr in diesem Chatthread befinden.",sendMessageGeneric:"Fehler beim Senden der Nachricht",callingNetworkFailure:"Problematische Anrufverbindung  Sie scheinen offline zu sein",startVideoGeneric:"Video konnte nicht gestartet werden",stopVideoGeneric:"Video konnte nicht beendet werden",muteGeneric:"Mikrofon konnte nicht stummgeschaltet werden",unmuteGeneric:"Stummschaltung des Mikrofons konnte nicht beendet werden",speakingWhileMuted:"Ihr Mikrofon ist stummgeschaltet",startScreenShareGeneric:"Beim Starten der Bildschirmfreigabe ist ein Problem aufgetreten.",stopScreenShareGeneric:"Bildschirmfreigabe konnte nicht beendet werden",callNetworkQualityLow:"Die Netzwerkqualitt ist niedrig.",callNoSpeakerFound:"Keine Lautsprecher oder Kopfhrer gefunden. Schlieen Sie ein Audiogert an, um den Anruf zu hren.",callNoMicrophoneFound:"Es wurden keine Mikrofone gefunden. Schlieen Sie ein Audioeingabegert an.",callMicrophoneAccessDenied:"Auf das Mikrofon kann nicht zugegriffen werden. Klicken Sie auf die Sperre in der Adressleiste, um dieser Webseite Berechtigungen zu erteilen.",callMicrophoneAccessDeniedSafari:"Auf das Mikrofon kann nicht zugegriffen werden. Aktualisieren Sie die Seite, um Berechtigungen zuzulassen, oder berprfen Sie die Einstellungen dieses Browsers, und stellen Sie sicher, dass die Berechtigungen fr diese Website aktiviert sind.",callMicrophoneMutedBySystem:"Sie werden von Ihrem System stummgeschaltet.",callMicrophoneUnmutedBySystem:"Ihr Mikrofon wurde wiederhergestellt, und Ihr System hat die Stummschaltung aufgehoben.",callMacOsMicrophoneAccessDenied:"Auf das Mikrofon kann nicht zugegriffen werden. Erteilen Sie die Mikrofonberechtigung in Ihren macOS-Datenschutzeinstellungen.",callLocalVideoFreeze:"Die Netzwerkbandbreite ist schlecht. Ihr Video wird mglicherweise fr andere Personen whrend des Anrufs angehalten angezeigt.",callCameraAccessDenied:"Auf die Kamera kann nicht zugegriffen werden. Klicken Sie auf die Sperre in der Adressleiste, um dieser Webseite Berechtigungen zu erteilen.",callCameraAccessDeniedSafari:"Auf die Kamera kann nicht zugegriffen werden. Aktualisieren Sie die Seite, um Berechtigungen zuzulassen, oder berprfen Sie die Einstellungen dieses Browsers, und stellen Sie sicher, dass die Berechtigungen fr diese Website aktiviert sind.",callCameraAlreadyInUse:"Auf die Kamera kann nicht zugegriffen werden. Sie wird mglicherweise bereits von einer anderen Anwendung verwendet.",callVideoStoppedBySystem:"Ihr Video wurde von Ihrem System beendet.",callVideoRecoveredBySystem:"Ihr Video wurde fortgesetzt.",callMacOsCameraAccessDenied:"MacOS blockiert den Zugriff auf Ihre Kamera. Aktualisieren Sie Ihre Datenschutzeinstellungen, damit dieser Browser auf Ihre Kamera zugreifen kann.",callMacOsScreenShareAccessDenied:"MacOS blockiert die Bildschirmfreigabe. Aktualisieren Sie Ihre Datenschutzeinstellungen, damit dieser Browser Ihren Bildschirm aufzeichnen kann.",dismissButtonAriaLabel:"Schlieen",failedToJoinCallGeneric:"Fehler bei der Teilnahme am Anruf.",failedToJoinCallInvalidMeetingLink:"Teilnahme an Besprechung nicht mglich. Ungltiger Link.",cameraFrozenForRemoteParticipants:"Benutzer im Anruf haben Probleme, Ihr Video zu sehen. berprfen Sie Ihre Gerte und Ihr Netzwerk.",unableToStartVideoEffect:"Videoeffekt kann nicht angewendet werden.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Das Spotlight fr Teilnehmer*innen kann nicht gestartet werden, da die maximale Anzahl von Teilnehmer*innen bereits im Spotlight ist."};var videoGallery$g={screenIsBeingSharedMessage:"Sie teilen Ihren Bildschirm",screenShareLoadingMessage:"Der Bildschirm von {participant} wird geladen",localVideoLabel:"Sie",localVideoCameraSwitcherLabel:"Kamera wechseln",localVideoMovementLabel:"Verschiebbare lokale Videokachel",localVideoSelectedDescription:"{cameraName} ausgewhlt",displayNamePlaceholder:"Teilnehmer ohne Namen",fitRemoteParticipantToFrame:"An Rahmen anpassen",fillRemoteParticipantFrame:"Rahmen ausfllen",pinParticipantForMe:"Fr mich anheften",pinParticipantForMeLimitReached:"Anheften (Limit erreicht)",unpinParticipantForMe:"Lsen",pinParticipantMenuItemAriaLabel:"{participantName} anheften",unpinParticipantMenuItemAriaLabel:"{participantName} lsen",pinnedParticipantAnnouncementAriaLabel:"{participantName} angeheftet",unpinnedParticipantAnnouncementAriaLabel:"{participantName} gelst",startSpotlightVideoTileMenuLabel:"Spotlight fr alle",addSpotlightVideoTileMenuLabel:"Spotlight hinzufgen",spotlightLimitReachedMenuTitle:"Spotlight-Limit erreicht",stopSpotlightVideoTileMenuLabel:"Spotlight beenden",stopSpotlightOnSelfVideoTileMenuLabel:"Spotlight beenden",attendeeRole:"Teilnehmer"};var dialpad$g={placeholderText:"Telefonnummer eingeben",deleteButtonAriaLabel:"Lschen"};var holdButton$g={onLabel:"Fortsetzen",offLabel:"Halten",tooltipOnContent:"Anruf fortsetzen",tooltipOffContent:"Anruf halten"};var videoTile$g={participantStateRinging:"Anrufen...",participantStateHold:"In der Warteschleife"};var CameraAndMicrophoneSitePermissionsRequest$g={primaryText:"Zulassen, dass {appName} Ihre Kamera und Ihr Mikrofon verwendet",secondaryText:"So knnen die Teilnehmer Sie sehen und hren.",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Kamera und Mikrofon fortfahren",ariaLabel:"Zugriff auf Kamera und Mikrofon zulassen"};var CameraSitePermissionsRequest$g={primaryText:"{appName} die Verwendung Ihrer Kamera erlauben",secondaryText:"So knnen die Teilnehmer Sie sehen.",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Kamera fortfahren",ariaLabel:"Kamerazugriff zulassen"};var MicrophoneSitePermissionsRequest$g={primaryText:"{appName} die Verwendung Ihres Mikrofons erlauben",secondaryText:"So knnen die Teilnehmer Sie hren.",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Mikrofon fortfahren",ariaLabel:"Mikrofonzugriff zulassen"};var CameraAndMicrophoneSitePermissionsCheck$g={primaryText:"berprfen des Kamera- und Mikrofonzugriffs",secondaryText:"Zugriff bei Aufforderung zulassen. Dies ist so, dass Teilnehmer Sie sehen und hren knnen.",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Kamera und Mikrofon fortfahren",ariaLabel:"berprfen des Kamera- und Mikrofonzugriffs. Erlauben Sie den Zugriff, wenn Sie aufgefordert werden."};var CameraSitePermissionsCheck$g={primaryText:"berprfung des Kamerazugriffs",secondaryText:"Zugriff bei Aufforderung zulassen. Dies ist so, dass Teilnehmer Sie sehen knnen.",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Kamera fortfahren",ariaLabel:"berprfen des Kamerazugriffs. Erlauben Sie den Zugriff, wenn Sie aufgefordert werden."};var MicrophoneSitePermissionsCheck$g={primaryText:"berprfen des Mikrofonzugriffs",secondaryText:"Zugriff bei Aufforderung zulassen. Dies ist so, dass Teilnehmer Sie hren knnen.",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Mikrofon fortfahren",ariaLabel:"Der Mikrofonzugriff wird berprft. Erlauben Sie den Zugriff, wenn Sie aufgefordert werden."};var CameraAndMicrophoneSitePermissionsDenied$g={primaryText:"Auf Kamera und Mikrofon kann nicht zugegriffen werden",secondaryText:"Klicken Sie auf das Schlosssymbol in der Adressleiste, um dieser Webseite Mikrofonberechtigungen zu erteilen. Mglicherweise ist eine Seitenaktualisierung erforderlich.",primaryButtonText:"Ohne Kamera und Mikrofon fortfahren",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung"};var CameraAndMicrophoneSitePermissionsDeniedSafari$g={primaryText:"Auf Kamera und Mikrofon kann nicht zugegriffen werden",secondaryText:"Aktualisieren Sie die Seite, um Berechtigungen zuzulassen, oder berprfen Sie die Einstellungen dieses Browsers und stellen Sie sicher, dass die Berechtigungen fr diese Website aktiviert sind.",primaryButtonText:"Ohne Kamera und Mikrofon fortfahren",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung"};var CameraSitePermissionsDenied$g={primaryText:"Auf die Kamera kann nicht zugegriffen werden",secondaryText:"Klicken Sie auf das Schlosssymbol in der Adressleiste, um dieser Webseite Kameraberechtigungen zu erteilen. Mglicherweise ist eine Seitenaktualisierung erforderlich.",primaryButtonText:"Ohne Kamera fortfahren",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung"};var MicrophoneSitePermissionsDenied$g={primaryText:"Auf das Mikrofon kann nicht zugegriffen werden",secondaryText:"Klicken Sie auf das Schlosssymbol in der Adressleiste, um dieser Webseite Mikrofonberechtigungen zu erteilen. Mglicherweise ist eine Seitenaktualisierung erforderlich.",primaryButtonText:"Ohne Mikrofon fortfahren",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung"};var CameraSitePermissionsDeniedSafari$g={primaryText:"Auf die Kamera kann nicht zugegriffen werden",secondaryText:"Aktualisieren Sie die Seite, um Berechtigungen zuzulassen, oder berprfen Sie die Einstellungen dieses Browsers und stellen Sie sicher, dass die Berechtigungen fr diese Website aktiviert sind.",primaryButtonText:"Ohne Kamera fortfahren",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung"};var MicrophoneSitePermissionsDeniedSafari$g={primaryText:"Auf das Mikrofon kann nicht zugegriffen werden",secondaryText:"Aktualisieren Sie die Seite, um Berechtigungen zuzulassen, oder berprfen Sie die Einstellungen dieses Browsers und stellen Sie sicher, dass die Berechtigungen fr diese Website aktiviert sind.",primaryButtonText:"Ohne Mikrofon fortfahren",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung"};var UnsupportedBrowser$g={primaryText:"Der Browser wird nicht untersttzt.",secondaryText:"Bitte nehmen Sie ber einen kompatiblen Browser an diesem Anruf teil.",moreHelpLinkText:"Kompatibilittsanforderungen anzeigen"};var UnsupportedBrowserVersion$g={primaryText:"Browserupdate erforderlich",secondaryText:"Um einen optimalen Anruf zu gewhrleisten, aktualisieren Sie Ihren Browser, und versuchen Sie dann erneut, an dem Anruf teilzunehmen.",moreHelpLinkText:"Kompatibilittsanforderungen anzeigen",continueAnywayButtonText:"Anruf ohne Aktualisierung starten"};var UnsupportedOperatingSystem$g={primaryText:"Das Betriebssystem wird nicht untersttzt.",secondaryText:"Nehmen Sie an diesem Anruf teil, indem Sie ein Gert mit einem kompatiblen Betriebssystem verwenden.",moreHelpLinkText:"Kompatibilittsanforderungen anzeigen"};var BrowserPermissionDenied$g={primaryText:"Kamera oder Mikrofon kann nicht verwendet werden",secondaryText:"Ihr Browser hat mglicherweise keinen Zugriff auf Ihre Kamera oder Ihr Mikrofon. ffnen Sie die Systemeinstellungen, um dieses Problem zu beheben.",primaryButtonText:"Erneut versuchen",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung"};var BrowserPermissionDeniedIOS$g={primaryText:"Mikrofonzugriff zulassen, um fortzufahren",secondaryText:"Damit andere Teilnehmer Sie hren knnen.",primaryButtonText:"Erneut versuchen",imageAltText:"Berechtigungsspeicherort fr Mikrofon- und Kameragerte fr iOS",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung",step1Text:"Zur Einstellungs-App wechseln",step2Text:"Scrollen Sie nach unten zu den Einstellungen dieses Browsers",step3Text:"Mikrofon einschalten (Kamera optional)",step4Text:"Versuchen Sie erneut, dem Anruf beizutreten",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$g={leftNavButtonAriaLabel:"Vorherige Seite",rightNavButtonAriaLabel:"Nchste Seite"};var de_DE$1 = {participantItem:participantItem$g,ParticipantList:ParticipantList$g,typingIndicator:typingIndicator$g,sendBox:sendBox$g,richTextSendBox:richTextSendBox$g,mentionPopover:mentionPopover$g,imageOverlay:imageOverlay$g,messageStatusIndicator:messageStatusIndicator$g,endCallButton:endCallButton$g,cameraButton:cameraButton$g,microphoneButton:microphoneButton$g,devicesButton:devicesButton$g,participantsButton:participantsButton$g,screenShareButton:screenShareButton$g,raiseHandButton:raiseHandButton$g,reactionButton:reactionButton$g,messageThread:messageThread$g,errorBar:errorBar$g,videoGallery:videoGallery$g,dialpad:dialpad$g,holdButton:holdButton$g,videoTile:videoTile$g,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$g,CameraSitePermissionsRequest:CameraSitePermissionsRequest$g,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$g,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$g,CameraSitePermissionsCheck:CameraSitePermissionsCheck$g,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$g,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$g,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$g,CameraSitePermissionsDenied:CameraSitePermissionsDenied$g,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$g,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$g,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$g,UnsupportedBrowser:UnsupportedBrowser$g,UnsupportedBrowserVersion:UnsupportedBrowserVersion$g,UnsupportedOperatingSystem:UnsupportedOperatingSystem$g,BrowserPermissionDenied:BrowserPermissionDenied$g,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$g,verticalGallery:verticalGallery$g};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for German (Germany).
 *
 * @public
 */
const COMPONENT_LOCALE_DE_DE = {
    strings: createComponentStrings(de_DE$1)
};

var participantItem$f={isMeText:"(t)",menuTitle:"Ms opciones",removeButtonLabel:"Quitar",sharingIconLabel:"Compartiendo",mutedIconLabel:"Silenciado",displayNamePlaceholder:"Participante sin nombre",participantStateRinging:"Llamando...",participantStateHold:"En espera",attendeeRole:"Asistente"};var ParticipantList$f={overflowParticipantCount:"+{overflowCount} ms"};var typingIndicator$f={singleUser:"{user} est escribiendo...",multipleUsers:"{users} estn escribiendo...",multipleUsersAbbreviateOne:"{users} y 1 usuario ms estn escribiendo...",multipleUsersAbbreviateMany:"{users} y {numOthers} usuarios ms estn escribiendo...",delimiter:", "};var sendBox$f={placeholderText:"Escribir un mensaje",textTooLong:"La longitud del mensaje supera el lmite mximo.",sendButtonAriaLabel:"Enviar mensaje",fileUploadsPendingError:"Cargando... Espere.",removeFile:"Quitar archivo",uploading:"Cargando",uploadCompleted:"Carga completada"};var richTextSendBox$f={placeholderText:"Escribir un mensaje",textTooLong:"La longitud del mensaje supera el lmite mximo.",sendButtonAriaLabel:"Enviar mensaje",fileUploadsPendingError:"Cargando... Espere.",removeFile:"Quitar archivo",uploading:"Cargando",uploadCompleted:"Carga completada",boldTooltip:"Negrita",italicTooltip:"Cursiva",underlineTooltip:"Subrayado",bulletListTooltip:"Lista con vietas",numberListTooltip:"Lista numerada",increaseIndentTooltip:"Aumentar sangra",decreaseIndentTooltip:"Reducir sangra",richTextFormatButtonTooltip:"Formato"};var mentionPopover$f={mentionPopoverHeader:"Sugerencias"};var imageOverlay$f={downloadButtonLabel:"Descargar",dismissButtonAriaLabel:"Cerrar"};var messageStatusIndicator$f={deliveredAriaLabel:"Mensaje enviado",deliveredTooltipText:"Enviado",seenAriaLabel:"Mensaje visto por otros usuarios",seenTooltipText:"Visto",readByTooltipText:"Ledo por {messageThreadReadCount} de {remoteParticipantsCount}",sendingAriaLabel:"Envo de mensajes",sendingTooltipText:"Enviando",failedToSendAriaLabel:"Error al enviar el mensaje",failedToSendTooltipText:"Error al enviar"};var endCallButton$f={label:"Baja",tooltipContent:"Abandonar llamada"};var cameraButton$f={onLabel:"Cmara",offLabel:"Cmara",tooltipDisabledContent:"La cmara est deshabilitada",tooltipOnContent:"Desconectar la cmara",tooltipOffContent:"Activar la cmara",tooltipVideoLoadingContent:"El vdeo se est cargando",cameraMenuTitle:"Cmara",cameraMenuTooltip:"Elegir cmara",cameraButtonSplitRoleDescription:"Botn de expansin",onSplitButtonAriaLabel:"Desactivar la cmara y las opciones de cmara",offSplitButtonAriaLabel:"Activar la cmara y las opciones de cmara",cameraActionTurnedOnAnnouncement:"La cmara se ha activado",cameraActionTurnedOffAnnouncement:"La cmara se ha desactivado",onSplitButtonPrimaryActionCamera:"Desconectar la cmara",offSplitButtonPrimaryActionCamera:"Activar la cmara",cameraPrimaryActionSplitButtonTitle:"Usar cmara",videoEffectsMenuItemTitle:"Efectos"};var microphoneButton$f={onLabel:"Micro",offLabel:"Micro",tooltipDisabledContent:"Micrfono deshabilitado",tooltipOnContent:"Silenciar micrfono",tooltipOffContent:"Reactivar micrfono",microphoneMenuTitle:"Micrfono",microphoneMenuTooltip:"Elegir micrfono",speakerMenuTitle:"Altavoz",speakerMenuTooltip:"Elegir altavoz",microphoneButtonSplitRoleDescription:"Botn de expansin",onSplitButtonAriaLabel:"Silenciar opciones de micrfono y audio",offSplitButtonAriaLabel:"Reactivar el micrfono y las opciones de audio",microphoneActionTurnedOnAnnouncement:"El micrfono se ha activado",microphoneActionTurnedOffAnnouncement:"El micrfono se ha desactivado",offSplitButtonMicrophonePrimaryAction:"Reactivar micrfono",onSplitButtonMicrophonePrimaryAction:"Silenciar micrfono",microphonePrimaryActionSplitButtonTitle:"Usar micrfono"};var devicesButton$f={label:"Dispositivos",tooltipContent:"Administrar dispositivos",cameraMenuTitle:"Cmara",cameraMenuTooltip:"Elegir cmara",audioDeviceMenuTitle:"Dispositivo de audio",audioDeviceMenuTooltip:"Elegir dispositivo de audio",microphoneMenuTitle:"Micrfono",microphoneMenuTooltip:"Elegir micrfono",speakerMenuTitle:"Altavoz",speakerMenuTooltip:"Elegir altavoz"};var participantsButton$f={label:"Contactos",tooltipContent:"Mostrar participantes",menuHeader:"En esta llamada",participantsListButtonLabel:"{numParticipants} personas",muteAllButtonLabel:"Silenciar a todos",copyInviteLinkButtonLabel:"Copiar vnculo de invitacin",copyInviteLinkActionedAriaLabel:"Vnculo de invitacin copiado"};var screenShareButton$f={onLabel:"Dejar de presentar",offLabel:"Presentar",tooltipDisabledContent:"La presentacin est deshabilitada",tooltipOnContent:"Presentando su pantalla",tooltipOffContent:"Presentar la pantalla"};var raiseHandButton$f={offLabel:"Participar",onLabel:"Bajar",tooltipDisabledContent:"La accin Levantar la mano est deshabilitada",tooltipOnContent:"Bajar la mano",tooltipOffContent:"Levantar la mano"};var reactionButton$f={label:"Reaccionar",ariaLabel:"Botn Reaccionar, Enviar una reaccin",tooltipDisabledContent:"La accin de reaccin est deshabilitada",tooltipContent:"Enviar una reaccin",likeReactionTooltipContent:"Me gusta",heartReactionTooltipContent:"Amor",laughReactionTooltipContent:"Risa",applauseReactionTooltipContent:"Aplauso",surprisedReactionTooltipContent:"Sorprendido"};var messageThread$f={yesterday:"Ayer",sunday:"Domingo",monday:"Lunes",tuesday:"Martes",wednesday:"Mircoles",thursday:"Jueves",friday:"Viernes",saturday:"Sbado",participantJoined:"se uni al chat.",participantLeft:"abandon el chat.",editMessage:"Editar",removeMessage:"Eliminar",resendMessage:"Intente enviar de nuevo",failToSendTag:"Error al enviar",editedTag:"Editado",liveAuthorIntro:"{author} dice",messageContentAriaText:"{author} dijo {message}",messageContentMineAriaText:"Has dicho {message}",editBoxTextLimit:"El mensaje supera el lmite de {limitNumber} caracteres",editBoxPlaceholderText:"Editar el mensaje",newMessagesIndicator:"Mensajes nuevos",noDisplayNameSub:"Sin nombre",editBoxCancelButton:"Cancelar",editBoxSubmitButton:"Listo",messageReadCount:"Ledo por {messageReadByCount} de {remoteParticipantsCount}",actionMenuMoreOptions:"Ms opciones",downloadFile:"Descargar archivo",blockedWarningText:"Este mensaje se elimin debido a la directiva de la organizacin.",blockedWarningLinkText:"Detalles",fileCardGroupMessage:"El mensaje tiene {fileCount} datos adjuntos",messageDeletedAnnouncementAriaLabel:"El mensaje se ha eliminado"};var errorBar$f={unableToReachChatService:"Sin conexin",accessDenied:"No se puede acceder a los servicios de chat. Compruebe las credenciales de usuario proporcionadas.",userNotInChatThread:"Ya no est en este hilo de chat",sendMessageNotInChatThread:"No se pudo enviar el mensaje porque ya no est en este hilo de chat",sendMessageGeneric:"Error al enviar el mensaje",callingNetworkFailure:"Problema al conectar la llamada; parece que no hay conexin",startVideoGeneric:"No se pudo iniciar el vdeo",stopVideoGeneric:"No se pudo detener el vdeo",muteGeneric:"No se pudo silenciar el micrfono",unmuteGeneric:"No se pudo reactivar el micrfono",speakingWhileMuted:"El micrfono est desactivado",startScreenShareGeneric:"Hubo un problema al iniciar la pantalla compartida.",stopScreenShareGeneric:"No se pudo detener la pantalla compartida",callNetworkQualityLow:"La calidad de la red es baja.",callNoSpeakerFound:"No se encontraron altavoces ni auriculares. Conecta un dispositivo de audio para escuchar la llamada.",callNoMicrophoneFound:"No se encontraron micrfonos. Conecta un dispositivo de entrada de audio.",callMicrophoneAccessDenied:"No se puede acceder al micrfono. Haga clic en el bloqueo de la barra de direcciones para conceder permiso a esta pgina web.",callMicrophoneAccessDeniedSafari:"No se puede acceder al micrfono. Actualice la pgina para permitir permisos o compruebe la configuracin de este explorador y compruebe que los permisos estn habilitados para este sitio web.",callMicrophoneMutedBySystem:"Su sistema ha silenciado su audio.",callMicrophoneUnmutedBySystem:"Su micrfono se ha recuperado y el sistema ha activado el audio.",callMacOsMicrophoneAccessDenied:"No se puede acceder al micrfono. Conceda permiso al micrfono en la configuracin de privacidad de macOS.",callLocalVideoFreeze:"El ancho de banda de red es deficiente. Es posible que el vdeo aparezca pausado para otros usuarios en la llamada.",callCameraAccessDenied:"No se puede acceder a la cmara. Haga clic en el bloqueo de la barra de direcciones para conceder permiso a esta pgina web.",callCameraAccessDeniedSafari:"No se puede acceder a la cmara. Actualice la pgina para permitir permisos o compruebe la configuracin de este explorador y compruebe que los permisos estn habilitados para este sitio web.",callCameraAlreadyInUse:"No se puede acceder a la cmara. Puede que ya la est usando otra aplicacin.",callVideoStoppedBySystem:"El sistema ha detenido el vdeo.",callVideoRecoveredBySystem:"El vdeo se ha reanudado.",callMacOsCameraAccessDenied:"MacOS est bloqueando el acceso a la cmara. Actualiza la configuracin de privacidad para permitir que este explorador acceda a la cmara.",callMacOsScreenShareAccessDenied:"MacOS est bloqueando el uso compartido de la pantalla. Actualice la configuracin de privacidad para permitir que este explorador grabe la pantalla.",dismissButtonAriaLabel:"Cerrar",failedToJoinCallGeneric:"No se pudo unir a la llamada.",failedToJoinCallInvalidMeetingLink:"No se puede unir a la reunin. Vnculo no vlido.",cameraFrozenForRemoteParticipants:"Los usuarios de la llamada tienen problemas para ver el vdeo. Compruebe los dispositivos y la red.",unableToStartVideoEffect:"No se puede aplicar el efecto de vdeo.",startSpotlightWhileMaxParticipantsAreSpotlighted:"No se puede iniciar el primer plano en los participantes porque el nmero mximo de participantes ya est puesto en primer plano."};var videoGallery$f={screenIsBeingSharedMessage:"Est compartiendo su pantalla",screenShareLoadingMessage:"Cargando la pantalla de {participant}",localVideoLabel:"T",localVideoCameraSwitcherLabel:"Cambiar de cmara",localVideoMovementLabel:"Mosaico de vdeo local movible",localVideoSelectedDescription:"{cameraName} seleccionada",displayNamePlaceholder:"Participante sin nombre",fitRemoteParticipantToFrame:"Ajustar al marco",fillRemoteParticipantFrame:"Marco de relleno",pinParticipantForMe:"Anclar para m",pinParticipantForMeLimitReached:"Pin (lmite alcanzado)",unpinParticipantForMe:"Desanclar",pinParticipantMenuItemAriaLabel:"Anclar {participantName}",unpinParticipantMenuItemAriaLabel:"Desanclar {participantName}",pinnedParticipantAnnouncementAriaLabel:"{participantName} anclado",unpinnedParticipantAnnouncementAriaLabel:"{participantName} desanclado",startSpotlightVideoTileMenuLabel:"Poner en primer plano para todos",addSpotlightVideoTileMenuLabel:"Agregar primer plano",spotlightLimitReachedMenuTitle:"Se alcanz el lmite de primer plano",stopSpotlightVideoTileMenuLabel:"Dejar de poner en primer plano",stopSpotlightOnSelfVideoTileMenuLabel:"Primer plano",attendeeRole:"Asistente"};var dialpad$f={placeholderText:"Introduzca el nmero de telfono",deleteButtonAriaLabel:"Eliminar"};var holdButton$f={onLabel:"Reanudar",offLabel:"En espera",tooltipOnContent:"Reanudar llamada",tooltipOffContent:"Poner llamada en espera"};var videoTile$f={participantStateRinging:"Llamando...",participantStateHold:"En espera"};var CameraAndMicrophoneSitePermissionsRequest$f={primaryText:"Permitir que {appName} usen la cmara y el micrfono",secondaryText:"Esto es para que los participantes puedan verle y orle.",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas",primaryButtonText:"Continuar sin cmara ni micrfono",ariaLabel:"Permitir el acceso a la cmara y al micrfono"};var CameraSitePermissionsRequest$f={primaryText:"Permitir que {appName} use la cmara",secondaryText:"Esto sirve para que los participantes puedan verle.",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas",primaryButtonText:"Continuar sin cmara",ariaLabel:"Permitir el acceso a la cmara"};var MicrophoneSitePermissionsRequest$f={primaryText:"Permitir que {appName} use el micrfono",secondaryText:"Esto sirve para que los participantes puedan orle.",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas",primaryButtonText:"Continuar sin micrfono",ariaLabel:"Permitir el acceso al micrfono"};var CameraAndMicrophoneSitePermissionsCheck$f={primaryText:"Comprobando el acceso a la cmara y al micrfono",secondaryText:"Permitir el acceso si se le solicita. Esto es para que los participantes puedan verle y orle.",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas",primaryButtonText:"Continuar sin cmara ni micrfono",ariaLabel:"Comprobando el acceso a la cmara y al micrfono. Permitir el acceso si se le solicita."};var CameraSitePermissionsCheck$f={primaryText:"Comprobando el acceso a la cmara",secondaryText:"Permitir el acceso si se le solicita. Esto es para que los participantes puedan verlo.",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas",primaryButtonText:"Continuar sin cmara",ariaLabel:"Comprobando el acceso a la cmara. Permitir el acceso si se le solicita."};var MicrophoneSitePermissionsCheck$f={primaryText:"Comprobando el acceso al micrfono",secondaryText:"Permitir el acceso si se le solicita. Esto es para que los participantes puedan orle.",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas",primaryButtonText:"Continuar sin micrfono",ariaLabel:"Comprobando el acceso al micrfono. Permitir el acceso si se le solicita."};var CameraAndMicrophoneSitePermissionsDenied$f={primaryText:"No se puede permitir el acceso a la cmara ni al micrfono.",secondaryText:"Haga clic en el icono de bloqueo de la barra de direcciones para conceder permisos de micrfono a esta pgina web. Es posible que sea necesario actualizar la pgina.",primaryButtonText:"Continuar sin cmara ni micrfono",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas"};var CameraAndMicrophoneSitePermissionsDeniedSafari$f={primaryText:"No se puede permitir el acceso a la cmara ni al micrfono.",secondaryText:"Actualice la pgina para permitir permisos o compruebe la configuracin de este explorador y compruebe que los permisos estn habilitados para este sitio web.",primaryButtonText:"Continuar sin cmara ni micrfono",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas"};var CameraSitePermissionsDenied$f={primaryText:"No se puede acceder a la cmara",secondaryText:"Haga clic en el icono de bloqueo de la barra de direcciones para conceder permisos de cmara a esta pgina web. Es posible que sea necesario actualizar la pgina.",primaryButtonText:"Continuar sin cmara",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas"};var MicrophoneSitePermissionsDenied$f={primaryText:"No se puede acceder al micrfono.",secondaryText:"Haga clic en el icono de bloqueo de la barra de direcciones para conceder permisos de micrfono a esta pgina web. Es posible que sea necesario actualizar la pgina.",primaryButtonText:"Continuar sin micrfono",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas"};var CameraSitePermissionsDeniedSafari$f={primaryText:"No se puede acceder a la cmara.",secondaryText:"Actualice la pgina para permitir permisos o compruebe la configuracin de este explorador y compruebe que los permisos estn habilitados para este sitio web.",primaryButtonText:"Continuar sin cmara",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas"};var MicrophoneSitePermissionsDeniedSafari$f={primaryText:"No se puede acceder al micrfono",secondaryText:"Actualice la pgina para permitir permisos o compruebe la configuracin de este explorador y compruebe que los permisos estn habilitados para este sitio web.",primaryButtonText:"Continuar sin micrfono",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas"};var UnsupportedBrowser$f={primaryText:"Explorador no compatible",secondaryText:"nase a esta llamada con un explorador compatible.",moreHelpLinkText:"Ver los requisitos de compatibilidad"};var UnsupportedBrowserVersion$f={primaryText:"Es necesario actualizar el explorador",secondaryText:"Para garantizar la mejor llamada posible, actualice el explorador e intente unirse de nuevo a la llamada.",moreHelpLinkText:"Ver los requisitos de compatibilidad",continueAnywayButtonText:"Iniciar llamada sin actualizar"};var UnsupportedOperatingSystem$f={primaryText:"Sistema operativo no compatible",secondaryText:"nase a esta llamada con un dispositivo con un sistema operativo compatible.",moreHelpLinkText:"Ver los requisitos de compatibilidad"};var BrowserPermissionDenied$f={primaryText:"No se puede usar la cmara o el micrfono",secondaryText:"Es posible que el explorador no tenga acceso a la cmara o al micrfono. Para solucionar este problema, abra Preferencias del sistema.",primaryButtonText:"Intentar de nuevo",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas"};var BrowserPermissionDeniedIOS$f={primaryText:"Permite el acceso al micrfono para continuar",secondaryText:"Para que otros participantes puedan orte.",primaryButtonText:"Intentar de nuevo",imageAltText:"Ubicacin de permisos del dispositivo de micrfono y cmara para iOS",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas",step1Text:"Ve a la aplicacin de Configuracin",step2Text:"Desplzate hacia abajo hasta la configuracin de este explorador",step3Text:"Activar micrfono (cmara opcional)",step4Text:"Intenta unirte de nuevo a la llamada",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$f={leftNavButtonAriaLabel:"pgina anterior",rightNavButtonAriaLabel:"pgina siguiente"};var es_ES$1 = {participantItem:participantItem$f,ParticipantList:ParticipantList$f,typingIndicator:typingIndicator$f,sendBox:sendBox$f,richTextSendBox:richTextSendBox$f,mentionPopover:mentionPopover$f,imageOverlay:imageOverlay$f,messageStatusIndicator:messageStatusIndicator$f,endCallButton:endCallButton$f,cameraButton:cameraButton$f,microphoneButton:microphoneButton$f,devicesButton:devicesButton$f,participantsButton:participantsButton$f,screenShareButton:screenShareButton$f,raiseHandButton:raiseHandButton$f,reactionButton:reactionButton$f,messageThread:messageThread$f,errorBar:errorBar$f,videoGallery:videoGallery$f,dialpad:dialpad$f,holdButton:holdButton$f,videoTile:videoTile$f,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$f,CameraSitePermissionsRequest:CameraSitePermissionsRequest$f,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$f,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$f,CameraSitePermissionsCheck:CameraSitePermissionsCheck$f,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$f,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$f,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$f,CameraSitePermissionsDenied:CameraSitePermissionsDenied$f,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$f,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$f,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$f,UnsupportedBrowser:UnsupportedBrowser$f,UnsupportedBrowserVersion:UnsupportedBrowserVersion$f,UnsupportedOperatingSystem:UnsupportedOperatingSystem$f,BrowserPermissionDenied:BrowserPermissionDenied$f,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$f,verticalGallery:verticalGallery$f};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Spanish (Spain).
 *
 * @public
 */
const COMPONENT_LOCALE_ES_ES = {
    strings: createComponentStrings(es_ES$1)
};

var participantItem$e={isMeText:"(sin)",menuTitle:"Lis vaihtoehtoja",removeButtonLabel:"Poista",sharingIconLabel:"Jakaminen",mutedIconLabel:"Mykistetty",displayNamePlaceholder:"Nimetn osallistuja",participantStateRinging:"Soitetaan...",participantStateHold:"Pidossa",attendeeRole:"Osallistuja"};var ParticipantList$e={overflowParticipantCount:"+{overflowCount} lis"};var typingIndicator$e={singleUser:"{user} kyttj kirjoittaa parhaillaan...",multipleUsers:"{users} kyttj kirjoittaa parhaillaan...",multipleUsersAbbreviateOne:"{users} ja yksi muu kyttj kirjoittaa parhaillaan...",multipleUsersAbbreviateMany:"{users} ja {numOthers} muuta kyttj kirjoittaa parhaillaan...",delimiter:", "};var sendBox$e={placeholderText:"Kirjoita viesti",textTooLong:"Viestin pituus ylitt enimmispituuden.",sendButtonAriaLabel:"Lhet viesti",fileUploadsPendingError:"Ladataan palvelimeen... Odota hetki.",removeFile:"Poista tiedosto",uploading:"Ladataan palvelimeen",uploadCompleted:"Ladattu palvelimeen"};var richTextSendBox$e={placeholderText:"Kirjoita viesti",textTooLong:"Viestin pituus ylitt enimmispituuden.",sendButtonAriaLabel:"Lhet viesti",fileUploadsPendingError:"Ladataan... Odota.",removeFile:"Poista tiedosto",uploading:"Ladataan",uploadCompleted:"Lataus valmis",boldTooltip:"Lihavoi",italicTooltip:"Kursivointi",underlineTooltip:"Alleviivaa",bulletListTooltip:"Luettelomerkeill varustettu luettelo",numberListTooltip:"Numeroitu luettelo",increaseIndentTooltip:"Suurenna sisennyst",decreaseIndentTooltip:"Pienenn sisennyst",richTextFormatButtonTooltip:"Muoto"};var mentionPopover$e={mentionPopoverHeader:"Ehdotuksia"};var imageOverlay$e={downloadButtonLabel:"Lataa",dismissButtonAriaLabel:"Sulje"};var messageStatusIndicator$e={deliveredAriaLabel:"Viesti on lhetetty",deliveredTooltipText:"Lhetetty",seenAriaLabel:"Muut ovat nhneet viestin",seenTooltipText:"Nhty",readByTooltipText:"{messageThreadReadCount}/{remoteParticipantsCount} osallistujaa on lukenut viestin",sendingAriaLabel:"Viesti lhetetn",sendingTooltipText:"Lhetetn",failedToSendAriaLabel:"Viestin lhettminen eponnistui",failedToSendTooltipText:"Lhettminen eponnistui"};var endCallButton$e={label:"Poistu",tooltipContent:"Poistu puhelusta"};var cameraButton$e={onLabel:"Kamera",offLabel:"Kamera",tooltipDisabledContent:"Kamera on poissa kytst",tooltipOnContent:"Poista kamera kytst",tooltipOffContent:"Kynnist kamera",tooltipVideoLoadingContent:"Videota ladataan",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Valitse kamera",cameraButtonSplitRoleDescription:"Jaettu painike",onSplitButtonAriaLabel:"Kameran ja sen kytst poistamisen asetukset",offSplitButtonAriaLabel:"Kameran ja sen kyttn ottamisen asetukset",cameraActionTurnedOnAnnouncement:"Kamerasi on otettu kyttn",cameraActionTurnedOffAnnouncement:"Kamerasi on poistettu kytst",onSplitButtonPrimaryActionCamera:"Poista kamera kytst",offSplitButtonPrimaryActionCamera:"Kynnist kamera",cameraPrimaryActionSplitButtonTitle:"Kyt kameraa",videoEffectsMenuItemTitle:"Tehosteet"};var microphoneButton$e={onLabel:"Mikrofoni",offLabel:"Mikrofoni",tooltipDisabledContent:"Mikrofoni on poissa kytst",tooltipOnContent:"Mykist mikrofoni",tooltipOffContent:"Poista mikrofonin mykistys",microphoneMenuTitle:"Mikrofoni",microphoneMenuTooltip:"Valitse mikrofoni",speakerMenuTitle:"Kaiutin",speakerMenuTooltip:"Valitse kaiutin",microphoneButtonSplitRoleDescription:"Jaettu painike",onSplitButtonAriaLabel:"nen ja mikrofonin mykistyksen asetukset",offSplitButtonAriaLabel:"nen ja mikrofonin mykistyksen poistamisen asetukset",microphoneActionTurnedOnAnnouncement:"Mikrofonisi on otettu kyttn",microphoneActionTurnedOffAnnouncement:"Mikrofonisi on poistettu kytst",offSplitButtonMicrophonePrimaryAction:"Poista mikrofonin mykistys",onSplitButtonMicrophonePrimaryAction:"Mykist mikrofoni",microphonePrimaryActionSplitButtonTitle:"Kyt mikrofonia"};var devicesButton$e={label:"Laitteet",tooltipContent:"Hallitse laitteita",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Valitse kamera",audioDeviceMenuTitle:"nilaite",audioDeviceMenuTooltip:"Valitse nilaite",microphoneMenuTitle:"Mikrofoni",microphoneMenuTooltip:"Valitse mikrofoni",speakerMenuTitle:"Kaiutin",speakerMenuTooltip:"Valitse kaiutin"};var participantsButton$e={label:"Ihmiset",tooltipContent:"Nyt osallistujat",menuHeader:"Tss puhelussa",participantsListButtonLabel:"{numParticipants} henkil",muteAllButtonLabel:"Mykist kaikki",copyInviteLinkButtonLabel:"Kopioi kutsulinkki",copyInviteLinkActionedAriaLabel:"Kutsulinkki kopioitu"};var screenShareButton$e={onLabel:"Lopeta esitys",offLabel:"Esit",tooltipDisabledContent:"Nytn jakaminen on poissa kytst",tooltipOnContent:"Nyttsi nytetn muille osallistujille",tooltipOffContent:"Nyt oma nyttsi"};var raiseHandButton$e={offLabel:"Nosta",onLabel:"Laske",tooltipDisabledContent:"Nosta ksi -toiminto on poistettu kytst",tooltipOnContent:"Laske ksi",tooltipOffContent:"Nosta ksi"};var reactionButton$e={label:"Reagoi",ariaLabel:"Reagoi-painike, lhet reaktio",tooltipDisabledContent:"Reaktiotoiminto on poistettu kytst",tooltipContent:"Lhet reaktio",likeReactionTooltipContent:"Tykk",heartReactionTooltipContent:"Ihastu",laughReactionTooltipContent:"Naura",applauseReactionTooltipContent:"Suosionosoitus",surprisedReactionTooltipContent:"Yllttynyt"};var messageThread$e={yesterday:"eilen",sunday:"sunnuntaina",monday:"maanantaina",tuesday:"tiistaina",wednesday:"keskiviikkona",thursday:"torstaina",friday:"perjantaina",saturday:"lauantaina",participantJoined:"liittyi keskusteluun.",participantLeft:"poistui keskustelusta.",editMessage:"Muokkaa",removeMessage:"Poista",resendMessage:"Yrit lhett viesti uudelleen",failToSendTag:"Lhettminen eponnistui",editedTag:"Muokattu",liveAuthorIntro:"{author} sanoo",messageContentAriaText:"{author} sanoi {message}",messageContentMineAriaText:"Sanoit {message}",editBoxTextLimit:"Viesti ylitt {limitNumber} merkin rajan",editBoxPlaceholderText:"Muokkaa viestisi",newMessagesIndicator:"Uudet viestit",noDisplayNameSub:"Ei nime",editBoxCancelButton:"Peruuta",editBoxSubmitButton:"Valmis",messageReadCount:"{messageReadByCount}/{remoteParticipantsCount} osallistujaa on lukenut viestin",actionMenuMoreOptions:"Lis vaihtoehtoja",downloadFile:"Lataa tiedosto",blockedWarningText:"Tm viesti poistettiin organisaation kytnnn vuoksi.",blockedWarningLinkText:"Listiedot",fileCardGroupMessage:"Viestiss on {fileCount} liite",messageDeletedAnnouncementAriaLabel:"Viesti on poistettu"};var errorBar$e={unableToReachChatService:"Olet offline-tilassa",accessDenied:"Keskustelupalveluihin ei saada yhteytt  tarkista annetut kyttjn tunnistetiedot",userNotInChatThread:"Et ole en mukana tss keskusteluketjussa",sendMessageNotInChatThread:"Viestin lhettminen eponnistui, koska et ole en tss keskusteluketjussa",sendMessageGeneric:"Viestin lhettminen eponnistui",callingNetworkFailure:"Puhelun yhdistmisess on ongelma. Vaikutat olevan offline-tilassa",startVideoGeneric:"Videon kynnistminen eponnistui",stopVideoGeneric:"Videon pysyttminen eponnistui",muteGeneric:"Mikrofonin mykistminen eponnistui",unmuteGeneric:"Mikrofonin mykistyksen poistaminen eponnistui",speakingWhileMuted:"Mikrofonisi on mykistetty",startScreenShareGeneric:"Nytn jakamisen aloittamisessa ilmeni ongelma.",stopScreenShareGeneric:"Nytn jakamisen lopettaminen eponnistui",callNetworkQualityLow:"Verkkoyhteyden laatu on huono.",callNoSpeakerFound:"Kaiuttimia tai kuulokkeita ei lytynyt. Yhdist nilaite voidaksesi kuulla puhelun.",callNoMicrophoneFound:"Mikrofoneja ei lytynyt. Yhdist nitulolaite.",callMicrophoneAccessDenied:"Mikrofonia ei voi kytt. Mynn kyttoikeus tlle verkkosivulle napsauttamalla osoiterivin lukitusta.",callMicrophoneAccessDeniedSafari:"Mikrofonia ei voi kytt. Salli kyttoikeudet pivittmll sivu tai tarkista tmn selaimen asetukset ja varmista, ett kyttoikeudet on otettu kyttn tss sivustossa.",callMicrophoneMutedBySystem:"Jrjestelmasetuksen perusteella sinut on mykistetty.",callMicrophoneUnmutedBySystem:"Mikrofonisi palautui kyttn ja jrjestelm on poistanut sen mykistyksen.",callMacOsMicrophoneAccessDenied:"Mikrofonia ei voi kytt. Salli mikrofonin kytt macOS:in tietosuoja-asetuksissa.",callLocalVideoFreeze:"Verkon kaistanleveys on heikko. Videokuvasi saattaa nky keskeytettyn puhelun muille osallistujille.",callCameraAccessDenied:"Kameraa ei voi kytt. Mynn kyttoikeus tlle verkkosivulle napsauttamalla osoiterivin lukitusta.",callCameraAccessDeniedSafari:"Kameraa ei voi kytt. Salli kyttoikeudet pivittmll sivu tai tarkista tmn selaimen asetukset ja varmista, ett kyttoikeudet on otettu kyttn tss sivustossa.",callCameraAlreadyInUse:"Kameraa ei voi kytt. Toinen sovellus saattaa jo kytt sit.",callVideoStoppedBySystem:"Jrjestelm on pysyttnyt videosi.",callVideoRecoveredBySystem:"Videosi nytetn jlleen.",callMacOsCameraAccessDenied:"MacOS est kameran kytn. Pivit tietosuoja-asetukset, jotta selain voi kytt kameraasi.",callMacOsScreenShareAccessDenied:"MacOS est nytn jakamisen. Pivit tietosuoja-asetukset, jotta selain voi tallentaa, mit nytllsi tapahtuu.",dismissButtonAriaLabel:"Sulje",failedToJoinCallGeneric:"Puheluun liittyminen eponnistui.",failedToJoinCallInvalidMeetingLink:"Kokoukseen liittyminen ei onnistu. Linkki on virheellinen.",cameraFrozenForRemoteParticipants:"Puhelun kyttjill on videokuvan nkymiseen liittyvi ongelmia. Tarkista laitteesi ja verkkosi.",unableToStartVideoEffect:"Videotehosteen kyttminen ei onnistu.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Osallistujien korostusta ei voi aloittaa, koska enimmismr osallistujia on jo valokeilassa."};var videoGallery$e={screenIsBeingSharedMessage:"Nyttsi jaetaan parhaillaan",screenShareLoadingMessage:"Ladataan kyttjn {participant} nytt",localVideoLabel:"Sin",localVideoCameraSwitcherLabel:"Vaihda kameraa",localVideoMovementLabel:"Siirrettv paikallisen videon ruutu",localVideoSelectedDescription:"{cameraName} on valittu",displayNamePlaceholder:"Nimetn osallistuja",fitRemoteParticipantToFrame:"Sovita kehykseen",fillRemoteParticipantFrame:"Tyt kehys",pinParticipantForMe:"Kiinnit minulle",pinParticipantForMeLimitReached:"Kiinnitys (enimmisraja saavutettu)",unpinParticipantForMe:"Poista kiinnitys",pinParticipantMenuItemAriaLabel:"Kiinnit {participantName}",unpinParticipantMenuItemAriaLabel:"Poista henkiln {participantName} kiinnitys",pinnedParticipantAnnouncementAriaLabel:"Kiinnitetty {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Poistettu henkiln {participantName} kiinnitys",startSpotlightVideoTileMenuLabel:"Lis valokeilaan kaikille",addSpotlightVideoTileMenuLabel:"Lis valokeilaan",spotlightLimitReachedMenuTitle:"Spotlight-raja saavutettu",stopSpotlightVideoTileMenuLabel:"Poista valokeilasta",stopSpotlightOnSelfVideoTileMenuLabel:"Valokeila",attendeeRole:"Osallistuja"};var dialpad$e={placeholderText:"Anna puhelinnumero",deleteButtonAriaLabel:"Poista"};var holdButton$e={onLabel:"Jatka",offLabel:"Pito",tooltipOnContent:"Jatka puhelua",tooltipOffContent:"Aseta puhelu pitoon"};var videoTile$e={participantStateRinging:"Soitetaan...",participantStateHold:"Pidossa"};var CameraAndMicrophoneSitePermissionsRequest$e={primaryText:"Salli {appName} kytt kameraa ja mikrofonia",secondaryText:"Nin osallistujat voivat nhd ja kuulla sinua.",linkText:"Tarvitsetko apua? Hae vianmritysohjeita",primaryButtonText:"Jatka ilman kameraa ja mikrofonia",ariaLabel:"Salli kameran ja mikrofonin kytt"};var CameraSitePermissionsRequest$e={primaryText:"Salli sovelluksen {appName} kytt kameraasi",secondaryText:"Tt tarvitaan, jotta muut osallistujat nkevt sinut.",linkText:"Tarvitsetko apua? Hae vianmritysohjeita",primaryButtonText:"Jatka ilman kameraa",ariaLabel:"Salli kameran kytt"};var MicrophoneSitePermissionsRequest$e={primaryText:"Salli sovelluksen {appName} kytt mikrofoniasi",secondaryText:"Tt tarvitaan, jotta muut osallistujat kuulevat sinut.",linkText:"Tarvitsetko apua? Hae vianmritysohjeita",primaryButtonText:"Jatka ilman mikrofonia",ariaLabel:"Salli mikrofonin kytt"};var CameraAndMicrophoneSitePermissionsCheck$e={primaryText:"Tarkistetaan kameran ja mikrofonin kyttoikeutta",secondaryText:"Salli kytt, jos niin kehotetaan tekemn. Nin osallistujat voivat nhd ja kuulla sinua.",linkText:"Tarvitsetko apua? Hae vianmritysohjeita",primaryButtonText:"Jatka ilman kameraa ja mikrofonia",ariaLabel:"Tarkistetaan kameran ja mikrofonin kyttoikeutta. Salli kytt pyydettess."};var CameraSitePermissionsCheck$e={primaryText:"Tarkistetaan kameran kyttoikeutta",secondaryText:"Salli kytt, jos niin kehotetaan tekemn. Osallistujat nkevt sinut tss.",linkText:"Tarvitsetko apua? Hae vianmritysohjeita",primaryButtonText:"Jatka ilman kameraa",ariaLabel:"Tarkistetaan kameran kyttoikeutta. Salli kytt pyydettess."};var MicrophoneSitePermissionsCheck$e={primaryText:"Tarkistetaan mikrofonin kyttoikeutta",secondaryText:"Salli kytt pyydettess. Tt tarvitaan, jotta muut osallistujat kuulevat sinut.",linkText:"Tarvitsetko apua? Hae vianmritysohjeita",primaryButtonText:"Jatka ilman mikrofonia",ariaLabel:"Tarkistetaan mikrofonin kyttoikeutta. Salli kytt pyydettess."};var CameraAndMicrophoneSitePermissionsDenied$e={primaryText:"Kameraa ja mikrofonia ei voi kytt",secondaryText:"Mynn mikrofonin kyttoikeudet tlle verkkosivulle napsauttamalla osoiterivin lukkokuvaketta. Sivun pivitys saattaa olla pakollinen.",primaryButtonText:"Jatka ilman kameraa ja mikrofonia",linkText:"Tarvitsetko apua? Hae vianmritysohjeita"};var CameraAndMicrophoneSitePermissionsDeniedSafari$e={primaryText:"Kameraa ja mikrofonia ei voi kytt",secondaryText:"Salli kyttoikeudet pivittmll sivu tai tarkista tmn selaimen asetukset ja varmista, ett kyttoikeudet on otettu kyttn tss sivustossa.",primaryButtonText:"Jatka ilman kameraa ja mikrofonia",linkText:"Tarvitsetko apua? Hae vianmritysohjeita"};var CameraSitePermissionsDenied$e={primaryText:"Kameraa ei voi kytt",secondaryText:"Mynn kameran kyttoikeudet tlle verkkosivulle napsauttamalla osoiterivin lukkokuvaketta. Sivun pivitys saattaa olla pakollinen.",primaryButtonText:"Jatka ilman kameraa",linkText:"Tarvitsetko apua? Hae vianmritysohjeita"};var MicrophoneSitePermissionsDenied$e={primaryText:"Mikrofonia ei voi kytt",secondaryText:"Mynn mikrofonin kyttoikeudet tlle verkkosivulle napsauttamalla osoiterivin lukkokuvaketta. Sivun pivitys saattaa olla pakollinen.",primaryButtonText:"Jatka ilman mikrofonia",linkText:"Tarvitsetko apua? Hae vianmritysohjeita"};var CameraSitePermissionsDeniedSafari$e={primaryText:"Kameraa ei voi kytt",secondaryText:"Salli kyttoikeudet pivittmll sivu tai tarkista tmn selaimen asetukset ja varmista, ett kyttoikeudet on otettu kyttn tss sivustossa.",primaryButtonText:"Jatka ilman kameraa",linkText:"Tarvitsetko apua? Hae vianmritysohjeita"};var MicrophoneSitePermissionsDeniedSafari$e={primaryText:"Mikrofonia ei voi kytt",secondaryText:"Salli kyttoikeudet pivittmll sivu tai tarkista tmn selaimen asetukset ja varmista, ett kyttoikeudet on otettu kyttn tss sivustossa.",primaryButtonText:"Jatka ilman mikrofonia",linkText:"Tarvitsetko apua? Hae vianmritysohjeita"};var UnsupportedBrowser$e={primaryText:"Selainta ei tueta",secondaryText:"Liity thn puheluun kyttmll yhteensopivaa selainta.",moreHelpLinkText:"Nyt yhteensopivuusvaatimukset"};var UnsupportedBrowserVersion$e={primaryText:"Selain on pivitettv",secondaryText:"Jotta puhelu olisi paras mahdollinen, pivit selain ja yrit liitty puheluun uudelleen.",moreHelpLinkText:"Nyt yhteensopivuusvaatimukset",continueAnywayButtonText:"Aloita puhelu pivittmtt"};var UnsupportedOperatingSystem$e={primaryText:"Kyttjrjestelm ei tueta",secondaryText:"Liity thn puheluun kyttmll laitetta, jossa on yhteensopiva kyttjrjestelm.",moreHelpLinkText:"Nyt yhteensopivuusvaatimukset"};var BrowserPermissionDenied$e={primaryText:"Kamerasi tai mikrofonisi kyttminen ei onnistu",secondaryText:"Selaimesi ei ehk voi kytt kameraasi tai mikrofoniasi. Voit korjata tmn avaamalla Jrjestelmasetukset.",primaryButtonText:"Yrit uudelleen",linkText:"Tarvitsetko apua? Hae vianmritysohjeita"};var BrowserPermissionDeniedIOS$e={primaryText:"Jatka sallimalla mikrofonin kytt",secondaryText:"Tarvitaan, jotta muut osallistujat kuulevat sinut.",primaryButtonText:"Yrit uudelleen",imageAltText:"Kohta, josta mikrofonin ja kameran kyttoikeus lytyy iOS:issa",linkText:"Tarvitsetko apua? Hae vianmritysohjeita",step1Text:"Siirry asetussovellukseen.",step2Text:"Vierit alaspin tmn selaimen asetuksiin",step3Text:"Ota mikrofoni kyttn (kameran kytt on valinnaista)",step4Text:"Yrit liitty puheluun uudelleen",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$e={leftNavButtonAriaLabel:"edellinen sivu",rightNavButtonAriaLabel:"seuraava sivu"};var fi_FI$1 = {participantItem:participantItem$e,ParticipantList:ParticipantList$e,typingIndicator:typingIndicator$e,sendBox:sendBox$e,richTextSendBox:richTextSendBox$e,mentionPopover:mentionPopover$e,imageOverlay:imageOverlay$e,messageStatusIndicator:messageStatusIndicator$e,endCallButton:endCallButton$e,cameraButton:cameraButton$e,microphoneButton:microphoneButton$e,devicesButton:devicesButton$e,participantsButton:participantsButton$e,screenShareButton:screenShareButton$e,raiseHandButton:raiseHandButton$e,reactionButton:reactionButton$e,messageThread:messageThread$e,errorBar:errorBar$e,videoGallery:videoGallery$e,dialpad:dialpad$e,holdButton:holdButton$e,videoTile:videoTile$e,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$e,CameraSitePermissionsRequest:CameraSitePermissionsRequest$e,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$e,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$e,CameraSitePermissionsCheck:CameraSitePermissionsCheck$e,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$e,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$e,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$e,CameraSitePermissionsDenied:CameraSitePermissionsDenied$e,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$e,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$e,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$e,UnsupportedBrowser:UnsupportedBrowser$e,UnsupportedBrowserVersion:UnsupportedBrowserVersion$e,UnsupportedOperatingSystem:UnsupportedOperatingSystem$e,BrowserPermissionDenied:BrowserPermissionDenied$e,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$e,verticalGallery:verticalGallery$e};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Finnish (Finland).
 *
 * @public
 */
const COMPONENT_LOCALE_FI_FI = {
    strings: createComponentStrings(fi_FI$1)
};

var participantItem$d={isMeText:"(vous)",menuTitle:"Plus doptions",removeButtonLabel:"Supprimer",sharingIconLabel:"Partage",mutedIconLabel:"Muet activ",displayNamePlaceholder:"Participant sans nom",participantStateRinging:"Appel en cours...",participantStateHold:"En attente",attendeeRole:"Participant"};var ParticipantList$d={overflowParticipantCount:"+{overflowCount} plus"};var typingIndicator$d={singleUser:"{user} en train dcrire...",multipleUsers:"{users} sont en train d'crire...",multipleUsersAbbreviateOne:"{users} et 1 autre en train d'crire...",multipleUsersAbbreviateMany:"{users} et {numOthers} autres en train dcrire...",delimiter:", "};var sendBox$d={placeholderText:"Saisir un message",textTooLong:"La longueur de votre message dpasse la limite maximale.",sendButtonAriaLabel:"Envoyer un message",fileUploadsPendingError:"Chargement en cours... Veuillez patienter.",removeFile:"Supprimer un fichier",uploading:"Chargement",uploadCompleted:"Tlchargement termin"};var richTextSendBox$d={placeholderText:"Saisir un message",textTooLong:"La longueur de votre message dpasse la limite maximale.",sendButtonAriaLabel:"Envoyer un message",fileUploadsPendingError:"Chargement en cours... Veuillez patienter.",removeFile:"Supprimer le fichier",uploading:"Tlchargement",uploadCompleted:"Chargement termin",boldTooltip:"Gras",italicTooltip:"Italique",underlineTooltip:"Souligner",bulletListTooltip:"Liste  puces",numberListTooltip:"Liste numrote",increaseIndentTooltip:"Augmenter le retrait",decreaseIndentTooltip:"Rduire le retrait",richTextFormatButtonTooltip:"Format"};var mentionPopover$d={mentionPopoverHeader:"Suggestions"};var imageOverlay$d={downloadButtonLabel:"Tlcharger",dismissButtonAriaLabel:"Fermer"};var messageStatusIndicator$d={deliveredAriaLabel:"Message envoy",deliveredTooltipText:"Envoy",seenAriaLabel:"Message vu par dautres personnes",seenTooltipText:"Vu",readByTooltipText:"Lu par {messageThreadReadCount} participants sur {remoteParticipantsCount}",sendingAriaLabel:"Envoi du message",sendingTooltipText:"Envoi",failedToSendAriaLabel:"chec d'envoi du message",failedToSendTooltipText:"chec de l'envoi"};var endCallButton$d={label:"Quitter",tooltipContent:"Quitter l'appel"};var cameraButton$d={onLabel:"Camra",offLabel:"Camra",tooltipDisabledContent:"La camra est dsactive.",tooltipOnContent:"Dsactiver la camra",tooltipOffContent:"Activer la camra",tooltipVideoLoadingContent:"Chargement de la vido",cameraMenuTitle:"Camra",cameraMenuTooltip:"Choisissez l'appareil photo",cameraButtonSplitRoleDescription:"Bouton partag",onSplitButtonAriaLabel:"Dsactiver les options dappareil photo et dappareil photo",offSplitButtonAriaLabel:"Activer les options dappareil photo et dappareil photo",cameraActionTurnedOnAnnouncement:"Votre camra a t active",cameraActionTurnedOffAnnouncement:"Votre camra a t dsactive",onSplitButtonPrimaryActionCamera:"Dsactiver lappareil photo",offSplitButtonPrimaryActionCamera:"Activer la camra",cameraPrimaryActionSplitButtonTitle:"Utiliser lappareil photo",videoEffectsMenuItemTitle:"Effets"};var microphoneButton$d={onLabel:"Microphone",offLabel:"Microphone",tooltipDisabledContent:"Le microphone est dsactiv.",tooltipOnContent:"Dsactiver le micro",tooltipOffContent:"Activer le micro",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choisissez le micro",speakerMenuTitle:"Haut-parleur",speakerMenuTooltip:"Choisissez le haut-parleur",microphoneButtonSplitRoleDescription:"Bouton partag",onSplitButtonAriaLabel:"Dsactiver le micro et les options audio",offSplitButtonAriaLabel:"Activer le son du microphone et des options audio",microphoneActionTurnedOnAnnouncement:"Votre micro a t activ",microphoneActionTurnedOffAnnouncement:"Votre micro a t dsactiv",offSplitButtonMicrophonePrimaryAction:"Activer le son du microphone",onSplitButtonMicrophonePrimaryAction:"Dsactiver le microphone",microphonePrimaryActionSplitButtonTitle:"Utiliser le microphone"};var devicesButton$d={label:"Appareils",tooltipContent:"Grer les appareils",cameraMenuTitle:"Appareil photo",cameraMenuTooltip:"Choisissez l'appareil photo",audioDeviceMenuTitle:"Priphrique audio",audioDeviceMenuTooltip:"Choisissez un priphrique audio",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choisissez le micro",speakerMenuTitle:"Haut-parleur",speakerMenuTooltip:"Choisissez le haut-parleur"};var participantsButton$d={label:"Personnes",tooltipContent:"Afficher les participants",menuHeader:"Pendant cet appel",participantsListButtonLabel:"{numParticipants} contacts",muteAllButtonLabel:"Dsactiver tous les micros",copyInviteLinkButtonLabel:"Copier le lien d'invitation",copyInviteLinkActionedAriaLabel:"Le lien dinvitation a t copi."};var screenShareButton$d={onLabel:"Arrter la prsentation",offLabel:"Prsenter",tooltipDisabledContent:"La prsentation est dsactive.",tooltipOnContent:"Prsentation de votre cran",tooltipOffContent:"Prsenter votre cran"};var raiseHandButton$d={offLabel:"Augmenter",onLabel:"Infrieur",tooltipDisabledContent:"L'action lever la main est dsactive",tooltipOnContent:"Baisser la main",tooltipOffContent:"Lever les mains"};var reactionButton$d={label:"Ragir",ariaLabel:"bouton React, envoyer une raction",tooltipDisabledContent:"Laction de raction est dsactive",tooltipContent:"Envoyer une raction",likeReactionTooltipContent:"Jaime",heartReactionTooltipContent:"Aimer",laughReactionTooltipContent:"Rire",applauseReactionTooltipContent:"Acclamation",surprisedReactionTooltipContent:"Surpris"};var messageThread$d={yesterday:"Hier",sunday:"Dimanche",monday:"Lundi",tuesday:"Mardi",wednesday:"Mercredi",thursday:"Jeudi",friday:"Vendredi",saturday:"Samedi",participantJoined:"a rejoint la conversation.",participantLeft:"a quitt le conversation.",editMessage:"Modifier",removeMessage:"Supprimer",resendMessage:"Ressayer l'envoi",failToSendTag:"chec de l'envoi",editedTag:"Modifi",liveAuthorIntro:"{author} dit",messageContentAriaText:"{author} a dit {message}",messageContentMineAriaText:"Vous avez dit {message}",editBoxTextLimit:"Votre message dpasse la limite de {limitNumber} caractres",editBoxPlaceholderText:"Modifier votre message",newMessagesIndicator:"Nouveaux messages",noDisplayNameSub:"Sans nom",editBoxCancelButton:"Annuler",editBoxSubmitButton:"Termin",messageReadCount:"Lu par {messageReadByCount} participants sur {remoteParticipantsCount}",actionMenuMoreOptions:"Plus doptions",downloadFile:"Tlcharger un fichier",blockedWarningText:"Ce message a t supprim en raison dune stratgie de lorganisation.",blockedWarningLinkText:"Dtails",fileCardGroupMessage:"Le message a {fileCount}pice jointe",messageDeletedAnnouncementAriaLabel:"Le message est supprim"};var errorBar$d={unableToReachChatService:"Vous tes hors connexion",accessDenied:"Impossible daccder aux services de conversation. Vrifiez les informations didentification de lutilisateur fournies",userNotInChatThread:"Vous nest plus dans ce thread de conversation",sendMessageNotInChatThread:"chec de lenvoi du message car vous ntes plus dans ce thread de conversation",sendMessageGeneric:"chec de lenvoi du message",callingNetworkFailure:"Perturbation de lappel de connexion : vous semblez tre hors connexion",startVideoGeneric:"chec du dmarrage de la vido",stopVideoGeneric:"chec de larrt de la vido",muteGeneric:"chec de la dsactivation du son du microphone",unmuteGeneric:"chec de lactivation du son du microphone",speakingWhileMuted:"Votre micro est dsactiv",startScreenShareGeneric:"Un problme est survenu durant le dmarrage du partage dcran.",stopScreenShareGeneric:"chec de larrt du partage dcran",callNetworkQualityLow:"La qualit de rseau est faible.",callNoSpeakerFound:"Aucun haut-parleur ou casque na t trouv. Connectez un priphrique audio pour entendre lappel.",callNoMicrophoneFound:"Aucun micro na t trouv. Connectez un priphrique dentre audio.",callMicrophoneAccessDenied:"Impossible daccder au microphone. Cliquez sur le verrou dans la barre dadresses pour accorder lautorisation  cette page Web.",callMicrophoneAccessDeniedSafari:"Impossible daccder au microphone. Actualisez la page pour autoriser les autorisations, ou vrifiez les paramtres de ce navigateur et vrifiez que les autorisations sont actives pour ce site web.",callMicrophoneMutedBySystem:"Votre micro est dsactiv par votre systme.",callMicrophoneUnmutedBySystem:"Votre micro a t rcupr et la son a t activ par votre systme.",callMacOsMicrophoneAccessDenied:"Impossible daccder au microphone. Accordez lautorisation de microphone dans vos paramtres de confidentialit macOS.",callLocalVideoFreeze:"La bande passante rseau est mdiocre. Votre vido peut apparatre suspendue pour les autres participants  lappel.",callCameraAccessDenied:"Impossible daccder  la camra. Cliquez sur le verrou dans la barre dadresses pour accorder lautorisation  cette page Web.",callCameraAccessDeniedSafari:"Impossible daccder  la camra. Actualisez la page pour autoriser les autorisations, ou vrifiez les paramtres de ce navigateur et vrifiez que les autorisations sont actives pour ce site web.",callCameraAlreadyInUse:"Impossible daccder  la camra. Il est peut-tre dj utilis par une autre application.",callVideoStoppedBySystem:"Votre vido a t arrte par votre systme.",callVideoRecoveredBySystem:"Votre vido a repris.",callMacOsCameraAccessDenied:"MacOS bloque laccs  votre camra. Mettez  jour vos paramtres de confidentialit pour autoriser ce navigateur  accder  votre camra.",callMacOsScreenShareAccessDenied:"MacOS bloque le partage dcran. Mettez  jour vos paramtres de confidentialit pour permettre  ce navigateur denregistrer votre cran.",dismissButtonAriaLabel:"Fermer",failedToJoinCallGeneric:"Nous navons pas pu rejoindre lappel.",failedToJoinCallInvalidMeetingLink:"Impossible de rejoindre la runion. Lien non valide.",cameraFrozenForRemoteParticipants:"Les utilisateurs de lappel rencontrent des problmes pour voir votre vido. Vrifiez vos appareils et votre rseau.",unableToStartVideoEffect:"Impossible dappliquer leffet vido.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Impossible de lancer la mise en lumire sur le(s) participant(s), car le nombre maximum de participants est dj mis en lumire."};var videoGallery$d={screenIsBeingSharedMessage:"Vous partagez votre cran.",screenShareLoadingMessage:"Chargement de lcran de {participant}",localVideoLabel:"Vous",localVideoCameraSwitcherLabel:"Changer de camra",localVideoMovementLabel:"Vignette de vido locale dplaable",localVideoSelectedDescription:"{cameraName} slectionne",displayNamePlaceholder:"Participant sans nom",fitRemoteParticipantToFrame:"Ajuster  l'image",fillRemoteParticipantFrame:"Remplir l'image",pinParticipantForMe:"pingler pour moi",pinParticipantForMeLimitReached:"pingler (limite atteinte)",unpinParticipantForMe:"Dtacher",pinParticipantMenuItemAriaLabel:"pingler {participantName}",unpinParticipantMenuItemAriaLabel:"Dtacher {participantName}",pinnedParticipantAnnouncementAriaLabel:"{participantName} a t pingl",unpinnedParticipantAnnouncementAriaLabel:"{participantName} a t dtach",startSpotlightVideoTileMenuLabel:"Mettre en vidence pour tout le monde",addSpotlightVideoTileMenuLabel:"Ajouter la mise en vidence",spotlightLimitReachedMenuTitle:"Limite Spotlight atteinte",stopSpotlightVideoTileMenuLabel:"Arrter la mise en vidence",stopSpotlightOnSelfVideoTileMenuLabel:"Quitter la mise en vidence",attendeeRole:"Participant(e)"};var dialpad$d={placeholderText:"Entrer un numro de tlphone",deleteButtonAriaLabel:"Supprimer"};var holdButton$d={onLabel:"Reprendre",offLabel:"Mettre en attente",tooltipOnContent:"Reprendre lappel",tooltipOffContent:"Mettre lappel en attente"};var videoTile$d={participantStateRinging:"Appel en cours...",participantStateHold:"En attente"};var CameraAndMicrophoneSitePermissionsRequest$d={primaryText:"Autoriser {appName}  utiliser votre camra et votre microphone",secondaryText:"Cela permet aux participants de vous voir et de vous entendre.",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes",primaryButtonText:"Continuer sans camra ni micro",ariaLabel:"Autoriser l'accs  la camra et au microphone"};var CameraSitePermissionsRequest$d={primaryText:"Autoriser {appName}  utiliser votre camra",secondaryText:"Cela permet aux participants de vous voir.",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes",primaryButtonText:"Continuer sans camra",ariaLabel:"Autoriser laccs  la camra"};var MicrophoneSitePermissionsRequest$d={primaryText:"Autoriser {appName}  utiliser votre micro",secondaryText:"Cela permet aux participants de vous couter.",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes",primaryButtonText:"Continuer sans microphone",ariaLabel:"Autoriser laccs au micro"};var CameraAndMicrophoneSitePermissionsCheck$d={primaryText:"Vrification de laccs  la camra et au microphone",secondaryText:"Autorisez laccs si vous y tes invit. Cela permet aux participants de vous voir et de vous entendre.",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes",primaryButtonText:"Continuer sans camra ni micro",ariaLabel:"Vrification de laccs  la camra et au microphone. Autorisez laccs si vous y tes invit."};var CameraSitePermissionsCheck$d={primaryText:"Vrification de laccs  la camra",secondaryText:"Autorisez laccs si vous y tes invit. Cela permet aux participants de vous voir.",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes",primaryButtonText:"Continuer sans appareil photo",ariaLabel:"Vrification de laccs  la camra. Autorisez laccs si vous y tes invit."};var MicrophoneSitePermissionsCheck$d={primaryText:"Vrification de laccs au microphone",secondaryText:"Autorisez laccs si vous y tes invit. Cela permet aux participants de vous entendre.",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes",primaryButtonText:"Continuer sans microphone",ariaLabel:"Vrification de laccs au microphone. Autorisez laccs si vous y tes invit."};var CameraAndMicrophoneSitePermissionsDenied$d={primaryText:"Nous navons pas pu accder au micro et  la camra.",secondaryText:"Cliquez sur licne de verrouillage dans la barre dadresses pour accorder des autorisations de microphone  cette page Web. Une actualisation de page peut tre ncessaire.",primaryButtonText:"Continuer sans camra ni microphone",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes"};var CameraAndMicrophoneSitePermissionsDeniedSafari$d={primaryText:"Nous navons pas pu accder au micro et  la camra.",secondaryText:"Actualisez la page pour autoriser les autorisations, ou vrifiez les paramtres de ce navigateur et vrifiez que les autorisations sont actives pour ce site web.",primaryButtonText:"Continuer sans camra ni microphone",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes"};var CameraSitePermissionsDenied$d={primaryText:"Impossible daccder  la camra",secondaryText:"Cliquez sur licne de verrouillage dans la barre dadresses pour accorder des autorisations dappareil photo  cette page Web. Une actualisation de page peut tre ncessaire.",primaryButtonText:"Continuer sans camra",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes"};var MicrophoneSitePermissionsDenied$d={primaryText:"Nous navons pas pu accder au micro.",secondaryText:"Cliquez sur licne de verrouillage dans la barre dadresses pour accorder des autorisations de microphone  cette page Web. Une actualisation de page peut tre ncessaire.",primaryButtonText:"Continuer sans microphone",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes"};var CameraSitePermissionsDeniedSafari$d={primaryText:"Nous navons pas pu accder  la camra.",secondaryText:"Actualisez la page pour autoriser les autorisations, ou vrifiez les paramtres de ce navigateur et vrifiez que les autorisations sont actives pour ce site web.",primaryButtonText:"Continuer sans appareil photo",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes"};var MicrophoneSitePermissionsDeniedSafari$d={primaryText:"Impossible daccder au microphone",secondaryText:"Actualisez la page pour autoriser les autorisations, ou vrifiez les paramtres de ce navigateur et vrifiez que les autorisations sont actives pour ce site web.",primaryButtonText:"Continuer sans microphone",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes"};var UnsupportedBrowser$d={primaryText:"Navigateur non pris en charge",secondaryText:"Rejoignez cet appel  laide dun navigateur compatible.",moreHelpLinkText:"Voir les exigences de compatibilit"};var UnsupportedBrowserVersion$d={primaryText:"Mise  jour du navigateur ncessaire",secondaryText:"Pour garantir le meilleur appel possible, mettez  jour votre navigateur, puis ressayez de rejoindre lappel.",moreHelpLinkText:"Voir les exigences de compatibilit",continueAnywayButtonText:"Dmarrer lappel sans mettre  jour"};var UnsupportedOperatingSystem$d={primaryText:"Systme d'exploitation non pris en charge",secondaryText:"Rejoignez cet appel  laide dun appareil avec un systme dexploitation compatible.",moreHelpLinkText:"Voir les exigences de compatibilit"};var BrowserPermissionDenied$d={primaryText:"Impossible dutiliser votre camra ou votre micro",secondaryText:"Votre navigateur na peut-tre pas accs  votre camra ou  votre micro. Pour rsoudre ce problme, ouvrez Prfrences systme.",primaryButtonText:"Ressayer",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes"};var BrowserPermissionDeniedIOS$d={primaryText:"Autoriser laccs au microphone pour continuer",secondaryText:"Ainsi, les autres participants peuvent vous entendre.",primaryButtonText:"Ressayer",imageAltText:"Emplacement des autorisations pour le microphone et la camra pour iOS",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes",step1Text:"Accder  lapplication Paramtres",step2Text:"Faites dfiler vers le bas pour accder aux paramtres de ce navigateur",step3Text:"Activer le microphone (camra facultative)",step4Text:"Ressayez de rejoindre lappel",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$d={leftNavButtonAriaLabel:"page prcdente",rightNavButtonAriaLabel:"page suivante"};var fr_FR$1 = {participantItem:participantItem$d,ParticipantList:ParticipantList$d,typingIndicator:typingIndicator$d,sendBox:sendBox$d,richTextSendBox:richTextSendBox$d,mentionPopover:mentionPopover$d,imageOverlay:imageOverlay$d,messageStatusIndicator:messageStatusIndicator$d,endCallButton:endCallButton$d,cameraButton:cameraButton$d,microphoneButton:microphoneButton$d,devicesButton:devicesButton$d,participantsButton:participantsButton$d,screenShareButton:screenShareButton$d,raiseHandButton:raiseHandButton$d,reactionButton:reactionButton$d,messageThread:messageThread$d,errorBar:errorBar$d,videoGallery:videoGallery$d,dialpad:dialpad$d,holdButton:holdButton$d,videoTile:videoTile$d,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$d,CameraSitePermissionsRequest:CameraSitePermissionsRequest$d,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$d,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$d,CameraSitePermissionsCheck:CameraSitePermissionsCheck$d,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$d,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$d,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$d,CameraSitePermissionsDenied:CameraSitePermissionsDenied$d,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$d,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$d,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$d,UnsupportedBrowser:UnsupportedBrowser$d,UnsupportedBrowserVersion:UnsupportedBrowserVersion$d,UnsupportedOperatingSystem:UnsupportedOperatingSystem$d,BrowserPermissionDenied:BrowserPermissionDenied$d,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$d,verticalGallery:verticalGallery$d};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for French (France).
 *
 * @public
 */
const COMPONENT_LOCALE_FR_FR = {
    strings: createComponentStrings(fr_FR$1)
};

var participantItem$c={isMeText:"()",menuTitle:" ",removeButtonLabel:"",sharingIconLabel:"",mutedIconLabel:"",displayNamePlaceholder:"  ",participantStateRinging:"...",participantStateHold:"",attendeeRole:""};var ParticipantList$c={overflowParticipantCount:"+{overflowCount} "};var typingIndicator$c={singleUser:"{user} ...",multipleUsers:"{users} ...",multipleUsersAbbreviateOne:"{users}    ...",multipleUsersAbbreviateMany:"{users} {numOthers}  ...",delimiter:", "};var sendBox$c={placeholderText:" ",textTooLong:"     .",sendButtonAriaLabel:" ",fileUploadsPendingError:"...  .",removeFile:" ",uploading:"",uploadCompleted:" "};var richTextSendBox$c={placeholderText:" ",textTooLong:"     .",sendButtonAriaLabel:" ",fileUploadsPendingError:"... .",removeFile:" ",uploading:"",uploadCompleted:" ",boldTooltip:"",italicTooltip:"",underlineTooltip:" ",bulletListTooltip:"  ",numberListTooltip:" ",increaseIndentTooltip:" ",decreaseIndentTooltip:" ",richTextFormatButtonTooltip:""};var mentionPopover$c={mentionPopoverHeader:""};var imageOverlay$c={downloadButtonLabel:"",dismissButtonAriaLabel:""};var messageStatusIndicator$c={deliveredAriaLabel:" ",deliveredTooltipText:"",seenAriaLabel:"  - ",seenTooltipText:"",readByTooltipText:" - {messageThreadReadCount}  {remoteParticipantsCount}",sendingAriaLabel:" ",sendingTooltipText:"",failedToSendAriaLabel:"  ",failedToSendTooltipText:" "};var endCallButton$c={label:"",tooltipContent:"  "};var cameraButton$c={onLabel:"",offLabel:"",tooltipDisabledContent:"  ",tooltipOnContent:" ",tooltipOffContent:" ",tooltipVideoLoadingContent:" ",cameraMenuTitle:"",cameraMenuTooltip:" ",cameraButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"    ",offSplitButtonAriaLabel:"   ",cameraActionTurnedOnAnnouncement:"  ",cameraActionTurnedOffAnnouncement:"  ",onSplitButtonPrimaryActionCamera:" ",offSplitButtonPrimaryActionCamera:"  ",cameraPrimaryActionSplitButtonTitle:" ",videoEffectsMenuItemTitle:""};var microphoneButton$c={onLabel:"",offLabel:"",tooltipDisabledContent:"  ",tooltipOnContent:" ",tooltipOffContent:"   ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:"",speakerMenuTooltip:" ",microphoneButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"   ",offSplitButtonAriaLabel:"     ",microphoneActionTurnedOnAnnouncement:"  ",microphoneActionTurnedOffAnnouncement:"  ",offSplitButtonMicrophonePrimaryAction:"    ",onSplitButtonMicrophonePrimaryAction:"  ",microphonePrimaryActionSplitButtonTitle:" "};var devicesButton$c={label:"",tooltipContent:" ",cameraMenuTitle:"",cameraMenuTooltip:" ",audioDeviceMenuTitle:" ",audioDeviceMenuTooltip:"  ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:"",speakerMenuTooltip:" "};var participantsButton$c={label:"",tooltipContent:" ",menuHeader:" ",participantsListButtonLabel:"{numParticipants} ",muteAllButtonLabel:" ",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"  "};var screenShareButton$c={onLabel:" ",offLabel:"",tooltipDisabledContent:"  ",tooltipOnContent:"   ",tooltipOffContent:"   "};var raiseHandButton$c={offLabel:"",onLabel:"",tooltipDisabledContent:"    ",tooltipOnContent:" ",tooltipOffContent:" "};var reactionButton$c={label:"",ariaLabel:" '',  ",tooltipDisabledContent:"   ",tooltipContent:" ",likeReactionTooltipContent:"",heartReactionTooltipContent:"",laughReactionTooltipContent:"",applauseReactionTooltipContent:"",surprisedReactionTooltipContent:""};var messageThread$c={yesterday:"",sunday:" ",monday:" ",tuesday:"",wednesday:" ",thursday:" ",friday:" ",saturday:" ",participantJoined:" '.",participantLeft:"  '.",editMessage:"",removeMessage:"",resendMessage:"  ",failToSendTag:" ",editedTag:"",liveAuthorIntro:"{author} ",messageContentAriaText:"{author}  {message}",messageContentMineAriaText:" {message}",editBoxTextLimit:"      {limitNumber} ",editBoxPlaceholderText:"   ",newMessagesIndicator:" ",noDisplayNameSub:" ",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:" - {messageReadByCount}  {remoteParticipantsCount}",actionMenuMoreOptions:" ",downloadFile:" ",blockedWarningText:"     .",blockedWarningLinkText:"",fileCardGroupMessage:"    {fileCount}",messageDeletedAnnouncementAriaLabel:" "};var errorBar$c={unableToReachChatService:"    ",accessDenied:"     ' -     ",userNotInChatThread:"       '",sendMessageNotInChatThread:"            '",sendMessageGeneric:"  ",callingNetworkFailure:"   -    ",startVideoGeneric:"   ",stopVideoGeneric:"  ",muteGeneric:"  ",unmuteGeneric:"   ",speakingWhileMuted:"  ",startScreenShareGeneric:"    .",stopScreenShareGeneric:"   ",callNetworkQualityLow:"  .",callNoSpeakerFound:"    .       .",callNoMicrophoneFound:"  .    .",callMicrophoneAccessDenied:"   .           .",callMicrophoneAccessDeniedSafari:"   .      ,              .",callMicrophoneMutedBySystem:"  -  .",callMicrophoneUnmutedBySystem:"       .",callMacOsMicrophoneAccessDenied:"   .       macOS.",callLocalVideoFreeze:"    .        .",callCameraAccessDenied:"   .           .",callCameraAccessDeniedSafari:"   .      ,              .",callCameraAlreadyInUse:"   .      -  .",callVideoStoppedBySystem:"   - .",callVideoRecoveredBySystem:"  .",callMacOsCameraAccessDenied:"MacOS     .            .",callMacOsScreenShareAccessDenied:"MacOS   .             .",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"  .",failedToJoinCallInvalidMeetingLink:"   .   .",cameraFrozenForRemoteParticipants:"      .      .",unableToStartVideoEffect:"    .",startSpotlightWhileMaxParticipantsAreSpotlighted:"              ."};var videoGallery$c={screenIsBeingSharedMessage:"    ",screenShareLoadingMessage:"    {participant}",localVideoLabel:"",localVideoCameraSwitcherLabel:" ",localVideoMovementLabel:"   ",localVideoSelectedDescription:"{cameraName} ",displayNamePlaceholder:"  ",fitRemoteParticipantToFrame:" ",fillRemoteParticipantFrame:"  ",pinParticipantForMe:" ",pinParticipantForMeLimitReached:" ( )",unpinParticipantForMe:" ",pinParticipantMenuItemAriaLabel:"  {participantName}",unpinParticipantMenuItemAriaLabel:"   {participantName}",pinnedParticipantAnnouncementAriaLabel:"{participantName} ",unpinnedParticipantAnnouncementAriaLabel:" {participantName} ",startSpotlightVideoTileMenuLabel:"   ",addSpotlightVideoTileMenuLabel:" ",spotlightLimitReachedMenuTitle:"  ",stopSpotlightVideoTileMenuLabel:"  ",stopSpotlightOnSelfVideoTileMenuLabel:" ",attendeeRole:""};var dialpad$c={placeholderText:"  ",deleteButtonAriaLabel:""};var holdButton$c={onLabel:"",offLabel:"",tooltipOnContent:" ",tooltipOffContent:" "};var videoTile$c={participantStateRinging:"...",participantStateHold:""};var CameraAndMicrophoneSitePermissionsRequest$c={primaryText:" {appName}    ",secondaryText:"      .",linkText:" ?     ",primaryButtonText:"   ",ariaLabel:"   "};var CameraSitePermissionsRequest$c={primaryText:" {appName}   ",secondaryText:"     .",linkText:" ?     ",primaryButtonText:"  ",ariaLabel:"  "};var MicrophoneSitePermissionsRequest$c={primaryText:" {appName}   ",secondaryText:"     .",linkText:" ?     ",primaryButtonText:"  ",ariaLabel:"  "};var CameraAndMicrophoneSitePermissionsCheck$c={primaryText:"     ",secondaryText:"     .       .",linkText:" ?     ",primaryButtonText:"   ",ariaLabel:"     .      ."};var CameraSitePermissionsCheck$c={primaryText:"    ",secondaryText:"     .      .",linkText:" ?     ",primaryButtonText:"  ",ariaLabel:"    .      ."};var MicrophoneSitePermissionsCheck$c={primaryText:"    ",secondaryText:"     .      .",linkText:" ?     ",primaryButtonText:"  ",ariaLabel:"    .      ."};var CameraAndMicrophoneSitePermissionsDenied$c={primaryText:"    ",secondaryText:"            .    .",primaryButtonText:"   ",linkText:" ?     "};var CameraAndMicrophoneSitePermissionsDeniedSafari$c={primaryText:"    ",secondaryText:"     ,              .",primaryButtonText:"   ",linkText:" ?     "};var CameraSitePermissionsDenied$c={primaryText:"   ",secondaryText:"            .    .",primaryButtonText:"  ",linkText:" ?     "};var MicrophoneSitePermissionsDenied$c={primaryText:"   ",secondaryText:"            .    .",primaryButtonText:"  ",linkText:" ?     "};var CameraSitePermissionsDeniedSafari$c={primaryText:"   ",secondaryText:"     ,              .",primaryButtonText:"  ",linkText:" ?     "};var MicrophoneSitePermissionsDeniedSafari$c={primaryText:"   ",secondaryText:"     ,              .",primaryButtonText:"  ",linkText:" ?     "};var UnsupportedBrowser$c={primaryText:"  ",secondaryText:"     .",moreHelpLinkText:"  "};var UnsupportedBrowserVersion$c={primaryText:"  ",secondaryText:"      ,         .",moreHelpLinkText:"  ",continueAnywayButtonText:"   "};var UnsupportedOperatingSystem$c={primaryText:"   ",secondaryText:"        .",moreHelpLinkText:"  "};var BrowserPermissionDenied$c={primaryText:"      ",secondaryText:"        .    ,   ' '.",primaryButtonText:" ",linkText:" ?     "};var BrowserPermissionDeniedIOS$c={primaryText:"    ",secondaryText:"     .",primaryButtonText:" ",imageAltText:"       iOS",linkText:" ?     ",step1Text:"   ''",step2Text:"     ",step3Text:"  ( )",step4Text:"   ",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$c={leftNavButtonAriaLabel:" ",rightNavButtonAriaLabel:" "};var he_IL$1 = {participantItem:participantItem$c,ParticipantList:ParticipantList$c,typingIndicator:typingIndicator$c,sendBox:sendBox$c,richTextSendBox:richTextSendBox$c,mentionPopover:mentionPopover$c,imageOverlay:imageOverlay$c,messageStatusIndicator:messageStatusIndicator$c,endCallButton:endCallButton$c,cameraButton:cameraButton$c,microphoneButton:microphoneButton$c,devicesButton:devicesButton$c,participantsButton:participantsButton$c,screenShareButton:screenShareButton$c,raiseHandButton:raiseHandButton$c,reactionButton:reactionButton$c,messageThread:messageThread$c,errorBar:errorBar$c,videoGallery:videoGallery$c,dialpad:dialpad$c,holdButton:holdButton$c,videoTile:videoTile$c,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$c,CameraSitePermissionsRequest:CameraSitePermissionsRequest$c,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$c,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$c,CameraSitePermissionsCheck:CameraSitePermissionsCheck$c,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$c,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$c,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$c,CameraSitePermissionsDenied:CameraSitePermissionsDenied$c,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$c,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$c,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$c,UnsupportedBrowser:UnsupportedBrowser$c,UnsupportedBrowserVersion:UnsupportedBrowserVersion$c,UnsupportedOperatingSystem:UnsupportedOperatingSystem$c,BrowserPermissionDenied:BrowserPermissionDenied$c,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$c,verticalGallery:verticalGallery$c};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Hebrew (Israel).
 *
 * @public
 */
const COMPONENT_LOCALE_HE_IL = {
    strings: createComponentStrings(he_IL$1)
};

var participantItem$b={isMeText:"(tu)",menuTitle:"Altre opzioni",removeButtonLabel:"Rimuovi",sharingIconLabel:"Condivisione",mutedIconLabel:"Disattivato",displayNamePlaceholder:"Partecipante senza nome",participantStateRinging:"Chiamata in corso...",participantStateHold:"Per l'attesa",attendeeRole:"Partecipante"};var ParticipantList$b={overflowParticipantCount:"+{overflowCount} altro"};var typingIndicator$b={singleUser:"{user} sta scrivendo ...",multipleUsers:"{users} stanno scrivendo ...",multipleUsersAbbreviateOne:"{users} e 1 altro stanno scrivendo ...",multipleUsersAbbreviateMany:"{users} e {numOthers} altri stanno scrivendo ...",delimiter:", "};var sendBox$b={placeholderText:"Immetti un messaggio",textTooLong:"La lunghezza del messaggio supera il limite massimo.",sendButtonAriaLabel:"Invio messaggio",fileUploadsPendingError:"Caricamento in corso... Attendere.",removeFile:"Rimuovi file",uploading:"Caricamento in corso",uploadCompleted:"Caricamento completato"};var richTextSendBox$b={placeholderText:"Immetti un messaggio",textTooLong:"La lunghezza del messaggio supera il limite massimo.",sendButtonAriaLabel:"Invia messaggio",fileUploadsPendingError:"Caricamento... Attendi.",removeFile:"Rimuovi file",uploading:"Caricamento",uploadCompleted:"Caricamento completato",boldTooltip:"Grassetto",italicTooltip:"Corsivo",underlineTooltip:"Sottolineato",bulletListTooltip:"Elenco puntato",numberListTooltip:"Elenco numerato",increaseIndentTooltip:"Aumenta rientro",decreaseIndentTooltip:"Riduci rientro",richTextFormatButtonTooltip:"Formato"};var mentionPopover$b={mentionPopoverHeader:"Suggerimenti"};var imageOverlay$b={downloadButtonLabel:"Scarica",dismissButtonAriaLabel:"Chiudi"};var messageStatusIndicator$b={deliveredAriaLabel:"Il messaggio  stato inviato",deliveredTooltipText:"Inviato",seenAriaLabel:"Messaggio visualizzato da altri utenti",seenTooltipText:"Visualizzato",readByTooltipText:"Letto da {messageThreadReadCount} di {remoteParticipantsCount}",sendingAriaLabel:"Invio del messaggio",sendingTooltipText:"Invio in corso",failedToSendAriaLabel:"Invio messaggio non riuscito",failedToSendTooltipText:"Invio non riuscito"};var endCallButton$b={label:"Permesso",tooltipContent:"Abbandona chiamata"};var cameraButton$b={onLabel:"Fotocamera",offLabel:"Fotocamera",tooltipDisabledContent:"La videocamera  disabilitata",tooltipOnContent:"Spegni la videocamera",tooltipOffContent:"Accendi la videocamera",tooltipVideoLoadingContent:"Il video  in corso di caricamento",cameraMenuTitle:"Fotocamera",cameraMenuTooltip:"Scegli fotocamera",cameraButtonSplitRoleDescription:"Pulsante di menu combinato",onSplitButtonAriaLabel:"Disattiva fotocamera e le opzioni della fotocamera",offSplitButtonAriaLabel:"Attiva fotocamera e le opzioni della fotocamera",cameraActionTurnedOnAnnouncement:"La videocamera  stata attivata",cameraActionTurnedOffAnnouncement:"La videocamera  stata disattivata",onSplitButtonPrimaryActionCamera:"Spegni la videocamera",offSplitButtonPrimaryActionCamera:"Accendi la videocamera",cameraPrimaryActionSplitButtonTitle:"Usa la fotocamera",videoEffectsMenuItemTitle:"Effetti"};var microphoneButton$b={onLabel:"Microfono",offLabel:"Microfono",tooltipDisabledContent:"Il microfono  disabilitato",tooltipOnContent:"Disattiva microfono",tooltipOffContent:"Riattiva microfono",microphoneMenuTitle:"Microfono",microphoneMenuTooltip:"Scegli microfono",speakerMenuTitle:"Altoparlante",speakerMenuTooltip:"Scegli altoparlante",microphoneButtonSplitRoleDescription:"Pulsante di menu combinato",onSplitButtonAriaLabel:"Disattiva microfono e opzioni audio",offSplitButtonAriaLabel:"Attiva microfono e opzioni audio",microphoneActionTurnedOnAnnouncement:"Il microfono  stato attivato",microphoneActionTurnedOffAnnouncement:"Il microfono  stato disattivato",offSplitButtonMicrophonePrimaryAction:"Riattiva microfono",onSplitButtonMicrophonePrimaryAction:"Disattiva microfono",microphonePrimaryActionSplitButtonTitle:"Usa il microfono"};var devicesButton$b={label:"Dispositivi",tooltipContent:"Gestisci dispositivi",cameraMenuTitle:"Fotocamera",cameraMenuTooltip:"Scegli fotocamera",audioDeviceMenuTitle:"Dispositivo audio",audioDeviceMenuTooltip:"Scegli dispositivo audio",microphoneMenuTitle:"Microfono",microphoneMenuTooltip:"Scegli microfono",speakerMenuTitle:"Altoparlante",speakerMenuTooltip:"Scegli altoparlante"};var participantsButton$b={label:"Persone",tooltipContent:"Mostra partecipanti",menuHeader:"In questa chiamata",participantsListButtonLabel:"{numParticipants} persone",muteAllButtonLabel:"Disattiva l'audio di tutti",copyInviteLinkButtonLabel:"Copia il collegamento dellinvito",copyInviteLinkActionedAriaLabel:"Collegamento di invito copiato"};var screenShareButton$b={onLabel:"Interrompi presentazione",offLabel:"Presentazione",tooltipDisabledContent:"La presentazione  disabilitata.",tooltipOnContent:"Presentazione dello schermo",tooltipOffContent:"Presenta lo schermo"};var raiseHandButton$b={offLabel:"Alza",onLabel:"Abbassa",tooltipDisabledContent:"L'azione Alza la mano  disabilitata",tooltipOnContent:"Abbassa la mano",tooltipOffContent:"Alza la mano"};var reactionButton$b={label:"Reagisci",ariaLabel:"Pulsante Reagisci, Invia una reazione",tooltipDisabledContent:"L'azione di reazione  disabilitata",tooltipContent:"Invia una reazione",likeReactionTooltipContent:"Mi piace",heartReactionTooltipContent:"Amore",laughReactionTooltipContent:"Risata",applauseReactionTooltipContent:"Applauso",surprisedReactionTooltipContent:"Sorpresa"};var messageThread$b={yesterday:"Ieri",sunday:"Domenica",monday:"Luned",tuesday:"Marted",wednesday:"Mercoled",thursday:"Gioved",friday:"Venerd",saturday:"Sabato",participantJoined:"si  unito alla chat.",participantLeft:"ha abbandonato la chat.",editMessage:"Modifica",removeMessage:"Elimina",resendMessage:"Riprova a inviare",failToSendTag:"Invio non riuscito",editedTag:"Modificato",liveAuthorIntro:"{author} dice",messageContentAriaText:"{author} ha detto {message}",messageContentMineAriaText:"Hai detto {message}",editBoxTextLimit:"Il messaggio ha superato il limite di caratteri {limitNumber}",editBoxPlaceholderText:"Modifica il messaggio",newMessagesIndicator:"Nuovi messaggi",noDisplayNameSub:"Nessun nome",editBoxCancelButton:"Annulla",editBoxSubmitButton:"Fatto",messageReadCount:"Letto da {messageReadByCount} di {remoteParticipantsCount}",actionMenuMoreOptions:"Altre opzioni",downloadFile:"Scarica file",blockedWarningText:"Questo messaggio  stato eliminato a causa dei criteri dell'organizzazione.",blockedWarningLinkText:"Dettagli",fileCardGroupMessage:"Il messaggio contiene {fileCount} allegato",messageDeletedAnnouncementAriaLabel:"Il messaggio  stato eliminato"};var errorBar$b={unableToReachChatService:"Sei offline",accessDenied:"Non  possibile accedere ai servizi di chat. Controllare le credenziali utente specificate",userNotInChatThread:"Non fai pi parte di questo thread di chat",sendMessageNotInChatThread:"Non  stato possibile inviare il messaggio perch non sei pi in questo thread di chat",sendMessageGeneric:"Impossibile inviare il messaggio",callingNetworkFailure:"Problema di connessione della chiamata: sembra che tu sia offline",startVideoGeneric:"Non  stato possibile avviare il video",stopVideoGeneric:"Non  stato possibile arrestare il video",muteGeneric:"Non  stato possibile disattivare l'audio del microfono",unmuteGeneric:"Non  stato possibile riattivare l'audio del microfono",speakingWhileMuted:"Il microfono  disattivato",startScreenShareGeneric:"Si  verificato un problema durante l'avvio della condivisione dello schermo.",stopScreenShareGeneric:"Non  stato possibile arrestare la condivisione dello schermo",callNetworkQualityLow:"La qualit della rete  bassa.",callNoSpeakerFound:"Non sono stati trovati altoparlanti o cuffie. Connetti un dispositivo audio per ascoltare la chiamata.",callNoMicrophoneFound:"Nessun microfono trovato. Connetti un dispositivo di input audio.",callMicrophoneAccessDenied:"Impossibile accedere al microfono. Fare clic sul blocco nella barra degli indirizzi per concedere l'autorizzazione a questa pagina Web.",callMicrophoneAccessDeniedSafari:"Impossibile accedere al microfono. Aggiornare la pagina per consentire le autorizzazioni oppure controllare le impostazioni del browser e verificare che le autorizzazioni siano abilitate per questo sito Web.",callMicrophoneMutedBySystem:"Il sistema disattiva l'audio.",callMicrophoneUnmutedBySystem:"Il microfono  stato ripristinato e il sistema ha riattivato l'audio.",callMacOsMicrophoneAccessDenied:"Impossibile accedere al microfono. Concedi l'autorizzazione al microfono nelle impostazioni di privacy di macOS.",callLocalVideoFreeze:"Larghezza di banda di rete insufficiente. Il video potrebbe essere sospeso per gli altri partecipanti alla chiamata.",callCameraAccessDenied:"Non  possibile accedere alla fotocamera. Fare clic sul blocco nella barra degli indirizzi per concedere l'autorizzazione a questa pagina Web.",callCameraAccessDeniedSafari:"Non  possibile accedere alla fotocamera. Aggiornare la pagina per consentire le autorizzazioni oppure controllare le impostazioni del browser e verificare che le autorizzazioni siano abilitate per questo sito Web.",callCameraAlreadyInUse:"Non  possibile accedere alla fotocamera. Potrebbe essere gi in uso da un'altra applicazione.",callVideoStoppedBySystem:"Il video  stato arrestato dal sistema.",callVideoRecoveredBySystem:"Il video  ripreso.",callMacOsCameraAccessDenied:"MacOS sta bloccando l'accesso alla fotocamera. Aggiorna le impostazioni di privacy per consentire a questo browser di accedere alla fotocamera.",callMacOsScreenShareAccessDenied:"MacOS sta bloccando la condivisione dello schermo. Aggiorna le impostazioni di privacy per consentire a questo browser di registrare lo schermo.",dismissButtonAriaLabel:"Chiudi",failedToJoinCallGeneric:"Non  stato possibile partecipare alla chiamata.",failedToJoinCallInvalidMeetingLink:"Impossibile partecipare alla riunione. Collegamento non valido.",cameraFrozenForRemoteParticipants:"Gli utenti della chiamata hanno problemi a visualizzare il video. Controllare i dispositivi e la rete.",unableToStartVideoEffect:"Non  possibile applicare l'effetto video.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Non  possibile avviare i contenuti in evidenza sui partecipanti perch il numero massimo di partecipanti  gi in evidenza."};var videoGallery$b={screenIsBeingSharedMessage:"Stai condividendo lo schermo",screenShareLoadingMessage:"Caricamento dello schermo di {participant}",localVideoLabel:"Tu",localVideoCameraSwitcherLabel:"Cambia videocamera",localVideoMovementLabel:"Riquadro video locale mobile",localVideoSelectedDescription:"{cameraName} selezionata",displayNamePlaceholder:"Partecipante senza nome",fitRemoteParticipantToFrame:"Adatta all'inquadratura",fillRemoteParticipantFrame:"Riempi l'inquadratura",pinParticipantForMe:"Aggiungi per me",pinParticipantForMeLimitReached:"Segnaposto (limite raggiunto)",unpinParticipantForMe:"Rimuovi",pinParticipantMenuItemAriaLabel:"Aggiungi {participantName}",unpinParticipantMenuItemAriaLabel:"Rimuovi {participantName}",pinnedParticipantAnnouncementAriaLabel:"{participantName} aggiunto",unpinnedParticipantAnnouncementAriaLabel:"{participantName} sbloccato",startSpotlightVideoTileMenuLabel:"Metti in evidenza per tutti",addSpotlightVideoTileMenuLabel:"Metti in evidenza",spotlightLimitReachedMenuTitle:" stato raggiunto il limite di contenuti in evidenza",stopSpotlightVideoTileMenuLabel:"Interrompi la posizione in evidenza",stopSpotlightOnSelfVideoTileMenuLabel:"Chiudi visualizzazione in evidenza",attendeeRole:"Partecipante"};var dialpad$b={placeholderText:"Inserisci numero di telefono",deleteButtonAriaLabel:"Elimina"};var holdButton$b={onLabel:"Riprendi",offLabel:"Mantenere",tooltipOnContent:"Riprendi chiamata",tooltipOffContent:"Metti in attesa chiamata"};var videoTile$b={participantStateRinging:"Chiamata in corso...",participantStateHold:"Per l'attesa"};var CameraAndMicrophoneSitePermissionsRequest$b={primaryText:"Consenti a {appName} di usare la fotocamera e il microfono",secondaryText:"In questo modo i partecipanti possono vederti e sentirti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza fotocamera e microfono",ariaLabel:"Consenti l'accesso alla fotocamera e al microfono"};var CameraSitePermissionsRequest$b={primaryText:"Consenti a {appName} di usare la fotocamera",secondaryText:"In questo modo i partecipanti possono vederti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza fotocamera",ariaLabel:"Consenti l'accesso alla fotocamera"};var MicrophoneSitePermissionsRequest$b={primaryText:"Consenti a {appName} di usare il microfono",secondaryText:"In questo modo i partecipanti possono sentirti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza microfono",ariaLabel:"Consenti l'accesso al microfono"};var CameraAndMicrophoneSitePermissionsCheck$b={primaryText:"Verifica dell'accesso alla fotocamera e al microfono",secondaryText:"Consenti l'accesso se richiesto. In questo modo i partecipanti possono vederti e sentirti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza fotocamera e microfono",ariaLabel:"Verifica dell'accesso alla fotocamera e al microfono. Consenti l'accesso se richiesto."};var CameraSitePermissionsCheck$b={primaryText:"Verifica dell'accesso alla fotocamera",secondaryText:"Consenti l'accesso se richiesto. In questo modo i partecipanti possono vederti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza fotocamera",ariaLabel:"Verifica dell'accesso alla fotocamera. Consenti l'accesso se richiesto."};var MicrophoneSitePermissionsCheck$b={primaryText:"Verifica dell'accesso al microfono",secondaryText:"Consenti l'accesso se richiesto. In questo modo i partecipanti possono sentirti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza microfono",ariaLabel:"Verifica dell'accesso al microfono. Consenti l'accesso se richiesto."};var CameraAndMicrophoneSitePermissionsDenied$b={primaryText:"Non  possibile accedere alla fotocamera e al microfono",secondaryText:"Fare clic sull'icona di blocco nella barra degli indirizzi per concedere le autorizzazioni del microfono a questa pagina Web. Potrebbe essere necessario un aggiornamento della pagina.",primaryButtonText:"Continua senza fotocamera e microfono",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var CameraAndMicrophoneSitePermissionsDeniedSafari$b={primaryText:"Non  possibile accedere alla fotocamera e al microfono",secondaryText:"Aggiornare la pagina per consentire le autorizzazioni oppure controllare le impostazioni del browser e verificare che le autorizzazioni siano abilitate per questo sito Web.",primaryButtonText:"Continua senza fotocamera e microfono",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var CameraSitePermissionsDenied$b={primaryText:"Impossibile accedere alla videocamera",secondaryText:"Fare clic sull'icona di blocco nella barra degli indirizzi per concedere le autorizzazioni della fotocamera a questa pagina Web. Potrebbe essere necessario un aggiornamento della pagina.",primaryButtonText:"Continua senza fotocamera",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var MicrophoneSitePermissionsDenied$b={primaryText:"Impossibile accedere al microfono",secondaryText:"Fare clic sull'icona di blocco nella barra degli indirizzi per concedere le autorizzazioni del microfono a questa pagina Web. Potrebbe essere necessario un aggiornamento della pagina.",primaryButtonText:"Continua senza microfono",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var CameraSitePermissionsDeniedSafari$b={primaryText:"Impossibile accedere alla videocamera",secondaryText:"Aggiornare la pagina per consentire le autorizzazioni oppure controllare le impostazioni del browser e verificare che le autorizzazioni siano abilitate per questo sito Web.",primaryButtonText:"Continua senza fotocamera",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var MicrophoneSitePermissionsDeniedSafari$b={primaryText:"Impossibile accedere al microfono",secondaryText:"Aggiornare la pagina per consentire le autorizzazioni oppure controllare le impostazioni del browser e verificare che le autorizzazioni siano abilitate per questo sito Web.",primaryButtonText:"Continua senza microfono",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var UnsupportedBrowser$b={primaryText:"Browser non supportato",secondaryText:"Partecipa alla chiamata utilizzando un browser compatibile.",moreHelpLinkText:"Visualizza i requisiti di compatibilit"};var UnsupportedBrowserVersion$b={primaryText:"Aggiornamento del browser necessario",secondaryText:"Per garantire la migliore chiamata possibile, aggiorna il browser e riprova a partecipare alla chiamata.",moreHelpLinkText:"Visualizza i requisiti di compatibilit",continueAnywayButtonText:"Avvia chiamata senza aggiornamento"};var UnsupportedOperatingSystem$b={primaryText:"Sistemi operativi non supportati",secondaryText:"Partecipa alla chiamata utilizzando un dispositivo con un sistema operativo compatibile.",moreHelpLinkText:"Visualizza i requisiti di compatibilit"};var BrowserPermissionDenied$b={primaryText:"Non  possibile usare la fotocamera o il microfono",secondaryText:"Il browser potrebbe non avere accesso alla fotocamera o al microfono. Per risolvere il problema, aprire Preferenze di sistema.",primaryButtonText:"Riprova",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var BrowserPermissionDeniedIOS$b={primaryText:"Consenti l'accesso al microfono per continuare",secondaryText:"Cos gli altri partecipanti possono sentirti.",primaryButtonText:"Riprova",imageAltText:"Posizione dell'autorizzazione del microfono e della fotocamera per iOS",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",step1Text:"Vai alle impostazioni dell'app",step2Text:"Scorri verso il basso fino alle impostazioni per questo browser",step3Text:"Attiva microfono (fotocamera facoltativa)",step4Text:"Prova a partecipare di nuovo alla chiamata",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$b={leftNavButtonAriaLabel:"Pagina precedente",rightNavButtonAriaLabel:"Pagina successiva"};var it_IT$1 = {participantItem:participantItem$b,ParticipantList:ParticipantList$b,typingIndicator:typingIndicator$b,sendBox:sendBox$b,richTextSendBox:richTextSendBox$b,mentionPopover:mentionPopover$b,imageOverlay:imageOverlay$b,messageStatusIndicator:messageStatusIndicator$b,endCallButton:endCallButton$b,cameraButton:cameraButton$b,microphoneButton:microphoneButton$b,devicesButton:devicesButton$b,participantsButton:participantsButton$b,screenShareButton:screenShareButton$b,raiseHandButton:raiseHandButton$b,reactionButton:reactionButton$b,messageThread:messageThread$b,errorBar:errorBar$b,videoGallery:videoGallery$b,dialpad:dialpad$b,holdButton:holdButton$b,videoTile:videoTile$b,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$b,CameraSitePermissionsRequest:CameraSitePermissionsRequest$b,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$b,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$b,CameraSitePermissionsCheck:CameraSitePermissionsCheck$b,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$b,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$b,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$b,CameraSitePermissionsDenied:CameraSitePermissionsDenied$b,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$b,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$b,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$b,UnsupportedBrowser:UnsupportedBrowser$b,UnsupportedBrowserVersion:UnsupportedBrowserVersion$b,UnsupportedOperatingSystem:UnsupportedOperatingSystem$b,BrowserPermissionDenied:BrowserPermissionDenied$b,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$b,verticalGallery:verticalGallery$b};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Italian (Italy).
 *
 * @public
 */
const COMPONENT_LOCALE_IT_IT = {
    strings: createComponentStrings(it_IT$1)
};

var participantItem$a={isMeText:"()",menuTitle:"",removeButtonLabel:"",sharingIconLabel:"",mutedIconLabel:"",displayNamePlaceholder:"",participantStateRinging:"...",participantStateHold:"",attendeeRole:""};var ParticipantList$a={overflowParticipantCount:" {overflowCount} "};var typingIndicator$a={singleUser:"{user} ...",multipleUsers:"{users} ...",multipleUsersAbbreviateOne:"{users}  1 ...",multipleUsersAbbreviateMany:"{users}  {numOthers} ...",delimiter:","};var sendBox$a={placeholderText:"",textTooLong:"",sendButtonAriaLabel:"",fileUploadsPendingError:"... ",removeFile:"",uploading:"",uploadCompleted:""};var richTextSendBox$a={placeholderText:"",textTooLong:"",sendButtonAriaLabel:"",fileUploadsPendingError:"...",removeFile:"",uploading:"",uploadCompleted:"",boldTooltip:"",italicTooltip:"",underlineTooltip:"",bulletListTooltip:"",numberListTooltip:"",increaseIndentTooltip:"",decreaseIndentTooltip:"",richTextFormatButtonTooltip:""};var mentionPopover$a={mentionPopoverHeader:""};var imageOverlay$a={downloadButtonLabel:"",dismissButtonAriaLabel:""};var messageStatusIndicator$a={deliveredAriaLabel:"",deliveredTooltipText:"",seenAriaLabel:"",seenTooltipText:"",readByTooltipText:"{remoteParticipantsCount}  {messageThreadReadCount} ",sendingAriaLabel:"",sendingTooltipText:"",failedToSendAriaLabel:"",failedToSendTooltipText:""};var endCallButton$a={label:"",tooltipContent:""};var cameraButton$a={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",tooltipVideoLoadingContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",cameraButtonSplitRoleDescription:"",onSplitButtonAriaLabel:" ",offSplitButtonAriaLabel:" ",cameraActionTurnedOnAnnouncement:"",cameraActionTurnedOffAnnouncement:"",onSplitButtonPrimaryActionCamera:"",offSplitButtonPrimaryActionCamera:"",cameraPrimaryActionSplitButtonTitle:"",videoEffectsMenuItemTitle:""};var microphoneButton$a={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:"",microphoneButtonSplitRoleDescription:"",onSplitButtonAriaLabel:"",offSplitButtonAriaLabel:"",microphoneActionTurnedOnAnnouncement:"",microphoneActionTurnedOffAnnouncement:"",offSplitButtonMicrophonePrimaryAction:"",onSplitButtonMicrophonePrimaryAction:"",microphonePrimaryActionSplitButtonTitle:""};var devicesButton$a={label:"",tooltipContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",audioDeviceMenuTitle:" ",audioDeviceMenuTooltip:" ",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:""};var participantsButton$a={label:"",tooltipContent:"",menuHeader:"",participantsListButtonLabel:"{numParticipants} ",muteAllButtonLabel:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:""};var screenShareButton$a={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:""};var raiseHandButton$a={offLabel:"",onLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:""};var reactionButton$a={label:"",ariaLabel:" ",tooltipDisabledContent:"",tooltipContent:"",likeReactionTooltipContent:"",heartReactionTooltipContent:"",laughReactionTooltipContent:"",applauseReactionTooltipContent:"",surprisedReactionTooltipContent:""};var messageThread$a={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:"",participantLeft:"",editMessage:"",removeMessage:"",resendMessage:"",failToSendTag:"",editedTag:"",liveAuthorIntro:"{author} ",messageContentAriaText:"{author}  {message} ",messageContentMineAriaText:"{message} ",editBoxTextLimit:"{limitNumber}",editBoxPlaceholderText:"",newMessagesIndicator:"",noDisplayNameSub:"",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:"{remoteParticipantsCount}  {messageReadByCount} ",actionMenuMoreOptions:"",downloadFile:"",blockedWarningText:"",blockedWarningLinkText:"",fileCardGroupMessage:" {fileCount} ",messageDeletedAnnouncementAriaLabel:""};var errorBar$a={unableToReachChatService:"",accessDenied:" - ",userNotInChatThread:" ",sendMessageNotInChatThread:" ",sendMessageGeneric:"",callingNetworkFailure:"",startVideoGeneric:"",stopVideoGeneric:"",muteGeneric:"",unmuteGeneric:"",speakingWhileMuted:"",startScreenShareGeneric:"",stopScreenShareGeneric:"",callNetworkQualityLow:"",callNoSpeakerFound:"",callNoMicrophoneFound:"",callMicrophoneAccessDenied:"  Web ",callMicrophoneAccessDeniedSafari:" Web ",callMicrophoneMutedBySystem:"",callMicrophoneUnmutedBySystem:"",callMacOsMicrophoneAccessDenied:"macOS ",callLocalVideoFreeze:"",callCameraAccessDenied:"  Web ",callCameraAccessDeniedSafari:" Web ",callCameraAlreadyInUse:"",callVideoStoppedBySystem:"",callVideoRecoveredBySystem:"",callMacOsCameraAccessDenied:"MacOS ",callMacOsScreenShareAccessDenied:"MacOS ",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"",failedToJoinCallInvalidMeetingLink:"",cameraFrozenForRemoteParticipants:"",unableToStartVideoEffect:"",startSpotlightWhileMaxParticipantsAreSpotlighted:""};var videoGallery$a={screenIsBeingSharedMessage:"",screenShareLoadingMessage:"{participant} ",localVideoLabel:"",localVideoCameraSwitcherLabel:"",localVideoMovementLabel:"  ",localVideoSelectedDescription:"{cameraName} ",displayNamePlaceholder:"",fitRemoteParticipantToFrame:"",fillRemoteParticipantFrame:"",pinParticipantForMe:"",pinParticipantForMeLimitReached:" ()",unpinParticipantForMe:"",pinParticipantMenuItemAriaLabel:"{participantName} ",unpinParticipantMenuItemAriaLabel:"{participantName} ",pinnedParticipantAnnouncementAriaLabel:"{participantName} ",unpinnedParticipantAnnouncementAriaLabel:"{participantName} ",startSpotlightVideoTileMenuLabel:"",addSpotlightVideoTileMenuLabel:"",spotlightLimitReachedMenuTitle:"",stopSpotlightVideoTileMenuLabel:"",stopSpotlightOnSelfVideoTileMenuLabel:"",attendeeRole:""};var dialpad$a={placeholderText:"",deleteButtonAriaLabel:""};var holdButton$a={onLabel:"",offLabel:"",tooltipOnContent:"",tooltipOffContent:""};var videoTile$a={participantStateRinging:"...",participantStateHold:""};var CameraAndMicrophoneSitePermissionsRequest$a={primaryText:"{appName}",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraSitePermissionsRequest$a={primaryText:"{appName} ",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var MicrophoneSitePermissionsRequest$a={primaryText:"{appName} ",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraAndMicrophoneSitePermissionsCheck$a={primaryText:"",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraSitePermissionsCheck$a={primaryText:"",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var MicrophoneSitePermissionsCheck$a={primaryText:"",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraAndMicrophoneSitePermissionsDenied$a={primaryText:"",secondaryText:"   Web ",primaryButtonText:"",linkText:"? "};var CameraAndMicrophoneSitePermissionsDeniedSafari$a={primaryText:"",secondaryText:" Web ",primaryButtonText:"",linkText:"? "};var CameraSitePermissionsDenied$a={primaryText:"",secondaryText:"   Web ",primaryButtonText:"",linkText:"? "};var MicrophoneSitePermissionsDenied$a={primaryText:"",secondaryText:"   Web ",primaryButtonText:"",linkText:"? "};var CameraSitePermissionsDeniedSafari$a={primaryText:"",secondaryText:" Web ",primaryButtonText:"",linkText:"? "};var MicrophoneSitePermissionsDeniedSafari$a={primaryText:"",secondaryText:" Web ",primaryButtonText:"",linkText:"? "};var UnsupportedBrowser$a={primaryText:"",secondaryText:"",moreHelpLinkText:""};var UnsupportedBrowserVersion$a={primaryText:"",secondaryText:"",moreHelpLinkText:"",continueAnywayButtonText:""};var UnsupportedOperatingSystem$a={primaryText:" ",secondaryText:" ",moreHelpLinkText:""};var BrowserPermissionDenied$a={primaryText:"",secondaryText:"[] ",primaryButtonText:"",linkText:"? "};var BrowserPermissionDeniedIOS$a={primaryText:"",secondaryText:"",primaryButtonText:"",imageAltText:"iOS  ",linkText:"? ",step1Text:"",step2Text:"",step3Text:" ()",step4Text:"",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$a={leftNavButtonAriaLabel:"",rightNavButtonAriaLabel:""};var ja_JP$1 = {participantItem:participantItem$a,ParticipantList:ParticipantList$a,typingIndicator:typingIndicator$a,sendBox:sendBox$a,richTextSendBox:richTextSendBox$a,mentionPopover:mentionPopover$a,imageOverlay:imageOverlay$a,messageStatusIndicator:messageStatusIndicator$a,endCallButton:endCallButton$a,cameraButton:cameraButton$a,microphoneButton:microphoneButton$a,devicesButton:devicesButton$a,participantsButton:participantsButton$a,screenShareButton:screenShareButton$a,raiseHandButton:raiseHandButton$a,reactionButton:reactionButton$a,messageThread:messageThread$a,errorBar:errorBar$a,videoGallery:videoGallery$a,dialpad:dialpad$a,holdButton:holdButton$a,videoTile:videoTile$a,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$a,CameraSitePermissionsRequest:CameraSitePermissionsRequest$a,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$a,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$a,CameraSitePermissionsCheck:CameraSitePermissionsCheck$a,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$a,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$a,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$a,CameraSitePermissionsDenied:CameraSitePermissionsDenied$a,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$a,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$a,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$a,UnsupportedBrowser:UnsupportedBrowser$a,UnsupportedBrowserVersion:UnsupportedBrowserVersion$a,UnsupportedOperatingSystem:UnsupportedOperatingSystem$a,BrowserPermissionDenied:BrowserPermissionDenied$a,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$a,verticalGallery:verticalGallery$a};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Japanese (Japan).
 *
 * @public
 */
const COMPONENT_LOCALE_JA_JP = {
    strings: createComponentStrings(ja_JP$1)
};

var participantItem$9={isMeText:"()",menuTitle:" ",removeButtonLabel:"",sharingIconLabel:" ",mutedIconLabel:"",displayNamePlaceholder:"  ",participantStateRinging:"  ...",participantStateHold:" ",attendeeRole:""};var ParticipantList$9={overflowParticipantCount:"+{overflowCount}  "};var typingIndicator$9={singleUser:"{user}   ...",multipleUsers:"{users}   ...",multipleUsersAbbreviateOne:"{users}   1  ...",multipleUsersAbbreviateMany:"{users}   {numOthers}   ...",delimiter:"   "};var sendBox$9={placeholderText:" ",textTooLong:"    .",sendButtonAriaLabel:" ",fileUploadsPendingError:" ...   .",removeFile:" ",uploading:" ",uploadCompleted:" "};var richTextSendBox$9={placeholderText:" ",textTooLong:"    .",sendButtonAriaLabel:" ",fileUploadsPendingError:" ...   .",removeFile:" ",uploading:" ",uploadCompleted:" ",boldTooltip:"",italicTooltip:"",underlineTooltip:"",bulletListTooltip:"  ",numberListTooltip:"  ",increaseIndentTooltip:"",decreaseIndentTooltip:"",richTextFormatButtonTooltip:""};var mentionPopover$9={mentionPopoverHeader:""};var imageOverlay$9={downloadButtonLabel:"",dismissButtonAriaLabel:""};var messageStatusIndicator$9={deliveredAriaLabel:" ",deliveredTooltipText:"",seenAriaLabel:"   ",seenTooltipText:"",readByTooltipText:"{messageThreadReadCount}/{remoteParticipantsCount} ",sendingAriaLabel:"  ",sendingTooltipText:" ",failedToSendAriaLabel:"  ",failedToSendTooltipText:" "};var endCallButton$9={label:"",tooltipContent:" "};var cameraButton$9={onLabel:"",offLabel:"",tooltipDisabledContent:" ",tooltipOnContent:" ",tooltipOffContent:" ",tooltipVideoLoadingContent:"  .",cameraMenuTitle:"",cameraMenuTooltip:" ",cameraButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"      ",offSplitButtonAriaLabel:"    ",cameraActionTurnedOnAnnouncement:"  .",cameraActionTurnedOffAnnouncement:"  .",onSplitButtonPrimaryActionCamera:" ",offSplitButtonPrimaryActionCamera:" ",cameraPrimaryActionSplitButtonTitle:" ",videoEffectsMenuItemTitle:""};var microphoneButton$9={onLabel:"",offLabel:"",tooltipDisabledContent:" ",tooltipOnContent:" ",tooltipOffContent:"  ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:"",speakerMenuTooltip:" ",microphoneButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"    ",offSplitButtonAriaLabel:"     ",microphoneActionTurnedOnAnnouncement:"  .",microphoneActionTurnedOffAnnouncement:"  .",offSplitButtonMicrophonePrimaryAction:"  ",onSplitButtonMicrophonePrimaryAction:" ",microphonePrimaryActionSplitButtonTitle:" "};var devicesButton$9={label:"",tooltipContent:" ",cameraMenuTitle:"",cameraMenuTooltip:" ",audioDeviceMenuTitle:" ",audioDeviceMenuTooltip:"  ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:"",speakerMenuTooltip:" "};var participantsButton$9={label:"",tooltipContent:" ",menuHeader:" ",participantsListButtonLabel:"{numParticipants}",muteAllButtonLabel:" ",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"  "};var screenShareButton$9={onLabel:" ",offLabel:"",tooltipDisabledContent:"   ",tooltipOnContent:"  ",tooltipOffContent:" "};var raiseHandButton$9={offLabel:" ",onLabel:"",tooltipDisabledContent:"   .",tooltipOnContent:" ",tooltipOffContent:" "};var reactionButton$9={label:"",ariaLabel:" ,  ",tooltipDisabledContent:"    .",tooltipContent:" ",likeReactionTooltipContent:"",heartReactionTooltipContent:"",laughReactionTooltipContent:"  ",applauseReactionTooltipContent:"",surprisedReactionTooltipContent:" "};var messageThread$9={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:" .",participantLeft:"  .",editMessage:"",removeMessage:"",resendMessage:"  ",failToSendTag:" ",editedTag:"",liveAuthorIntro:"{author}  .",messageContentAriaText:"{author}  {message}() .",messageContentMineAriaText:" {message}() .",editBoxTextLimit:" {limitNumber}   .",editBoxPlaceholderText:" ",newMessagesIndicator:" ",noDisplayNameSub:" ",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:"{messageReadByCount}/{remoteParticipantsCount} ",actionMenuMoreOptions:" ",downloadFile:" ",blockedWarningText:"     .",blockedWarningLinkText:" ",fileCardGroupMessage:" {fileCount}   ",messageDeletedAnnouncementAriaLabel:" ."};var errorBar$9={unableToReachChatService:" .",accessDenied:"    .     .",userNotInChatThread:"     .",sendMessageNotInChatThread:"         .",sendMessageGeneric:"  ",callingNetworkFailure:"   -    .",startVideoGeneric:"  ",stopVideoGeneric:"  ",muteGeneric:"  ",unmuteGeneric:"   ",speakingWhileMuted:" ",startScreenShareGeneric:"     .",stopScreenShareGeneric:"   ",callNetworkQualityLow:"  .",callNoSpeakerFound:"     .       .",callNoMicrophoneFound:"   .    .",callMicrophoneAccessDenied:"   .         .",callMicrophoneAccessDeniedSafari:"   .                  .",callMicrophoneMutedBySystem:"  .",callMicrophoneUnmutedBySystem:"    .",callMacOsMicrophoneAccessDenied:"   . macOS      .",callLocalVideoFreeze:"  .          .",callCameraAccessDenied:"   .         .",callCameraAccessDeniedSafari:"   .                  .",callCameraAlreadyInUse:"   .        .",callVideoStoppedBySystem:"   .",callVideoRecoveredBySystem:"  .",callMacOsCameraAccessDenied:"MacOS     .          .",callMacOsScreenShareAccessDenied:"MacOS    .          .",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"  .",failedToJoinCallInvalidMeetingLink:"   .  .",cameraFrozenForRemoteParticipants:"       .   .",unableToStartVideoEffect:"    .",startSpotlightWhileMaxParticipantsAreSpotlighted:"         ."};var videoGallery$9={screenIsBeingSharedMessage:"  .",screenShareLoadingMessage:"{participant}    ",localVideoLabel:"",localVideoCameraSwitcherLabel:" ",localVideoMovementLabel:"    ",localVideoSelectedDescription:"{cameraName} ",displayNamePlaceholder:"  ",fitRemoteParticipantToFrame:" ",fillRemoteParticipantFrame:" ",pinParticipantForMe:"",pinParticipantForMeLimitReached:"  ",unpinParticipantForMe:" ",pinParticipantMenuItemAriaLabel:"{participantName} ",unpinParticipantMenuItemAriaLabel:"{participantName}  ",pinnedParticipantAnnouncementAriaLabel:"{participantName} ",unpinnedParticipantAnnouncementAriaLabel:"{participantName}  ",startSpotlightVideoTileMenuLabel:"  ",addSpotlightVideoTileMenuLabel:" ",spotlightLimitReachedMenuTitle:"  ",stopSpotlightVideoTileMenuLabel:" ",stopSpotlightOnSelfVideoTileMenuLabel:" ",attendeeRole:""};var dialpad$9={placeholderText:"  .",deleteButtonAriaLabel:""};var holdButton$9={onLabel:"",offLabel:"",tooltipOnContent:" ",tooltipOffContent:" "};var videoTile$9={participantStateRinging:"  ...",participantStateHold:" "};var CameraAndMicrophoneSitePermissionsRequest$9={primaryText:"{appName}     ",secondaryText:"      .",linkText:" ?    ",primaryButtonText:"    ",ariaLabel:"    "};var CameraSitePermissionsRequest$9={primaryText:"{appName}   ",secondaryText:"     .",linkText:" ?    ",primaryButtonText:"  ",ariaLabel:"  "};var MicrophoneSitePermissionsRequest$9={primaryText:"{appName}   ",secondaryText:"      .",linkText:" ?    ",primaryButtonText:"  ",ariaLabel:"  "};var CameraAndMicrophoneSitePermissionsCheck$9={primaryText:"     ",secondaryText:"   .       .",linkText:" ?    ",primaryButtonText:"    ",ariaLabel:"     .    ."};var CameraSitePermissionsCheck$9={primaryText:"   ",secondaryText:"   .      .",linkText:" ?    ",primaryButtonText:"  ",ariaLabel:"   .    ."};var MicrophoneSitePermissionsCheck$9={primaryText:"   ",secondaryText:"   .     .",linkText:" ?    ",primaryButtonText:"  ",ariaLabel:"   .    ."};var CameraAndMicrophoneSitePermissionsDenied$9={primaryText:"     ",secondaryText:"          .      .",primaryButtonText:"    ",linkText:" ?    "};var CameraAndMicrophoneSitePermissionsDeniedSafari$9={primaryText:"     ",secondaryText:"                 .",primaryButtonText:"    ",linkText:" ?    "};var CameraSitePermissionsDenied$9={primaryText:"   ",secondaryText:"          .      .",primaryButtonText:"  ",linkText:" ?    "};var MicrophoneSitePermissionsDenied$9={primaryText:"   ",secondaryText:"          .      .",primaryButtonText:"  ",linkText:" ?    "};var CameraSitePermissionsDeniedSafari$9={primaryText:"   ",secondaryText:"                 .",primaryButtonText:"  ",linkText:" ?    "};var MicrophoneSitePermissionsDeniedSafari$9={primaryText:"   ",secondaryText:"                 .",primaryButtonText:"  ",linkText:" ?    "};var UnsupportedBrowser$9={primaryText:"  ",secondaryText:"     .",moreHelpLinkText:"   "};var UnsupportedBrowserVersion$9={primaryText:"  ",secondaryText:"         .",moreHelpLinkText:"   ",continueAnywayButtonText:"   "};var UnsupportedOperatingSystem$9={primaryText:"   ",secondaryText:"        .",moreHelpLinkText:"   "};var BrowserPermissionDenied$9={primaryText:"     ",secondaryText:"        .       .",primaryButtonText:" ",linkText:" ?    "};var BrowserPermissionDeniedIOS$9={primaryText:"   ",secondaryText:"       .",primaryButtonText:" ",imageAltText:"iOS      ",linkText:" ?    ",step1Text:"  .",step2Text:"   Scroll down",step3Text:" (  )",step4Text:"   .",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$9={leftNavButtonAriaLabel:" ",rightNavButtonAriaLabel:" "};var ko_KR$1 = {participantItem:participantItem$9,ParticipantList:ParticipantList$9,typingIndicator:typingIndicator$9,sendBox:sendBox$9,richTextSendBox:richTextSendBox$9,mentionPopover:mentionPopover$9,imageOverlay:imageOverlay$9,messageStatusIndicator:messageStatusIndicator$9,endCallButton:endCallButton$9,cameraButton:cameraButton$9,microphoneButton:microphoneButton$9,devicesButton:devicesButton$9,participantsButton:participantsButton$9,screenShareButton:screenShareButton$9,raiseHandButton:raiseHandButton$9,reactionButton:reactionButton$9,messageThread:messageThread$9,errorBar:errorBar$9,videoGallery:videoGallery$9,dialpad:dialpad$9,holdButton:holdButton$9,videoTile:videoTile$9,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$9,CameraSitePermissionsRequest:CameraSitePermissionsRequest$9,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$9,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$9,CameraSitePermissionsCheck:CameraSitePermissionsCheck$9,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$9,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$9,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$9,CameraSitePermissionsDenied:CameraSitePermissionsDenied$9,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$9,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$9,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$9,UnsupportedBrowser:UnsupportedBrowser$9,UnsupportedBrowserVersion:UnsupportedBrowserVersion$9,UnsupportedOperatingSystem:UnsupportedOperatingSystem$9,BrowserPermissionDenied:BrowserPermissionDenied$9,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$9,verticalGallery:verticalGallery$9};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Korean (South Korea).
 *
 * @public
 */
const COMPONENT_LOCALE_KO_KR = {
    strings: createComponentStrings(ko_KR$1)
};

var participantItem$8={isMeText:"(deg)",menuTitle:"Flere alternativer",removeButtonLabel:"Fjern",sharingIconLabel:"Deling",mutedIconLabel:"Dempet",displayNamePlaceholder:"Deltaker uten navn",participantStateRinging:"Ringer ...",participantStateHold:"P vent",attendeeRole:"Deltaker"};var ParticipantList$8={overflowParticipantCount:"+{overflowCount} flere"};var typingIndicator$8={singleUser:"{user} skriver ...",multipleUsers:"{users} skriver ...",multipleUsersAbbreviateOne:"{users} og 1 annen skriver ...",multipleUsersAbbreviateMany:"{users} og {numOthers} andre skriver ...",delimiter:", "};var sendBox$8={placeholderText:"Skriv en melding",textTooLong:"Meldingslengden er over maksimumsgrensen.",sendButtonAriaLabel:"Send melding",fileUploadsPendingError:"Laster opp. Vent litt ...",removeFile:"Fjern fil",uploading:"Laster opp",uploadCompleted:"Opplasting fullfrt"};var richTextSendBox$8={placeholderText:"Skriv en melding",textTooLong:"Meldingslengden er over maksimumsgrensen.",sendButtonAriaLabel:"Send melding",fileUploadsPendingError:"Laster opp ... Vent litt.",removeFile:"Fjern fil",uploading:"Laster opp",uploadCompleted:"Opplasting fullfrt",boldTooltip:"Fet",italicTooltip:"Kursiv",underlineTooltip:"Understreking",bulletListTooltip:"Punktliste",numberListTooltip:"Nummerert liste",increaseIndentTooltip:"k innrykk",decreaseIndentTooltip:"Reduser innrykk",richTextFormatButtonTooltip:"Format"};var mentionPopover$8={mentionPopoverHeader:"Forslag"};var imageOverlay$8={downloadButtonLabel:"Last ned",dismissButtonAriaLabel:"Lukk"};var messageStatusIndicator$8={deliveredAriaLabel:"Melding sendt",deliveredTooltipText:"Sendt",seenAriaLabel:"Melding sett av andre",seenTooltipText:"Sett",readByTooltipText:"Lest av {messageThreadReadCount} av {remoteParticipantsCount}",sendingAriaLabel:"Sending av melding",sendingTooltipText:"Sender",failedToSendAriaLabel:"Melding ikke sendt",failedToSendTooltipText:"Kan ikke sende"};var endCallButton$8={label:"Forlat",tooltipContent:"Forlat samtale"};var cameraButton$8={onLabel:"Kamera",offLabel:"Kamera",tooltipDisabledContent:"Kameraet er deaktivert",tooltipOnContent:"Sl av kamera",tooltipOffContent:"Sl p kamera",tooltipVideoLoadingContent:"Videoen lastes inn",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Velg kamera",cameraButtonSplitRoleDescription:"Rullegardinknapp",onSplitButtonAriaLabel:"Sl av kamera og kameraalternativer",offSplitButtonAriaLabel:"Sl p kamera og kameraalternativer",cameraActionTurnedOnAnnouncement:"Kameraet er sltt p",cameraActionTurnedOffAnnouncement:"Kameraet er sltt av.",onSplitButtonPrimaryActionCamera:"Sl av kamera",offSplitButtonPrimaryActionCamera:"Sl p kamera",cameraPrimaryActionSplitButtonTitle:"Bruk kamera",videoEffectsMenuItemTitle:"Effekter"};var microphoneButton$8={onLabel:"Mikrofon",offLabel:"Mikrofon",tooltipDisabledContent:"Mikrofonen er deaktivert",tooltipOnContent:"Demp mikrofon",tooltipOffContent:"Opphev demping av mikrofon",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Velg mikrofon",speakerMenuTitle:"Hyttaler",speakerMenuTooltip:"Velg hyttaler",microphoneButtonSplitRoleDescription:"Rullegardinknapp",onSplitButtonAriaLabel:"Demp mikrofon og lydalternativer",offSplitButtonAriaLabel:"Opphev demping av mikrofon og lydalternativer",microphoneActionTurnedOnAnnouncement:"Mikrofonen er sltt p",microphoneActionTurnedOffAnnouncement:"Mikrofonen er sltt av",offSplitButtonMicrophonePrimaryAction:"Opphev demping av mikrofon",onSplitButtonMicrophonePrimaryAction:"Demp mikrofon",microphonePrimaryActionSplitButtonTitle:"Bruk mikrofon"};var devicesButton$8={label:"Enheter",tooltipContent:"Administrer enheter",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Velg kamera",audioDeviceMenuTitle:"Lydenhet",audioDeviceMenuTooltip:"Velg lydenhet",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Velg mikrofon",speakerMenuTitle:"Hyttaler",speakerMenuTooltip:"Velg hyttaler"};var participantsButton$8={label:"Personer",tooltipContent:"Vis deltakere",menuHeader:"I denne samtalen",participantsListButtonLabel:"{numParticipants} personer",muteAllButtonLabel:"Demp alle",copyInviteLinkButtonLabel:"Kopier invitasjonskobling",copyInviteLinkActionedAriaLabel:"Invitasjonskobling er kopiert"};var screenShareButton$8={onLabel:"Stopp presentasjon",offLabel:"Presenter",tooltipDisabledContent:"Presentasjon er deaktivert",tooltipOnContent:"Presenterer skjermen din",tooltipOffContent:"Presenter skjermen din"};var raiseHandButton$8={offLabel:"Rekk opp",onLabel:"Ta ned",tooltipDisabledContent:"Rekk opp hnden-handlingen er deaktivert",tooltipOnContent:"Ta ned hnden",tooltipOffContent:"Rekke opp hnden"};var reactionButton$8={label:"Reager",ariaLabel:"Reager-knapp, send en reaksjon",tooltipDisabledContent:"Reaksjonshandling er deaktivert",tooltipContent:"Send en reaksjon",likeReactionTooltipContent:"Liker",heartReactionTooltipContent:"Kjrlighet",laughReactionTooltipContent:"Latter",applauseReactionTooltipContent:"Applaus",surprisedReactionTooltipContent:"Overrasket"};var messageThread$8={yesterday:"I gr",sunday:"Sndag",monday:"Mandag",tuesday:"Tirsdag",wednesday:"Onsdag",thursday:"Torsdag",friday:"Fredag",saturday:"Lrdag",participantJoined:"ble med i chatten.",participantLeft:"forlot chatten.",editMessage:"Rediger",removeMessage:"Slett",resendMessage:"Prv  sende p nytt",failToSendTag:"Kan ikke sende",editedTag:"Redigert",liveAuthorIntro:"{author} sier",messageContentAriaText:"{author} sa {message}",messageContentMineAriaText:"Du sa {message}",editBoxTextLimit:"Meldingen er over grensen p {limitNumber} tegn",editBoxPlaceholderText:"Rediger meldingen",newMessagesIndicator:"Nye meldinger",noDisplayNameSub:"Uten navn",editBoxCancelButton:"Avbryt",editBoxSubmitButton:"Fullfrt",messageReadCount:"Lest av {messageReadByCount} av {remoteParticipantsCount}",actionMenuMoreOptions:"Flere alternativer",downloadFile:"Last ned fil",blockedWarningText:"Denne meldingen ble slettet p grunn av en organisasjonspolicy.",blockedWarningLinkText:"Detaljer",fileCardGroupMessage:"Meldingen har {fileCount} vedlegg",messageDeletedAnnouncementAriaLabel:"Meldingen er slettet"};var errorBar$8={unableToReachChatService:"Du er frakoblet",accessDenied:"Fr ikke tilgang til chattjenester. Kontroller brukerlegitimasjonen som er angitt",userNotInChatThread:"Du er ikke lenger i denne chattetrden",sendMessageNotInChatThread:"Kan ikke sende meldingen fordi du ikke lenger er i denne chattetrden",sendMessageGeneric:"Kan ikke sende meldingen",callingNetworkFailure:"Problemer med  koble til samtalen  du ser ut til  vre frakoblet",startVideoGeneric:"Kan ikke starte video",stopVideoGeneric:"Kan ikke stoppe video",muteGeneric:"Kan ikke dempe mikrofonen",unmuteGeneric:"Kan ikke oppheve demping av mikrofon",speakingWhileMuted:"Mikrofonen er dempet",startScreenShareGeneric:"Det oppstod et problem under start av skjermdeling.",stopScreenShareGeneric:"Kan ikke stoppe skjermdeling",callNetworkQualityLow:"Nettverkskvaliteten er lav.",callNoSpeakerFound:"Finner ingen hyttalere eller hodetelefoner. Koble til en lydenhet for  hre samtalen.",callNoMicrophoneFound:"Finner ingen mikrofoner. Koble til en lydinndataenhet.",callMicrophoneAccessDenied:"Fr ikke tilgang til mikrofonen. Klikk lsen i adresselinjen for  gi tillatelse til denne nettsiden.",callMicrophoneAccessDeniedSafari:"Fr ikke tilgang til mikrofonen. Oppdater siden for  tillate tillatelser, eller kontroller innstillingene for denne nettleseren og kontroller at tillatelser er aktivert for dette nettstedet.",callMicrophoneMutedBySystem:"Du er dempet av systemet.",callMicrophoneUnmutedBySystem:"Mikrofonen ble gjenopprettet, og dempingen ble opphevet av systemet.",callMacOsMicrophoneAccessDenied:"Fr ikke tilgang til mikrofonen. Gi mikrofontillatelse i personverninnstillingene for macOS.",callLocalVideoFreeze:"Nettverksbndbredden er drlig. Videoen kan vre midlertidig stanset for andre i samtalen.",callCameraAccessDenied:"Fr ikke tilgang til kameraet. Klikk lsen i adresselinjen for  gi tillatelse til denne nettsiden.",callCameraAccessDeniedSafari:"Fr ikke tilgang til kameraet. Oppdater siden for  tillate tillatelser, eller kontroller innstillingene for denne nettleseren og kontroller at tillatelser er aktivert for dette nettstedet.",callCameraAlreadyInUse:"Fr ikke tilgang til kameraet. Det kan allerede vre i bruk av et annet program.",callVideoStoppedBySystem:"Videoen er stoppet av systemet.",callVideoRecoveredBySystem:"Videoen er gjenopptatt.",callMacOsCameraAccessDenied:"MacOS blokkerer tilgang til kameraet. Oppdater personverninnstillingene for  gi denne nettleseren tilgang til kameraet.",callMacOsScreenShareAccessDenied:"MacOS blokkerer skjermdeling. Oppdater personverninnstillingene for  tillate at denne nettleseren registrerer skjermen.",dismissButtonAriaLabel:"Lukk",failedToJoinCallGeneric:"Kan ikke bli med i samtalen.",failedToJoinCallInvalidMeetingLink:"Kan ikke bli med i mtet. Ugyldig kobling.",cameraFrozenForRemoteParticipants:"Brukere i samtalen har problemer med  se videoen. Kontroller enhetene og nettverket.",unableToStartVideoEffect:"Kan ikke bruke videoeffekt.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Kan ikke starte rampelys p deltaker(e) fordi maksimalt antall deltakere allerede er satt i rampelyset."};var videoGallery$8={screenIsBeingSharedMessage:"Du deler skjermen",screenShareLoadingMessage:"Laster inn skjermen til {participant}",localVideoLabel:"Du",localVideoCameraSwitcherLabel:"Bytt kamera",localVideoMovementLabel:"Flyttbar lokal videoflis",localVideoSelectedDescription:"{cameraName} valgt",displayNamePlaceholder:"Deltaker uten navn",fitRemoteParticipantToFrame:"Tilpass til ramme",fillRemoteParticipantFrame:"Fyll ramme",pinParticipantForMe:"Fest for meg",pinParticipantForMeLimitReached:"Pin-kode (grense ndd)",unpinParticipantForMe:"Lsne",pinParticipantMenuItemAriaLabel:"Fest {participantName}",unpinParticipantMenuItemAriaLabel:"Lsne {participantName}",pinnedParticipantAnnouncementAriaLabel:"Festet {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Lsnet {participantName}",startSpotlightVideoTileMenuLabel:"Sett i rampelyset for alle",addSpotlightVideoTileMenuLabel:"Legg til rampelys",spotlightLimitReachedMenuTitle:"Rampelys-grensen er ndd",stopSpotlightVideoTileMenuLabel:"Fjern fra rampelyset",stopSpotlightOnSelfVideoTileMenuLabel:"Rampelys av",attendeeRole:"Deltaker"};var dialpad$8={placeholderText:"Skriv inn telefonnummeret",deleteButtonAriaLabel:"Slett"};var holdButton$8={onLabel:"Fortsett",offLabel:"Vent",tooltipOnContent:"Fortsett samtale",tooltipOffContent:"Sett samtalen p vent"};var videoTile$8={participantStateRinging:"Ringer ...",participantStateHold:"P vent"};var CameraAndMicrophoneSitePermissionsRequest$8={primaryText:"Tillat {appName}  bruke kameraet og mikrofonen",secondaryText:"Dette er for at deltakerne skal kunne se og hre deg.",linkText:"Trenger du hjelp? F hjelp til feilsking",primaryButtonText:"Fortsett uten kamera og mikrofon",ariaLabel:"Gi tilgang til kamera og mikrofon"};var CameraSitePermissionsRequest$8={primaryText:"Tillat at {appName} bruker kameraet",secondaryText:"Dette er for at deltakerne skal kunne se deg.",linkText:"Trenger du hjelp? F hjelp til feilsking",primaryButtonText:"Fortsett uten kamera",ariaLabel:"Gi kameratilgang"};var MicrophoneSitePermissionsRequest$8={primaryText:"Tillat at {appName} bruker mikrofonen",secondaryText:"Dette er for at deltakerne skal kunne hre deg.",linkText:"Trenger du hjelp? F hjelp til feilsking",primaryButtonText:"Fortsett uten mikrofon",ariaLabel:"Tillat mikrofontilgang"};var CameraAndMicrophoneSitePermissionsCheck$8={primaryText:"Ser etter tilgang til kamera og mikrofon",secondaryText:"Gi tilgang hvis du blir bedt om det. Dette er slik at deltakerne kan se og hre deg.",linkText:"Trenger du hjelp? F hjelp til feilsking",primaryButtonText:"Fortsett uten kamera og mikrofon",ariaLabel:"Ser etter tilgang til kamera og mikrofon. Gi tilgang hvis du blir bedt om det."};var CameraSitePermissionsCheck$8={primaryText:"Ser etter kameratilgang",secondaryText:"Gi tilgang hvis du blir bedt om det. Dette er slik at deltakerne kan se deg.",linkText:"Trenger du hjelp? F hjelp til feilsking",primaryButtonText:"Fortsett uten kamera",ariaLabel:"Ser etter kameratilgang. Gi tilgang hvis du blir bedt om det."};var MicrophoneSitePermissionsCheck$8={primaryText:"Ser etter mikrofontilgang",secondaryText:"Gi tilgang hvis du blir bedt om det. Dette er slik at deltakerne kan hre deg.",linkText:"Trenger du hjelp? F hjelp til feilsking",primaryButtonText:"Fortsett uten mikrofon",ariaLabel:"Ser etter mikrofontilgang. Gi tilgang hvis du blir bedt om det."};var CameraAndMicrophoneSitePermissionsDenied$8={primaryText:"Fr ikke tilgang til kamera og mikrofon",secondaryText:"Klikk p lseikonet i adresselinjen for  gi mikrofontillatelser til denne nettsiden. En sideoppdatering kan vre ndvendig.",primaryButtonText:"Fortsett uten kamera og mikrofon",linkText:"Trenger du hjelp? F hjelp til feilsking"};var CameraAndMicrophoneSitePermissionsDeniedSafari$8={primaryText:"Fr ikke tilgang til kamera og mikrofon",secondaryText:"Oppdater siden for  tillate tillatelser, eller kontroller innstillingene for denne nettleseren og kontroller at tillatelser er aktivert for dette nettstedet.",primaryButtonText:"Fortsett uten kamera og mikrofon",linkText:"Trenger du hjelp? F hjelp til feilsking"};var CameraSitePermissionsDenied$8={primaryText:"Fr ikke tilgang til kamera",secondaryText:"Klikk p lseikonet p adresselinjen for  gi kameratillatelser til denne nettsiden. En sideoppdatering kan vre ndvendig.",primaryButtonText:"Fortsett uten kamera",linkText:"Trenger du hjelp? F hjelp til feilsking"};var MicrophoneSitePermissionsDenied$8={primaryText:"Fr ikke tilgang til mikrofonen",secondaryText:"Klikk p lseikonet i adresselinjen for  gi mikrofontillatelser til denne nettsiden. En sideoppdatering kan vre ndvendig.",primaryButtonText:"Fortsett uten mikrofon",linkText:"Trenger du hjelp? F hjelp til feilsking"};var CameraSitePermissionsDeniedSafari$8={primaryText:"Fr ikke tilgang til kamera",secondaryText:"Oppdater siden for  tillate tillatelser, eller kontroller innstillingene for denne nettleseren og kontroller at tillatelser er aktivert for dette nettstedet.",primaryButtonText:"Fortsett uten kamera",linkText:"Trenger du hjelp? F hjelp til feilsking"};var MicrophoneSitePermissionsDeniedSafari$8={primaryText:"Fr ikke tilgang til mikrofonen",secondaryText:"Oppdater siden for  tillate tillatelser, eller kontroller innstillingene for denne nettleseren og kontroller at tillatelser er aktivert for dette nettstedet.",primaryButtonText:"Fortsett uten mikrofon",linkText:"Trenger du hjelp? F hjelp til feilsking"};var UnsupportedBrowser$8={primaryText:"Nettleseren stttes ikke",secondaryText:"Bli med i denne samtalen ved hjelp av en kompatibel nettleser.",moreHelpLinkText:"Se kompatibilitetskrav"};var UnsupportedBrowserVersion$8={primaryText:"Nettleseroppdatering kreves",secondaryText:"Hvis du vil sikre best mulig samtale, m du oppdatere nettleseren og deretter prve  bli med i samtalen p nytt.",moreHelpLinkText:"Se kompatibilitetskrav",continueAnywayButtonText:"Start anrop uten  oppdatere"};var UnsupportedOperatingSystem$8={primaryText:"Operativsystem stttes ikke",secondaryText:"Bli med i denne samtalen ved hjelp av en enhet med et kompatibelt operativsystem.",moreHelpLinkText:"Se kompatibilitetskrav"};var BrowserPermissionDenied$8={primaryText:"Kan ikke bruke kameraet eller mikrofonen",secondaryText:"Nettleseren har kanskje ikke tilgang til kameraet eller mikrofonen. pne Systemvalg for  lse dette problemet.",primaryButtonText:"Prv p nytt",linkText:"Trenger du hjelp? F hjelp til feilsking"};var BrowserPermissionDeniedIOS$8={primaryText:"Gi mikrofontilgang for  fortsette",secondaryText:"Slik at andre deltakere kan hre deg.",primaryButtonText:"Prv p nytt",imageAltText:"Plassering av mikrofon- og kameraenhetstillatelse for iOS",linkText:"Trenger du hjelp? F hjelp til feilsking",step1Text:"G til Innstillinger-appen",step2Text:"Rull ned til innstillinger for denne nettleseren",step3Text:"Sl p mikrofon (kamera valgfritt)",step4Text:"Prv  bli med i samtalen p nytt",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$8={leftNavButtonAriaLabel:"forrige side",rightNavButtonAriaLabel:"neste side"};var nb_NO$1 = {participantItem:participantItem$8,ParticipantList:ParticipantList$8,typingIndicator:typingIndicator$8,sendBox:sendBox$8,richTextSendBox:richTextSendBox$8,mentionPopover:mentionPopover$8,imageOverlay:imageOverlay$8,messageStatusIndicator:messageStatusIndicator$8,endCallButton:endCallButton$8,cameraButton:cameraButton$8,microphoneButton:microphoneButton$8,devicesButton:devicesButton$8,participantsButton:participantsButton$8,screenShareButton:screenShareButton$8,raiseHandButton:raiseHandButton$8,reactionButton:reactionButton$8,messageThread:messageThread$8,errorBar:errorBar$8,videoGallery:videoGallery$8,dialpad:dialpad$8,holdButton:holdButton$8,videoTile:videoTile$8,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$8,CameraSitePermissionsRequest:CameraSitePermissionsRequest$8,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$8,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$8,CameraSitePermissionsCheck:CameraSitePermissionsCheck$8,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$8,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$8,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$8,CameraSitePermissionsDenied:CameraSitePermissionsDenied$8,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$8,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$8,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$8,UnsupportedBrowser:UnsupportedBrowser$8,UnsupportedBrowserVersion:UnsupportedBrowserVersion$8,UnsupportedOperatingSystem:UnsupportedOperatingSystem$8,BrowserPermissionDenied:BrowserPermissionDenied$8,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$8,verticalGallery:verticalGallery$8};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Norwegian Bokml (Norway) .
 *
 * @public
 */
const COMPONENT_LOCALE_NB_NO = {
    strings: createComponentStrings(nb_NO$1)
};

var participantItem$7={isMeText:"(jij)",menuTitle:"Meer opties",removeButtonLabel:"Verwijderen",sharingIconLabel:"Delen",mutedIconLabel:"Gedempt",displayNamePlaceholder:"Naamloze deelnemer",participantStateRinging:"Bellen...",participantStateHold:"In de wacht",attendeeRole:"Genodigde"};var ParticipantList$7={overflowParticipantCount:"+{overflowCount} meer"};var typingIndicator$7={singleUser:"{user} typt ...",multipleUsers:"{users} typen ...",multipleUsersAbbreviateOne:"{users} en 1 andere persoon typen ...",multipleUsersAbbreviateMany:"{users} en {numOthers} anderen typen ...",delimiter:", "};var sendBox$7={placeholderText:"Een bericht invoeren",textTooLong:"De lengte van uw bericht overschrijdt de maximumlimiet.",sendButtonAriaLabel:"Bericht verzenden",fileUploadsPendingError:"Uploaden.... Een ogenblik geduld.",removeFile:"Bestand verwijderen",uploading:"Uploaden",uploadCompleted:"Upload voltooid"};var richTextSendBox$7={placeholderText:"Een bericht invoeren",textTooLong:"De lengte van uw bericht overschrijdt de maximumlimiet.",sendButtonAriaLabel:"Bericht verzenden",fileUploadsPendingError:"Uploaden... Een ogenblik geduld.",removeFile:"Bestand verwijderen",uploading:"Uploaden",uploadCompleted:"Upload voltooid",boldTooltip:"Vet",italicTooltip:"Cursief",underlineTooltip:"Onderstrepen",bulletListTooltip:"Lijst met opsommingstekens",numberListTooltip:"Genummerde lijst",increaseIndentTooltip:"Inspringing vergroten",decreaseIndentTooltip:"Inspringing verkleinen",richTextFormatButtonTooltip:"Indeling"};var mentionPopover$7={mentionPopoverHeader:"Suggesties"};var imageOverlay$7={downloadButtonLabel:"Downloaden",dismissButtonAriaLabel:"Sluiten"};var messageStatusIndicator$7={deliveredAriaLabel:"Bericht verzonden",deliveredTooltipText:"Verzonden",seenAriaLabel:"Bericht gezien door anderen",seenTooltipText:"Gezien",readByTooltipText:"Gelezen door {messageThreadReadCount} van {remoteParticipantsCount}",sendingAriaLabel:"Bericht verzenden",sendingTooltipText:"Verzenden",failedToSendAriaLabel:"Het bericht is niet verzonden",failedToSendTooltipText:"Kan niet verzenden"};var endCallButton$7={label:"Verlaten",tooltipContent:"Gesprek verlaten"};var cameraButton$7={onLabel:"Camera",offLabel:"Camera",tooltipDisabledContent:"Camera is uitgeschakeld",tooltipOnContent:"Camera uitschakelen",tooltipOffContent:"Camera inschakelen",tooltipVideoLoadingContent:"Video wordt geladen",cameraMenuTitle:"Camera",cameraMenuTooltip:"Camera kiezen",cameraButtonSplitRoleDescription:"Knop Splitsen",onSplitButtonAriaLabel:"Camera- en cameraopties uitschakelen",offSplitButtonAriaLabel:"Camera- en cameraopties inschakelen",cameraActionTurnedOnAnnouncement:"Uw camera is ingeschakeld",cameraActionTurnedOffAnnouncement:"Uw camera is uitgeschakeld",onSplitButtonPrimaryActionCamera:"Camera uitschakelen",offSplitButtonPrimaryActionCamera:"Camera inschakelen",cameraPrimaryActionSplitButtonTitle:"Camera gebruiken",videoEffectsMenuItemTitle:"Effecten"};var microphoneButton$7={onLabel:"Microfoon",offLabel:"Microfoon",tooltipDisabledContent:"Microfoon is uitgeschakeld",tooltipOnContent:"Microfoon uitschakelen",tooltipOffContent:"Microfoon inschakelen",microphoneMenuTitle:"Microfoon",microphoneMenuTooltip:"Microfoon kiezen",speakerMenuTitle:"Luidspreker",speakerMenuTooltip:"Luidspreker kiezen",microphoneButtonSplitRoleDescription:"Knop Splitsen",onSplitButtonAriaLabel:"Microfoon- en audioopties dempen",offSplitButtonAriaLabel:"Microfoon- en audioopties dempen opheffen",microphoneActionTurnedOnAnnouncement:"Uw microfoon is ingeschakeld",microphoneActionTurnedOffAnnouncement:"Uw microfoon is uitgeschakeld",offSplitButtonMicrophonePrimaryAction:"Microfoon inschakelen",onSplitButtonMicrophonePrimaryAction:"Microfoon uitschakelen",microphonePrimaryActionSplitButtonTitle:"Microfoon gebruiken"};var devicesButton$7={label:"Apparaten",tooltipContent:"Apparaten beheren",cameraMenuTitle:"Camera",cameraMenuTooltip:"Camera kiezen",audioDeviceMenuTitle:"Audioapparaat",audioDeviceMenuTooltip:"Audioapparaat kiezen",microphoneMenuTitle:"Microfoon",microphoneMenuTooltip:"Microfoon kiezen",speakerMenuTitle:"Spreker",speakerMenuTooltip:"Luidspreker kiezen"};var participantsButton$7={label:"Personen",tooltipContent:"Deelnemers weergeven",menuHeader:"In dit gesprek",participantsListButtonLabel:"{numParticipants} personen",muteAllButtonLabel:"Alles dempen",copyInviteLinkButtonLabel:"Uitnodigingskoppeling kopiren",copyInviteLinkActionedAriaLabel:"Uitnodigingskoppeling gekopieerd"};var screenShareButton$7={onLabel:"Presenteren stoppen",offLabel:"Presenteren",tooltipDisabledContent:"Presenteren is uitgeschakeld",tooltipOnContent:"Uw scherm presenteren",tooltipOffContent:"Uw scherm presenteren"};var raiseHandButton$7={offLabel:"Opsteken",onLabel:"Laten zakken",tooltipDisabledContent:"Actie Hand opsteken is uitgeschakeld",tooltipOnContent:"Hand laten zakken",tooltipOffContent:"Hand opsteken"};var reactionButton$7={label:"Reageren",ariaLabel:"Knop Regageren, een reactie verzenden",tooltipDisabledContent:"Reactieactie is uitgeschakeld",tooltipContent:"Verzend een reactie",likeReactionTooltipContent:"Vind ik leuk",heartReactionTooltipContent:"Hartje",laughReactionTooltipContent:"Lachen",applauseReactionTooltipContent:"Applaus",surprisedReactionTooltipContent:"Verrast"};var messageThread$7={yesterday:"Gisteren",sunday:"Zondag",monday:"Maandag",tuesday:"Dinsdag",wednesday:"Woensdag",thursday:"Donderdag",friday:"Vrijdag",saturday:"Zaterdag",participantJoined:"neemt nu deel aan de chat.",participantLeft:"heeft de chat verlaten.",editMessage:"Bewerken",removeMessage:"Verwijderen",resendMessage:"Probeer opnieuw te verzenden",failToSendTag:"Verzenden mislukt",editedTag:"Bewerkt",liveAuthorIntro:"{author} zegt",messageContentAriaText:"{author} zei {message}",messageContentMineAriaText:"U zei: {message}",editBoxTextLimit:"Uw bericht heeft de limiet van {limitNumber} tekens overschreden",editBoxPlaceholderText:"Uw bericht bewerken",newMessagesIndicator:"Nieuwe berichten",noDisplayNameSub:"Geen naam",editBoxCancelButton:"Annuleren",editBoxSubmitButton:"Gereed",messageReadCount:"Gelezen door {messageReadByCount} van {remoteParticipantsCount}",actionMenuMoreOptions:"Meer opties",downloadFile:"Bestand downloaden",blockedWarningText:"Dit bericht is verwijderd vanwege organisatiebeleid.",blockedWarningLinkText:"Details",fileCardGroupMessage:"Het bericht heeft {fileCount} bijlage",messageDeletedAnnouncementAriaLabel:"Het bericht is verwijderd"};var errorBar$7={unableToReachChatService:"U bent offline",accessDenied:"Kan geen toegang krijgen tot chatservices. Controleer de opgegeven gebruikersreferenties",userNotInChatThread:"U bent niet meer aanwezig in deze chatthread",sendMessageNotInChatThread:"Verzenden van bericht is mislukt omdat u zich niet meer in deze chatthread bevindt",sendMessageGeneric:"Kan bericht niet verzenden",callingNetworkFailure:"Er zijn problemen met het verbinden van een gesprek - Het lijkt erop dat u offline bent",startVideoGeneric:"Kan video niet starten",stopVideoGeneric:"Kan video niet stoppen",muteGeneric:"Kan microfoon niet dempen",unmuteGeneric:"Kan dempen van microfoon niet opheffen",speakingWhileMuted:"De microfoon is gedempt",startScreenShareGeneric:"Er is een probleem opgetreden bij het starten van scherm delen.",stopScreenShareGeneric:"Kan scherm delen niet stoppen",callNetworkQualityLow:"De netwerkkwaliteit is laag.",callNoSpeakerFound:"Geen luidsprekers of hoofdtelefoon gevonden. Sluit een audioapparaat aan om het gesprek te beluisteren.",callNoMicrophoneFound:"Geen microfoons gevonden. Sluit een audio-invoerapparaat aan.",callMicrophoneAccessDenied:"Kan geen toegang krijgen tot de microfoon. Klik op de vergrendeling in de adresbalk om toestemming te verlenen aan deze webpagina.",callMicrophoneAccessDeniedSafari:"Kan geen toegang krijgen tot de microfoon. Vernieuw de pagina om machtigingen toe te staan of controleer de instellingen van deze browser en controleer of machtigingen zijn ingeschakeld voor deze website.",callMicrophoneMutedBySystem:"U bent gedempt door jouw systeem.",callMicrophoneUnmutedBySystem:"De microfoon is hersteld en het dempen van de microfoon is door het systeem opgeheven.",callMacOsMicrophoneAccessDenied:"Kan geen toegang krijgen tot de microfoon. Verleen microfoonmachtiging in de privacyinstellingen voor macOS.",callLocalVideoFreeze:"De netwerkbandbreedte is slecht. Je video wordt mogelijk onderbroken weergegeven voor anderen in het gesprek.",callCameraAccessDenied:"Kan geen toegang krijgen tot de camera. Klik op de vergrendeling in de adresbalk om toestemming te verlenen aan deze webpagina.",callCameraAccessDeniedSafari:"Kan geen toegang krijgen tot de camera. Vernieuw de pagina om machtigingen toe te staan of controleer de instellingen van deze browser en controleer of machtigingen zijn ingeschakeld voor deze website.",callCameraAlreadyInUse:"Kan geen toegang krijgen tot de camera. Het wordt mogelijk al gebruikt door een andere toepassing.",callVideoStoppedBySystem:"Uw video is gestopt door uw systeem.",callVideoRecoveredBySystem:"Uw video is hervat.",callMacOsCameraAccessDenied:"MacOS blokkeert de toegang tot jouw camera. Werk je privacyinstellingen bij, zodat deze browser toegang heeft tot jouw camera.",callMacOsScreenShareAccessDenied:"MacOS blokkeert scherm delen. Werk je privacyinstellingen bij, zodat deze browser jouw scherm kan opnemen.",dismissButtonAriaLabel:"Sluiten",failedToJoinCallGeneric:"Deelnemen aan gesprek mislukt.",failedToJoinCallInvalidMeetingLink:"Kan niet deelnemen aan vergadering. Ongeldige koppeling.",cameraFrozenForRemoteParticipants:"Gebruikers in het gesprek ondervinden problemen bij het zien van uw video. Controleer uw apparaten en netwerk.",unableToStartVideoEffect:"Kan video-effect niet toepassen.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Kan de deelnemer(s) niet in de spotlight plaatsen omdat het maximum aantal deelnemers in de spotlight is bereikt."};var videoGallery$7={screenIsBeingSharedMessage:"U deelt uw scherm",screenShareLoadingMessage:"Scherm van {participant} laden",localVideoLabel:"U",localVideoCameraSwitcherLabel:"Camera wisselen",localVideoMovementLabel:"Tegel voor verwisselbare lokale video",localVideoSelectedDescription:"{cameraName} geselecteerd",displayNamePlaceholder:"Naamloze deelnemer",fitRemoteParticipantToFrame:"Aanpassen aan frame",fillRemoteParticipantFrame:"Frame vullen",pinParticipantForMe:"Voor mij vastmaken",pinParticipantForMeLimitReached:"Pin (limiet bereikt)",unpinParticipantForMe:"Losmaken",pinParticipantMenuItemAriaLabel:"{participantName} vastmaken",unpinParticipantMenuItemAriaLabel:"{participantName} losmaken",pinnedParticipantAnnouncementAriaLabel:"{participantName} vastgemaakt",unpinnedParticipantAnnouncementAriaLabel:"{participantName} losgemaakt",startSpotlightVideoTileMenuLabel:"Spotlight voor iedereen",addSpotlightVideoTileMenuLabel:"Spotlight toevoegen",spotlightLimitReachedMenuTitle:"Spotlightlimiet bereikt",stopSpotlightVideoTileMenuLabel:"Spotlighten stoppen",stopSpotlightOnSelfVideoTileMenuLabel:"Spotlight afsluiten",attendeeRole:"Genodigde"};var dialpad$7={placeholderText:"Telefoonnummer invoeren",deleteButtonAriaLabel:"Verwijderen"};var holdButton$7={onLabel:"Hervatten",offLabel:"Pauze",tooltipOnContent:"Gesprek hervatten",tooltipOffContent:"Gesprek in wachtrij plaatsen"};var videoTile$7={participantStateRinging:"Bellen...",participantStateHold:"In de wacht"};var CameraAndMicrophoneSitePermissionsRequest$7={primaryText:"Toestaan dat {appName} uw camera en microfoon gebruikt",secondaryText:"Dit is zodat deelnemers u kunnen zien en horen.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder camera en microfoon",ariaLabel:"Toegang tot camera en microfoon toestaan"};var CameraSitePermissionsRequest$7={primaryText:"{appName} toestaan om uw camera te gebruiken",secondaryText:"Dit is zodat deelnemers u kunnen zien.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder camera",ariaLabel:"Cameratoegang toestaan"};var MicrophoneSitePermissionsRequest$7={primaryText:"{appName} toestaan om uw microfoon te gebruiken",secondaryText:"Dit is zodat deelnemers u kunnen horen.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder microfoon",ariaLabel:"Microfoontoegang toestaan"};var CameraAndMicrophoneSitePermissionsCheck$7={primaryText:"Controleren op toegang tot camera en microfoon",secondaryText:"Toegang toestaan als hierom wordt gevraagd. Dit is zodat deelnemers u kunnen zien en horen.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder camera en microfoon",ariaLabel:"Controleren op toegang tot camera en microfoon. Toegang toestaan als hierom wordt gevraagd."};var CameraSitePermissionsCheck$7={primaryText:"Controleren op cameratoegang",secondaryText:"Toegang toestaan als hierom wordt gevraagd. Dit is zodat deelnemers u kunnen zien.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder camera",ariaLabel:"Controleren op cameratoegang. Toegang toestaan als hierom wordt gevraagd."};var MicrophoneSitePermissionsCheck$7={primaryText:"Controleren op toegang tot microfoon",secondaryText:"Toegang toestaan als hierom wordt gevraagd. Dit is zodat deelnemers u kunnen horen.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder microfoon",ariaLabel:"Controleren op toegang tot microfoon. Toegang toestaan als hierom wordt gevraagd."};var CameraAndMicrophoneSitePermissionsDenied$7={primaryText:"Geen toegang tot camera en microfoon",secondaryText:"Klik op het vergrendelingspictogram op de adresbalk om microfoonmachtigingen toe te kennen aan deze webpagina. Mogelijk is een paginavernieuwing vereist.",primaryButtonText:"Doorgaan zonder camera en microfoon",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var CameraAndMicrophoneSitePermissionsDeniedSafari$7={primaryText:"Geen toegang tot camera en microfoon",secondaryText:"Vernieuw de pagina om machtigingen toe te staan of controleer de instellingen van deze browser en controleer of machtigingen zijn ingeschakeld voor deze website.",primaryButtonText:"Doorgaan zonder camera en microfoon",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var CameraSitePermissionsDenied$7={primaryText:"Geen toegang tot camera",secondaryText:"Klik op het vergrendelingspictogram op de adresbalk om cameramachtigingen toe te kennen aan deze webpagina. Mogelijk is een paginavernieuwing vereist.",primaryButtonText:"Doorgaan zonder camera",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var MicrophoneSitePermissionsDenied$7={primaryText:"Geen toegang tot microfoon",secondaryText:"Klik op het vergrendelingspictogram op de adresbalk om microfoonmachtigingen toe te kennen aan deze webpagina. Mogelijk is een paginavernieuwing vereist.",primaryButtonText:"Doorgaan zonder microfoon",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var CameraSitePermissionsDeniedSafari$7={primaryText:"Geen toegang tot camera",secondaryText:"Vernieuw de pagina om machtigingen toe te staan of controleer de instellingen van deze browser en controleer of machtigingen zijn ingeschakeld voor deze website.",primaryButtonText:"Doorgaan zonder camera",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var MicrophoneSitePermissionsDeniedSafari$7={primaryText:"Geen toegang tot microfoon",secondaryText:"Vernieuw de pagina om machtigingen toe te staan of controleer de instellingen van deze browser en controleer of machtigingen zijn ingeschakeld voor deze website.",primaryButtonText:"Doorgaan zonder microfoon",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var UnsupportedBrowser$7={primaryText:"Browser wordt niet ondersteund",secondaryText:"Neem deel aan dit gesprek via een compatibele browser.",moreHelpLinkText:"Compatibiliteitsvereisten bekijken"};var UnsupportedBrowserVersion$7={primaryText:"Browserupdate vereist",secondaryText:"Werk uw browser bij en probeer opnieuw deel te nemen aan het gesprek om ervoor te zorgen dat u het beste kunt bellen.",moreHelpLinkText:"Compatibiliteitsvereisten bekijken",continueAnywayButtonText:"Oproep starten zonder bij te werken"};var UnsupportedOperatingSystem$7={primaryText:"Besturingssysteem niet ondersteund",secondaryText:"Neem deel aan dit gesprek via een apparaat met een compatibel besturingssysteem.",moreHelpLinkText:"Compatibiliteitsvereisten bekijken"};var BrowserPermissionDenied$7={primaryText:"Kan uw camera of microfoon niet gebruiken",secondaryText:"Uw browser heeft mogelijk geen toegang tot uw camera of microfoon. Open Systeemvoorkeuren om dit op te lossen.",primaryButtonText:"Opnieuw proberen",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var BrowserPermissionDeniedIOS$7={primaryText:"Microfoontoegang toestaan om door te gaan",secondaryText:"Zodat andere deelnemers u kunnen horen.",primaryButtonText:"Opnieuw proberen",imageAltText:"Machtigingslocatie voor microfoon en cameraapparaat voor iOS",linkText:"Hulp nodig? Hulp bij probleemoplossing",step1Text:"Ga naar de app Instellingen",step2Text:"Schuif omlaag naar instellingen voor deze browser",step3Text:"Microfoon inschakelen (camera optioneel)",step4Text:"Probeer opnieuw deel te nemen aan het gesprek",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$7={leftNavButtonAriaLabel:"vorige pagina",rightNavButtonAriaLabel:"volgende pagina"};var nl_NL$1 = {participantItem:participantItem$7,ParticipantList:ParticipantList$7,typingIndicator:typingIndicator$7,sendBox:sendBox$7,richTextSendBox:richTextSendBox$7,mentionPopover:mentionPopover$7,imageOverlay:imageOverlay$7,messageStatusIndicator:messageStatusIndicator$7,endCallButton:endCallButton$7,cameraButton:cameraButton$7,microphoneButton:microphoneButton$7,devicesButton:devicesButton$7,participantsButton:participantsButton$7,screenShareButton:screenShareButton$7,raiseHandButton:raiseHandButton$7,reactionButton:reactionButton$7,messageThread:messageThread$7,errorBar:errorBar$7,videoGallery:videoGallery$7,dialpad:dialpad$7,holdButton:holdButton$7,videoTile:videoTile$7,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$7,CameraSitePermissionsRequest:CameraSitePermissionsRequest$7,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$7,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$7,CameraSitePermissionsCheck:CameraSitePermissionsCheck$7,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$7,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$7,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$7,CameraSitePermissionsDenied:CameraSitePermissionsDenied$7,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$7,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$7,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$7,UnsupportedBrowser:UnsupportedBrowser$7,UnsupportedBrowserVersion:UnsupportedBrowserVersion$7,UnsupportedOperatingSystem:UnsupportedOperatingSystem$7,BrowserPermissionDenied:BrowserPermissionDenied$7,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$7,verticalGallery:verticalGallery$7};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Dutch (Netherlands).
 *
 * @public
 */
const COMPONENT_LOCALE_NL_NL = {
    strings: createComponentStrings(nl_NL$1)
};

var participantItem$6={isMeText:"(Ty)",menuTitle:"Wicej opcji",removeButtonLabel:"Usu",sharingIconLabel:"Udostpnianie",mutedIconLabel:"Wyciszono",displayNamePlaceholder:"Uczestnik bez nazwy",participantStateRinging:"Trwa czenie",participantStateHold:"Zawieszony",attendeeRole:"Uczestnik"};var ParticipantList$6={overflowParticipantCount:"+{overflowCount} wicej"};var typingIndicator$6={singleUser:"Uytkownik {user} pisze...",multipleUsers:"{users} pisz...",multipleUsersAbbreviateOne:"{users} i 1 inny uytkownik pisz...",multipleUsersAbbreviateMany:"{users} i {numOthers} innych uytkownikw pisz...",delimiter:", "};var sendBox$6={placeholderText:"Wprowad wiadomo",textTooLong:"Dugo wiadomoci przekracza maksymalny limit.",sendButtonAriaLabel:"Wylij wiadomo",fileUploadsPendingError:"Trwa przekazywanie... Czekaj.",removeFile:"Usuwanie pliku",uploading:"Przekazywanie",uploadCompleted:"Zakoczono przekazywanie"};var richTextSendBox$6={placeholderText:"Wprowad wiadomo",textTooLong:"Dugo wiadomoci przekracza maksymalny limit.",sendButtonAriaLabel:"Wylij wiadomo",fileUploadsPendingError:"Trwa przekazywanie... Czekaj.",removeFile:"Usu plik",uploading:"Przekazywanie",uploadCompleted:"Zakoczono przekazywanie",boldTooltip:"Pogrubienie",italicTooltip:"Kursywa",underlineTooltip:"Podkrelenie",bulletListTooltip:"Lista punktowana",numberListTooltip:"Lista numerowana",increaseIndentTooltip:"Zwiksz wcicie",decreaseIndentTooltip:"Zmniejsz wcicie",richTextFormatButtonTooltip:"Formatowanie"};var mentionPopover$6={mentionPopoverHeader:"Sugestie"};var imageOverlay$6={downloadButtonLabel:"Pobierz",dismissButtonAriaLabel:"Zamknij"};var messageStatusIndicator$6={deliveredAriaLabel:"Wiadomo zostaa wysana",deliveredTooltipText:"Wysano",seenAriaLabel:"Wiadomo widziana przez inne osoby",seenTooltipText:"Wywietlono",readByTooltipText:"Przeczytane przez {messageThreadReadCount} z {remoteParticipantsCount}",sendingAriaLabel:"Wysyanie wiadomoci",sendingTooltipText:"Wysyanie",failedToSendAriaLabel:"Nie udao si wysa wiadomoci",failedToSendTooltipText:"Nie udao si wysa"};var endCallButton$6={label:"Wyjd",tooltipContent:"Opu rozmow"};var cameraButton$6={onLabel:"Kamera",offLabel:"Kamera",tooltipDisabledContent:"Kamera jest wyczona",tooltipOnContent:"Wycz kamer",tooltipOffContent:"Wcz kamer",tooltipVideoLoadingContent:"adowanie wideo w toku",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Wybierz kamer",cameraButtonSplitRoleDescription:"Przycisk podziau",onSplitButtonAriaLabel:"Wycz kamer i jej opcje",offSplitButtonAriaLabel:"Wcz kamer i jej opcje",cameraActionTurnedOnAnnouncement:"Kamera zostaa wczona",cameraActionTurnedOffAnnouncement:"Kamera zostaa wyczona",onSplitButtonPrimaryActionCamera:"Wycz kamer",offSplitButtonPrimaryActionCamera:"Wcz kamer",cameraPrimaryActionSplitButtonTitle:"Uyj kamery",videoEffectsMenuItemTitle:"Efekty"};var microphoneButton$6={onLabel:"Mikrofon",offLabel:"Mikrofon",tooltipDisabledContent:"Mikrofon jest wyczony",tooltipOnContent:"Wycisz mikrofon",tooltipOffContent:"Wycz wyciszenie mikrofonu",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Wybierz mikrofon",speakerMenuTitle:"Gonik",speakerMenuTooltip:"Wybierz gonik",microphoneButtonSplitRoleDescription:"Przycisk podziau",onSplitButtonAriaLabel:"Wyciszenie mikrofonu i opcji dwiku",offSplitButtonAriaLabel:"Wycz wyciszenie mikrofonu i opcji dwiku",microphoneActionTurnedOnAnnouncement:"Mikrofon zosta wczony",microphoneActionTurnedOffAnnouncement:"Mikrofon zosta wyczony",offSplitButtonMicrophonePrimaryAction:"Wycz wyciszenie mikrofonu",onSplitButtonMicrophonePrimaryAction:"Wycisz mikrofon",microphonePrimaryActionSplitButtonTitle:"Uyj mikrofonu"};var devicesButton$6={label:"Urzdzenia",tooltipContent:"Zarzdzaj urzdzeniami",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Wybierz kamer",audioDeviceMenuTitle:"Urzdzenie audio",audioDeviceMenuTooltip:"Wybierz urzdzenie audio",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Wybierz mikrofon",speakerMenuTitle:"Gonik",speakerMenuTooltip:"Wybierz gonik"};var participantsButton$6={label:"Osoby",tooltipContent:"Poka uczestnikw",menuHeader:"W tej rozmowie",participantsListButtonLabel:"Liczba osb: {numParticipants}",muteAllButtonLabel:"Wycisz wszystkich",copyInviteLinkButtonLabel:"Kopiuj link do zaproszenia",copyInviteLinkActionedAriaLabel:"Skopiowano link do zaproszenia"};var screenShareButton$6={onLabel:"Zakocz prezentacj",offLabel:"Obecne",tooltipDisabledContent:"Prezentowanie jest wyczone",tooltipOnContent:"Prezentowanie ekranu",tooltipOffContent:"Prezentuj swj ekran"};var raiseHandButton$6={offLabel:"Podnie",onLabel:"Opu",tooltipDisabledContent:"Akcja Podnie rk jest wyczona",tooltipOnContent:"Opu rk",tooltipOffContent:"Podnie rk"};var reactionButton$6={label:"Zareaguj",ariaLabel:"Przycisk reagowania, Wylij reakcj",tooltipDisabledContent:"Akcja reakcji jest wyczona",tooltipContent:"Wylij reakcj",likeReactionTooltipContent:"Lubi",heartReactionTooltipContent:"Mio",laughReactionTooltipContent:"miech",applauseReactionTooltipContent:"Aplauz",surprisedReactionTooltipContent:"Niespodzianka"};var messageThread$6={yesterday:"Wczoraj",sunday:"Niedziela",monday:"Poniedziaek",tuesday:"Wtorek",wednesday:"roda",thursday:"Czwartek",friday:"Pitek",saturday:"Sobota",participantJoined:"doczy do czatu.",participantLeft:"opuci czat.",editMessage:"Edytuj",removeMessage:"Usu",resendMessage:"Sprbuj wysa ponownie",failToSendTag:"Nie udao si wysa",editedTag:"Edytowane",liveAuthorIntro:"Autor {author} mwi",messageContentAriaText:"Uytkownik {author} powiedzia: {message}",messageContentMineAriaText:"Wypowiedziano: {message}",editBoxTextLimit:"Twoja wiadomo przekracza limit {limitNumber} znakw",editBoxPlaceholderText:"Edytuj wiadomo",newMessagesIndicator:"Nowe wiadomoci",noDisplayNameSub:"Bez nazwy",editBoxCancelButton:"Anuluj",editBoxSubmitButton:"Gotowe",messageReadCount:"Przeczytane przez {messageReadByCount} z {remoteParticipantsCount}",actionMenuMoreOptions:"Wicej opcji",downloadFile:"Pobierz plik",blockedWarningText:"Ta wiadomo zostaa usunita ze wzgldu na zasady organizacyjne.",blockedWarningLinkText:"Szczegy",fileCardGroupMessage:"Wiadomo ma nastpujc liczb zacznikw: {fileCount}",messageDeletedAnnouncementAriaLabel:"Wiadomo zostaa usunita"};var errorBar$6={unableToReachChatService:"Jeste w trybie offline",accessDenied:"Nie mona uzyska dostpu do usug czatu  sprawd podane powiadczenia uytkownika",userNotInChatThread:"Nie jeste ju w tym wtku czatu",sendMessageNotInChatThread:"Nie mona wysa wiadomoci, poniewa nie jeste ju w tym wtku czatu",sendMessageGeneric:"Nie udao si wysa wiadomoci",callingNetworkFailure:"Problem z nawizaniem poczenia  wyglda na to, e jeste w trybie offline",startVideoGeneric:"Nie mona uruchomi wideo",stopVideoGeneric:"Nie mona zatrzyma wideo",muteGeneric:"Nie mona wyciszy mikrofonu",unmuteGeneric:"Nie mona wyczy wyciszenia mikrofonu",speakingWhileMuted:"Mikrofon jest wyciszony",startScreenShareGeneric:"Wystpi problem podczas uruchamiania udostpniania ekranu.",stopScreenShareGeneric:"Nie mona zatrzyma udostpniania ekranu",callNetworkQualityLow:"Niska jako sieci.",callNoSpeakerFound:"Nie znaleziono gonikw ani suchawek. Podcz urzdzenie audio, aby sysze rozmow.",callNoMicrophoneFound:"Nie znaleziono mikrofonw. Podcz urzdzenie wejciowe audio.",callMicrophoneAccessDenied:"Nie mona uzyska dostpu do mikrofonu. Kliknij blokad na pasku adresu, aby udzieli uprawnienia do tej strony sieci Web.",callMicrophoneAccessDeniedSafari:"Nie mona uzyska dostpu do mikrofonu. Odwie stron, aby zezwoli na uprawnienia, lub sprawd ustawienia tej przegldarki i sprawd, czy uprawnienia s wczone dla tej witryny internetowej.",callMicrophoneMutedBySystem:"System wyciszy Ci.",callMicrophoneUnmutedBySystem:"Mikrofon zosta odzyskany i system wyczy wyciszenie.",callMacOsMicrophoneAccessDenied:"Nie mona uzyska dostpu do mikrofonu. Udziel uprawnienia do mikrofonu w ustawieniach prywatnoci systemu macOS.",callLocalVideoFreeze:"Przepustowo sieci jest saba. Twoje wideo moe by wstrzymane dla innych osb podczas rozmowy.",callCameraAccessDenied:"Nie mona uzyska dostpu do kamery. Kliknij blokad na pasku adresu, aby udzieli uprawnienia do tej strony sieci Web.",callCameraAccessDeniedSafari:"Nie mona uzyska dostpu do kamery. Odwie stron, aby zezwoli na uprawnienia, lub sprawd ustawienia tej przegldarki i sprawd, czy uprawnienia s wczone dla tej witryny internetowej.",callCameraAlreadyInUse:"Nie mona uzyska dostpu do kamery. By moe jest ju uywany przez inn aplikacj.",callVideoStoppedBySystem:"Wideo zostao zatrzymane przez system.",callVideoRecoveredBySystem:"Wideo zostao wznowione.",callMacOsCameraAccessDenied:"System MacOS blokuje dostp do kamery. Zaktualizuj ustawienia prywatnoci, aby zezwoli tej przegldarce na dostp do kamery.",callMacOsScreenShareAccessDenied:"System MacOS blokuje udostpnianie ekranu. Zaktualizuj ustawienia prywatnoci, aby zezwoli tej przegldarce na rejestrowanie ekranu.",dismissButtonAriaLabel:"Zamknij",failedToJoinCallGeneric:"Nie mona doczy do rozmowy.",failedToJoinCallInvalidMeetingLink:"Nie mona doczy do spotkania. Nieprawidowy link.",cameraFrozenForRemoteParticipants:"Uytkownicy w trakcie rozmowy maj problemy z wywietleniem Twojego wideo. Sprawd urzdzenia i sie.",unableToStartVideoEffect:"Nie mona zastosowa efektu wideo.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Nie mona rozpocz wyrnienia uczestnikw, poniewa maksymalna liczba uczestnikw jest ju wyrniona."};var videoGallery$6={screenIsBeingSharedMessage:"Udostpniasz ekran",screenShareLoadingMessage:"adowanie ekranu uczestnika {participant}",localVideoLabel:"Ty",localVideoCameraSwitcherLabel:"Przecz kamer",localVideoMovementLabel:"Ruchomy lokalny kafelek wideo",localVideoSelectedDescription:"Wybrano kamer {cameraName}",displayNamePlaceholder:"Uczestnik bez nazwy",fitRemoteParticipantToFrame:"Dopasuj do ramki",fillRemoteParticipantFrame:"Wypenij ramk",pinParticipantForMe:"Przypnij dla mnie",pinParticipantForMeLimitReached:"Przypicie (osignito limit)",unpinParticipantForMe:"Odepnij",pinParticipantMenuItemAriaLabel:"Przypnij uczestnika {participantName}",unpinParticipantMenuItemAriaLabel:"Odepnij uczestnika {participantName}",pinnedParticipantAnnouncementAriaLabel:"Przypity uczestnik {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Odpity uczestnik {participantName}",startSpotlightVideoTileMenuLabel:"Wyrnij dla wszystkich",addSpotlightVideoTileMenuLabel:"Dodaj wyrnienie",spotlightLimitReachedMenuTitle:"Osignito limit wyrnienia",stopSpotlightVideoTileMenuLabel:"Zatrzymaj wyrnianie",stopSpotlightOnSelfVideoTileMenuLabel:"Zakocz wyrnienie",attendeeRole:"Uczestnik"};var dialpad$6={placeholderText:"Wprowad numer telefonu",deleteButtonAriaLabel:"Usu"};var holdButton$6={onLabel:"Wznw",offLabel:"Zawie",tooltipOnContent:"Wznw poczenie",tooltipOffContent:"Zawie poczenie"};var videoTile$6={participantStateRinging:"Trwa czenie",participantStateHold:"Zawieszony"};var CameraAndMicrophoneSitePermissionsRequest$6={primaryText:"Zezwalaj {appName} na uywanie kamery i mikrofonu",secondaryText:"Dziki temu uczestnicy bd mogli Ci zobaczy i usysze.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw",primaryButtonText:"Kontynuuj bez kamery i mikrofonu",ariaLabel:"Zezwalaj na dostp do kamery i mikrofonu"};var CameraSitePermissionsRequest$6={primaryText:"Zezwalaj aplikacji {appName} na korzystanie z kamery",secondaryText:"Dziki temu uczestnicy bd mogli Ci zobaczy.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw",primaryButtonText:"Kontynuuj bez kamery",ariaLabel:"Zezwalaj na dostp do kamery"};var MicrophoneSitePermissionsRequest$6={primaryText:"Zezwalaj aplikacji {appName} na uywanie mikrofonu",secondaryText:"Dziki temu uczestnicy bd mogli Ci usysze.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw",primaryButtonText:"Kontynuuj bez mikrofonu",ariaLabel:"Zezwalaj na dostp do mikrofonu"};var CameraAndMicrophoneSitePermissionsCheck$6={primaryText:"Sprawdzanie dostpu do kamery i mikrofonu",secondaryText:"Zezwalaj na dostp, jeli zostanie wywietlony monit. Dziki temu uczestnicy bd mogli Ci zobaczy i usysze.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw",primaryButtonText:"Kontynuuj bez kamery i mikrofonu",ariaLabel:"Sprawdzanie dostpu do kamery i mikrofonu. Zezwalaj na dostp, jeli zostanie wywietlony monit."};var CameraSitePermissionsCheck$6={primaryText:"Sprawdzanie dostpu do kamery",secondaryText:"Zezwalaj na dostp, jeli zostanie wywietlony monit. Dziki temu uczestnicy bd mogli Ci zobaczy.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw",primaryButtonText:"Kontynuuj bez kamery",ariaLabel:"Sprawdzanie dostpu do kamery. Zezwalaj na dostp, jeli zostanie wywietlony monit."};var MicrophoneSitePermissionsCheck$6={primaryText:"Sprawdzanie dostpu do mikrofonu",secondaryText:"Zezwalaj na dostp, jeli zostanie wywietlony monit. Dziki temu uczestnicy bd mogli Ci usysze.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw",primaryButtonText:"Kontynuuj bez mikrofonu",ariaLabel:"Sprawdzanie dostpu do mikrofonu. Zezwalaj na dostp, jeli zostanie wywietlony monit."};var CameraAndMicrophoneSitePermissionsDenied$6={primaryText:"Brak dostpu do kamery i mikrofonu",secondaryText:"Kliknij ikon blokady na pasku adresu, aby udzieli uprawnie mikrofonu do tej strony sieci Web. Odwieenie strony moe by wymagane.",primaryButtonText:"Kontynuuj bez kamery i mikrofonu",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw"};var CameraAndMicrophoneSitePermissionsDeniedSafari$6={primaryText:"Brak dostpu do kamery i mikrofonu",secondaryText:"Odwie stron, aby zezwoli na uprawnienia, lub sprawd ustawienia tej przegldarki i sprawd, czy uprawnienia s wczone dla tej witryny internetowej.",primaryButtonText:"Kontynuuj bez kamery i mikrofonu",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw"};var CameraSitePermissionsDenied$6={primaryText:"Brak dostpu do kamery",secondaryText:"Kliknij ikon blokady na pasku adresu, aby udzieli uprawnie kamery do tej strony sieci Web. Odwieenie strony moe by wymagane.",primaryButtonText:"Kontynuuj bez kamery",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw"};var MicrophoneSitePermissionsDenied$6={primaryText:"Brak dostpu do mikrofonu",secondaryText:"Kliknij ikon blokady na pasku adresu, aby udzieli uprawnie mikrofonu do tej strony sieci Web. Odwieenie strony moe by wymagane.",primaryButtonText:"Kontynuuj bez mikrofonu",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw"};var CameraSitePermissionsDeniedSafari$6={primaryText:"Brak dostpu do kamery",secondaryText:"Odwie stron, aby zezwoli na uprawnienia, lub sprawd ustawienia tej przegldarki i sprawd, czy uprawnienia s wczone dla tej witryny internetowej.",primaryButtonText:"Kontynuuj bez kamery",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw"};var MicrophoneSitePermissionsDeniedSafari$6={primaryText:"Brak dostpu do mikrofonu",secondaryText:"Odwie stron, aby zezwoli na uprawnienia, lub sprawd ustawienia tej przegldarki i sprawd, czy uprawnienia s wczone dla tej witryny internetowej.",primaryButtonText:"Kontynuuj bez mikrofonu",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw"};var UnsupportedBrowser$6={primaryText:"Nieobsugiwana przegldarka",secondaryText:"Docz do tej rozmowy przy uyciu zgodnej przegldarki.",moreHelpLinkText:"Zobacz wymagania dotyczce zgodnoci"};var UnsupportedBrowserVersion$6={primaryText:"Wymagana aktualizacja przegldarki",secondaryText:"Aby zapewni najlepsz moliw rozmow, zaktualizuj przegldark, a nastpnie sprbuj ponownie doczy do rozmowy.",moreHelpLinkText:"Zobacz wymagania dotyczce zgodnoci",continueAnywayButtonText:"Rozpocznij rozmow bez aktualizowania"};var UnsupportedOperatingSystem$6={primaryText:"System operacyjny nie jest obsugiwany",secondaryText:"Docz do tej rozmowy przy uyciu urzdzenia ze zgodnym systemem operacyjnym.",moreHelpLinkText:"Zobacz wymagania dotyczce zgodnoci"};var BrowserPermissionDenied$6={primaryText:"Nie mona uy kamery lub mikrofonu",secondaryText:"Twoja przegldarka moe nie mie dostpu do kamery lub mikrofonu. Aby rozwiza ten problem, otwrz okno Preferencje systemowe.",primaryButtonText:"Sprbuj ponownie",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw"};var BrowserPermissionDeniedIOS$6={primaryText:"Zezwalaj na dostp do mikrofonu, aby kontynuowa",secondaryText:"Inni uczestnicy bd mogli Ci usysze.",primaryButtonText:"Sprbuj ponownie",imageAltText:"Lokalizacja uprawnie urzdzenia z mikrofonem i kamer dla systemu iOS",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczc rozwizywania problemw",step1Text:"Przejd do aplikacji Ustawienia",step2Text:"Przewi w d do ustawie dla tej przegldarki",step3Text:"Wcz mikrofon (opcjonalnie kamer)",step4Text:"Sprbuj ponownie doczy do rozmowy",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$6={leftNavButtonAriaLabel:"poprzednia strona",rightNavButtonAriaLabel:"nastpna strona"};var pl_PL$1 = {participantItem:participantItem$6,ParticipantList:ParticipantList$6,typingIndicator:typingIndicator$6,sendBox:sendBox$6,richTextSendBox:richTextSendBox$6,mentionPopover:mentionPopover$6,imageOverlay:imageOverlay$6,messageStatusIndicator:messageStatusIndicator$6,endCallButton:endCallButton$6,cameraButton:cameraButton$6,microphoneButton:microphoneButton$6,devicesButton:devicesButton$6,participantsButton:participantsButton$6,screenShareButton:screenShareButton$6,raiseHandButton:raiseHandButton$6,reactionButton:reactionButton$6,messageThread:messageThread$6,errorBar:errorBar$6,videoGallery:videoGallery$6,dialpad:dialpad$6,holdButton:holdButton$6,videoTile:videoTile$6,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$6,CameraSitePermissionsRequest:CameraSitePermissionsRequest$6,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$6,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$6,CameraSitePermissionsCheck:CameraSitePermissionsCheck$6,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$6,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$6,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$6,CameraSitePermissionsDenied:CameraSitePermissionsDenied$6,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$6,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$6,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$6,UnsupportedBrowser:UnsupportedBrowser$6,UnsupportedBrowserVersion:UnsupportedBrowserVersion$6,UnsupportedOperatingSystem:UnsupportedOperatingSystem$6,BrowserPermissionDenied:BrowserPermissionDenied$6,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$6,verticalGallery:verticalGallery$6};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Polish (Poland).
 *
 * @public
 */
const COMPONENT_LOCALE_PL_PL = {
    strings: createComponentStrings(pl_PL$1)
};

var participantItem$5={isMeText:"(voc)",menuTitle:"Mais opes",removeButtonLabel:"Remover",sharingIconLabel:"Compartilhamento",mutedIconLabel:"Silenciado",displayNamePlaceholder:"Participante sem nome",participantStateRinging:"Chamando...",participantStateHold:"Em espera",attendeeRole:"Participante"};var ParticipantList$5={overflowParticipantCount:"+{overflowCount} mais"};var typingIndicator$5={singleUser:"{user} est digitando ...",multipleUsers:"{users} esto digitando ...",multipleUsersAbbreviateOne:"{users} e 1 outro esto digitando...",multipleUsersAbbreviateMany:"{users} e {numOthers} outros esto digitando ...",delimiter:", "};var sendBox$5={placeholderText:"Inserir uma mensagem",textTooLong:"O comprimento da mensagem est acima do limite mximo.",sendButtonAriaLabel:"Enviar mensagem",fileUploadsPendingError:"Carregando... Aguarde.",removeFile:"Remover arquivo",uploading:"Carregando",uploadCompleted:"Carregamento concludo"};var richTextSendBox$5={placeholderText:"Inserir uma mensagem",textTooLong:"O comprimento da mensagem est acima do limite mximo.",sendButtonAriaLabel:"Enviar mensagem",fileUploadsPendingError:"Carregando... Aguarde.",removeFile:"Remover arquivo",uploading:"Carregando",uploadCompleted:"Carregamento concludo",boldTooltip:"Negrito",italicTooltip:"Itlico",underlineTooltip:"Sublinhar",bulletListTooltip:"Lista com marcadores",numberListTooltip:"Lista numerada",increaseIndentTooltip:"Aumentar recuo",decreaseIndentTooltip:"Diminuir recuo",richTextFormatButtonTooltip:"Formato"};var mentionPopover$5={mentionPopoverHeader:"Sugestes"};var imageOverlay$5={downloadButtonLabel:"Baixar",dismissButtonAriaLabel:"Fechar"};var messageStatusIndicator$5={deliveredAriaLabel:"Mensagem enviada",deliveredTooltipText:"Enviado",seenAriaLabel:"Mensagem vista por outras pessoas",seenTooltipText:"Visto",readByTooltipText:"Lido por {messageThreadReadCount} de {remoteParticipantsCount}",sendingAriaLabel:"Envio de mensagem",sendingTooltipText:"Enviando",failedToSendAriaLabel:"Falha ao enviar mensagem",failedToSendTooltipText:"Falha ao enviar"};var endCallButton$5={label:"Sair",tooltipContent:"Sair da chamada"};var cameraButton$5={onLabel:"Cmera",offLabel:"Cmera",tooltipDisabledContent:"A cmera est desabilitada",tooltipOnContent:"Desabilitar a cmera",tooltipOffContent:"Ligar a cmera",tooltipVideoLoadingContent:"O vdeo est carregando",cameraMenuTitle:"Cmera",cameraMenuTooltip:"Escolher cmera",cameraButtonSplitRoleDescription:"Boto de diviso",onSplitButtonAriaLabel:"Desabilitar a cmera e as opes da cmera",offSplitButtonAriaLabel:"Habilitar a cmera e as opes da cmera",cameraActionTurnedOnAnnouncement:"A cmera foi ligada",cameraActionTurnedOffAnnouncement:"A cmera foi desligada",onSplitButtonPrimaryActionCamera:"Desligar a cmera",offSplitButtonPrimaryActionCamera:"Ligar a cmera",cameraPrimaryActionSplitButtonTitle:"Usar cmera",videoEffectsMenuItemTitle:"Efeitos"};var microphoneButton$5={onLabel:"Microfone",offLabel:"Microfone",tooltipDisabledContent:"O microfone est desabilitado",tooltipOnContent:"Ativar mudo do microfone",tooltipOffContent:"Desativar mudo do microfone",microphoneMenuTitle:"Microfone",microphoneMenuTooltip:"Escolher microfone",speakerMenuTitle:"Alto-falante",speakerMenuTooltip:"Escolher alto-falante",microphoneButtonSplitRoleDescription:"Boto de diviso",onSplitButtonAriaLabel:"Ativar mudo das opes de microfone e udio",offSplitButtonAriaLabel:"Desativar mudo do microfone e opes de udio",microphoneActionTurnedOnAnnouncement:"O microfone foi ligado",microphoneActionTurnedOffAnnouncement:"O microfone foi desligado",offSplitButtonMicrophonePrimaryAction:"Desativar mudo do microfone",onSplitButtonMicrophonePrimaryAction:"Ativar mudo do microfone",microphonePrimaryActionSplitButtonTitle:"Usar o microfone"};var devicesButton$5={label:"Dispositivos",tooltipContent:"Gerenciar dispositivos",cameraMenuTitle:"Cmera",cameraMenuTooltip:"Escolher cmera",audioDeviceMenuTitle:"Dispositivo de udio",audioDeviceMenuTooltip:"Escolher dispositivo de udio",microphoneMenuTitle:"Microfone",microphoneMenuTooltip:"Escolher microfone",speakerMenuTitle:"Alto-falante",speakerMenuTooltip:"Escolher alto-falante"};var participantsButton$5={label:"Pessoas",tooltipContent:"Mostrar participantes",menuHeader:"Nesta chamada",participantsListButtonLabel:"{numParticipants} pessoas",muteAllButtonLabel:"Silenciar todos",copyInviteLinkButtonLabel:"Copiar o link de convite",copyInviteLinkActionedAriaLabel:"Link de convite copiado"};var screenShareButton$5={onLabel:"Interromper apresentao",offLabel:"Apresentao",tooltipDisabledContent:"A apresentao est desabilitada.",tooltipOnContent:"Apresentando sua tela",tooltipOffContent:"Apresentar sua tela"};var raiseHandButton$5={offLabel:"Levantar",onLabel:"Baixar",tooltipDisabledContent:"A ao Levantar a Mo est desabilitada",tooltipOnContent:"Baixar a Mo",tooltipOffContent:"Levantar a Mo"};var reactionButton$5={label:"Reagir",ariaLabel:"Boto Reagir, Enviar umareao",tooltipDisabledContent:"A ao de reao est desabilitada",tooltipContent:"Enviar uma reao",likeReactionTooltipContent:"Curtir",heartReactionTooltipContent:"Amor",laughReactionTooltipContent:"Gargalhada",applauseReactionTooltipContent:"Aplausos",surprisedReactionTooltipContent:"Surpreso"};var messageThread$5={yesterday:"Ontem",sunday:"Domingo",monday:"Segunda",tuesday:"Tera-feira",wednesday:"Quarta-feira",thursday:"quinta-feira",friday:"Sexta-feira",saturday:"Sbado",participantJoined:"ingressou no chat.",participantLeft:"saiu do chat.",editMessage:"Editar",removeMessage:"Excluir",resendMessage:"Tente enviar novamente",failToSendTag:"Falha ao enviar",editedTag:"Editado",liveAuthorIntro:"{author} disse",messageContentAriaText:"{author} disse {message}",messageContentMineAriaText:"Voc disse {message}",editBoxTextLimit:"Sua mensagem est acima do limite de {limitNumber} caracteres",editBoxPlaceholderText:"Edite sua mensagem",newMessagesIndicator:"Novas mensagens",noDisplayNameSub:"Sem nome",editBoxCancelButton:"Cancelar",editBoxSubmitButton:"Concludo",messageReadCount:"Lido por {messageReadByCount} de {remoteParticipantsCount}",actionMenuMoreOptions:"Mais opes",downloadFile:"Baixar arquivo",blockedWarningText:"Esta mensagem foi excluda devido  poltica organizacional.",blockedWarningLinkText:"Detalhes",fileCardGroupMessage:"A mensagem tem {fileCount} anexo",messageDeletedAnnouncementAriaLabel:"A mensagem foi excluda"};var errorBar$5={unableToReachChatService:"Voc est offline",accessDenied:"No  possvel acessar os servios de chat - verifique as credenciais do usurio fornecidas",userNotInChatThread:"Voc no est mais neste tpico de chat",sendMessageNotInChatThread:"Falha ao enviar mensagem porque voc no est mais neste thread de chat",sendMessageGeneric:"Falha ao enviar mensagem",callingNetworkFailure:"Chamada de conexo desabilitar - parece que voc est offline",startVideoGeneric:"Falha ao iniciar o vdeo",stopVideoGeneric:"Falha ao interromper o vdeo",muteGeneric:"Falha ao ativar mudo do microfone",unmuteGeneric:"Falha ao desativar mudo do microfone",speakingWhileMuted:"O microfone est com o mudo ativado",startScreenShareGeneric:"Ocorreu um problema ao iniciar o compartilhamento de tela.",stopScreenShareGeneric:"Falha ao interromper o compartilhamento de tela",callNetworkQualityLow:"A qualidade da rede  baixa.",callNoSpeakerFound:"Nenhum alto-falante ou fone de ouvido encontrado. Conecte um dispositivo de udio para ouvir a chamada.",callNoMicrophoneFound:"Nenhum microfone encontrado. Conecte um dispositivo de entrada de udio.",callMicrophoneAccessDenied:"No  possvel acessar o microfone. Clique no bloqueio na barra de endereos para conceder permisso a esta pgina da Web.",callMicrophoneAccessDeniedSafari:"No  possvel acessar o microfone. Atualize a pgina para permitir permisses ou verifique as configuraes deste navegador e verifique se as permisses esto habilitadas para este site.",callMicrophoneMutedBySystem:"Voc est com as notificaes desativada pelo sistema.",callMicrophoneUnmutedBySystem:"Seu microfone se recuperou e voc foi desativado pelo sistema.",callMacOsMicrophoneAccessDenied:"No  possvel acessar o microfone. Conceda permisso ao microfone nas configuraes de privacidade do macOS.",callLocalVideoFreeze:"A largura de banda da rede  ruim. Seu vdeo pode aparecer em pausa para outras pessoas na chamada.",callCameraAccessDenied:"No  possvel acessar a cmera. Clique no bloqueio na barra de endereos para conceder permisso a esta pgina da Web.",callCameraAccessDeniedSafari:"No  possvel acessar a cmera. Atualize a pgina para permitir permisses ou verifique as configuraes deste navegador e verifique se as permisses esto habilitadas para este site.",callCameraAlreadyInUse:"No  possvel acessar a cmera. Talvez ele j esteja em uso por outro aplicativo.",callVideoStoppedBySystem:"Seu vdeo foi interrompido pelo sistema.",callVideoRecoveredBySystem:"Seu vdeo foi retomado.",callMacOsCameraAccessDenied:"O MacOS est bloqueando o acesso  sua cmera. Atualize suas configuraes de privacidade para permitir que este navegador acesse sua cmera.",callMacOsScreenShareAccessDenied:"O MacOS est bloqueando o compartilhamento de tela. Atualize suas configuraes de privacidade para permitir que este navegador grave sua tela.",dismissButtonAriaLabel:"Fechar",failedToJoinCallGeneric:"Ocorreu um erro ao ingressar na chamada.",failedToJoinCallInvalidMeetingLink:"No  possvel ingressar na Reunio. Link Invlido.",cameraFrozenForRemoteParticipants:"Os usurios na chamada esto enfrentando problemas para ver seu vdeo. Verifique seus dispositivos e a rede.",unableToStartVideoEffect:"No  possvel aplicar o efeito de vdeo.",startSpotlightWhileMaxParticipantsAreSpotlighted:"No  possvel iniciar o destaque nos participantes porque o nmero mximo de participantes j est em destaque."};var videoGallery$5={screenIsBeingSharedMessage:"Voc est compartilhando suatela",screenShareLoadingMessage:"Carregando a tela do {participant}",localVideoLabel:"Voc",localVideoCameraSwitcherLabel:"Alternar cmera",localVideoMovementLabel:"Bloco de Vdeo Local Removvel",localVideoSelectedDescription:"{cameraName} selecionado",displayNamePlaceholder:"Participante sem nome",fitRemoteParticipantToFrame:"Ajustar ao quadro",fillRemoteParticipantFrame:"Preencher quadro",pinParticipantForMe:"Fixar para mim",pinParticipantForMeLimitReached:"PIN (limite alcanado)",unpinParticipantForMe:"Desafixar",pinParticipantMenuItemAriaLabel:"Fixar {participantName}",unpinParticipantMenuItemAriaLabel:"Desafixar {participantName}",pinnedParticipantAnnouncementAriaLabel:"Fixado {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Desafixado {participantName}",startSpotlightVideoTileMenuLabel:"Destacar para todos",addSpotlightVideoTileMenuLabel:"Adicionar destaque",spotlightLimitReachedMenuTitle:"Limite de destaque atingido",stopSpotlightVideoTileMenuLabel:"Parar de destacar",stopSpotlightOnSelfVideoTileMenuLabel:"Sair de destaque",attendeeRole:"Participante"};var dialpad$5={placeholderText:"Inserir o nmero do telefone",deleteButtonAriaLabel:"Excluir"};var holdButton$5={onLabel:"Retomar",offLabel:"Reteno",tooltipOnContent:"Retomar chamada",tooltipOffContent:"Manter chamada em espera"};var videoTile$5={participantStateRinging:"Chamando...",participantStateHold:"Em espera"};var CameraAndMicrophoneSitePermissionsRequest$5={primaryText:"Permitir {appName} usar a cmera e o microfone",secondaryText:"Isso  para que os participantes possam ver e ouvir voc.",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas",primaryButtonText:"Continuar sem cmera emicrofone",ariaLabel:"Permitir acesso  cmera e ao microfone"};var CameraSitePermissionsRequest$5={primaryText:"Permitir que {appName} use acmera",secondaryText:"Isso  para que osparticipantes possam ver voc.",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas",primaryButtonText:"Continuar sem acmera",ariaLabel:"Permitir acesso  cmera"};var MicrophoneSitePermissionsRequest$5={primaryText:"Permitir que {appName} use omicrofone",secondaryText:"Isso  para que osparticipantes possam ouvir voc.",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas",primaryButtonText:"Continuar sem omicrofone",ariaLabel:"Permitir acesso aomicrofone"};var CameraAndMicrophoneSitePermissionsCheck$5={primaryText:"Verificando o acesso  cmera e aomicrofone",secondaryText:"Permitir acesso, se solicitado. Isso  para que os participantes possam ver e ouvir voc.",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas",primaryButtonText:"Continuar sem cmera emicrofone",ariaLabel:"Verificando o acesso  cmera e ao microfone. Permitir o acesso sesolicitado."};var CameraSitePermissionsCheck$5={primaryText:"Verificando o acesso cmera",secondaryText:"Permitir acesso, se solicitado. Isso  para que os participantes possam ver voc.",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas",primaryButtonText:"Continuar sem cmera",ariaLabel:"Verificando o acesso cmera. Permitir o acesso se solicitado."};var MicrophoneSitePermissionsCheck$5={primaryText:"Verificando o acesso aomicrofone",secondaryText:"Permitir acesso, se solicitado. Isso  para que os participantes possam ouvir voc.",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas",primaryButtonText:"Continuar sem microfone",ariaLabel:"Verificando acesso aomicrofone. Permitir o acesso se solicitado."};var CameraAndMicrophoneSitePermissionsDenied$5={primaryText:"No  possvel acessar a cmera e o microfone",secondaryText:"Clique no cone de bloqueio na barra de endereos para conceder permisses de microfone a esta pgina da Web. Uma atualizao de pgina pode ser necessria.",primaryButtonText:"Continuar sem cmera emicrofone",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas"};var CameraAndMicrophoneSitePermissionsDeniedSafari$5={primaryText:"No  possvel acessar a cmera e o microfone",secondaryText:"Atualize a pgina para permitir permisses ou verifique as configuraes deste navegador e verifique se as permisses esto habilitadas para este site.",primaryButtonText:"Continuar sem cmera emicrofone",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas"};var CameraSitePermissionsDenied$5={primaryText:"No  possvel acessar a cmera",secondaryText:"Clique no cone de bloqueio na barra de endereos para conceder permisses de cmera a esta pgina da Web. Uma atualizao de pgina pode ser necessria.",primaryButtonText:"Continuar sem acmera",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas"};var MicrophoneSitePermissionsDenied$5={primaryText:"No  possvel acessar o microfone",secondaryText:"Clique no cone de bloqueio na barra de endereos para conceder permisses de microfone a esta pgina da Web. Uma atualizao de pgina pode ser necessria.",primaryButtonText:"Continuar sem microfone",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas"};var CameraSitePermissionsDeniedSafari$5={primaryText:"No  possvel acessar a cmera",secondaryText:"Atualize a pgina para permitir permisses ou verifique as configuraes deste navegador e verifique se as permisses esto habilitadas para este site.",primaryButtonText:"Continuar sem cmera",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas"};var MicrophoneSitePermissionsDeniedSafari$5={primaryText:"No  possvel acessar o microfone",secondaryText:"Atualize a pgina para permitir permisses ou verifique as configuraes deste navegador e verifique se as permisses esto habilitadas para este site.",primaryButtonText:"Continuar sem omicrofone",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas"};var UnsupportedBrowser$5={primaryText:"Navegador sem suporte",secondaryText:"Ingresse nesta chamada usando um navegador compatvel.",moreHelpLinkText:"Consulte os requisitos de compatibilidade"};var UnsupportedBrowserVersion$5={primaryText:"Atualizao do navegador necessria",secondaryText:"Para garantir a melhor chamada possvel, atualize o navegador e tente ingressar na chamada novamente.",moreHelpLinkText:"Consulte os requisitos de compatibilidade",continueAnywayButtonText:"Iniciar chamada sem atualizar"};var UnsupportedOperatingSystem$5={primaryText:"Sistema operacional sem suporte",secondaryText:"Ingresse nesta chamada usando um dispositivo com um sistema operacional compatvel.",moreHelpLinkText:"Consulte os requisitos de compatibilidade"};var BrowserPermissionDenied$5={primaryText:"No  possvel usar sua cmera ou microfone",secondaryText:"Seu navegador pode no ter acesso  cmera ou ao microfone. Para corrigir isso, abra as Preferncias do Sistema.",primaryButtonText:"Tentar novamente",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas"};var BrowserPermissionDeniedIOS$5={primaryText:"Permitir acesso ao microfone para continuar",secondaryText:"Para que outros participantes possam ouvi-lo.",primaryButtonText:"Tentar novamente",imageAltText:"Localizao da permisso do microfone e do dispositivo da cmera para iOS",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas",step1Text:"Acessar o aplicativo Configuraes",step2Text:"Rolar para baixo at as configuraes deste navegador",step3Text:"Ligar o microfone (Cmera opcional)",step4Text:"Tentar ingressar na chamada novamente",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$5={leftNavButtonAriaLabel:"pgina anterior",rightNavButtonAriaLabel:"prxima pgina"};var pt_BR$1 = {participantItem:participantItem$5,ParticipantList:ParticipantList$5,typingIndicator:typingIndicator$5,sendBox:sendBox$5,richTextSendBox:richTextSendBox$5,mentionPopover:mentionPopover$5,imageOverlay:imageOverlay$5,messageStatusIndicator:messageStatusIndicator$5,endCallButton:endCallButton$5,cameraButton:cameraButton$5,microphoneButton:microphoneButton$5,devicesButton:devicesButton$5,participantsButton:participantsButton$5,screenShareButton:screenShareButton$5,raiseHandButton:raiseHandButton$5,reactionButton:reactionButton$5,messageThread:messageThread$5,errorBar:errorBar$5,videoGallery:videoGallery$5,dialpad:dialpad$5,holdButton:holdButton$5,videoTile:videoTile$5,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$5,CameraSitePermissionsRequest:CameraSitePermissionsRequest$5,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$5,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$5,CameraSitePermissionsCheck:CameraSitePermissionsCheck$5,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$5,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$5,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$5,CameraSitePermissionsDenied:CameraSitePermissionsDenied$5,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$5,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$5,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$5,UnsupportedBrowser:UnsupportedBrowser$5,UnsupportedBrowserVersion:UnsupportedBrowserVersion$5,UnsupportedOperatingSystem:UnsupportedOperatingSystem$5,BrowserPermissionDenied:BrowserPermissionDenied$5,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$5,verticalGallery:verticalGallery$5};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Portuguese (Brazil).
 *
 * @public
 */
const COMPONENT_LOCALE_PT_BR = {
    strings: createComponentStrings(pt_BR$1)
};

var participantItem$4={isMeText:"()",menuTitle:" ",removeButtonLabel:"",sharingIconLabel:" ",mutedIconLabel:" ",displayNamePlaceholder:"  ",participantStateRinging:" ...",participantStateHold:" ",attendeeRole:""};var ParticipantList$4={overflowParticipantCount:"  {overflowCount}"};var typingIndicator$4={singleUser:"{user}  ...",multipleUsers:"{users}  ...",multipleUsersAbbreviateOne:"{users}   1  ...",multipleUsersAbbreviateMany:"{users}   {numOthers}  ...",delimiter:"; "};var sendBox$4={placeholderText:" ",textTooLong:"    .",sendButtonAriaLabel:" ",fileUploadsPendingError:" . ...",removeFile:" ",uploading:"",uploadCompleted:" "};var richTextSendBox$4={placeholderText:" ",textTooLong:"    .",sendButtonAriaLabel:" ",fileUploadsPendingError:" ... .",removeFile:" ",uploading:"",uploadCompleted:" ",boldTooltip:"",italicTooltip:"",underlineTooltip:"",bulletListTooltip:" ",numberListTooltip:" ",increaseIndentTooltip:" ",decreaseIndentTooltip:" ",richTextFormatButtonTooltip:""};var mentionPopover$4={mentionPopoverHeader:""};var imageOverlay$4={downloadButtonLabel:"",dismissButtonAriaLabel:""};var messageStatusIndicator$4={deliveredAriaLabel:" ",deliveredTooltipText:"",seenAriaLabel:"   ",seenTooltipText:"",readByTooltipText:": {messageThreadReadCount}  {remoteParticipantsCount}",sendingAriaLabel:" ",sendingTooltipText:"",failedToSendAriaLabel:"   ",failedToSendTooltipText:"  "};var endCallButton$4={label:"",tooltipContent:" "};var cameraButton$4={onLabel:"",offLabel:"",tooltipDisabledContent:" ",tooltipOnContent:" ",tooltipOffContent:" ",tooltipVideoLoadingContent:" ",cameraMenuTitle:"",cameraMenuTooltip:" ",cameraButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"    ",offSplitButtonAriaLabel:"    ",cameraActionTurnedOnAnnouncement:" ",cameraActionTurnedOffAnnouncement:" ",onSplitButtonPrimaryActionCamera:" ",offSplitButtonPrimaryActionCamera:" ",cameraPrimaryActionSplitButtonTitle:" ",videoEffectsMenuItemTitle:""};var microphoneButton$4={onLabel:"",offLabel:"",tooltipDisabledContent:" ",tooltipOnContent:" ",tooltipOffContent:" ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:"",speakerMenuTooltip:" ",microphoneButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"    ",offSplitButtonAriaLabel:"    ",microphoneActionTurnedOnAnnouncement:"  ",microphoneActionTurnedOffAnnouncement:"  ",offSplitButtonMicrophonePrimaryAction:" ",onSplitButtonMicrophonePrimaryAction:" ",microphonePrimaryActionSplitButtonTitle:" "};var devicesButton$4={label:"",tooltipContent:" ",cameraMenuTitle:"",cameraMenuTooltip:" ",audioDeviceMenuTitle:" ",audioDeviceMenuTooltip:"  ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:"",speakerMenuTooltip:" "};var participantsButton$4={label:"",tooltipContent:" ",menuHeader:"  ",participantsListButtonLabel:": {numParticipants}",muteAllButtonLabel:"  ",copyInviteLinkButtonLabel:"   ",copyInviteLinkActionedAriaLabel:"   "};var screenShareButton$4={onLabel:" ",offLabel:"",tooltipDisabledContent:" ",tooltipOnContent:" ",tooltipOffContent:" "};var raiseHandButton$4={offLabel:" ",onLabel:"",tooltipDisabledContent:" \" \" ",tooltipOnContent:" ",tooltipOffContent:" "};var reactionButton$4={label:"",ariaLabel:" \"\",  ",tooltipDisabledContent:"  ",tooltipContent:" ",likeReactionTooltipContent:"",heartReactionTooltipContent:"",laughReactionTooltipContent:"",applauseReactionTooltipContent:"",surprisedReactionTooltipContent:""};var messageThread$4={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:"  .",participantLeft:" .",editMessage:"",removeMessage:"",resendMessage:"  ",failToSendTag:"  ",editedTag:"",liveAuthorIntro:"{author} ",messageContentAriaText:"{author}  {message}",messageContentMineAriaText:"  {message}",editBoxTextLimit:"     {limitNumber} ",editBoxPlaceholderText:" ",newMessagesIndicator:" ",noDisplayNameSub:" ",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:": {messageReadByCount}  {remoteParticipantsCount}",actionMenuMoreOptions:" ",downloadFile:" ",blockedWarningText:"     .",blockedWarningLinkText:"",fileCardGroupMessage:"  {fileCount} ",messageDeletedAnnouncementAriaLabel:" "};var errorBar$4={unableToReachChatService:"   ",accessDenied:"      .     ",userNotInChatThread:"       ",sendMessageNotInChatThread:"   ,          ",sendMessageGeneric:"   ",callingNetworkFailure:"    ,    ",startVideoGeneric:"   ",stopVideoGeneric:"   ",muteGeneric:"   ",unmuteGeneric:"   ",speakingWhileMuted:" ",startScreenShareGeneric:"     .",stopScreenShareGeneric:"    ",callNetworkQualityLow:"  : .",callNoSpeakerFound:"    .   ,   .",callNoMicrophoneFound:"  .    .",callMicrophoneAccessDenied:"     .     ,      -.",callMicrophoneAccessDeniedSafari:"     .  ,   ,      ,    -  .",callMicrophoneMutedBySystem:"   .",callMicrophoneUnmutedBySystem:" ,     .",callMacOsMicrophoneAccessDenied:"     .          macOS.",callLocalVideoFreeze:"   .          .",callCameraAccessDenied:"     .     ,      -.",callCameraAccessDeniedSafari:"     .  ,   ,      ,    -  .",callCameraAlreadyInUse:"     . ,     .",callVideoStoppedBySystem:"   .",callVideoRecoveredBySystem:"  .",callMacOsCameraAccessDenied:"MacOS    .   ,       .",callMacOsScreenShareAccessDenied:"MacOS   .   ,       .",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"    .",failedToJoinCallInvalidMeetingLink:"    .  .",cameraFrozenForRemoteParticipants:"        .     .",unableToStartVideoEffect:"    .",startSpotlightWhileMaxParticipantsAreSpotlighted:"    ,       ."};var videoGallery$4={screenIsBeingSharedMessage:"   ",screenShareLoadingMessage:"   {participant}",localVideoLabel:"",localVideoCameraSwitcherLabel:" ",localVideoMovementLabel:"   ",localVideoSelectedDescription:"  {cameraName}",displayNamePlaceholder:"  ",fitRemoteParticipantToFrame:"  ",fillRemoteParticipantFrame:" ",pinParticipantForMe:"  ",pinParticipantForMeLimitReached:" ( )",unpinParticipantForMe:"",pinParticipantMenuItemAriaLabel:"  {participantName}",unpinParticipantMenuItemAriaLabel:"  {participantName}",pinnedParticipantAnnouncementAriaLabel:" {participantName} ",unpinnedParticipantAnnouncementAriaLabel:" {participantName} ",startSpotlightVideoTileMenuLabel:"   ",addSpotlightVideoTileMenuLabel:" ",spotlightLimitReachedMenuTitle:"   ",stopSpotlightVideoTileMenuLabel:" ",stopSpotlightOnSelfVideoTileMenuLabel:"",attendeeRole:""};var dialpad$4={placeholderText:"  ",deleteButtonAriaLabel:""};var holdButton$4={onLabel:"",offLabel:"",tooltipOnContent:" ",tooltipOffContent:"   "};var videoTile$4={participantStateRinging:" ...",participantStateHold:" "};var CameraAndMicrophoneSitePermissionsRequest$4={primaryText:" {appName}    ",secondaryText:"   ,       .",linkText:" ?     ",primaryButtonText:"    ",ariaLabel:"     "};var CameraSitePermissionsRequest$4={primaryText:"  {appName}  ",secondaryText:"   ,     .",linkText:" ?     ",primaryButtonText:"  ",ariaLabel:"   "};var MicrophoneSitePermissionsRequest$4={primaryText:"  {appName}  ",secondaryText:"   ,     .",linkText:" ?     ",primaryButtonText:"  ",ariaLabel:"   "};var CameraAndMicrophoneSitePermissionsCheck$4={primaryText:"     ",secondaryText:"   .    ,       .",linkText:" ?     ",primaryButtonText:"    ",ariaLabel:"     .    ."};var CameraSitePermissionsCheck$4={primaryText:"   ",secondaryText:"   .    ,     .",linkText:" ?     ",primaryButtonText:"  ",ariaLabel:"   .    ."};var MicrophoneSitePermissionsCheck$4={primaryText:"   ",secondaryText:"   .    ,     .",linkText:" ?     ",primaryButtonText:"  ",ariaLabel:"   .    ."};var CameraAndMicrophoneSitePermissionsDenied$4={primaryText:"       ",secondaryText:"     ,          -.    .",primaryButtonText:"    ",linkText:" ?     "};var CameraAndMicrophoneSitePermissionsDeniedSafari$4={primaryText:"       ",secondaryText:" ,   ,          -.",primaryButtonText:"    ",linkText:" ?     "};var CameraSitePermissionsDenied$4={primaryText:"     ",secondaryText:"     ,       -.    .",primaryButtonText:"  ",linkText:" ?     "};var MicrophoneSitePermissionsDenied$4={primaryText:"     ",secondaryText:"     ,          -.    .",primaryButtonText:"  ",linkText:" ?     "};var CameraSitePermissionsDeniedSafari$4={primaryText:"     ",secondaryText:" ,   ,          -.",primaryButtonText:"  ",linkText:" ?     "};var MicrophoneSitePermissionsDeniedSafari$4={primaryText:"     ",secondaryText:" ,   ,          -.",primaryButtonText:"  ",linkText:" ?     "};var UnsupportedBrowser$4={primaryText:"  ",secondaryText:"       .",moreHelpLinkText:".   "};var UnsupportedBrowserVersion$4={primaryText:"  ",secondaryText:"    ,         .",moreHelpLinkText:".   ",continueAnywayButtonText:"   "};var UnsupportedOperatingSystem$4={primaryText:"   ",secondaryText:"   ,      .",moreHelpLinkText:".   "};var BrowserPermissionDenied$4={primaryText:"     ",secondaryText:",         .    ,   .",primaryButtonText:" ",linkText:" ?     "};var BrowserPermissionDeniedIOS$4={primaryText:"   ,  ",secondaryText:" ,     .",primaryButtonText:" ",imageAltText:"        iOS",linkText:" ?     ",step1Text:"   \"\"",step2Text:"      ",step3Text:"  ( )",step4Text:"     ",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$4={leftNavButtonAriaLabel:" ",rightNavButtonAriaLabel:" "};var ru_RU$1 = {participantItem:participantItem$4,ParticipantList:ParticipantList$4,typingIndicator:typingIndicator$4,sendBox:sendBox$4,richTextSendBox:richTextSendBox$4,mentionPopover:mentionPopover$4,imageOverlay:imageOverlay$4,messageStatusIndicator:messageStatusIndicator$4,endCallButton:endCallButton$4,cameraButton:cameraButton$4,microphoneButton:microphoneButton$4,devicesButton:devicesButton$4,participantsButton:participantsButton$4,screenShareButton:screenShareButton$4,raiseHandButton:raiseHandButton$4,reactionButton:reactionButton$4,messageThread:messageThread$4,errorBar:errorBar$4,videoGallery:videoGallery$4,dialpad:dialpad$4,holdButton:holdButton$4,videoTile:videoTile$4,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$4,CameraSitePermissionsRequest:CameraSitePermissionsRequest$4,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$4,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$4,CameraSitePermissionsCheck:CameraSitePermissionsCheck$4,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$4,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$4,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$4,CameraSitePermissionsDenied:CameraSitePermissionsDenied$4,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$4,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$4,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$4,UnsupportedBrowser:UnsupportedBrowser$4,UnsupportedBrowserVersion:UnsupportedBrowserVersion$4,UnsupportedOperatingSystem:UnsupportedOperatingSystem$4,BrowserPermissionDenied:BrowserPermissionDenied$4,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$4,verticalGallery:verticalGallery$4};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Russian (Russia).
 *
 * @public
 */
const COMPONENT_LOCALE_RU_RU = {
    strings: createComponentStrings(ru_RU$1)
};

var participantItem$3={isMeText:"(du)",menuTitle:"Fler alternativ",removeButtonLabel:"Ta bort",sharingIconLabel:"Delar",mutedIconLabel:"Ljudet r avstngt",displayNamePlaceholder:"Namnls deltagare",participantStateRinging:"Ringer...",participantStateHold:"Parkerat",attendeeRole:"Deltagare"};var ParticipantList$3={overflowParticipantCount:"+{overflowCount} till"};var typingIndicator$3={singleUser:"{user} skriver...",multipleUsers:"{users} skriver...",multipleUsersAbbreviateOne:"{users} och 1 annan skriver...",multipleUsersAbbreviateMany:"{users} och {numOthers} andra skriver...",delimiter:", "};var sendBox$3={placeholderText:"Skriv ett meddelande",textTooLong:"Meddelandelngden verskrider maxgrnsen.",sendButtonAriaLabel:"Skicka meddelande",fileUploadsPendingError:"Uppladdning pgr... Vnta.",removeFile:"Ta bort filen",uploading:"Laddar upp",uploadCompleted:"Uppladdningen har slutfrts"};var richTextSendBox$3={placeholderText:"Skriv ett meddelande",textTooLong:"Meddelandelngden verskrider maxgrnsen.",sendButtonAriaLabel:"Skicka meddelande",fileUploadsPendingError:"Laddar upp... Var god vnta.",removeFile:"Ta bort fil",uploading:"Laddar upp",uploadCompleted:"Uppladdningen har slutfrts",boldTooltip:"Fet",italicTooltip:"Kursiv",underlineTooltip:"Understruken",bulletListTooltip:"Punktlista",numberListTooltip:"Numrerad lista",increaseIndentTooltip:"ka indrag",decreaseIndentTooltip:"Minska indrag",richTextFormatButtonTooltip:"Format"};var mentionPopover$3={mentionPopoverHeader:"Frslag"};var imageOverlay$3={downloadButtonLabel:"Ladda ner",dismissButtonAriaLabel:"Stng"};var messageStatusIndicator$3={deliveredAriaLabel:"Meddelandet har skickats",deliveredTooltipText:"Skickat",seenAriaLabel:"Meddelande som andra ser",seenTooltipText:"Sett",readByTooltipText:"Lst av {messageThreadReadCount} av {remoteParticipantsCount}",sendingAriaLabel:"Meddelandet skickas",sendingTooltipText:"Skickar",failedToSendAriaLabel:"Meddelandet skickades inte",failedToSendTooltipText:"Inte skickat"};var endCallButton$3={label:"Lmna",tooltipContent:"Lmna samtal"};var cameraButton$3={onLabel:"Kamera",offLabel:"Kamera",tooltipDisabledContent:"Kameran r inaktiverad",tooltipOnContent:"Stng av kameran",tooltipOffContent:"Aktivera kameran",tooltipVideoLoadingContent:"Videon lses in",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Vlj kamera",cameraButtonSplitRoleDescription:"Delningsknapp",onSplitButtonAriaLabel:"Inaktivera kamera- och kameraalternativ",offSplitButtonAriaLabel:"Aktivera kamera- och kameraalternativ",cameraActionTurnedOnAnnouncement:"Kameran har aktiverats",cameraActionTurnedOffAnnouncement:"Kameran har stngts av",onSplitButtonPrimaryActionCamera:"Stng av kameran",offSplitButtonPrimaryActionCamera:"Aktivera kameran",cameraPrimaryActionSplitButtonTitle:"Anvnd kamera",videoEffectsMenuItemTitle:"Effekter"};var microphoneButton$3={onLabel:"Mikrofon",offLabel:"Mikrofon",tooltipDisabledContent:"Mikrofonen r inaktiverad",tooltipOnContent:"Stng av mikrofonen",tooltipOffContent:"Sl p mikrofonen",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Vlj mikrofon",speakerMenuTitle:"Hgtalare",speakerMenuTooltip:"Vlj hgtalare",microphoneButtonSplitRoleDescription:"Delningsknapp",onSplitButtonAriaLabel:"Ljud av mikrofon och ljudalternativ",offSplitButtonAriaLabel:"Sl p ljudet fr mikrofon och ljudalternativ",microphoneActionTurnedOnAnnouncement:"Mikrofonen har aktiverats",microphoneActionTurnedOffAnnouncement:"Mikrofonen har inaktiverats",offSplitButtonMicrophonePrimaryAction:"Sl p mikrofonen",onSplitButtonMicrophonePrimaryAction:"Stng av mikrofonen",microphonePrimaryActionSplitButtonTitle:"Anvnd mikrofon"};var devicesButton$3={label:"Enheter",tooltipContent:"Hantera enheter",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Vlj kamera",audioDeviceMenuTitle:"Ljudenhet",audioDeviceMenuTooltip:"Vlj ljudenhet",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Vlj mikrofon",speakerMenuTitle:"Hgtalare",speakerMenuTooltip:"Vlj hgtalare"};var participantsButton$3={label:"Personer",tooltipContent:"Visa deltagare",menuHeader:"I det hr samtalet",participantsListButtonLabel:"{numParticipants} personer",muteAllButtonLabel:"Ljud av fr alla",copyInviteLinkButtonLabel:"Kopiera inbjudningslnk",copyInviteLinkActionedAriaLabel:"Inbjudningslnken har kopierats"};var screenShareButton$3={onLabel:"Sluta presentera",offLabel:"Present",tooltipDisabledContent:"Presentationen r inaktiverad",tooltipOnContent:"Visar din skrm",tooltipOffContent:"Dela skrmen"};var raiseHandButton$3={offLabel:"Hand",onLabel:"Lgre",tooltipDisabledContent:"tgrden Rck upp hand r inaktiverad",tooltipOnContent:"Ta ned handen",tooltipOffContent:"Rck upp handen"};var reactionButton$3={label:"Reagera",ariaLabel:"React-knapp, skicka en reaktion",tooltipDisabledContent:"Reaktionstgrden r inaktiverad",tooltipContent:"Skicka en reaktion",likeReactionTooltipContent:"Gilla",heartReactionTooltipContent:"Krlek",laughReactionTooltipContent:"Skrattar",applauseReactionTooltipContent:"Appld",surprisedReactionTooltipContent:"Frvnad"};var messageThread$3={yesterday:"I gr",sunday:"Sndag",monday:"Mndag",tuesday:"Tisdag",wednesday:"Onsdag",thursday:"Torsdag",friday:"Fredag",saturday:"Lrdag",participantJoined:"gick med i chatten.",participantLeft:"lmnade chatten.",editMessage:"Redigera",removeMessage:"Ta bort",resendMessage:"Frsk skicka igen",failToSendTag:"Inte skickat",editedTag:"Redigerad",liveAuthorIntro:"{author} sger",messageContentAriaText:"{author} sa {message}",messageContentMineAriaText:"Du sa {message}",editBoxTextLimit:"Meddelandet verskrider grnsen p {limitNumber} tecken",editBoxPlaceholderText:"Redigera meddelandet",newMessagesIndicator:"Nya meddelanden",noDisplayNameSub:"Inget namn",editBoxCancelButton:"Avbryt",editBoxSubmitButton:"Klar",messageReadCount:"Lst av {messageReadByCount} av {remoteParticipantsCount}",actionMenuMoreOptions:"Fler alternativ",downloadFile:"Ladda ner fil",blockedWarningText:"Det hr meddelandet har tagits bort p grund av en organisationsprincip.",blockedWarningLinkText:"Information",fileCardGroupMessage:"Meddelandet har {fileCount} bifogad fil",messageDeletedAnnouncementAriaLabel:"Meddelandet har tagits bort"};var errorBar$3={unableToReachChatService:"Du r offline",accessDenied:"Det gr inte att komma t chatttjnster  kontrollera de angivna autentiseringsuppgifterna",userNotInChatThread:"Du r inte lngre i den hr chatttrden",sendMessageNotInChatThread:"Det gick inte att skicka meddelandet eftersom du inte lngre r i den hr chatttrden",sendMessageGeneric:"Meddelandet inte skickat",callingNetworkFailure:"Strande anslutningssamtal  du verkar vara offline",startVideoGeneric:"Det gick inte att starta videon",stopVideoGeneric:"Det gick inte att stoppa videon",muteGeneric:"Det gick inte att stnga av mikrofonen",unmuteGeneric:"Det gick inte att sl p mikrofonen",speakingWhileMuted:"Mikrofonens ljud har stngts av",startScreenShareGeneric:"Det uppstod ett problem nr skrmdelningen skulle startas.",stopScreenShareGeneric:"Det gick inte att stoppa skrmdelning",callNetworkQualityLow:"Ntverkskvaliteten r lg.",callNoSpeakerFound:"Inga hgtalare eller hrlurar hittades. Anslut en ljudenhet fr att hra samtalet.",callNoMicrophoneFound:"Inga mikrofoner hittades. Anslut en ljudinmatningsenhet.",callMicrophoneAccessDenied:"Det gr inte att komma t mikrofonen. Klicka p lset i adressfltet om du vill bevilja behrighet till den hr webbsidan.",callMicrophoneAccessDeniedSafari:"Det gr inte att komma t mikrofonen. Uppdatera sidan om du vill tillta behrigheter, eller kontrollera webblsarens instllningar och kontrollera att behrigheter r aktiverade fr den hr webbplatsen.",callMicrophoneMutedBySystem:"Du r avstngt av systemet.",callMicrophoneUnmutedBySystem:"Mikrofonen har terstllts och datorn har slagit p ljudet.",callMacOsMicrophoneAccessDenied:"Det gr inte att komma t mikrofonen. Bevilja mikrofonbehrighet i dina sekretessinstllningar fr macOS.",callLocalVideoFreeze:"Ntverksbandbredden r dlig. Din video kan visas pausad fr andra i samtalet.",callCameraAccessDenied:"Det gr inte att komma t kameran. Klicka p lset i adressfltet om du vill bevilja behrighet till den hr webbsidan.",callCameraAccessDeniedSafari:"Det gr inte att komma t kameran. Uppdatera sidan om du vill tillta behrigheter, eller kontrollera webblsarens instllningar och kontrollera att behrigheter r aktiverade fr den hr webbplatsen.",callCameraAlreadyInUse:"Det gr inte att komma t kameran. Den kanske redan anvnds av ett annat program.",callVideoStoppedBySystem:"Din video har stoppats av systemet.",callVideoRecoveredBySystem:"Videon har terupptagits.",callMacOsCameraAccessDenied:"MacOS blockerar tkomsten till kameran. Uppdatera dina sekretessinstllningar s att den hr webblsaren fr tkomst till kameran.",callMacOsScreenShareAccessDenied:"MacOS blockerar skrmdelning. Uppdatera dina sekretessinstllningar s att den hr webblsaren kan spela in din skrm.",dismissButtonAriaLabel:"Stng",failedToJoinCallGeneric:"Det gick inte att ansluta till samtalet.",failedToJoinCallInvalidMeetingLink:"Det gr inte att ansluta till mtet. Ogiltig lnk.",cameraFrozenForRemoteParticipants:"Anvndare i samtalet har problem med att se din video. Kontrollera dina enheter och ntverk.",unableToStartVideoEffect:"Det gr inte att tillmpa videoeffekten.",startSpotlightWhileMaxParticipantsAreSpotlighted:"Det gr inte att starta spotlight p deltagare eftersom det maximala antalet deltagare redan r uppmrksammat."};var videoGallery$3={screenIsBeingSharedMessage:"Du delar din skrm",screenShareLoadingMessage:"Lser in {participant}s skrm",localVideoLabel:"Du",localVideoCameraSwitcherLabel:"Vxla kamera",localVideoMovementLabel:"Flyttbar lokal videopanel",localVideoSelectedDescription:"{cameraName} har valts",displayNamePlaceholder:"Namnls deltagare",fitRemoteParticipantToFrame:"Anpassa till ruta",fillRemoteParticipantFrame:"Fyll ruta",pinParticipantForMe:"Fst t mig",pinParticipantForMeLimitReached:"Fst (grnsen har ntts)",unpinParticipantForMe:"Ta bort",pinParticipantMenuItemAriaLabel:"Fst {participantName}",unpinParticipantMenuItemAriaLabel:"Ta bort {participantName}",pinnedParticipantAnnouncementAriaLabel:"Fst {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Borttagen {participantName}",startSpotlightVideoTileMenuLabel:"Uppmrksamma fr alla",addSpotlightVideoTileMenuLabel:"Lgg till uppmrksammande",spotlightLimitReachedMenuTitle:"Spotlight-grnsen har ntts",stopSpotlightVideoTileMenuLabel:"Sluta uppmrksamma",stopSpotlightOnSelfVideoTileMenuLabel:"Spotlight",attendeeRole:"Deltagare"};var dialpad$3={placeholderText:"Ange telefonnummer",deleteButtonAriaLabel:"Ta bort"};var holdButton$3={onLabel:"teruppta",offLabel:"Bevarande",tooltipOnContent:"teruppta samtal",tooltipOffContent:"Parkera samtal"};var videoTile$3={participantStateRinging:"Ringer...",participantStateHold:"Parkerat"};var CameraAndMicrophoneSitePermissionsRequest$3={primaryText:"Tillt {appName} anvnda kameran och mikrofonen",secondaryText:"Det hr r s att deltagarna kan se och hra dig.",linkText:"Behver du hjlp? F hjlp med felskning",primaryButtonText:"Fortstt utan kamera och mikrofon",ariaLabel:"Tillt kamera- och mikrofontkomst"};var CameraSitePermissionsRequest$3={primaryText:"Tillt {appName} att anvnda kameran",secondaryText:"Det hr r s att deltagarna kan se dig.",linkText:"Behver du hjlp? F hjlp med felskning",primaryButtonText:"Fortstt utan kamera",ariaLabel:"Tillt kameratkomst"};var MicrophoneSitePermissionsRequest$3={primaryText:"Tillt {appName} att anvnda mikrofonen",secondaryText:"Det hr r s att deltagarna kan hra dig.",linkText:"Behver du hjlp? F hjlp med felskning",primaryButtonText:"Fortstt utan mikrofon",ariaLabel:"Tillt mikrofontkomst"};var CameraAndMicrophoneSitePermissionsCheck$3={primaryText:"Sker efter tkomst till kameran och mikrofonen",secondaryText:"Tillt tkomst om du uppmanas till det. Det hr r s att deltagarna kan se och hra dig.",linkText:"Behver du hjlp? F hjlp med felskning",primaryButtonText:"Fortstt utan kamera och mikrofon",ariaLabel:"Sker efter tkomst till kameran och mikrofonen. Tillt tkomst om du uppmanas att gra det."};var CameraSitePermissionsCheck$3={primaryText:"Sker efter kameratkomst",secondaryText:"Tillt tkomst om du uppmanas att gra det. Det hr r s att deltagarna kan se dig.",linkText:"Behver du hjlp? F hjlp med felskning",primaryButtonText:"Fortstt utan kamera",ariaLabel:"Sker efter kameratkomst. Tillt tkomst om du uppmanas att gra det."};var MicrophoneSitePermissionsCheck$3={primaryText:"Sker efter mikrofontkomst",secondaryText:"Tillt tkomst om du uppmanas till det. Det hr r s att deltagarna kan hra dig.",linkText:"Behver du hjlp? F hjlp med felskning",primaryButtonText:"Fortstt utan mikrofon",ariaLabel:"Sker efter mikrofontkomst. Tillt tkomst om du uppmanas att gra det."};var CameraAndMicrophoneSitePermissionsDenied$3={primaryText:"Det gr inte att komma t kameran och mikrofonen",secondaryText:"Klicka p lsikonen i adressfltet om du vill bevilja mikrofonbehrighet till den hr webbsidan. Det kan krvas en siduppdatering.",primaryButtonText:"Fortstt utan kamera och mikrofon",linkText:"Behver du hjlp? F hjlp med felskning"};var CameraAndMicrophoneSitePermissionsDeniedSafari$3={primaryText:"Det gr inte att komma t kameran och mikrofonen",secondaryText:"Uppdatera sidan om du vill tillta behrigheter, eller kontrollera webblsarens instllningar och kontrollera att behrigheter r aktiverade fr den hr webbplatsen.",primaryButtonText:"Fortstt utan kamera och mikrofon",linkText:"Behver du hjlp? F hjlp med felskning"};var CameraSitePermissionsDenied$3={primaryText:"Det gr inte att komma t kameran",secondaryText:"Klicka p lsikonen i adressfltet om du vill bevilja kamerabehrigheter till den hr webbsidan. Det kan krvas en siduppdatering.",primaryButtonText:"Fortstt utan kamera",linkText:"Behver du hjlp? F hjlp med felskning"};var MicrophoneSitePermissionsDenied$3={primaryText:"Det gr inte att komma t mikrofonen",secondaryText:"Klicka p lsikonen i adressfltet om du vill bevilja mikrofonbehrighet till den hr webbsidan. Det kan krvas en siduppdatering.",primaryButtonText:"Fortstt utan mikrofon",linkText:"Behver du hjlp? F hjlp med felskning"};var CameraSitePermissionsDeniedSafari$3={primaryText:"Det gr inte att komma t kameran",secondaryText:"Uppdatera sidan om du vill tillta behrigheter, eller kontrollera webblsarens instllningar och kontrollera att behrigheter r aktiverade fr den hr webbplatsen.",primaryButtonText:"Fortstt utan kamera",linkText:"Behver du hjlp? F hjlp med felskning"};var MicrophoneSitePermissionsDeniedSafari$3={primaryText:"Det gr inte att komma t mikrofonen",secondaryText:"Uppdatera sidan om du vill tillta behrigheter, eller kontrollera webblsarens instllningar och kontrollera att behrigheter r aktiverade fr den hr webbplatsen.",primaryButtonText:"Fortstt utan mikrofon",linkText:"Behver du hjlp? F hjlp med felskning"};var UnsupportedBrowser$3={primaryText:"Webblsaren stds inte",secondaryText:"Anslut till samtalet med en kompatibel webblsare.",moreHelpLinkText:"Se kompatibilitetskrav"};var UnsupportedBrowserVersion$3={primaryText:"Uppdatering av webblsare krvs",secondaryText:"Uppdatera webblsaren och frsk sedan ansluta till samtalet igen fr att skerstlla bsta mjliga samtal.",moreHelpLinkText:"Se kompatibilitetskrav",continueAnywayButtonText:"Starta samtal utan att uppdatera"};var UnsupportedOperatingSystem$3={primaryText:"Operativsystemet stds inte",secondaryText:"Anslut till det hr samtalet med en enhet med ett kompatibelt operativsystem.",moreHelpLinkText:"Se kompatibilitetskrav"};var BrowserPermissionDenied$3={primaryText:"Det gr inte att anvnda kameran eller mikrofonen",secondaryText:"Din webblsare kanske inte har tkomst till din kamera eller mikrofon. tgrda detta genom att ppna Systeminstllningar.",primaryButtonText:"Frsk igen",linkText:"Behver du hjlp? F hjlp med felskning"};var BrowserPermissionDeniedIOS$3={primaryText:"Tillt mikrofontkomst fr att fortstta",secondaryText:"S att andra deltagare kan hra dig.",primaryButtonText:"Frsk igen",imageAltText:"Behrighetsplats fr mikrofon och kameraenhet fr iOS",linkText:"Behver du hjlp? F hjlp med felskning",step1Text:"G till appen Instllningar",step2Text:"Rulla ned till instllningarna fr den hr webblsaren",step3Text:"Aktivera mikrofon (kamera valfritt)",step4Text:"Frsk ansluta till samtalet igen",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$3={leftNavButtonAriaLabel:"fregende sida",rightNavButtonAriaLabel:"nsta sida"};var sv_SE$1 = {participantItem:participantItem$3,ParticipantList:ParticipantList$3,typingIndicator:typingIndicator$3,sendBox:sendBox$3,richTextSendBox:richTextSendBox$3,mentionPopover:mentionPopover$3,imageOverlay:imageOverlay$3,messageStatusIndicator:messageStatusIndicator$3,endCallButton:endCallButton$3,cameraButton:cameraButton$3,microphoneButton:microphoneButton$3,devicesButton:devicesButton$3,participantsButton:participantsButton$3,screenShareButton:screenShareButton$3,raiseHandButton:raiseHandButton$3,reactionButton:reactionButton$3,messageThread:messageThread$3,errorBar:errorBar$3,videoGallery:videoGallery$3,dialpad:dialpad$3,holdButton:holdButton$3,videoTile:videoTile$3,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$3,CameraSitePermissionsRequest:CameraSitePermissionsRequest$3,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$3,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$3,CameraSitePermissionsCheck:CameraSitePermissionsCheck$3,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$3,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$3,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$3,CameraSitePermissionsDenied:CameraSitePermissionsDenied$3,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$3,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$3,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$3,UnsupportedBrowser:UnsupportedBrowser$3,UnsupportedBrowserVersion:UnsupportedBrowserVersion$3,UnsupportedOperatingSystem:UnsupportedOperatingSystem$3,BrowserPermissionDenied:BrowserPermissionDenied$3,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$3,verticalGallery:verticalGallery$3};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Swedish (Sweden) .
 *
 * @public
 */
const COMPONENT_LOCALE_SV_SE = {
    strings: createComponentStrings(sv_SE$1)
};

var participantItem$2={isMeText:"(siz)",menuTitle:"Dier Seenekler",removeButtonLabel:"Kaldr",sharingIconLabel:"Paylam",mutedIconLabel:"Ses kapatld",displayNamePlaceholder:"Adsz katlmc",participantStateRinging:"Aryor...",participantStateHold:"Beklemede",attendeeRole:"Katlmc"};var ParticipantList$2={overflowParticipantCount:"{overflowCount} tane daha"};var typingIndicator$2={singleUser:"{user} yazyor...",multipleUsers:"{users} yazyor ...",multipleUsersAbbreviateOne:"{users} ve 1 kii daha yazyor...",multipleUsersAbbreviateMany:"{users} ve {numOthers} kii daha yazyor...",delimiter:", "};var sendBox$2={placeholderText:"Bir mesaj girin",textTooLong:"letinizin uzunluu st snr ayor.",sendButtonAriaLabel:"leti gnder",fileUploadsPendingError:"Karya ykleniyor... Ltfen bekleyin.",removeFile:"Dosyay kaldr",uploading:"Karya ykleniyor",uploadCompleted:"Karya ykleme tamamland"};var richTextSendBox$2={placeholderText:"Bir mesaj girin",textTooLong:"letinizin uzunluu st snr ayor.",sendButtonAriaLabel:"Mesaj gnder",fileUploadsPendingError:"Karya ykleniyor... Ltfen bekleyin.",removeFile:"Dosyay kaldr",uploading:"Ykleniyor",uploadCompleted:"Karya ykleme tamamland",boldTooltip:"Kaln",italicTooltip:"talik",underlineTooltip:"Alt izili",bulletListTooltip:"Madde iaretli liste",numberListTooltip:"Numaralandrlm liste",increaseIndentTooltip:"Girintiyi artr",decreaseIndentTooltip:"Girintiyi azalt",richTextFormatButtonTooltip:"Biim"};var mentionPopover$2={mentionPopoverHeader:"neriler"};var imageOverlay$2={downloadButtonLabel:"ndir",dismissButtonAriaLabel:"Kapat"};var messageStatusIndicator$2={deliveredAriaLabel:"leti gnderildi",deliveredTooltipText:"Gnderilen",seenAriaLabel:"leti bakalar tarafndan grld",seenTooltipText:"Grld",readByTooltipText:"{messageThreadReadCount} / {remoteParticipantsCount} katlmc tarafndan okundu",sendingAriaLabel:"leti gnderiliyor",sendingTooltipText:"Gnderiliyor",failedToSendAriaLabel:"leti gnderilemedi",failedToSendTooltipText:"Gnderilemedi"};var endCallButton$2={label:"Ayrl",tooltipContent:"Aramadan ayrl"};var cameraButton$2={onLabel:"Kamera",offLabel:"Kamera",tooltipDisabledContent:"Kamera devre d",tooltipOnContent:"Kameray kapat",tooltipOffContent:"Kameray a",tooltipVideoLoadingContent:"Video ykleniyor",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera se",cameraButtonSplitRoleDescription:"Blnm dme",onSplitButtonAriaLabel:"Kameray ve kamera seeneklerini devre d brak",offSplitButtonAriaLabel:"Kameray ve kamera seeneklerini etkinletir",cameraActionTurnedOnAnnouncement:"Kameranz ald",cameraActionTurnedOffAnnouncement:"Kameranz kapatld",onSplitButtonPrimaryActionCamera:"Kameray kapat",offSplitButtonPrimaryActionCamera:"Kameray a",cameraPrimaryActionSplitButtonTitle:"Kameray kullan",videoEffectsMenuItemTitle:"Efektler"};var microphoneButton$2={onLabel:"Mikrofon",offLabel:"Mikrofon",tooltipDisabledContent:"Mikrofon devre d",tooltipOnContent:"Mikrofonun sesini kapat",tooltipOffContent:"Mikrofonun sesini a",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon se",speakerMenuTitle:"Hoparlr",speakerMenuTooltip:"Hoparlr se",microphoneButtonSplitRoleDescription:"Blnm dme",onSplitButtonAriaLabel:"Mikrofonun ve ses seeneklerinin sesini kapat",offSplitButtonAriaLabel:"Mikrofonun ve ses seeneklerinin sesini a",microphoneActionTurnedOnAnnouncement:"Mikrofonunuz ald",microphoneActionTurnedOffAnnouncement:"Mikrofonunuz kapatld",offSplitButtonMicrophonePrimaryAction:"Mikrofonun sesini a",onSplitButtonMicrophonePrimaryAction:"Mikrofonun sesini kapat",microphonePrimaryActionSplitButtonTitle:"Mikrofonu kullan"};var devicesButton$2={label:"Cihazlar",tooltipContent:"Cihazlar ynet",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera se",audioDeviceMenuTitle:"Ses Cihaz",audioDeviceMenuTooltip:"Ses cihaz se",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon se",speakerMenuTitle:"Hoparlr",speakerMenuTooltip:"Hoparlr se"};var participantsButton$2={label:"Kiiler",tooltipContent:"Katlmclar gster",menuHeader:"Bu aramada",participantsListButtonLabel:"{numParticipants} kiiler",muteAllButtonLabel:"Tmnn sesini kapat",copyInviteLinkButtonLabel:"Davet balantsn kopyala",copyInviteLinkActionedAriaLabel:"Davet balants kopyaland"};var screenShareButton$2={onLabel:"Sunumu Durdur",offLabel:"Sun",tooltipDisabledContent:"Sunu devre d brakld.",tooltipOnContent:"Ekrannz sunuluyor",tooltipOffContent:"Ekrannz sunun"};var raiseHandButton$2={offLabel:"Kaldr",onLabel:"ndir",tooltipDisabledContent:"El Kaldrma eylemi devre d brakld",tooltipOnContent:"Eli ndirme",tooltipOffContent:"El Kaldrma"};var reactionButton$2={label:"Tepki ver",ariaLabel:"Tepki Dmesi, Bir tepki gnder",tooltipDisabledContent:"Tepki eylemi devre d brakld",tooltipContent:"Tepki gnder",likeReactionTooltipContent:"Been",heartReactionTooltipContent:"Ak",laughReactionTooltipContent:"Kahkaha",applauseReactionTooltipContent:"Alk",surprisedReactionTooltipContent:"arm"};var messageThread$2={yesterday:"Dn",sunday:"Pazar",monday:"Pazartesi",tuesday:"Sal",wednesday:"aramba",thursday:"Perembe",friday:"Cuma",saturday:"Cumartesi",participantJoined:"sohbete katld.",participantLeft:"sohbetten ayrld.",editMessage:"Dzenle",removeMessage:"Sil",resendMessage:"Yeniden gndermeyi deneyin",failToSendTag:"Gnderilemedi",editedTag:"Dzenlendi",liveAuthorIntro:"{author} yle diyor:",messageContentAriaText:"{author} iletisinde unu yazd: {message}",messageContentMineAriaText:"{message}dediniz",editBoxTextLimit:"letiniz en fazla {limitNumber} ayor",editBoxPlaceholderText:"letinizi dzenleyin",newMessagesIndicator:"Yeni iletiler",noDisplayNameSub:"Ad yok",editBoxCancelButton:"ptal",editBoxSubmitButton:"Bitti",messageReadCount:"{messageReadByCount} / {remoteParticipantsCount} katlmc tarafndan okundu",actionMenuMoreOptions:"Dier Seenekler",downloadFile:"Dosyay indir",blockedWarningText:"Bu ileti kurulu ilkesi nedeniyle silindi.",blockedWarningLinkText:"Ayrntlar",fileCardGroupMessage:"letide {fileCount} ek var",messageDeletedAnnouncementAriaLabel:"leti silindi"};var errorBar$2={unableToReachChatService:"evrimdsnz",accessDenied:"Sohbet hizmetlerine eriilemedi. Ltfen salanan kullanc kimlik bilgilerini denetleyin",userNotInChatThread:"Artk bu sohbet yazmas iinde deilsiniz",sendMessageNotInChatThread:"Artk bu sohbet yazmas iinde olmadnz iin ileti gnderilemedi",sendMessageGeneric:"leti gnderilemedi",callingNetworkFailure:"Arama balanrken sorun olutu; evrimd grnyorsunuz",startVideoGeneric:"Video balatlamad",stopVideoGeneric:"Video durdurulamad",muteGeneric:"Mikrofonun sesi kapatlamad",unmuteGeneric:"Mikrofonun sesi alamad",speakingWhileMuted:"Mikrofonunuzun sesi kapal",startScreenShareGeneric:"Ekran paylam balatlrken bir sorun olutu.",stopScreenShareGeneric:"Ekran paylam durdurulamad",callNetworkQualityLow:"A kalitesi dk.",callNoSpeakerFound:"Hoparlr veya kulaklk bulunamad. Aramay dinlemek iin bir ses aygt balayn.",callNoMicrophoneFound:"Mikrofon bulunamad. Ses giri cihaz balan.",callMicrophoneAccessDenied:"Mikrofona eriemiyor. Bu web sayfas iin izin vermek iin adres ubuundaki kilidi tklatn.",callMicrophoneAccessDeniedSafari:"Mikrofona eriemiyor. zin vermek iin sayfay yenileyin veya bu taraycnn ayarlarn denetleyin ve bu web sitesi iin izinlerin etkinletirildiinden emin olun.",callMicrophoneMutedBySystem:"Sisteminiz tarafndan sessize alndnz.",callMicrophoneUnmutedBySystem:"Mikrofonunuz kurtarld ve sisteminiz tarafndan sesiniz ald.",callMacOsMicrophoneAccessDenied:"Mikrofona eriilemiyor. macOS gizlilik ayarlarnzda mikrofon izni verin.",callLocalVideoFreeze:"A bant genilii dk. Grntl aramada bakalar iin duraklatlm grnyor olabilir.",callCameraAccessDenied:"Kameraya eriemiyor. Bu web sayfas iin izin vermek iin adres ubuundaki kilidi tklatn.",callCameraAccessDeniedSafari:"Kameraya eriemiyor. zin vermek iin sayfay yenileyin veya bu taraycnn ayarlarn denetleyin ve bu web sitesi iin izinlerin etkinletirildiinden emin olun.",callCameraAlreadyInUse:"Kameraya eriemiyor. Baka bir uygulama tarafndan zaten kullanlyor olabilir.",callVideoStoppedBySystem:"Videonuz sisteminiz tarafndan durduruldu.",callVideoRecoveredBySystem:"Videonuz devam ediyor.",callMacOsCameraAccessDenied:"MacOS kameranza eriimi engelliyor. Bu taraycnn kameranza erimesine izin vermek iin gizlilik ayarlarnz gncelletirin.",callMacOsScreenShareAccessDenied:"MacOS ekran paylamn engelliyor. Bu taraycnn ekrannz kaydetmesini izin vermek iin gizlilik ayarlarnz gncelletirin.",dismissButtonAriaLabel:"Kapat",failedToJoinCallGeneric:"Aramaya katlnamad.",failedToJoinCallInvalidMeetingLink:"Toplantya katlnamyor. Geersiz Balant.",cameraFrozenForRemoteParticipants:"Aramadaki kullanclar videonuzu grmekte sorun yayor. Ltfen cihazlarnz ve alarnz kontrol edin.",unableToStartVideoEffect:"Video efekti uygulanamyor.",startSpotlightWhileMaxParticipantsAreSpotlighted:"ne karlan katlmc says zaten st snr getiinden katlmclarda ne karma zellii balatlamyor."};var videoGallery$2={screenIsBeingSharedMessage:"Ekrannz paylayorsunuz.",screenShareLoadingMessage:"{participant} adl katlmcnn ekrann ykleme",localVideoLabel:"Siz",localVideoCameraSwitcherLabel:"Kameray deitir",localVideoMovementLabel:"Tanabilir Yerel Video Kutucuu",localVideoSelectedDescription:"{cameraName} seildi",displayNamePlaceholder:"Adsz katlmc",fitRemoteParticipantToFrame:"ereveye sdr",fillRemoteParticipantFrame:"ereveyi doldur",pinParticipantForMe:"Benim iin sabitle",pinParticipantForMeLimitReached:"Sabitleme (snra ulald)",unpinParticipantForMe:"Sabitlemeyi kaldr",pinParticipantMenuItemAriaLabel:"{participantName} adl katlmcy sabitle",unpinParticipantMenuItemAriaLabel:"{participantName} adl katlmcnn sabitlemesini kaldr",pinnedParticipantAnnouncementAriaLabel:"{participantName} adl katlmc sabitlendi",unpinnedParticipantAnnouncementAriaLabel:"{participantName} adl katlmcnn sabitlemesi kaldrld",startSpotlightVideoTileMenuLabel:"Herkes iin ne kar",addSpotlightVideoTileMenuLabel:"ne karma ekle",spotlightLimitReachedMenuTitle:"ne karma snrna ulald",stopSpotlightVideoTileMenuLabel:"ne karmay durdur",stopSpotlightOnSelfVideoTileMenuLabel:"ne karmadan k",attendeeRole:"Katlmc"};var dialpad$2={placeholderText:"Telefon numaras gir",deleteButtonAriaLabel:"Sil"};var holdButton$2={onLabel:"Devam et",offLabel:"Beklet",tooltipOnContent:"Grmeye devam etme",tooltipOffContent:"Aramay bekletme"};var videoTile$2={participantStateRinging:"Aranyor...",participantStateHold:"Beklemede"};var CameraAndMicrophoneSitePermissionsRequest$2={primaryText:"{appName} uygulamasnn kameranz ve mikrofonunuzu kullanmasna izin verin",secondaryText:"Bu, katlmclarn sizi grebilmesi ve duyabilmesi iindir.",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln",primaryButtonText:"Kamera ve mikrofon olmadan devam et",ariaLabel:"Kamera ve mikrofon eriimine izin ver"};var CameraSitePermissionsRequest$2={primaryText:"{appName} uygulamasnn kameranz kullanmasna izin verin",secondaryText:"Bu, katlmclarn sizi grebilmesi iindir.",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln",primaryButtonText:"Kamera olmadan devam et",ariaLabel:"Kamera eriimine izin ver"};var MicrophoneSitePermissionsRequest$2={primaryText:"{appName} uygulamasnn mikrofonunuzu kullanmasna izin verin",secondaryText:"Bu, katlmclarn sizi duyabilmesi iindir.",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln",primaryButtonText:"Mikrofon olmadan devam et",ariaLabel:"Mikrofon eriimine izin ver"};var CameraAndMicrophoneSitePermissionsCheck$2={primaryText:"Kamera ve mikrofon eriimi denetleniyor",secondaryText:"stenirse eriime izin verin. Bu, katlmclarn sizi grebilmesi ve duyabilmesi iindir.",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln",primaryButtonText:"Kamera ve mikrofon olmadan devam et",ariaLabel:"Kamera ve mikrofon eriimi denetleniyor. stenirse eriime izin verin."};var CameraSitePermissionsCheck$2={primaryText:"Kamera eriimi denetleniyor",secondaryText:"stenirse eriime izin verin. Bu, katlmclarn sizi grebilmesi iindir.",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln",primaryButtonText:"Kamera olmadan devam et",ariaLabel:"Kamera eriimi denetleniyor. stenirse eriime izin verin."};var MicrophoneSitePermissionsCheck$2={primaryText:"Mikrofon eriimi denetleniyor",secondaryText:"stenirse eriime izin verin. Bu, katlmclarn sizi duyabilmesi iindir.",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln",primaryButtonText:"Mikrofon olmadan devam et",ariaLabel:"Mikrofon eriimi denetleniyor. stenirse eriime izin verin."};var CameraAndMicrophoneSitePermissionsDenied$2={primaryText:"Kamera ve mikrofona eriemiyor",secondaryText:"Bu web sayfas iin mikrofon izinleri vermek iin adres ubuundaki kilit simgesine tklayn. Sayfa yenilemesi gerekebilir.",primaryButtonText:"Kamera ve mikrofon olmadan devam et",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln"};var CameraAndMicrophoneSitePermissionsDeniedSafari$2={primaryText:"Kamera ve mikrofona eriemiyor",secondaryText:"zin vermek iin sayfay yenileyin veya bu taraycnn ayarlarn denetleyin ve bu web sitesi iin izinlerin etkinletirildiinden emin olun.",primaryButtonText:"Kamera ve mikrofon olmadan devam et",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln"};var CameraSitePermissionsDenied$2={primaryText:"Kameraya eriilemiyor",secondaryText:"Bu web sayfasnda kamera izinleri vermek iin adres ubuundaki kilit simgesine tklayn. Sayfa yenilemesi gerekebilir.",primaryButtonText:"Kamera olmadan devam et",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln"};var MicrophoneSitePermissionsDenied$2={primaryText:"Mikrofona eriilemiyor",secondaryText:"Bu web sayfas iin mikrofon izinleri vermek iin adres ubuundaki kilit simgesine tklayn. Sayfa yenilemesi gerekebilir.",primaryButtonText:"Mikrofon olmadan devam et",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln"};var CameraSitePermissionsDeniedSafari$2={primaryText:"Kameraya eriilemiyor",secondaryText:"zin vermek iin sayfay yenileyin veya bu taraycnn ayarlarn denetleyin ve bu web sitesi iin izinlerin etkinletirildiinden emin olun.",primaryButtonText:"Kamera olmadan devam et",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln"};var MicrophoneSitePermissionsDeniedSafari$2={primaryText:"Mikrofona eriilemiyor",secondaryText:"zin vermek iin sayfay yenileyin veya bu taraycnn ayarlarn denetleyin ve bu web sitesi iin izinlerin etkinletirildiinden emin olun.",primaryButtonText:"Mikrofon olmadan devam et",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln"};var UnsupportedBrowser$2={primaryText:"Tarayc desteklenmiyor",secondaryText:"Ltfen uyumlu bir tarayc kullanarak bu aramaya katln.",moreHelpLinkText:"Uyumluluk gereksinimlerini grntleyin"};var UnsupportedBrowserVersion$2={primaryText:"Tarayc gncelletirmesi gerekiyor",secondaryText:"Mmkn olan en iyi arama deneyimi iin ltfen taraycnz gncelletirin ve aramaya yeniden katlmay deneyin.",moreHelpLinkText:"Uyumluluk gereksinimlerini grntleyin",continueAnywayButtonText:"Gncelletirmeden arama balat"};var UnsupportedOperatingSystem$2={primaryText:"letim sistemi desteklenmiyor",secondaryText:"Ltfen uyumlu bir iletim sistemine sahip bir cihaz kullanarak bu arya katln.",moreHelpLinkText:"Uyumluluk gereksinimlerini grntleyin"};var BrowserPermissionDenied$2={primaryText:"Kameranz veya mikrofonunuzu kullanamazsnz",secondaryText:"Taraycnzn kameranza veya mikrofonunuza eriimi olmayabilir. Bunu dzeltmek iin Sistem Tercihleri'ni an.",primaryButtonText:"Yeniden dene",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln"};var BrowserPermissionDeniedIOS$2={primaryText:"Devam etmek iin mikrofon eriimine izin ver",secondaryText:"Bylece dier katlmclar sizi duyabilir.",primaryButtonText:"Yeniden dene",imageAltText:"iOS iin mikrofon ve kamera cihaz izin konumu",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln",step1Text:"Ayarlar uygulamasna gidin",step2Text:"Bu taraycnn ayarlarna ilerleyin",step3Text:"Mikrofonu A (stee bal kamera)",step4Text:"Aramaya tekrar katlmay deneyin",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$2={leftNavButtonAriaLabel:"nceki sayfa",rightNavButtonAriaLabel:"sonraki sayfa"};var tr_TR$1 = {participantItem:participantItem$2,ParticipantList:ParticipantList$2,typingIndicator:typingIndicator$2,sendBox:sendBox$2,richTextSendBox:richTextSendBox$2,mentionPopover:mentionPopover$2,imageOverlay:imageOverlay$2,messageStatusIndicator:messageStatusIndicator$2,endCallButton:endCallButton$2,cameraButton:cameraButton$2,microphoneButton:microphoneButton$2,devicesButton:devicesButton$2,participantsButton:participantsButton$2,screenShareButton:screenShareButton$2,raiseHandButton:raiseHandButton$2,reactionButton:reactionButton$2,messageThread:messageThread$2,errorBar:errorBar$2,videoGallery:videoGallery$2,dialpad:dialpad$2,holdButton:holdButton$2,videoTile:videoTile$2,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$2,CameraSitePermissionsRequest:CameraSitePermissionsRequest$2,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$2,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$2,CameraSitePermissionsCheck:CameraSitePermissionsCheck$2,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$2,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$2,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$2,CameraSitePermissionsDenied:CameraSitePermissionsDenied$2,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$2,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$2,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$2,UnsupportedBrowser:UnsupportedBrowser$2,UnsupportedBrowserVersion:UnsupportedBrowserVersion$2,UnsupportedOperatingSystem:UnsupportedOperatingSystem$2,BrowserPermissionDenied:BrowserPermissionDenied$2,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$2,verticalGallery:verticalGallery$2};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Turkish (Turkey).
 *
 * @public
 */
const COMPONENT_LOCALE_TR_TR = {
    strings: createComponentStrings(tr_TR$1)
};

var participantItem$1={isMeText:"()",menuTitle:"",removeButtonLabel:"",sharingIconLabel:"",mutedIconLabel:"",displayNamePlaceholder:"",participantStateRinging:"...",participantStateHold:"",attendeeRole:""};var ParticipantList$1={overflowParticipantCount:"+{overflowCount} "};var typingIndicator$1={singleUser:"{user} ...",multipleUsers:"{users} ...",multipleUsersAbbreviateOne:"{users}  1 ...",multipleUsersAbbreviateMany:"{users}  {numOthers} ...",delimiter:" "};var sendBox$1={placeholderText:"",textTooLong:"",sendButtonAriaLabel:"",fileUploadsPendingError:"...",removeFile:"",uploading:"",uploadCompleted:""};var richTextSendBox$1={placeholderText:"",textTooLong:"",sendButtonAriaLabel:"",fileUploadsPendingError:"...",removeFile:"",uploading:"",uploadCompleted:"",boldTooltip:"",italicTooltip:"",underlineTooltip:"",bulletListTooltip:"",numberListTooltip:"",increaseIndentTooltip:"",decreaseIndentTooltip:"",richTextFormatButtonTooltip:""};var mentionPopover$1={mentionPopoverHeader:""};var imageOverlay$1={downloadButtonLabel:"",dismissButtonAriaLabel:""};var messageStatusIndicator$1={deliveredAriaLabel:"",deliveredTooltipText:"",seenAriaLabel:"",seenTooltipText:"",readByTooltipText:"{messageThreadReadCount}/{remoteParticipantsCount} ",sendingAriaLabel:"",sendingTooltipText:"",failedToSendAriaLabel:"",failedToSendTooltipText:""};var endCallButton$1={label:"",tooltipContent:""};var cameraButton$1={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",tooltipVideoLoadingContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",cameraButtonSplitRoleDescription:"",onSplitButtonAriaLabel:"",offSplitButtonAriaLabel:"",cameraActionTurnedOnAnnouncement:"",cameraActionTurnedOffAnnouncement:"",onSplitButtonPrimaryActionCamera:"",offSplitButtonPrimaryActionCamera:"",cameraPrimaryActionSplitButtonTitle:"",videoEffectsMenuItemTitle:""};var microphoneButton$1={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:"",microphoneButtonSplitRoleDescription:"",onSplitButtonAriaLabel:"",offSplitButtonAriaLabel:"",microphoneActionTurnedOnAnnouncement:"",microphoneActionTurnedOffAnnouncement:"",offSplitButtonMicrophonePrimaryAction:"",onSplitButtonMicrophonePrimaryAction:"",microphonePrimaryActionSplitButtonTitle:""};var devicesButton$1={label:"",tooltipContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",audioDeviceMenuTitle:"",audioDeviceMenuTooltip:"",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:""};var participantsButton$1={label:"",tooltipContent:"",menuHeader:"",participantsListButtonLabel:"{numParticipants} ",muteAllButtonLabel:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:""};var screenShareButton$1={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:""};var raiseHandButton$1={offLabel:"",onLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:""};var reactionButton$1={label:"",ariaLabel:"",tooltipDisabledContent:"",tooltipContent:"",likeReactionTooltipContent:"",heartReactionTooltipContent:"",laughReactionTooltipContent:"",applauseReactionTooltipContent:"",surprisedReactionTooltipContent:""};var messageThread$1={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:"",participantLeft:"",editMessage:"",removeMessage:"",resendMessage:"",failToSendTag:"",editedTag:"",liveAuthorIntro:"{author} ",messageContentAriaText:"{author}  {message}",messageContentMineAriaText:" {message}",editBoxTextLimit:"{limitNumber}",editBoxPlaceholderText:"",newMessagesIndicator:"",noDisplayNameSub:"",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:"{messageReadByCount}/{remoteParticipantsCount} ",actionMenuMoreOptions:"",downloadFile:"",blockedWarningText:"",blockedWarningLinkText:"",fileCardGroupMessage:" {fileCount} ",messageDeletedAnnouncementAriaLabel:""};var errorBar$1={unableToReachChatService:"",accessDenied:" - ",userNotInChatThread:"",sendMessageNotInChatThread:"",sendMessageGeneric:"",callingNetworkFailure:" - ",startVideoGeneric:"",stopVideoGeneric:"",muteGeneric:"",unmuteGeneric:"",speakingWhileMuted:"",startScreenShareGeneric:"",stopScreenShareGeneric:"",callNetworkQualityLow:"",callNoSpeakerFound:"",callNoMicrophoneFound:"",callMicrophoneAccessDenied:"",callMicrophoneAccessDeniedSafari:"",callMicrophoneMutedBySystem:"",callMicrophoneUnmutedBySystem:"",callMacOsMicrophoneAccessDenied:" macOS ",callLocalVideoFreeze:"",callCameraAccessDenied:"",callCameraAccessDeniedSafari:"",callCameraAlreadyInUse:"",callVideoStoppedBySystem:"",callVideoRecoveredBySystem:"",callMacOsCameraAccessDenied:"MacOS ",callMacOsScreenShareAccessDenied:"MacOS ",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"",failedToJoinCallInvalidMeetingLink:"",cameraFrozenForRemoteParticipants:"",unableToStartVideoEffect:"",startSpotlightWhileMaxParticipantsAreSpotlighted:""};var videoGallery$1={screenIsBeingSharedMessage:"",screenShareLoadingMessage:" {participant} ",localVideoLabel:"",localVideoCameraSwitcherLabel:"",localVideoMovementLabel:"",localVideoSelectedDescription:" {cameraName}",displayNamePlaceholder:"",fitRemoteParticipantToFrame:"",fillRemoteParticipantFrame:"",pinParticipantForMe:"",pinParticipantForMeLimitReached:"()",unpinParticipantForMe:"",pinParticipantMenuItemAriaLabel:" {participantName}",unpinParticipantMenuItemAriaLabel:" {participantName}",pinnedParticipantAnnouncementAriaLabel:" {participantName}",unpinnedParticipantAnnouncementAriaLabel:" {participantName}",startSpotlightVideoTileMenuLabel:"",addSpotlightVideoTileMenuLabel:"",spotlightLimitReachedMenuTitle:"",stopSpotlightVideoTileMenuLabel:"",stopSpotlightOnSelfVideoTileMenuLabel:"",attendeeRole:""};var dialpad$1={placeholderText:"",deleteButtonAriaLabel:""};var holdButton$1={onLabel:"",offLabel:"",tooltipOnContent:"",tooltipOffContent:""};var videoTile$1={participantStateRinging:"...",participantStateHold:""};var CameraAndMicrophoneSitePermissionsRequest$1={primaryText:"{appName}",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraSitePermissionsRequest$1={primaryText:" {appName} ",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var MicrophoneSitePermissionsRequest$1={primaryText:" {appName} ",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraAndMicrophoneSitePermissionsCheck$1={primaryText:"",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraSitePermissionsCheck$1={primaryText:"",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var MicrophoneSitePermissionsCheck$1={primaryText:"",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraAndMicrophoneSitePermissionsDenied$1={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var CameraAndMicrophoneSitePermissionsDeniedSafari$1={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var CameraSitePermissionsDenied$1={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var MicrophoneSitePermissionsDenied$1={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var CameraSitePermissionsDeniedSafari$1={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var MicrophoneSitePermissionsDeniedSafari$1={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var UnsupportedBrowser$1={primaryText:"",secondaryText:"",moreHelpLinkText:""};var UnsupportedBrowserVersion$1={primaryText:"",secondaryText:"",moreHelpLinkText:"",continueAnywayButtonText:""};var UnsupportedOperatingSystem$1={primaryText:"",secondaryText:"",moreHelpLinkText:""};var BrowserPermissionDenied$1={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var BrowserPermissionDeniedIOS$1={primaryText:"",secondaryText:"",primaryButtonText:"",imageAltText:"iOS ",linkText:"? ",step1Text:"",step2Text:"",step3Text:"()",step4Text:"",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery$1={leftNavButtonAriaLabel:"",rightNavButtonAriaLabel:""};var zh_CN$1 = {participantItem:participantItem$1,ParticipantList:ParticipantList$1,typingIndicator:typingIndicator$1,sendBox:sendBox$1,richTextSendBox:richTextSendBox$1,mentionPopover:mentionPopover$1,imageOverlay:imageOverlay$1,messageStatusIndicator:messageStatusIndicator$1,endCallButton:endCallButton$1,cameraButton:cameraButton$1,microphoneButton:microphoneButton$1,devicesButton:devicesButton$1,participantsButton:participantsButton$1,screenShareButton:screenShareButton$1,raiseHandButton:raiseHandButton$1,reactionButton:reactionButton$1,messageThread:messageThread$1,errorBar:errorBar$1,videoGallery:videoGallery$1,dialpad:dialpad$1,holdButton:holdButton$1,videoTile:videoTile$1,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$1,CameraSitePermissionsRequest:CameraSitePermissionsRequest$1,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$1,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$1,CameraSitePermissionsCheck:CameraSitePermissionsCheck$1,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$1,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$1,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$1,CameraSitePermissionsDenied:CameraSitePermissionsDenied$1,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$1,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$1,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$1,UnsupportedBrowser:UnsupportedBrowser$1,UnsupportedBrowserVersion:UnsupportedBrowserVersion$1,UnsupportedOperatingSystem:UnsupportedOperatingSystem$1,BrowserPermissionDenied:BrowserPermissionDenied$1,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$1,verticalGallery:verticalGallery$1};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Chinese (Mainland China).
 *
 * @public
 */
const COMPONENT_LOCALE_ZH_CN = {
    strings: createComponentStrings(zh_CN$1)
};

var participantItem={isMeText:"()",menuTitle:"",removeButtonLabel:"",sharingIconLabel:"",mutedIconLabel:"",displayNamePlaceholder:"",participantStateRinging:"...",participantStateHold:"",attendeeRole:""};var ParticipantList={overflowParticipantCount:" {overflowCount} "};var typingIndicator={singleUser:"{user} ...",multipleUsers:"{users} ...",multipleUsersAbbreviateOne:"{users}  1 ...",multipleUsersAbbreviateMany:"{users}  {numOthers} ...",delimiter:" "};var sendBox={placeholderText:"",textTooLong:"",sendButtonAriaLabel:"",fileUploadsPendingError:"... ",removeFile:"",uploading:"",uploadCompleted:""};var richTextSendBox={placeholderText:"",textTooLong:"",sendButtonAriaLabel:"",fileUploadsPendingError:"...",removeFile:"",uploading:"",uploadCompleted:"",boldTooltip:"",italicTooltip:"",underlineTooltip:"",bulletListTooltip:"",numberListTooltip:"",increaseIndentTooltip:"",decreaseIndentTooltip:"",richTextFormatButtonTooltip:""};var mentionPopover={mentionPopoverHeader:""};var imageOverlay={downloadButtonLabel:"",dismissButtonAriaLabel:""};var messageStatusIndicator={deliveredAriaLabel:"",deliveredTooltipText:"",seenAriaLabel:"",seenTooltipText:"",readByTooltipText:" {messageThreadReadCount} / {remoteParticipantsCount}",sendingAriaLabel:"",sendingTooltipText:"",failedToSendAriaLabel:"",failedToSendTooltipText:""};var endCallButton={label:"",tooltipContent:""};var cameraButton={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",tooltipVideoLoadingContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",cameraButtonSplitRoleDescription:"[] ",onSplitButtonAriaLabel:"",offSplitButtonAriaLabel:"",cameraActionTurnedOnAnnouncement:"",cameraActionTurnedOffAnnouncement:"",onSplitButtonPrimaryActionCamera:"",offSplitButtonPrimaryActionCamera:"",cameraPrimaryActionSplitButtonTitle:"",videoEffectsMenuItemTitle:""};var microphoneButton={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:"",microphoneButtonSplitRoleDescription:"[] ",onSplitButtonAriaLabel:"",offSplitButtonAriaLabel:"",microphoneActionTurnedOnAnnouncement:"",microphoneActionTurnedOffAnnouncement:"",offSplitButtonMicrophonePrimaryAction:"",onSplitButtonMicrophonePrimaryAction:"",microphonePrimaryActionSplitButtonTitle:""};var devicesButton={label:"",tooltipContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",audioDeviceMenuTitle:"",audioDeviceMenuTooltip:"",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:""};var participantsButton={label:"",tooltipContent:"",menuHeader:"",participantsListButtonLabel:"{numParticipants} ",muteAllButtonLabel:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:""};var screenShareButton={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:""};var raiseHandButton={offLabel:"",onLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:""};var reactionButton={label:"",ariaLabel:"",tooltipDisabledContent:"",tooltipContent:"",likeReactionTooltipContent:"",heartReactionTooltipContent:"",laughReactionTooltipContent:"",applauseReactionTooltipContent:"",surprisedReactionTooltipContent:""};var messageThread={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:"",participantLeft:"",editMessage:"",removeMessage:"",resendMessage:"",failToSendTag:"",editedTag:"",liveAuthorIntro:"{author} ",messageContentAriaText:"{author}  {message}",messageContentMineAriaText:" {message}",editBoxTextLimit:" {limitNumber} ",editBoxPlaceholderText:"",newMessagesIndicator:"",noDisplayNameSub:"",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:" {messageReadByCount} / {remoteParticipantsCount}",actionMenuMoreOptions:"",downloadFile:"",blockedWarningText:"",blockedWarningLinkText:"",fileCardGroupMessage:" {fileCount} ",messageDeletedAnnouncementAriaLabel:""};var errorBar={unableToReachChatService:"",accessDenied:" - ",userNotInChatThread:"",sendMessageNotInChatThread:"",sendMessageGeneric:"",callingNetworkFailure:" - ",startVideoGeneric:"",stopVideoGeneric:"",muteGeneric:"",unmuteGeneric:"",speakingWhileMuted:"",startScreenShareGeneric:"",stopScreenShareGeneric:"",callNetworkQualityLow:"",callNoSpeakerFound:"",callNoMicrophoneFound:"",callMicrophoneAccessDenied:"",callMicrophoneAccessDeniedSafari:"",callMicrophoneMutedBySystem:"",callMicrophoneUnmutedBySystem:"",callMacOsMicrophoneAccessDenied:" MacOS ",callLocalVideoFreeze:"",callCameraAccessDenied:"",callCameraAccessDeniedSafari:"",callCameraAlreadyInUse:"",callVideoStoppedBySystem:"",callVideoRecoveredBySystem:"",callMacOsCameraAccessDenied:"MacOS ",callMacOsScreenShareAccessDenied:"MacOS ",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"",failedToJoinCallInvalidMeetingLink:"",cameraFrozenForRemoteParticipants:"",unableToStartVideoEffect:"",startSpotlightWhileMaxParticipantsAreSpotlighted:""};var videoGallery={screenIsBeingSharedMessage:"",screenShareLoadingMessage:" {participant} ",localVideoLabel:"",localVideoCameraSwitcherLabel:"",localVideoMovementLabel:"",localVideoSelectedDescription:" {cameraName}",displayNamePlaceholder:"",fitRemoteParticipantToFrame:"",fillRemoteParticipantFrame:"",pinParticipantForMe:"",pinParticipantForMeLimitReached:" ()",unpinParticipantForMe:"",pinParticipantMenuItemAriaLabel:" {participantName}",unpinParticipantMenuItemAriaLabel:" {participantName}",pinnedParticipantAnnouncementAriaLabel:" {participantName}",unpinnedParticipantAnnouncementAriaLabel:" {participantName}",startSpotlightVideoTileMenuLabel:"",addSpotlightVideoTileMenuLabel:"",spotlightLimitReachedMenuTitle:"",stopSpotlightVideoTileMenuLabel:"",stopSpotlightOnSelfVideoTileMenuLabel:"",attendeeRole:""};var dialpad={placeholderText:"",deleteButtonAriaLabel:""};var holdButton={onLabel:"",offLabel:"",tooltipOnContent:"",tooltipOffContent:""};var videoTile={participantStateRinging:"...",participantStateHold:""};var CameraAndMicrophoneSitePermissionsRequest={primaryText:" {appName} ",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraSitePermissionsRequest={primaryText:" {appName} ",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var MicrophoneSitePermissionsRequest={primaryText:" {appName} ",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraAndMicrophoneSitePermissionsCheck={primaryText:"",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraSitePermissionsCheck={primaryText:"",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var MicrophoneSitePermissionsCheck={primaryText:"",secondaryText:"",linkText:"? ",primaryButtonText:"",ariaLabel:""};var CameraAndMicrophoneSitePermissionsDenied={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var CameraAndMicrophoneSitePermissionsDeniedSafari={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var CameraSitePermissionsDenied={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var MicrophoneSitePermissionsDenied={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var CameraSitePermissionsDeniedSafari={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var MicrophoneSitePermissionsDeniedSafari={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var UnsupportedBrowser={primaryText:"",secondaryText:"",moreHelpLinkText:""};var UnsupportedBrowserVersion={primaryText:"",secondaryText:"",moreHelpLinkText:"",continueAnywayButtonText:""};var UnsupportedOperatingSystem={primaryText:"",secondaryText:"",moreHelpLinkText:""};var BrowserPermissionDenied={primaryText:"",secondaryText:" []",primaryButtonText:"",linkText:"? "};var BrowserPermissionDeniedIOS={primaryText:"",secondaryText:"",primaryButtonText:"",imageAltText:"iOS ",linkText:"? ",step1Text:" [] ",step2Text:"",step3Text:" ()",step4Text:"",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var verticalGallery={leftNavButtonAriaLabel:"",rightNavButtonAriaLabel:""};var zh_TW$1 = {participantItem:participantItem,ParticipantList:ParticipantList,typingIndicator:typingIndicator,sendBox:sendBox,richTextSendBox:richTextSendBox,mentionPopover:mentionPopover,imageOverlay:imageOverlay,messageStatusIndicator:messageStatusIndicator,endCallButton:endCallButton,cameraButton:cameraButton,microphoneButton:microphoneButton,devicesButton:devicesButton,participantsButton:participantsButton,screenShareButton:screenShareButton,raiseHandButton:raiseHandButton,reactionButton:reactionButton,messageThread:messageThread,errorBar:errorBar,videoGallery:videoGallery,dialpad:dialpad,holdButton:holdButton,videoTile:videoTile,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest,CameraSitePermissionsRequest:CameraSitePermissionsRequest,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck,CameraSitePermissionsCheck:CameraSitePermissionsCheck,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari,CameraSitePermissionsDenied:CameraSitePermissionsDenied,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari,UnsupportedBrowser:UnsupportedBrowser,UnsupportedBrowserVersion:UnsupportedBrowserVersion,UnsupportedOperatingSystem:UnsupportedOperatingSystem,BrowserPermissionDenied:BrowserPermissionDenied,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS,verticalGallery:verticalGallery};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Chinese (Taiwan).
 *
 * @public
 */
const COMPONENT_LOCALE_ZH_TW = {
    strings: createComponentStrings(zh_TW$1)
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const checkIsSpeaking = (participant) => participant.isSpeaking && !participant.isMuted;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @internal */
const _dominantSpeakersWithFlatId = (dominantSpeakers) => {
    var _a;
    return (_a = dominantSpeakers === null || dominantSpeakers === void 0 ? void 0 : dominantSpeakers.speakersList) === null || _a === void 0 ? void 0 : _a.map(toFlatCommunicationIdentifier);
};
/** @internal */
const _videoGalleryRemoteParticipantsMemo = (remoteParticipants, isHideAttendeeNamesEnabled) => {
    if (!remoteParticipants) {
        return [];
    }
    return memoizedAllConvertRemoteParticipant(memoizedFn => {
        return Object.values(remoteParticipants)
            /**
             * hiding participants who are inLobby, idle, or connecting in ACS clients till we can admit users through ACS clients.
             * phone users will be in the connecting state until they are connected to the call.
             */ .filter((participant) => {
            return !['InLobby', 'Idle', 'Connecting', 'Disconnected'].includes(participant.state) || communicationCommon.isPhoneNumberIdentifier(participant.identifier);
        }).map((participant) => {
            const state = _isRingingPSTNParticipant(participant);
            let displayName = participant.displayName;
            return memoizedFn(toFlatCommunicationIdentifier(participant.identifier), participant.isMuted, checkIsSpeaking(participant), participant.videoStreams, state, displayName, /* @conditional-compile-remove(raise-hand) */ participant.raisedHand);
        });
    });
};
const memoizedAllConvertRemoteParticipant = memoizeFnAll((userId, isMuted, isSpeaking, videoStreams, state, displayName, raisedHand, reaction, spotlight, contentSharingStream) => {
    return convertRemoteParticipantToVideoGalleryRemoteParticipant(userId, isMuted, isSpeaking, videoStreams, state, displayName, /* @conditional-compile-remove(raise-hand) */ raisedHand);
});
/** @private */
const convertRemoteParticipantToVideoGalleryRemoteParticipant = (userId, isMuted, isSpeaking, videoStreams, state, displayName, raisedHand, reaction, spotlight, contentSharingStream) => {
    const rawVideoStreamsArray = Object.values(videoStreams);
    let videoStream = undefined;
    let screenShareStream = undefined;
    const sdkRemoteVideoStream = Object.values(rawVideoStreamsArray).find(i => i.mediaStreamType === 'Video' && i.isAvailable) || Object.values(rawVideoStreamsArray).find(i => i.mediaStreamType === 'Video');
    const sdkScreenShareStream = Object.values(rawVideoStreamsArray).find(i => i.mediaStreamType === 'ScreenSharing' && i.isAvailable) || Object.values(rawVideoStreamsArray).find(i => i.mediaStreamType === 'ScreenSharing');
    if (sdkRemoteVideoStream) {
        videoStream = convertRemoteVideoStreamToVideoGalleryStream(sdkRemoteVideoStream);
    }
    if (sdkScreenShareStream) {
        screenShareStream = convertRemoteVideoStreamToVideoGalleryStream(sdkScreenShareStream);
    }
    return {
        userId,
        displayName,
        isMuted,
        isSpeaking,
        videoStream,
        screenShareStream,
        isScreenSharingOn: screenShareStream !== undefined && screenShareStream.isAvailable,
        /* @conditional-compile-remove(raise-hand) */
        raisedHand: raisedHand
    };
};
const convertRemoteVideoStreamToVideoGalleryStream = (stream) => {
    var _a, _b, _c;
    return {
        id: stream.id,
        isAvailable: stream.isAvailable,
        isMirrored: (_a = stream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
        renderElement: (_b = stream.view) === null || _b === void 0 ? void 0 : _b.target,
        scalingMode: (_c = stream.view) === null || _c === void 0 ? void 0 : _c.scalingMode,
        streamSize: stream.streamSize
    };
};
/** @private */
const memoizeLocalParticipant = memoizeOne((identifier, displayName, isMuted, isScreenSharingOn, localVideoStream, /* @conditional-compile-remove(rooms) */ role, /* @conditional-compile-remove(raise-hand) */ raisedHand) => {
    var _a, _b;
    return ({
        userId: identifier,
        displayName: displayName !== null && displayName !== void 0 ? displayName : '',
        isMuted: isMuted,
        isScreenSharingOn: isScreenSharingOn,
        videoStream: {
            isAvailable: !!localVideoStream,
            isMirrored: (_a = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
            renderElement: (_b = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _b === void 0 ? void 0 : _b.target
        },
        /* @conditional-compile-remove(rooms) */
        role,
        /* @conditional-compile-remove(raise-hand) */
        raisedHand: raisedHand
    });
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const getRemoteParticipantsExcludingConsumers = reselect.createSelector([getRemoteParticipants$1], (remoteParticipants) => {
    /* @conditional-compile-remove(rooms) */
    {
        const newRemoteParticipants = Object.assign({}, remoteParticipants);
        Object.keys(newRemoteParticipants).forEach(k => {
            if (newRemoteParticipants[k].role === 'Consumer') {
                delete newRemoteParticipants[k];
            }
        });
        return newRemoteParticipants;
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Provides data attributes to {@link VideoGallery} component.
 * @public
 */
const videoGallerySelector = reselect.createSelector([getScreenShareRemoteParticipant, getRemoteParticipantsExcludingConsumers, getLocalVideoStreams$1, getIsMuted, getIsScreenSharingOn, getDisplayName$2, getIdentifier, getDominantSpeakers, /* @conditional-compile-remove(optimal-video-count) */
    getOptimalVideoCount, /* @conditional-compile-remove(rooms) */
    getRole$1, /* @conditional-compile-remove(raise-hand) */
    getLocalParticipantRaisedHand$1], (screenShareRemoteParticipantId, remoteParticipants, localVideoStreams, isMuted, isScreenSharingOn, displayName, identifier, dominantSpeakers, /* @conditional-compile-remove(optimal-video-count) */ optimalVideoCount, /* @conditional-compile-remove(rooms) */ role, /* @conditional-compile-remove(raise-hand) */ raisedHand) => {
    const screenShareRemoteParticipant = screenShareRemoteParticipantId && remoteParticipants ? remoteParticipants[screenShareRemoteParticipantId] : undefined;
    const localVideoStream = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(i => i.mediaStreamType === 'Video');
    const dominantSpeakerIds = _dominantSpeakersWithFlatId(dominantSpeakers);
    dominantSpeakerIds === null || dominantSpeakerIds === void 0 ? void 0 : dominantSpeakerIds.forEach((speaker, idx) => idx);
    const noRemoteParticipants = [];
    return {
        screenShareParticipant: screenShareRemoteParticipant ? convertRemoteParticipantToVideoGalleryRemoteParticipant(toFlatCommunicationIdentifier(screenShareRemoteParticipant.identifier), screenShareRemoteParticipant.isMuted, checkIsSpeaking(screenShareRemoteParticipant), screenShareRemoteParticipant.videoStreams, screenShareRemoteParticipant.state, screenShareRemoteParticipant.displayName, /* @conditional-compile-remove(raise-hand) */ screenShareRemoteParticipant.raisedHand) : undefined,
        localParticipant: memoizeLocalParticipant(identifier, displayName, isMuted, isScreenSharingOn, localVideoStream, /* @conditional-compile-remove(rooms) */ role, /* @conditional-compile-remove(raise-hand) */ raisedHand),
        remoteParticipants: _videoGalleryRemoteParticipantsMemo(updateUserDisplayNamesTrampoline$2(remoteParticipants ? Object.values(remoteParticipants) : noRemoteParticipants)),
        dominantSpeakers: dominantSpeakerIds,
        /* @conditional-compile-remove(optimal-video-count) */
        maxRemoteVideoStreams: optimalVideoCount
    };
});
const updateUserDisplayNamesTrampoline$2 = (remoteParticipants) => {
    return remoteParticipants;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const convertRemoteParticipantToParticipantListParticipant = (userId, displayName, state, isMuted, isScreenSharing, isSpeaking, raisedHand, localUserCanRemoveOthers) => {
    const identifier = fromFlatCommunicationIdentifier(userId);
    return {
        userId,
        displayName,
        state,
        isMuted,
        isScreenSharing,
        isSpeaking,
        // ACS users can not remove Teams users.
        // Removing unknown types of users is undefined.
        isRemovable: (communicationCommon.getIdentifierKind(identifier).kind === 'communicationUser' || communicationCommon.getIdentifierKind(identifier).kind === 'phoneNumber') && localUserCanRemoveOthers
    };
};
/* @conditional-compile-remove(rooms) */
/**
 * @private
 */
const memoizedConvertAllremoteParticipantsBetaRelease = memoizeFnAll((userId, displayName, state, isMuted, isScreenSharing, isSpeaking, raisedHand, localUserCanRemoveOthers) => {
    return convertRemoteParticipantToParticipantListParticipantBetaRelease(userId, displayName, state, isMuted, isScreenSharing, isSpeaking, raisedHand, localUserCanRemoveOthers);
});
/* @conditional-compile-remove(rooms) */
const convertRemoteParticipantToParticipantListParticipantBetaRelease = (userId, displayName, state, isMuted, isScreenSharing, isSpeaking, raisedHand, localUserCanRemoveOthers) => {
    return Object.assign({}, convertRemoteParticipantToParticipantListParticipant(userId, displayName, state, isMuted, isScreenSharing, isSpeaking, raisedHand, localUserCanRemoveOthers));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const convertRemoteParticipantsToParticipantListParticipants = (remoteParticipants, localUserCanRemoveOthers, isHideAttendeeNamesEnabled, localUserRole, spotlightedParticipants) => {
    const conversionCallback = (memoizeFn) => {
        return remoteParticipants
            // Filter out MicrosoftBot participants
            .filter((participant) => {
            return !communicationCommon.isMicrosoftTeamsAppIdentifier(participant.identifier);
        })
            /**
             * hiding participants who are inLobby, idle, or connecting in ACS clients till we can admit users through ACS clients.
             * phone users will be in the connecting state until they are connected to the call.
             */ .filter(participant => {
            return !['InLobby', 'Idle', 'Connecting', 'Disconnected'].includes(participant.state) || communicationCommon.isPhoneNumberIdentifier(participant.identifier);
        }).map((participant) => {
            const isScreenSharing = Object.values(participant.videoStreams).some(videoStream => videoStream.mediaStreamType === 'ScreenSharing' && videoStream.isAvailable);
            /**
             * We want to check the participant to see if they are a PSTN participant joining the call
             * and mapping their state to be 'Ringing'
             */
            const state = _isRingingPSTNParticipant(participant);
            let displayName = participant.displayName;
            return memoizeFn(toFlatCommunicationIdentifier(participant.identifier), displayName, state, participant.isMuted, isScreenSharing, participant.isSpeaking, /* @conditional-compile-remove(raise-hand) */ participant.raisedHand, localUserCanRemoveOthers);
        }).sort((a, b) => {
            var _a, _b;
            const nameA = ((_a = a.displayName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || '';
            const nameB = ((_b = b.displayName) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || '';
            if (nameA < nameB) {
                return -1;
            }
            else if (nameA > nameB) {
                return 1;
            }
            else {
                return 0;
            }
        });
    };
    /* @conditional-compile-remove(rooms) */
    return memoizedConvertAllremoteParticipantsBetaRelease(conversionCallback);
};
/**
 * Selects data that drives {@link ParticipantList} component.
 *
 * @public
 */
const participantListSelector = reselect.createSelector([getIdentifier, getDisplayName$2, getRemoteParticipantsExcludingConsumers, getIsScreenSharingOn, getIsMuted, /* @conditional-compile-remove(raise-hand) */ getLocalParticipantRaisedHand$1, getRole$1, getParticipantCount], (userId, displayName, remoteParticipants, isScreenSharingOn, isMuted, /* @conditional-compile-remove(raise-hand) */ raisedHand, role, partitipantCount) => {
    const localUserCanRemoveOthers = localUserCanRemoveOthersTrampoline(role);
    const participants = remoteParticipants ? convertRemoteParticipantsToParticipantListParticipants(updateUserDisplayNamesTrampoline$1(Object.values(remoteParticipants)), localUserCanRemoveOthers) : [];
    participants.push({
        userId: userId,
        displayName: displayName,
        isScreenSharing: isScreenSharingOn,
        isMuted: isMuted,
        /* @conditional-compile-remove(raise-hand) */
        raisedHand: raisedHand,
        state: 'Connected',
        // Local participant can never remove themselves.
        isRemovable: false
    });
    return {
        participants: participants,
        myUserId: userId
    };
});
const updateUserDisplayNamesTrampoline$1 = (remoteParticipants) => {
    return remoteParticipants;
};
const localUserCanRemoveOthersTrampoline = (role) => {
    /* @conditional-compile-remove(rooms) */
    return role === 'Presenter' || role === 'Unknown' || role === undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Selects data that drives {@link ParticipantsButton} component.
 *
 * @public
 */
const participantsButtonSelector = reselect.createSelector([participantListSelector], (participantListProps) => {
    return participantListProps;
});

/**
 * Create a set of default handlers for given component. Memoization is applied to the result. Multiple invocations with
 * the same arguments will return the same handler instances. DeclarativeCallAgent, DeclarativeDeviceManager, and
 * DeclarativeCall may be undefined. If undefined, their associated handlers will not be created and returned.
 *
 * @param callClient - StatefulCallClient returned from
 *   {@link @azure/communication-react#createStatefulCallClient}.
 * @param callAgent - Instance of {@link @azure/communication-calling#CallClient}.
 * @param deviceManager - Instance of {@link @azure/communication-calling#DeviceManager}.
 * @param call - Instance of {@link @azure/communication-calling#Call}.
 * @param _ - React component that you want to generate handlers for.
 *
 * @public
 */
const createDefaultCallingHandlersForComponent = (callClient, callAgent, deviceManager, call, _Component) => {
    if (!callAgent && !call && !deviceManager) {
        return createDefaultCallingHandlers(callClient, callAgent, deviceManager, call);
    }
    if (callAgent && _isACSCallAgent() && (!call || call && _isACSCall())) {
        return createDefaultCallingHandlers(callClient, callAgent, deviceManager, call);
    }
    throw new Error('CallAgent type and Call type are not compatible!');
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Hook to obtain a handler for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers$3 = (component) => {
    var _a, _b, _c;
    const callClient = (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.callClient;
    const deviceManager = useDeviceManager();
    const call = (_b = React.useContext(CallContext$1)) === null || _b === void 0 ? void 0 : _b.call;
    const callAgent = (_c = React.useContext(CallAgentContext)) === null || _c === void 0 ? void 0 : _c.callAgent;
    if (!callClient) {
        return undefined;
    }
    // Handle edge case, validate if call and callAgent are the same type (ACS/Teams)
    if (callAgent && _isTeamsCallAgent()) {
        if (call && !_isTeamsCall()) {
            throw new Error('A TeamsCall must be provided when callAgent is TeamsCallAgent');
        }
    }
    if (callAgent && _isACSCallAgent()) {
        if (call && !_isACSCall()) {
            throw new Error('A regular ACS Call must be provided when callAgent is regular CallAgent');
        }
    }
    return createDefaultCallingHandlersForComponent(callClient, callAgent, deviceManager, call);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector$3 = (selector, selectorProps) => {
    var _a, _b, _c;
    const callClient = (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.callClient;
    const callId = (_c = (_b = React.useContext(CallContext$1)) === null || _b === void 0 ? void 0 : _b.call) === null || _c === void 0 ? void 0 : _c.id;
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const callIdConfigProps = React.useMemo(() => ({
        callId
    }), [callId]);
    const [props, setProps] = React.useState(callClient && selector ? selector(callClient.getState(), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callIdConfigProps) : undefined);
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        if (!callClient || !selector) {
            return;
        }
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(state, selectorProps !== null && selectorProps !== void 0 ? selectorProps : callIdConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        callClient.onStateChange(onStateChange);
        return () => {
            callClient.offStateChange(onStateChange);
        };
    }, [callClient, selector, selectorProps, callIdConfigProps, mounted]);
    return selector ? props : undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Select the first 3 active errors from the state for the `ErrorBar` component.
 *
 * In case there are many errors, only the first three errors are returned to avoid
 * filling up the UI with too many errors.
 *
 * Invariants:
 *   - `ErrorType` is never repeated in the returned errors.
 *   - Errors are returned in a fixed order by `ErrorType`.
 *
 * @public
 */
const errorBarSelector$1 = reselect.createSelector([getLatestErrors$1, getDiagnostics, getDeviceManager$1, getEnvironmentInfo], (latestErrors, diagnostics, deviceManager, environmentInfo) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    // The order in which the errors are returned is significant: The `ErrorBar` shows errors on the UI in that order.
    // There are several options for the ordering:
    //   - Sorted by when the errors happened (latest first / oldest first).
    //   - Stable sort by error type.
    //
    // We chose to stable sort by error type: We intend to show only a small number of errors on the UI and we do not
    // have timestamps for errors.
    const activeErrorMessages = [];
    const isSafari = () => {
        return /^((?!chrome|android|crios|fxios).)*safari/i.test(navigator.userAgent);
    };
    const isMacOS = () => {
        return false;
    };
    // Errors reported via diagnostics are more reliable than from API method failures, so process those first.
    if (((_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReceiveQuality) === null || _a === void 0 ? void 0 : _a.value) === communicationCalling.DiagnosticQuality.Bad || ((_b = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReceiveQuality) === null || _b === void 0 ? void 0 : _b.value) === communicationCalling.DiagnosticQuality.Poor) {
        activeErrorMessages.push({
            type: 'callNetworkQualityLow'
        });
    }
    if (((_c = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.noSpeakerDevicesEnumerated) === null || _c === void 0 ? void 0 : _c.value) === true) {
        activeErrorMessages.push({
            type: 'callNoSpeakerFound'
        });
    }
    if (((_d = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.noMicrophoneDevicesEnumerated) === null || _d === void 0 ? void 0 : _d.value) === true) {
        activeErrorMessages.push({
            type: 'callNoMicrophoneFound'
        });
    }
    if (((_e = deviceManager.deviceAccess) === null || _e === void 0 ? void 0 : _e.audio) === false && isSafari()) {
        activeErrorMessages.push({
            type: 'callMicrophoneAccessDeniedSafari'
        });
    }
    if (((_f = deviceManager.deviceAccess) === null || _f === void 0 ? void 0 : _f.audio) === false && !isSafari()) {
        activeErrorMessages.push({
            type: 'callMicrophoneAccessDenied'
        });
    }
    if (((_g = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphonePermissionDenied) === null || _g === void 0 ? void 0 : _g.value) === true && isMacOS()) {
        activeErrorMessages.push({
            type: 'callMacOsMicrophoneAccessDenied'
        });
    }
    else if (((_h = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphonePermissionDenied) === null || _h === void 0 ? void 0 : _h.value) === true) {
        activeErrorMessages.push({
            type: 'callMicrophoneAccessDenied'
        });
    }
    const microphoneMuteUnexpectedlyDiagnostic = (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphoneMuteUnexpectedly) || (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphoneNotFunctioning);
    if (microphoneMuteUnexpectedlyDiagnostic) {
        if (microphoneMuteUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Bad) {
            // Inform the user that microphone stopped working and inform them to start microphone again
            activeErrorMessages.push({
                type: 'callMicrophoneMutedBySystem'
            });
        }
        else if (microphoneMuteUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Good) {
            // Inform the user that microphone recovered
            activeErrorMessages.push({
                type: 'callMicrophoneUnmutedBySystem'
            });
        }
    }
    const cameraStoppedUnexpectedlyDiagnostic = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraStoppedUnexpectedly;
    if (cameraStoppedUnexpectedlyDiagnostic) {
        if (cameraStoppedUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Bad) {
            // Inform the user that camera stopped working and inform them to start video again
            activeErrorMessages.push({
                type: 'callVideoStoppedBySystem'
            });
        }
        else if (cameraStoppedUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Good) {
            // Inform the user that camera recovered
            activeErrorMessages.push({
                type: 'callVideoRecoveredBySystem'
            });
        }
    }
    if (((_j = deviceManager.deviceAccess) === null || _j === void 0 ? void 0 : _j.video) === false && isSafari()) {
        activeErrorMessages.push({
            type: 'callCameraAccessDeniedSafari'
        });
    }
    else if (((_k = deviceManager.deviceAccess) === null || _k === void 0 ? void 0 : _k.video) === false) {
        activeErrorMessages.push({
            type: 'callCameraAccessDenied'
        });
    }
    else {
        if (((_l = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraFreeze) === null || _l === void 0 ? void 0 : _l.value) === true) {
            activeErrorMessages.push({
                type: 'cameraFrozenForRemoteParticipants'
            });
        }
    }
    /**
     * show the Mac specific strings if the platform is detected as mac
     */
    if (((_m = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraPermissionDenied) === null || _m === void 0 ? void 0 : _m.value) === true && isMacOS()) {
        activeErrorMessages.push({
            type: 'callMacOsCameraAccessDenied'
        });
    }
    /**
     * This UFD only works on mac still so we should only see it fire on mac.
     */
    if (((_o = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.screenshareRecordingDisabled) === null || _o === void 0 ? void 0 : _o.value) === true && isMacOS()) {
        activeErrorMessages.push({
            type: 'callMacOsScreenShareAccessDenied'
        });
    }
    else if (((_p = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.screenshareRecordingDisabled) === null || _p === void 0 ? void 0 : _p.value) === true) {
        activeErrorMessages.push({
            type: 'startScreenShareGeneric'
        });
    }
    // Prefer to show errors with privacy implications.
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.stopVideo', 'stopVideoGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.mute', 'muteGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.stopScreenSharing', 'stopScreenShareGeneric');
    if (((_q = latestErrors['Call.startVideo']) === null || _q === void 0 ? void 0 : _q.message) === 'Call.startVideo: Video operation failure SourceUnavailableError') {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.startVideo', 'callCameraAlreadyInUse');
    }
    else if (((_r = latestErrors['Call.startVideo']) === null || _r === void 0 ? void 0 : _r.message) === 'Call.startVideo: Video operation failure permissionDeniedError') {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.startVideo', 'callCameraAccessDenied');
    }
    else {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.startVideo', 'startVideoGeneric');
    }
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.unmute', 'unmuteGeneric');
    /* @conditional-compile-remove(video-background-effects) */
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'VideoEffectsFeature.startEffects', 'unableToStartVideoEffect');
    if (((_s = latestErrors['CallAgent.join']) === null || _s === void 0 ? void 0 : _s.message) === 'CallAgent.join: Invalid meeting link') {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'CallAgent.join', 'failedToJoinCallInvalidMeetingLink');
    }
    else {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'CallAgent.join', 'failedToJoinCallGeneric');
    }
    // We only return the first few errors to avoid filling up the UI with too many `MessageBar`s.
    activeErrorMessages.splice(maxErrorCount$1);
    return {
        activeErrorMessages: activeErrorMessages
    };
});
const appendActiveErrorIfDefined = (activeErrorMessages, latestErrors, target, activeErrorType) => {
    if (latestErrors[target] === undefined) {
        return;
    }
    activeErrorMessages.push({
        type: activeErrorType,
        timestamp: latestErrors[target].timestamp
    });
};
const maxErrorCount$1 = 3;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const emptySelector = () => ({});
/**
 * Get the selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
const getSelector$1 = (component) => {
    /* @conditional-compile-remove(raise-hand) */
    if (component === RaiseHandButton) {
        return findConditionalCompiledSelector(component);
    }
    return findSelector$1(component);
};
const findSelector$1 = (component) => {
    /* @conditional-compile-remove(dialpad) */ /* @conditional-compile-remove(PSTN-calls) */
    // Dialpad only has handlers currently and doesn't require any props from the stateful layer so return the emptySelector
    if (component === Dialpad) {
        return emptySelector;
    }
    switch (component) {
        case VideoGallery:
            return videoGallerySelector;
        case MicrophoneButton:
            return microphoneButtonSelector;
        case CameraButton:
            return cameraButtonSelector;
        case ScreenShareButton:
            return screenShareButtonSelector;
        case DevicesButton:
            return devicesButtonSelector;
        case ParticipantList$k:
            return participantListSelector;
        case ParticipantsButton:
            return participantsButtonSelector;
        case EndCallButton:
            return emptySelector;
        case ErrorBar:
            return errorBarSelector$1;
    }
    return undefined;
};
/* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(raise-hand) */
const findConditionalCompiledSelector = (component) => {
    switch (component) {
        /* @conditional-compile-remove(raise-hand) */
        case RaiseHandButton:
            /* @conditional-compile-remove(raise-hand) */
            return raiseHandButtonSelector;
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$q = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Create the default implementation of {@link ChatHandlers}.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * Returned object is memoized to avoid rerenders when used as props for React Components.
 *
 * @public
 */
const createDefaultChatHandlers = memoizeOne((chatClient, chatThreadClient) => {
    let messageIterator = undefined;
    let readReceiptIterator = undefined;
    return {
        onSendMessage: (content, options) => __awaiter$q(void 0, void 0, void 0, function* () {
            const sendMessageRequest = {
                content,
                senderDisplayName: chatClient.getState().displayName
            };
            yield chatThreadClient.sendMessage(sendMessageRequest, options);
        }),
        onUpdateMessage: (messageId, content, options) => __awaiter$q(void 0, void 0, void 0, function* () {
            const updatedMetadata = (options === null || options === void 0 ? void 0 : options.metadata) ? Object.assign({}, options.metadata) : {};
            updatedMetadata.fileSharingMetadata = JSON.stringify((options === null || options === void 0 ? void 0 : options.attachmentMetadata) || []);
            yield chatThreadClient.updateMessage(messageId, {
                content,
                metadata: updatedMetadata
            });
        }),
        onDeleteMessage: (messageId) => __awaiter$q(void 0, void 0, void 0, function* () {
            yield chatThreadClient.deleteMessage(messageId);
        }),
        // This handler is designed for chatThread to consume
        onMessageSeen: (chatMessageId) => __awaiter$q(void 0, void 0, void 0, function* () {
            yield chatThreadClient.sendReadReceipt({
                chatMessageId
            });
        }),
        onTyping: () => __awaiter$q(void 0, void 0, void 0, function* () {
            yield chatThreadClient.sendTypingNotification();
        }),
        onRemoveParticipant: (userId) => __awaiter$q(void 0, void 0, void 0, function* () {
            yield chatThreadClient.removeParticipant(fromFlatCommunicationIdentifier(userId));
        }),
        updateThreadTopicName: (topicName) => __awaiter$q(void 0, void 0, void 0, function* () {
            yield chatThreadClient.updateTopic(topicName);
        }),
        onLoadPreviousChatMessages: (messagesToLoad) => __awaiter$q(void 0, void 0, void 0, function* () {
            var _a, _b, _c;
            if (messageIterator === undefined) {
                // Lazy definition so that errors in the method call are reported correctly.
                // Also allows recovery via retries in case of transient errors.
                messageIterator = chatThreadClient.listMessages({
                    maxPageSize: 50
                });
            }
            if (readReceiptIterator === undefined) {
                readReceiptIterator = chatThreadClient.listReadReceipts();
            }
            // get the earliest message time
            let remainingMessagesToGet = messagesToLoad;
            let isAllChatMessagesLoaded = false;
            let earliestTime = Number.MAX_SAFE_INTEGER;
            while (remainingMessagesToGet >= 1) {
                const message = yield messageIterator.next();
                if ((_a = message === null || message === void 0 ? void 0 : message.value) === null || _a === void 0 ? void 0 : _a.id) {
                    if (parseInt(message.value.id) < earliestTime) {
                        earliestTime = parseInt(message.value.id);
                    }
                }
                if (((_b = message.value) === null || _b === void 0 ? void 0 : _b.type) && message.value.type === 'text') {
                    remainingMessagesToGet--;
                }
                // We have traversed all messages in this thread
                if (message.done) {
                    isAllChatMessagesLoaded = true;
                    break;
                }
            }
            // keep fetching read receipts until read receipt time < earlist message time
            let readReceipt = yield readReceiptIterator.next();
            while (!readReceipt.done && parseInt((_c = readReceipt === null || readReceipt === void 0 ? void 0 : readReceipt.value) === null || _c === void 0 ? void 0 : _c.chatMessageId) >= earliestTime) {
                readReceipt = yield readReceiptIterator.next();
            }
            return isAllChatMessagesLoaded;
        })
    };
});
/**
 * Create a set of default handlers for given component.
 *
 * Returned object is memoized (with reference to the arguments) to avoid
 * renders when used as props for React Components.
 *
 * @public
 */
const createDefaultChatHandlersForComponent = (chatClient, chatThreadClient, _) => {
    return createDefaultChatHandlers(chatClient, chatThreadClient);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const ChatClientContext = React.createContext(undefined);
/**
 * A {@link React.Context} that stores a {@link StatefulChatClient}.
 *
 * Chat components from this package must be wrapped with a {@link ChatClientProvider}.
 *
 * @public
 */
const ChatClientProvider = (props) => {
    return React.createElement(ChatClientContext.Provider, { value: props.chatClient }, props.children);
};
/**
 * Hook to obtain {@link StatefulChatClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useChatClient = () => {
    const chatClient = React.useContext(ChatClientContext);
    if (!chatClient) {
        throw 'Please wrap components with ChatClientProvider and initialize a chat client before calling the hook!';
    }
    return chatClient;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const ChatThreadClientContext = React.createContext(undefined);
/**
 * A {@link React.Context} that stores a {@link @azure/communication-chat#ChatThreadClient}.
 *
 * Chat components from this package must be wrapped with a {@link ChatThreadClientProvider}.
 *
 * @public
 */
const ChatThreadClientProvider = (props) => {
    return React.createElement(ChatThreadClientContext.Provider, { value: props.chatThreadClient }, props.children);
};
/**
 * Hook to obtain {@link @azure/communication-chat#ChatThreadClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useChatThreadClient = () => {
    const chatThreadClient = React.useContext(ChatThreadClientContext);
    if (!chatThreadClient) {
        throw 'Please wrap components with ChatThreadClientProvider and initialize a chat thread client before calling the hook.';
    }
    return chatThreadClient;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Hook to obtain a handler for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useHandlers$2 = (component) => {
    const chatClient = React.useContext(ChatClientContext);
    const chatThreadClient = React.useContext(ChatThreadClientContext);
    if (!chatThreadClient || !chatClient) {
        return undefined;
    }
    return createDefaultChatHandlersForComponent(chatClient, chatThreadClient);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector$2 = (selector, selectorProps) => {
    var _a;
    const chatClient = React.useContext(ChatClientContext);
    const threadId = (_a = React.useContext(ChatThreadClientContext)) === null || _a === void 0 ? void 0 : _a.threadId;
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const threadConfigProps = React.useMemo(() => ({
        threadId
    }), [threadId]);
    const [props, setProps] = React.useState(chatClient && selector ? selector(chatClient.getState(), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps) : undefined);
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        if (!chatClient || !selector) {
            return;
        }
        const onStateChange = (state) => {
            const newProps = selector(state, selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        chatClient.onStateChange(onStateChange);
        return () => {
            chatClient.offStateChange(onStateChange);
        };
    }, [chatClient, selector, selectorProps, threadConfigProps]);
    return selector ? props : undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const getUserId = (state) => toFlatCommunicationIdentifier(state.userId);
/**
 * @private
 */
const getDisplayName$1 = (state) => state.displayName;
/**
 * @private
 */
const getChatMessages = (state, props) => { var _a; return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages) || {}; };
/**
 * @private
 */
const getParticipants = (state, props) => { var _a; return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.participants) || {}; };
/**
 * @private
 */
const getReadReceipts = (state, props) => {
    var _a;
    return (_a = state.threads[props === null || props === void 0 ? void 0 : props.threadId]) === null || _a === void 0 ? void 0 : _a.readReceipts;
};
/**
 * @private
 */
const getIsLargeGroup = (state, props) => {
    var _a;
    const participants = (_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.participants;
    return !!participants && Object.values(participants).length > 20;
};
/**
 * @private
 */
const getLatestReadTime = (state, props) => { var _a; return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.latestReadTime) || new Date(0); };
/**
 * @private
 */
const getTypingIndicators = (state, props) => {
    var _a;
    return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.typingIndicators) || [];
};
/**
 * @private
 */
const getLatestErrors = (state) => state.latestErrors;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Selector for {@link SendBox} component.
 *
 * @public
 */
const sendBoxSelector = reselect.createSelector([getUserId, getDisplayName$1], (userId, displayName) => ({
    displayName: displayName,
    userId: userId
}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const MINIMUM_TYPING_INTERVAL_IN_MILLISECONDS = 8000;
/**
 * @private
 */
const PARTICIPANTS_THRESHOLD = 20;
/**
 * @private
 */
const MINUTE_IN_MS = 1000 * 60;
/**
 * @private
 *
 * TODO: Import enum from @azure/communication-chat when ChatMessageType shows up in new release version
 * (or define our type to decouple)
 */
const ACSKnownMessageType = {
    text: 'text',
    html: 'html',
    richtextHtml: 'richtext/html',
    topicUpdated: 'topicUpdated',
    participantAdded: 'participantAdded',
    participantRemoved: 'participantRemoved'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const compareMessages = (firstMessage, secondMessage) => {
    if (firstMessage.createdOn === undefined) {
        return 1;
    }
    if (secondMessage.createdOn === undefined) {
        return -1;
    }
    const firstDate = new Date(firstMessage.createdOn).getTime();
    const secondDate = new Date(secondMessage.createdOn).getTime();
    // Workaround to get a stable order of message before we can get sequenceId from chat service.
    // MessageIds are generated by time order the message persist, a good candidate other than time
    const idDelta = firstMessage.messageId && secondMessage.messageId ? Number.parseInt(firstMessage.messageId) - Number.parseInt(secondMessage.messageId) : 0;
    return firstDate - secondDate === 0 ? idDelta : firstDate - secondDate;
};

/**
 * @private
 */
const updateMessagesWithAttached = (chatMessagesWithStatus) => {
    chatMessagesWithStatus.sort(compareMessages);
    chatMessagesWithStatus.forEach((message, index, messages) => {
        var _a, _b;
        if (message.messageType === 'chat') {
            /**
             * Attached === true means it is within a group of messages in the current order
             * Attached === top/bottom means it is on the top/bottom boundary
             * Attached === false means it is just a single message
             * A group of messages: continuous messages that belong to the same sender and not intercepted by other senders.
             */
            let attached = false;
            const previousMessage = index > 0 ? messages[index - 1] : undefined;
            const nextMessage = index === messages.length - 1 ? undefined : messages[index + 1];
            const previousSenderId = (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.messageType) === 'chat' ? previousMessage.senderId : undefined;
            const nextSenderId = (nextMessage === null || nextMessage === void 0 ? void 0 : nextMessage.messageType) === 'chat' ? nextMessage.senderId : undefined;
            const timediff = new Date((_a = message === null || message === void 0 ? void 0 : message.createdOn) !== null && _a !== void 0 ? _a : '').getTime() - new Date((_b = previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.createdOn) !== null && _b !== void 0 ? _b : '').getTime();
            const diffMins = Math.round(timediff / MINUTE_IN_MS); // minutes
            if (previousSenderId !== message.senderId) {
                attached = message.senderId === nextSenderId ? 'top' : false;
            }
            else if (diffMins && diffMins >= 5) {
                // if there are more than or equal to 5 mins time gap between messages do not attach and show time stamp
                attached = false;
            }
            else {
                attached = message.senderId === nextSenderId ? true : 'bottom';
            }
            message.attached = attached;
        }
    });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const memoizedAllConvertChatMessage = memoizeFnAll((_key, chatMessage, userId, isSeen, isLargeGroup) => {
    const messageType = chatMessage.type.toLowerCase();
    if (messageType === ACSKnownMessageType.text || messageType === ACSKnownMessageType.richtextHtml || messageType === ACSKnownMessageType.html) {
        return convertToUiChatMessage(chatMessage, userId, isSeen, isLargeGroup);
    }
    else {
        return convertToUiSystemMessage(chatMessage);
    }
});
const processChatMessageContent = (message) => {
    var _a, _b, _c, _d;
    let content = (_a = message.content) === null || _a === void 0 ? void 0 : _a.message;
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    if (((_b = message.content) === null || _b === void 0 ? void 0 : _b.attachments) && ((_c = message.content) === null || _c === void 0 ? void 0 : _c.attachments.length) > 0 && sanitizedMessageContentType(message.type).includes('html')) {
        const attachments = (_d = message.content) === null || _d === void 0 ? void 0 : _d.attachments;
        // Fill in the src here
        /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
        if (content) {
            const document = new DOMParser().parseFromString(content !== null && content !== void 0 ? content : '', 'text/html');
            document.querySelectorAll('img').forEach(img => {
                var _a, _b;
                const attachmentPreviewUrl = (_a = attachments.find(attachment => attachment.id === img.id)) === null || _a === void 0 ? void 0 : _a.previewUrl;
                if (attachmentPreviewUrl) {
                    const resourceCache = (_b = message.resourceCache) === null || _b === void 0 ? void 0 : _b[attachmentPreviewUrl];
                    img.src = getResourceSourceUrl(resourceCache);
                }
            });
            content = document.body.innerHTML;
        }
        const teamsImageHtmlContent = attachments.filter(attachment => { var _a, _b; return attachment.attachmentType === 'image' && attachment.previewUrl !== undefined && !((_b = (_a = message.content) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes(attachment.id)); }).map(attachment => generateImageAttachmentImgHtml(message, attachment)).join('');
        if (teamsImageHtmlContent) {
            return (content !== null && content !== void 0 ? content : '') + teamsImageHtmlContent;
        }
    }
    return content;
};
/* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
const generateImageAttachmentImgHtml = (message, attachment) => {
    var _a;
    if (attachment.previewUrl !== undefined) {
        const contentType = extractAttachmentContentTypeFromName(attachment.name);
        const resourceCache = (_a = message.resourceCache) === null || _a === void 0 ? void 0 : _a[attachment.previewUrl];
        const src = getResourceSourceUrl(resourceCache);
        return `\r\n<p><img alt="image" src="${src}" itemscope="${contentType}" id="${attachment.id}"></p>`;
    }
    return '';
};
/* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
const getResourceSourceUrl = (result) => {
    let src = '';
    if (result) {
        if (result.error || !result.sourceUrl) {
            // In case of an error we set src to some invalid value to show broken image
            src = 'blob://';
        }
        else {
            src = result.sourceUrl;
        }
    }
    return src;
};
/* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
const extractAttachmentContentTypeFromName = (name) => {
    if (name === undefined) {
        return '';
    }
    const indexOfLastDot = name.lastIndexOf('.');
    if (indexOfLastDot === undefined || indexOfLastDot < 0) {
        return '';
    }
    const contentType = name.substring(indexOfLastDot + 1);
    return contentType;
};
const convertToUiChatMessage = (message, userId, isSeen, isLargeGroup) => {
    const messageSenderId = message.sender !== undefined ? toFlatCommunicationIdentifier(message.sender) : userId;
    return {
        messageType: 'chat',
        createdOn: message.createdOn,
        content: processChatMessageContent(message),
        contentType: sanitizedMessageContentType(message.type),
        status: !isLargeGroup && message.status === 'delivered' && isSeen ? 'seen' : message.status,
        senderDisplayName: message.senderDisplayName,
        senderId: messageSenderId,
        messageId: message.id,
        clientMessageId: message.clientMessageId,
        editedOn: message.editedOn,
        deletedOn: message.deletedOn,
        mine: messageSenderId === userId,
        metadata: message.metadata
    };
};
const convertToUiSystemMessage = (message) => {
    var _a, _b, _c, _d, _e;
    const systemMessageType = message.type;
    if (systemMessageType === 'participantAdded' || systemMessageType === 'participantRemoved') {
        return {
            messageType: 'system',
            systemMessageType,
            createdOn: message.createdOn,
            participants: (_c = (_b = (_a = message.content) === null || _a === void 0 ? void 0 : _a.participants) === null || _b === void 0 ? void 0 : _b.filter((participant) => participant.displayName && participant.displayName !== '').map((participant) => ({
                userId: toFlatCommunicationIdentifier(participant.id),
                displayName: participant.displayName
            }))) !== null && _c !== void 0 ? _c : [],
            messageId: message.id,
            iconName: systemMessageType === 'participantAdded' ? 'PeopleAdd' : 'PeopleBlock'
        };
    }
    else {
        // Only topic updated type left, according to ACSKnown type
        return {
            messageType: 'system',
            systemMessageType: 'topicUpdated',
            createdOn: message.createdOn,
            topic: (_e = (_d = message.content) === null || _d === void 0 ? void 0 : _d.topic) !== null && _e !== void 0 ? _e : '',
            messageId: message.id,
            iconName: 'Edit'
        };
    }
};
/** Returns `true` if the message has participants and at least one participant has a display name. */
const hasValidParticipant = (chatMessage) => { var _a; return !!((_a = chatMessage.content) === null || _a === void 0 ? void 0 : _a.participants) && chatMessage.content.participants.some((p) => !!p.displayName); };
/**
 *
 * @private
 */
const messageThreadSelectorWithThread = () => reselect.createSelector([getUserId, getChatMessages, getLatestReadTime, getIsLargeGroup, getReadReceipts, getParticipants], (userId, chatMessages, latestReadTime, isLargeGroup, readReceipts, participants) => {
    // We can't get displayName in teams meeting interop for now, disable rr feature when it is teams interop
    const isTeamsInterop = Object.values(participants).find(p => 'microsoftTeamsUserId' in p.id) !== undefined;
    // get number of participants
    // filter out the non valid participants (no display name)
    // Read Receipt details will be disabled when participant count is 0
    const participantCount = isTeamsInterop ? undefined : Object.values(participants).filter(p => p.displayName && p.displayName !== '').length;
    // creating key value pairs of senderID: last read message information
    const readReceiptsBySenderId = {};
    // readReceiptsBySenderId[senderID] gets updated every time a new message is read by this sender
    // in this way we can make sure that we are only saving the latest read message id and read on time for each sender
    readReceipts.filter(r => r.sender && toFlatCommunicationIdentifier(r.sender) !== userId).forEach(r => {
        var _a, _b;
        readReceiptsBySenderId[toFlatCommunicationIdentifier(r.sender)] = {
            lastReadMessage: r.chatMessageId,
            displayName: (_b = (_a = participants[toFlatCommunicationIdentifier(r.sender)]) === null || _a === void 0 ? void 0 : _a.displayName) !== null && _b !== void 0 ? _b : ''
        };
    });
    // A function takes parameter above and generate return value
    const convertedMessages = memoizedAllConvertChatMessage(memoizedFn => Object.values(chatMessages).filter(message => message.type.toLowerCase() === ACSKnownMessageType.text || message.type.toLowerCase() === ACSKnownMessageType.richtextHtml || message.type.toLowerCase() === ACSKnownMessageType.html || message.type === ACSKnownMessageType.participantAdded && hasValidParticipant(message) || message.type === ACSKnownMessageType.participantRemoved && hasValidParticipant(message) ||
        // TODO: Add support for topicUpdated system messages in MessageThread component.
        // message.type === ACSKnownMessageType.topicUpdated ||
        message.clientMessageId !== undefined).filter(isMessageValidToRender).map(message => {
        var _a;
        return memoizedFn((_a = message.id) !== null && _a !== void 0 ? _a : message.clientMessageId, message, userId, message.createdOn <= latestReadTime, isLargeGroup);
    }));
    updateMessagesWithAttached(convertedMessages);
    return {
        userId,
        showMessageStatus: true,
        messages: convertedMessages,
        participantCount,
        readReceiptsBySenderId
    };
});
const sanitizedMessageContentType = (type) => {
    const lowerCaseType = type.toLowerCase();
    return lowerCaseType === 'text' || lowerCaseType === 'html' || lowerCaseType === 'richtext/html' ? lowerCaseType : 'unknown';
};
const isMessageValidToRender = (message) => {
    var _a, _b, _c;
    if (message.deletedOn) {
        return false;
    }
    if (((_a = message.metadata) === null || _a === void 0 ? void 0 : _a.fileSharingMetadata) || /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */ ((_b = message.content) === null || _b === void 0 ? void 0 : _b.attachments)) {
        return true;
    }
    return !!(message.content && ((_c = message.content) === null || _c === void 0 ? void 0 : _c.message) !== '');
};
/**
 * Selector for {@link MessageThread} component.
 *
 * @public
 */
messageThreadSelectorWithThread();

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const filterTypingIndicators = (typingIndicators, userId) => {
    const filteredTypingIndicators = [];
    const seen = new Set();
    const date8SecondsAgo = new Date(Date.now() - MINIMUM_TYPING_INTERVAL_IN_MILLISECONDS);
    for (let i = typingIndicators.length - 1; i >= 0; i--) {
        const typingIndicator = typingIndicators[i];
        if (toFlatCommunicationIdentifier(typingIndicator.sender) === userId) {
            continue;
        }
        if (typingIndicator.receivedOn < date8SecondsAgo) {
            continue;
        }
        if (seen.has(toFlatCommunicationIdentifier(typingIndicator.sender))) {
            continue;
        }
        seen.add(toFlatCommunicationIdentifier(typingIndicator.sender));
        filteredTypingIndicators.push(typingIndicator);
    }
    return filteredTypingIndicators;
};
const convertSdkTypingIndicatorsToCommunicationParticipants = (typingIndicators, participants) => {
    return typingIndicators.map(typingIndicator => {
        var _a;
        return ({
            userId: toFlatCommunicationIdentifier(typingIndicator.sender),
            displayName: (_a = participants[toFlatCommunicationIdentifier(typingIndicator.sender)]) === null || _a === void 0 ? void 0 : _a.displayName
        });
    });
};
/**
 * Selector for {@link TypingIndicator} component.
 *
 * @public
 */
const typingIndicatorSelector = reselect.createSelector([getTypingIndicators, getParticipants, getUserId], (typingIndicators, participants, userId) => {
    // if the participant size reaches the threshold then return no typing users
    if (Object.values(participants).length >= PARTICIPANTS_THRESHOLD) {
        return {
            typingUsers: []
        };
    }
    // filter typing indicators to remove those that are from the duplicate users or current user as well as those older than a threshold
    const filteredTypingIndicators = filterTypingIndicators(typingIndicators, userId);
    const typingUsers = convertSdkTypingIndicatorsToCommunicationParticipants(filteredTypingIndicators, participants);
    return {
        typingUsers
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const convertChatParticipantsToCommunicationParticipants = (chatParticipants) => {
    return chatParticipants.map((participant) => {
        return {
            userId: toFlatCommunicationIdentifier(participant.id),
            displayName: participant.displayName,
            // ACS users can not remove Teams users.
            // Removing phone numbers or unknown types of users is undefined.
            isRemovable: communicationCommon.getIdentifierKind(participant.id).kind === 'communicationUser'
        };
    });
};
/**
 * get the index of moderator to help updating its display name if they are the local user or removing them from list of participants otherwise
 */
const moderatorIndex = (participants) => {
    return participants.map(p => p.displayName).indexOf(undefined);
};
/**
 * Selector for {@link ParticipantList} component.
 *
 * @public
 */
const chatParticipantListSelector = reselect__namespace.createSelector([getUserId, getParticipants, getDisplayName$1], (userId, chatParticipants, displayName) => {
    let participants = convertChatParticipantsToCommunicationParticipants(Object.values(chatParticipants));
    if (0 !== participants.length) {
        const moderatorIdx = moderatorIndex(participants);
        if (-1 !== moderatorIdx) {
            const userIndex = participants.map(p => p.userId).indexOf(userId);
            if (moderatorIdx === userIndex) {
                participants[moderatorIdx].displayName = displayName;
            }
            else {
                participants = participants.filter(p => p.displayName);
            }
        }
    }
    return {
        myUserId: userId,
        participants: participants
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Select the first fiew active errors from the state for the {@link ErrorBar} component.
 *
 * In case there are many errors, only a few top errors are returned to avoid
 * filling up the UI with too many errors.
 *
 * Invariants:
 *   - {@link ErrorType} is never repeated in the returned errors.
 *   - Errors are returned in a fixed order by {@link ErrorType}.
 *
 * @public
 */
const errorBarSelector = reselect.createSelector([getLatestErrors], (latestErrors) => {
    var _a;
    // The order in which the errors are returned is significant: The `ErrorBar` shows errors on the UI in that order.
    // There are several options for the ordering:
    //   - Sorted by when the errors happened (latest first / oldest first).
    //   - Stable sort by error type.
    //
    // We chose to stable sort by error type: We intend to show only a small number of errors on the UI and we do not
    // have timestamps for errors.
    const activeErrorMessages = [];
    let specificSendMessageErrorSeen = false;
    {
        const error = latestUnableToReachChatServiceError(latestErrors);
        if (error !== undefined) {
            activeErrorMessages.push(error);
        }
    }
    {
        const error = latestAccessDeniedError(latestErrors);
        if (error !== undefined) {
            activeErrorMessages.push(error);
        }
    }
    const sendMessageError = latestErrors['ChatThreadClient.sendMessage'];
    {
        const error = latestNotInThisThreadError(latestErrors);
        if (error !== undefined) {
            if (sendMessageError !== undefined) {
                activeErrorMessages.push({
                    type: 'sendMessageNotInChatThread',
                    // Set the latest timestamp of all the errors that translated to an active error.
                    timestamp: sendMessageError.timestamp > ((_a = error.timestamp) !== null && _a !== void 0 ? _a : 0) ? sendMessageError.timestamp : error.timestamp
                });
                specificSendMessageErrorSeen = true;
            }
            else {
                activeErrorMessages.push(error);
            }
        }
    }
    if (!specificSendMessageErrorSeen && sendMessageError !== undefined) {
        activeErrorMessages.push({
            type: 'sendMessageGeneric',
            timestamp: sendMessageError.timestamp
        });
    }
    // We only return the first few errors to avoid filling up the UI with too many `MessageBar`s.
    activeErrorMessages.splice(maxErrorCount);
    return {
        activeErrorMessages: activeErrorMessages
    };
});
const maxErrorCount = 3;
const accessErrorTargets = ['ChatThreadClient.getProperties', 'ChatThreadClient.listMessages', 'ChatThreadClient.listParticipants', 'ChatThreadClient.sendMessage', 'ChatThreadClient.sendTypingNotification'];
const latestUnableToReachChatServiceError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'unableToReachChatService', (error) => {
        return !!error && !!error.innerError && 'code' in error.innerError && error.innerError.code === 'REQUEST_SEND_ERROR';
    });
};
const latestAccessDeniedError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'accessDenied', (error) => {
        return !!error && !!error.innerError && 'statusCode' in error.innerError && error.innerError.statusCode === 401;
    });
};
const latestNotInThisThreadError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'userNotInChatThread', (error) => {
        if (!error || !error.innerError) {
            return false;
        }
        // Explicitly ignore 400 REST error when listParticipants() is called and a BotContact MRI is found in the participants.
        // This check should be removed when the chat SDK has handled this issue. Note: The this does not stop the error being logged to the console.
        // To the best of our ability we have confirmed this to have no impact on the participantList returned (all valid participants are still returned), nor
        // does it have an impact on the participant list updating on other participants joining/leaving or on individual participant actions like removeParticipant.
        if (isErrorDueToBotContact(error)) {
            return false;
        }
        // Chat service returns 403 if a user has been removed from a thread.
        // Chat service returns either 400 or 404 if the thread ID is malformed, depending on how the thread ID is malformed.
        return [400, 403, 404].some(statusCode => 'statusCode' in error.innerError && error.innerError.statusCode === statusCode);
    });
};
const botContactMRIPrefix = '28:';
const isErrorDueToBotContact = (error) => 'statusCode' in error.innerError && error.innerError.statusCode === 400 && error.innerError.message.includes(`Identifier format is not supported (${botContactMRIPrefix}`);
const latestActiveErrorSatisfying = (errors, activeErrorType, predicate) => {
    const activeErrorMessages = [];
    for (const target of accessErrorTargets) {
        const error = errors[target];
        if (predicate(error)) {
            activeErrorMessages.push({
                type: activeErrorType,
                timestamp: error.timestamp
            });
        }
    }
    if (activeErrorMessages.length === 0) {
        return undefined;
    }
    // We're actually sure that both timestamps will always exist, because we set them above.
    activeErrorMessages.sort((a, b) => { var _a, _b, _c, _d; return ((_b = (_a = a.timestamp) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = b.timestamp) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0); });
    return activeErrorMessages[activeErrorMessages.length - 1];
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Get the selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const getSelector = (component) => {
    return findSelector(component);
};
const messageThreadSelectorsByThread = {};
const findSelector = (component) => {
    // For the message thread selector we need to create a new one for each thread
    // If we have just one for the entire app, then we will have updates when not expecting due to
    // the arguments changing
    const getMessageThreadSelector = () => {
        var _a, _b;
        const threadId = (_b = (_a = React.useContext(ChatThreadClientContext)) === null || _a === void 0 ? void 0 : _a.threadId) !== null && _b !== void 0 ? _b : 'default-id-when-not-in-provider';
        let messageThreadSelectorImpl = messageThreadSelectorsByThread[threadId];
        if (!messageThreadSelectorImpl) {
            messageThreadSelectorsByThread[threadId] = messageThreadSelectorWithThread();
            messageThreadSelectorImpl = messageThreadSelectorsByThread[threadId];
        }
        return messageThreadSelectorImpl;
    };
    switch (component) {
        case SendBox$1:
            return sendBoxSelector;
        case MessageThread:
            return getMessageThreadSelector();
        case TypingIndicator:
            return typingIndicatorSelector;
        case ParticipantList$k:
            return chatParticipantListSelector;
        case ErrorBar:
            return errorBarSelector;
    }
    return undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Error thrown from failed {@link StatefulChatClient} methods.
 *
 * @public
 */
class ChatError extends Error {
    constructor(target, innerError, timestamp) {
        super();
        this.target = target;
        this.innerError = innerError;
        // Testing note: It is easier to mock Date::now() than the Date() constructor.
        this.timestamp = timestamp !== null && timestamp !== void 0 ? timestamp : new Date(Date.now());
        this.name = 'ChatError';
        this.message = `${this.target}: ${this.innerError.message}`;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const Constants = {
    TYPING_INDICATOR_MAINTAIN_TIME: 8 * 1000,
    DUMMY_DATE: new Date(0)
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const chatStatefulLogger = logger.createClientLogger('communication-react:chat-stateful');

var __awaiter$p = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
/**
 * @private
 */
class ResourceDownloadQueue {
    constructor(context, authentication) {
        this._messagesNeedingResourceRetrieval = [];
        this.isActive = false;
        this._requestsToCancel = {};
        this._context = context;
        this._credential = authentication.credential;
        this._endpoint = authentication.endpoint;
    }
    containsMessageWithSameAttachments(message) {
        var _a, _b, _c;
        let contains = false;
        const incomingAttachment = (_a = message.content) === null || _a === void 0 ? void 0 : _a.attachments;
        if (incomingAttachment) {
            for (const m of this._messagesNeedingResourceRetrieval) {
                const existingAttachment = (_c = (_b = m.content) === null || _b === void 0 ? void 0 : _b.attachments) !== null && _c !== void 0 ? _c : [];
                contains = incomingAttachment.every((element, index) => element === existingAttachment[index]);
                if (contains) {
                    break;
                }
            }
        }
        return contains;
    }
    addMessage(message) {
        // make a copy of message and add to queue
        const copy = Object.assign({}, message);
        this._messagesNeedingResourceRetrieval.push(copy);
    }
    startQueue(threadId, operation, options) {
        return __awaiter$p(this, void 0, void 0, function* () {
            if (this.isActive) {
                return;
            }
            while (this._messagesNeedingResourceRetrieval.length > 0) {
                this.isActive = true;
                let message = this._messagesNeedingResourceRetrieval.shift();
                if (!message) {
                    this.isActive = false;
                    continue;
                }
                if (options) {
                    const singleUrl = options.singleUrl;
                    message = yield this.downloadSingleUrl(message, singleUrl, operation);
                }
                else {
                    message = yield this.downloadAllPreviewUrls(message, operation);
                }
                this._context.setChatMessage(threadId, message);
                this.isActive = false;
            }
        });
    }
    cancelAllRequests() {
        for (const key in this._requestsToCancel) {
            this._requestsToCancel[key].abortController.abort();
        }
        this._requestsToCancel = {};
    }
    cancelRequest(url) {
        if (this._requestsToCancel[url]) {
            this._requestsToCancel[url].abortController.abort();
            delete this._requestsToCancel[url];
        }
    }
    downloadSingleUrl(message, resourceUrl, operation) {
        return __awaiter$p(this, void 0, void 0, function* () {
            const response = {
                sourceUrl: ''
            };
            try {
                const abortController = new AbortController();
                const blobUrl = yield this.downloadResource(operation, resourceUrl, abortController);
                response.sourceUrl = blobUrl;
            }
            catch (error) {
                response.error = error;
                delete this._requestsToCancel[resourceUrl];
            }
            message = Object.assign(Object.assign({}, message), { resourceCache: Object.assign(Object.assign({}, message.resourceCache), { [resourceUrl]: response }) });
            return message;
        });
    }
    downloadAllPreviewUrls(message, operation) {
        var _a;
        return __awaiter$p(this, void 0, void 0, function* () {
            const attachments = (_a = message.content) === null || _a === void 0 ? void 0 : _a.attachments;
            if (message.type === 'html' && attachments) {
                if (message.resourceCache === undefined) {
                    message.resourceCache = {};
                }
                for (const attachment of attachments) {
                    if (attachment.previewUrl && attachment.attachmentType === 'image') {
                        const response = {
                            sourceUrl: ''
                        };
                        try {
                            const abortController = new AbortController();
                            const blobUrl = yield this.downloadResource(operation, attachment.previewUrl, abortController);
                            response.sourceUrl = blobUrl;
                        }
                        catch (error) {
                            response.error = error;
                            delete this._requestsToCancel[attachment.previewUrl];
                        }
                        message.resourceCache[attachment.previewUrl] = response;
                    }
                }
            }
            return message;
        });
    }
    downloadResource(operation, url, abortController) {
        return __awaiter$p(this, void 0, void 0, function* () {
            this._requestsToCancel[url] = {
                src: url,
                abortController
            };
            const blobUrl = yield operation(url, {
                credential: this._credential,
                endpoint: this._endpoint
            }, {
                abortController
            });
            delete this._requestsToCancel[url];
            return blobUrl;
        });
    }
}
/* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
/**
 * @private
 */
const fetchImageSource = (src, authentication, options) => __awaiter$p(void 0, void 0, void 0, function* () {
    function fetchWithAuthentication(url, token, options) {
        return __awaiter$p(this, void 0, void 0, function* () {
            const headers = new Headers();
            headers.append('Authorization', `Bearer ${token}`);
            return yield fetchWithTimeout(url, {
                timeout: options.timeout,
                headers,
                abortController: options.abortController
            });
        });
    }
    function fetchWithTimeout(resource, options) {
        return __awaiter$p(this, void 0, void 0, function* () {
            // default timeout is 30 seconds
            const { timeout = 30000, abortController } = options;
            const id = setTimeout(() => {
                abortController.abort();
            }, timeout);
            const response = yield fetch(resource, Object.assign(Object.assign({}, options), { signal: abortController.signal }));
            clearTimeout(id);
            return response;
        });
    }
    const fetchUrl = new URL(src);
    const endpoint = new URL(authentication.endpoint);
    let token = '';
    if (fetchUrl.hostname === endpoint.hostname && fetchUrl.protocol === 'https:') {
        token = (yield authentication.credential.getToken()).token;
    }
    const response = yield fetchWithAuthentication(src, token, options);
    const blob = yield response.blob();
    return URL.createObjectURL(blob);
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$o = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
immer.enableMapSet();
// Needed to generate state diff for verbose logging.
immer.enablePatches();
/**
 * @internal
 */
let ChatContext$1 = class ChatContext {
    constructor(maxListeners, /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */ credential, /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */ endpoint) {
        this._state = {
            userId: {
                id: ''
            },
            displayName: '',
            threads: {},
            latestErrors: {}
        };
        this._batchMode = false;
        this.typingIndicatorInterval = undefined;
        /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
        this._inlineImageQueue = undefined;
        /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
        this._fullsizeImageQueue = undefined;
        this._logger = logger.createClientLogger('communication-react:chat-context');
        this._emitter = new EventEmitter();
        /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
        if (credential) {
            this._inlineImageQueue = new ResourceDownloadQueue(this, {
                credential,
                endpoint: endpoint !== null && endpoint !== void 0 ? endpoint : ''
            });
            this._fullsizeImageQueue = new ResourceDownloadQueue(this, {
                credential,
                endpoint: endpoint !== null && endpoint !== void 0 ? endpoint : ''
            });
        }
        if (maxListeners) {
            this._emitter.setMaxListeners(maxListeners);
        }
    }
    getState() {
        return this._state;
    }
    modifyState(modifier) {
        const priorState = this._state;
        this._state = immer.produce(this._state, modifier, (patches) => {
            if (logger.getLogLevel() === 'verbose') {
                // Log to `info` because AzureLogger.verbose() doesn't show up in console.
                this._logger.info(`State change: ${_safeJSONStringify(patches)}`);
            }
        });
        if (!this._batchMode && this._state !== priorState) {
            this._emitter.emit('stateChanged', this._state);
        }
    }
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    dispose() {
        this.modifyState((draft) => {
            var _a, _b;
            (_a = this._inlineImageQueue) === null || _a === void 0 ? void 0 : _a.cancelAllRequests();
            (_b = this._fullsizeImageQueue) === null || _b === void 0 ? void 0 : _b.cancelAllRequests();
            Object.keys(draft.threads).forEach(threadId => {
                const thread = draft.threads[threadId];
                Object.keys(thread.chatMessages).forEach(messageId => {
                    const cache = thread.chatMessages[messageId].resourceCache;
                    if (cache) {
                        Object.keys(cache).forEach(resourceUrl => {
                            const resource = cache[resourceUrl];
                            if (resource.sourceUrl) {
                                URL.revokeObjectURL(resource.sourceUrl);
                            }
                        });
                    }
                    thread.chatMessages[messageId].resourceCache = undefined;
                });
            });
        });
        // Any item in queue should be removed.
    }
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    downloadResourceToCache(threadId, messageId, resourceUrl) {
        var _a;
        return __awaiter$o(this, void 0, void 0, function* () {
            let message = (_a = this.getState().threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages[messageId];
            if (message && this._fullsizeImageQueue) {
                if (!message.resourceCache) {
                    message = Object.assign(Object.assign({}, message), { resourceCache: {} });
                }
                // Need to discuss retry logic in case of failure
                this._fullsizeImageQueue.addMessage(message);
                yield this._fullsizeImageQueue.startQueue(threadId, fetchImageSource, {
                    singleUrl: resourceUrl
                });
            }
        });
    }
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    removeResourceFromCache(threadId, messageId, resourceUrl) {
        this.modifyState((draft) => {
            var _a, _b, _c;
            const message = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages[messageId];
            if (message && this._fullsizeImageQueue && this._fullsizeImageQueue.containsMessageWithSameAttachments(message)) {
                (_b = this._fullsizeImageQueue) === null || _b === void 0 ? void 0 : _b.cancelRequest(resourceUrl);
            }
            else if (message && this._inlineImageQueue && this._inlineImageQueue.containsMessageWithSameAttachments(message)) {
                (_c = this._inlineImageQueue) === null || _c === void 0 ? void 0 : _c.cancelRequest(resourceUrl);
            }
            if (message && message.resourceCache && message.resourceCache[resourceUrl]) {
                const resource = message.resourceCache[resourceUrl];
                if (resource.sourceUrl) {
                    URL.revokeObjectURL(resource.sourceUrl);
                }
                delete message.resourceCache[resourceUrl];
            }
        });
    }
    setThread(threadId, threadState) {
        this.modifyState((draft) => {
            draft.threads[threadId] = threadState;
        });
    }
    createThread(threadId, properties) {
        this.modifyState((draft) => {
            draft.threads[threadId] = {
                chatMessages: {},
                threadId: threadId,
                properties: properties,
                participants: {},
                readReceipts: [],
                typingIndicators: [],
                latestReadTime: new Date(0)
            };
        });
    }
    updateChatConfig(userId, displayName) {
        this.modifyState((draft) => {
            draft.displayName = displayName;
            draft.userId = userId;
        });
    }
    createThreadIfNotExist(threadId, properties) {
        const exists = Object.prototype.hasOwnProperty.call(this.getState().threads, threadId);
        if (!exists) {
            this.createThread(threadId, properties);
            return true;
        }
        return false;
    }
    updateThread(threadId, properties) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                thread.properties = properties;
            }
        });
    }
    updateThreadTopic(threadId, topic) {
        this.modifyState((draft) => {
            if (topic === undefined) {
                return;
            }
            const thread = draft.threads[threadId];
            if (thread && !thread.properties) {
                thread.properties = {
                    topic: topic
                };
            }
            else if (thread && thread.properties) {
                thread.properties.topic = topic;
            }
        });
    }
    deleteThread(threadId) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                delete draft.threads[threadId];
            }
        });
    }
    setChatMessages(threadId, messages) {
        this.modifyState((draft) => {
            const threadState = draft.threads[threadId];
            if (threadState) {
                threadState.chatMessages = messages;
            }
            // remove typing indicator when receive messages
            const thread = draft.threads[threadId];
            if (thread) {
                for (const message of Object.values(messages)) {
                    this.filterTypingIndicatorForUser(thread, message.sender);
                }
            }
        });
    }
    updateChatMessageContent(threadId, messagesId, content) {
        this.modifyState((draft) => {
            var _a;
            const chatMessage = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages[messagesId];
            if (chatMessage) {
                if (!chatMessage.content) {
                    chatMessage.content = {};
                }
                chatMessage.content.message = content;
            }
        });
    }
    deleteLocalMessage(threadId, localId) {
        let localMessageDeleted = false;
        this.modifyState((draft) => {
            var _a;
            const chatMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
            const message = chatMessages ? chatMessages[localId] : undefined;
            if (chatMessages && message && message.clientMessageId) {
                delete chatMessages[message.clientMessageId];
                localMessageDeleted = true;
            }
        });
        return localMessageDeleted;
    }
    deleteMessage(threadId, id) {
        this.modifyState((draft) => {
            var _a;
            const chatMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
            if (chatMessages) {
                delete chatMessages[id];
            }
        });
    }
    setParticipant(threadId, participant) {
        this.modifyState((draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                participants[toFlatCommunicationIdentifier(participant.id)] = participant;
            }
        });
    }
    setParticipants(threadId, participants) {
        this.modifyState((draft) => {
            var _a;
            const participantsMap = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participantsMap) {
                for (const participant of participants) {
                    participantsMap[toFlatCommunicationIdentifier(participant.id)] = participant;
                }
            }
        });
    }
    deleteParticipants(threadId, participantIds) {
        this.modifyState((draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                participantIds.forEach(id => {
                    delete participants[toFlatCommunicationIdentifier(id)];
                });
            }
        });
    }
    deleteParticipant(threadId, participantId) {
        this.modifyState((draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                delete participants[toFlatCommunicationIdentifier(participantId)];
            }
        });
    }
    addReadReceipt(threadId, readReceipt) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            const readReceipts = thread === null || thread === void 0 ? void 0 : thread.readReceipts;
            if (thread && readReceipts) {
                // TODO(prprabhu): Replace `this.getState()` with `draft`?
                if (readReceipt.sender !== this.getState().userId && thread.latestReadTime < readReceipt.readOn) {
                    thread.latestReadTime = readReceipt.readOn;
                }
                readReceipts.push(readReceipt);
            }
        });
    }
    startTypingIndicatorCleanUp() {
        if (this.typingIndicatorInterval) {
            return;
        }
        this.typingIndicatorInterval = window.setInterval(() => {
            let isTypingActive = false;
            this.modifyState((draft) => {
                for (const thread of Object.values(draft.threads)) {
                    const filteredTypingIndicators = thread.typingIndicators.filter(typingIndicator => {
                        const timeGap = Date.now() - typingIndicator.receivedOn.getTime();
                        return timeGap < Constants.TYPING_INDICATOR_MAINTAIN_TIME;
                    });
                    if (thread.typingIndicators.length !== filteredTypingIndicators.length) {
                        thread.typingIndicators = filteredTypingIndicators;
                    }
                    if (thread.typingIndicators.length > 0) {
                        isTypingActive = true;
                    }
                }
            });
            if (!isTypingActive && this.typingIndicatorInterval) {
                window.clearInterval(this.typingIndicatorInterval);
                this.typingIndicatorInterval = undefined;
            }
        }, 1000);
    }
    addTypingIndicator(threadId, typingIndicator) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                const typingIndicators = thread.typingIndicators;
                typingIndicators.push(typingIndicator);
            }
        });
        // Make sure we only maintain a period of typing indicator for perf purposes
        this.startTypingIndicatorCleanUp();
    }
    setChatMessage(threadId, message) {
        /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
        this.parseAttachments(threadId, message);
        const { id: messageId, clientMessageId } = message;
        if (messageId || clientMessageId) {
            this.modifyState((draft) => {
                var _a;
                const threadMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
                const isLocalIdInMap = threadMessages && clientMessageId && threadMessages[clientMessageId];
                const messageKey = !messageId || isLocalIdInMap ? clientMessageId : messageId;
                if (threadMessages && messageKey) {
                    threadMessages[messageKey] = message;
                }
                // remove typing indicator when receive a message from a user
                const thread = draft.threads[threadId];
                if (thread) {
                    this.filterTypingIndicatorForUser(thread, message.sender);
                }
            });
        }
    }
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    parseAttachments(threadId, message) {
        var _a;
        const attachments = (_a = message.content) === null || _a === void 0 ? void 0 : _a.attachments;
        if (message.type === 'html' && attachments && attachments.length > 0) {
            if (this._inlineImageQueue && !this._inlineImageQueue.containsMessageWithSameAttachments(message) && message.resourceCache === undefined) {
                // Need to discuss retry logic in case of failure
                this._inlineImageQueue.addMessage(message);
                this._inlineImageQueue.startQueue(threadId, fetchImageSource);
            }
        }
    }
    /**
     * Tees any errors encountered in an async function to the state.
     *
     * @param f Async function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws ChatError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withAsyncErrorTeedToState(f, target) {
        return (...args) => __awaiter$o(this, void 0, void 0, function* () {
            try {
                return yield f(...args);
            }
            catch (error) {
                const chatError = toChatError(target, error);
                this.setLatestError(target, chatError);
                throw chatError;
            }
        });
    }
    /**
     * Tees any errors encountered in an function to the state.
     *
     * @param f Function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws ChatError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withErrorTeedToState(f, target) {
        return (...args) => {
            try {
                chatStatefulLogger.info(`Chat stateful client target function called: ${target}`);
                return f(...args);
            }
            catch (error) {
                const chatError = toChatError(target, error);
                this.setLatestError(target, chatError);
                throw chatError;
            }
        };
    }
    setLatestError(target, error) {
        this.modifyState((draft) => {
            draft.latestErrors[target] = error;
        });
    }
    // This is a mutating function, only use it inside of a produce() function
    filterTypingIndicatorForUser(thread, userId) {
        if (!userId) {
            return;
        }
        const typingIndicators = thread.typingIndicators;
        const userIdAsKey = toFlatCommunicationIdentifier(userId);
        const filteredTypingIndicators = typingIndicators.filter(typingIndicator => toFlatCommunicationIdentifier(typingIndicator.sender) !== userIdAsKey);
        if (filteredTypingIndicators.length !== typingIndicators.length) {
            thread.typingIndicators = filteredTypingIndicators;
        }
    }
    /**
     * Batch updates to minimize `stateChanged` events across related operations.
     *
     * - A maximum of one `stateChanged` event is emitted, at the end of the operations.
     * - No `stateChanged` event is emitted if the state did not change through the operations.
     * - In case of an exception, state is reset to the prior value and no `stateChanged` event is emitted.
     *
     * All operations finished in this batch should be synchronous.
     * This function is not reentrant -- do not call batch() from within another batch().
     */
    batch(operations) {
        if (this._batchMode) {
            throw new Error('batch() called from within another batch()');
        }
        this._batchMode = true;
        const priorState = this._state;
        try {
            operations();
            if (this._state !== priorState) {
                this._emitter.emit('stateChanged', this._state);
            }
        }
        catch (e) {
            this._state = priorState;
            if (logger.getLogLevel() === 'verbose') {
                this._logger.warning(`State rollback to: ${_safeJSONStringify(priorState)}`);
            }
            throw e;
        }
        finally {
            this._batchMode = false;
        }
    }
    onStateChange(handler) {
        this._emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this._emitter.off('stateChanged', handler);
    }
};
const toChatError = (target, error) => {
    if (error instanceof Error) {
        return new ChatError(target, error);
    }
    return new ChatError(target, new Error(`${error}`));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const convertChatMessage = (message, status = 'delivered', clientMessageId) => {
    return Object.assign(Object.assign({}, message), { clientMessageId: clientMessageId, status });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$n = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues$1 = (window && window.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
// TODO: When we can get messageId of event from SDK, remove this
// Maximum time to look back message list when we receive a system event
const maxSyncTimeInMs = 10 * 1000;
/**
 * @private
 */
class EventSubscriber {
    constructor(chatClient, chatContext) {
        this.convertEventToChatMessage = (event) => {
            return convertChatMessage({
                id: event.id,
                version: event.version,
                content: {
                    message: event.message,
                    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
                    attachments: event.attachments
                },
                type: this.convertEventType(event.type),
                sender: event.sender,
                senderDisplayName: event.senderDisplayName,
                sequenceId: '',
                // Note: there is a bug in chatMessageReceived event that it is missing sequenceId
                createdOn: new Date(event.createdOn),
                editedOn: 'editedOn' in event ? event.editedOn : undefined,
                metadata: event.metadata
            });
        };
        // convert event type to chatMessage type, only possible type is 'html' and 'text' in chat event
        this.convertEventType = (type) => {
            const lowerCaseType = type.toLowerCase();
            if (lowerCaseType === 'richtext/html' || lowerCaseType === 'html') {
                return 'html';
            }
            else {
                return 'text';
            }
        };
        this.onChatMessageReceived = (event) => {
            var _a;
            // Today we are avoiding how to render these messages. In the future we can
            // remove this condition and handle this message appropriately.
            const messageEventType = event.type.toLowerCase();
            if (messageEventType !== 'text' && messageEventType !== 'richtext/html' && messageEventType !== 'html') {
                return;
            }
            const newMessage = this.convertEventToChatMessage(event);
            // Because of bug in chatMessageReceived event, if we already have that particular message in context, we want to
            // make sure to not overwrite the sequenceId when calling setChatMessage.
            const existingMessage = (_a = this.chatContext.getState().threads[event.threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages[event.id];
            if (existingMessage) {
                newMessage.sequenceId = existingMessage.sequenceId;
            }
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.setChatMessage(event.threadId, newMessage);
            });
        };
        this.onChatMessageDeleted = (event) => {
            this.chatContext.deleteMessage(event.threadId, event.id);
        };
        this.onChatMessageEdited = (event) => {
            const editedMessage = this.convertEventToChatMessage(event);
            this.chatContext.setChatMessage(event.threadId, convertChatMessage(editedMessage));
        };
        this.onParticipantsAdded = (event) => {
            const participantsToAdd = event.participantsAdded.map(participant => (Object.assign(Object.assign({}, participant), { shareHistoryTime: participant.shareHistoryTime ? new Date(participant.shareHistoryTime) : undefined })));
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.setParticipants(event.threadId, participantsToAdd);
            });
            this.fetchLastParticipantMessage(event.threadId, 'participantAdded');
        };
        // This is a temporary fix that no participant message is received for onChatMessageReceived event, which should be handled by JS SDK.
        // Without the temporary fix, there are missing 'participant joined' and 'participant left' system messages in the chat thread.
        this.fetchLastParticipantMessage = (threadId, actionType) => __awaiter$n(this, void 0, void 0, function* () {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues$1(this.chatClient.getChatThreadClient(threadId).listMessages({
                    startTime: new Date(Date.now() - maxSyncTimeInMs)
                })), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const message = _c;
                    if (message.type === actionType) {
                        this.chatContext.setChatMessage(threadId, Object.assign(Object.assign({}, message), { status: 'delivered' }));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
        this.onParticipantsRemoved = (event) => {
            const participantIds = event.participantsRemoved.map(participant => {
                return participant.id;
            });
            this.chatContext.deleteParticipants(event.threadId, participantIds);
            // If the current user is removed from the thread, do not fetch the last participant message
            // as they no longer have access to the thread.
            const currentUserId = toFlatCommunicationIdentifier(this.chatContext.getState().userId);
            const wasCurrentUserRemoved = participantIds.find(id => toFlatCommunicationIdentifier(id) === currentUserId);
            if (!wasCurrentUserRemoved) {
                this.fetchLastParticipantMessage(event.threadId, 'participantRemoved');
            }
        };
        this.onReadReceiptReceived = (event) => {
            const readReceipt = Object.assign(Object.assign({}, event), { sender: event.sender, readOn: new Date(event.readOn) });
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.addReadReceipt(event.threadId, readReceipt);
            });
        };
        this.onTypingIndicatorReceived = (typingIndicator) => {
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(typingIndicator.threadId);
                this.chatContext.addTypingIndicator(typingIndicator.threadId, typingIndicator);
            });
        };
        this.onChatThreadCreated = (event) => {
            const properties = {
                topic: event.properties.topic
            };
            if (!this.chatContext.createThreadIfNotExist(event.threadId, properties)) {
                this.chatContext.updateThread(event.threadId, properties);
            }
        };
        this.onChatThreadDeleted = (event) => {
            this.chatContext.deleteThread(event.threadId);
        };
        this.onChatThreadPropertiesUpdated = (event) => {
            this.chatContext.updateThread(event.threadId, {
                topic: event.properties.topic
            });
        };
        this.subscribe = () => {
            this.chatClient.on('chatMessageReceived', this.onChatMessageReceived);
            this.chatClient.on('chatMessageDeleted', this.onChatMessageDeleted);
            this.chatClient.on('chatMessageEdited', this.onChatMessageEdited);
            this.chatClient.on('participantsAdded', this.onParticipantsAdded);
            this.chatClient.on('participantsRemoved', this.onParticipantsRemoved);
            this.chatClient.on('readReceiptReceived', this.onReadReceiptReceived);
            this.chatClient.on('typingIndicatorReceived', this.onTypingIndicatorReceived);
            this.chatClient.on('chatThreadCreated', this.onChatThreadCreated);
            this.chatClient.on('chatThreadDeleted', this.onChatThreadDeleted);
            this.chatClient.on('chatThreadPropertiesUpdated', this.onChatThreadPropertiesUpdated);
        };
        this.unsubscribe = () => {
            this.chatClient.off('chatMessageReceived', this.onChatMessageReceived);
            this.chatClient.off('chatMessageDeleted', this.onChatMessageDeleted);
            this.chatClient.off('chatMessageEdited', this.onChatMessageEdited);
            this.chatClient.off('participantsAdded', this.onParticipantsAdded);
            this.chatClient.off('participantsRemoved', this.onParticipantsRemoved);
            this.chatClient.off('readReceiptReceived', this.onReadReceiptReceived);
            this.chatClient.off('typingIndicatorReceived', this.onTypingIndicatorReceived);
            this.chatClient.off('chatThreadCreated', this.onChatThreadCreated);
            this.chatClient.off('chatThreadDeleted', this.onChatThreadDeleted);
            this.chatClient.off('chatThreadPropertiesUpdated', this.onChatThreadPropertiesUpdated);
        };
        this.chatClient = chatClient;
        this.chatContext = chatContext;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$m = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Create a decorated iterator
 * returned iterators.
 *
 * @param iteratorCreator the function to create the original iterator
 * @param context chatContext
 * @param decorateFn the function for the decorating behavior
 */
const createDecoratedIterator = (iteratorCreator, context, decorateFn) => {
    return (...args) => {
        const threadsIterator = iteratorCreator(...args);
        return {
            next() {
                return __awaiter$m(this, void 0, void 0, function* () {
                    const result = yield threadsIterator.next();
                    if (!result.done && result.value) {
                        decorateFn(result.value, context);
                    }
                    return result;
                });
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                const pages = threadsIterator.byPage(settings);
                return {
                    next() {
                        return __awaiter$m(this, void 0, void 0, function* () {
                            const result = yield pages.next();
                            const page = result.value;
                            if (!result.done && result.value) {
                                context.batch(() => {
                                    for (const item of page) {
                                        decorateFn(item, context);
                                    }
                                });
                            }
                            return result;
                        });
                    },
                    [Symbol.asyncIterator]() {
                        return this;
                    }
                };
            }
        };
    };
};
/**
 *
 * @param iteratorCreator Function that creates the base iteartor
 * @param context The ChatContext that stores all internal state.
 * @param target See {@link ChatContext.asyncTeeErrorToState}.
 * @returns A function to create an iterator that handles errors when iterting over the iterator from `iteratorCreator`.
 */
const createErrorHandlingIterator = (iteratorCreator, context, target) => {
    return (...args) => {
        const innerIter = iteratorCreator(...args);
        return {
            next: context.withAsyncErrorTeedToState(innerIter.next.bind(innerIter), target),
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                const pages = innerIter.byPage(settings);
                return {
                    next: context.withAsyncErrorTeedToState(pages.next.bind(pages), target),
                    [Symbol.asyncIterator]() {
                        return this;
                    }
                };
            }
        };
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const createDecoratedListMessages = (chatThreadClient, context) => {
    const setMessage = (message, context) => {
        context.setChatMessage(chatThreadClient.threadId, convertChatMessage(message));
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listMessages.bind(chatThreadClient), 'ChatThreadClient.listMessages'), context, 'ChatThreadClient.listMessages'), context, setMessage);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const createDecoratedListReadReceipts = (chatThreadClient, context) => {
    const setReadReceipt = (readReceipt, context) => {
        context.addReadReceipt(chatThreadClient.threadId, Object.assign({}, readReceipt));
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listReadReceipts.bind(chatThreadClient), 'ChatThreadClient.listReadReceipts'), context, 'ChatThreadClient.listReadReceipts'), context, setReadReceipt);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const createDecoratedListParticipants = (chatThreadClient, context) => {
    const setParticipant = (participant, context) => {
        context.setParticipant(chatThreadClient.threadId, participant);
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listParticipants.bind(chatThreadClient), 'ChatThreadClient.listParticipants'), context, 'ChatThreadClient.listParticipants'), context, setParticipant);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$l = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProxyChatThreadClient {
    constructor(context) {
        this._context = context;
    }
    get(chatThreadClient, prop) {
        switch (prop) {
            case 'listMessages':
                {
                    return createDecoratedListMessages(chatThreadClient, this._context);
                }
            case 'getMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$l(this, void 0, void 0, function* () {
                        const message = yield chatThreadClient.getMessage(...args);
                        this._context.setChatMessage(chatThreadClient.threadId, convertChatMessage(message));
                        return message;
                    }), 'ChatThreadClient.getMessage');
                }
            case 'sendMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$l(this, void 0, void 0, function* () {
                        var _a;
                        // Retry logic?
                        const [request, options] = args;
                        const { content } = request;
                        const clientMessageId = nanoid.nanoid(); // Generate a local short uuid for message
                        const newMessage = {
                            content: {
                                message: content
                            },
                            clientMessageId,
                            id: '',
                            type: (_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : 'text',
                            sequenceId: '',
                            version: '',
                            createdOn: new Date(),
                            status: 'sending',
                            senderDisplayName: this._context.getState().displayName,
                            sender: this._context.getState().userId,
                            metadata: options === null || options === void 0 ? void 0 : options.metadata
                        };
                        this._context.setChatMessage(chatThreadClient.threadId, newMessage);
                        let result = undefined;
                        try {
                            result = yield chatThreadClient.sendMessage(...args);
                        }
                        catch (e) {
                            this._context.setChatMessage(chatThreadClient.threadId, Object.assign(Object.assign({}, newMessage), { status: 'failed' }));
                            throw e;
                        }
                        if (result === null || result === void 0 ? void 0 : result.id) {
                            this._context.batch(() => {
                                if (!result) {
                                    return;
                                }
                                this._context.setChatMessage(chatThreadClient.threadId, Object.assign(Object.assign({}, newMessage), { clientMessageId: undefined, status: 'delivered', id: result.id }));
                                this._context.deleteLocalMessage(chatThreadClient.threadId, clientMessageId);
                            });
                        }
                        return result;
                    }), 'ChatThreadClient.sendMessage');
                }
            case 'addParticipants':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$l(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.addParticipants(...args);
                        const [addRequest] = args;
                        const participantsToAdd = addRequest.participants;
                        this._context.setParticipants(chatThreadClient.threadId, participantsToAdd);
                        return result;
                    }), 'ChatThreadClient.addParticipants');
                }
            case 'deleteMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$l(this, void 0, void 0, function* () {
                        // DeleteMessage is able to either delete local one(for failed message) or synced message
                        const [messageId] = args;
                        if (this._context.deleteLocalMessage(chatThreadClient.threadId, messageId)) {
                            return {};
                        }
                        const result = yield chatThreadClient.deleteMessage(...args);
                        this._context.deleteMessage(chatThreadClient.threadId, messageId);
                        return result;
                    }), 'ChatThreadClient.deleteMessage');
                }
            case 'listParticipants':
                {
                    return createDecoratedListParticipants(chatThreadClient, this._context);
                }
            case 'listReadReceipts':
                {
                    return createDecoratedListReadReceipts(chatThreadClient, this._context);
                }
            case 'sendTypingNotification':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$l(this, void 0, void 0, function* () {
                        return yield chatThreadClient.sendTypingNotification(...args);
                    }), 'ChatThreadClient.sendTypingNotification');
                }
            case 'removeParticipant':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$l(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.removeParticipant(...args);
                        const [removeIdentifier] = args;
                        this._context.deleteParticipant(chatThreadClient.threadId, communicationCommon.getIdentifierKind(removeIdentifier));
                        return result;
                    }), 'ChatThreadClient.removeParticipant');
                }
            case 'updateMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$l(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.updateMessage(...args);
                        const [messageId, updateOption] = args;
                        this._context.updateChatMessageContent(chatThreadClient.threadId, messageId, updateOption === null || updateOption === void 0 ? void 0 : updateOption.content);
                        return result;
                    }), 'ChatThreadClient.updateMessage');
                }
            case 'updateTopic':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$l(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.updateTopic(...args);
                        const [topic] = args;
                        this._context.updateThreadTopic(chatThreadClient.threadId, topic);
                        return result;
                    }), 'ChatThreadClient.updateTopic');
                }
            case 'getProperties':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$l(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.getProperties(...args);
                        this._context.updateThread(chatThreadClient.threadId, result);
                        return result;
                    }), 'ChatThreadClient.getProperties');
                }
            default:
                return Reflect.get(chatThreadClient, prop);
        }
    }
}
/**
 * @private
 */
const chatThreadClientDeclaratify = (chatThreadClient, context) => {
    context.createThreadIfNotExist(chatThreadClient.threadId);
    return new Proxy(chatThreadClient, new ProxyChatThreadClient(context));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const createDecoratedListThreads = (chatClient, context) => {
    const setThreadProperties = (chatThreadItem, context) => {
        const properties = {
            topic: chatThreadItem.topic
        };
        if (!context.createThreadIfNotExist(chatThreadItem.id, properties)) {
            context.updateThread(chatThreadItem.id, properties);
        }
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatClient.listChatThreads.bind(chatClient), 'ChatClient.listChatThreads'), context, 'ChatClient.listChatThreads'), context, setThreadProperties);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$k = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const proxyChatClient = {
    get: function (chatClient, prop, receiver) {
        // skip receiver.context call to avoid recursive bugs
        if (prop === 'context') {
            return Reflect.get(chatClient, prop);
        }
        const context = receiver.context;
        switch (prop) {
            case 'createChatThread':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            const result = yield chatClient.createChatThread(...args);
                            const thread = result.chatThread;
                            if (thread) {
                                const [request] = args;
                                context.createThread(thread.id, {
                                    topic: request.topic
                                });
                            }
                            return result;
                        });
                    }, 'ChatClient.createChatThread');
                }
            case 'deleteChatThread':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            const result = yield chatClient.deleteChatThread(...args);
                            context.deleteThread(args[0]);
                            return result;
                        });
                    }, 'ChatClient.deleteChatThread');
                }
            case 'listChatThreads':
                {
                    return createDecoratedListThreads(chatClient, context);
                }
            case 'getChatThreadClient':
                {
                    return function (...args) {
                        const chatThreadClient = chatClient.getChatThreadClient(...args);
                        // TODO(prprabhu): Ensure that thread properties are fetched into the ChatContext at this point.
                        // A new thread might be created here, but the properties will never be fetched.
                        return chatThreadClientDeclaratify(chatThreadClient, context);
                    };
                }
            case 'startRealtimeNotifications':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            const ret = yield chatClient.startRealtimeNotifications(...args);
                            if (!receiver.eventSubscriber) {
                                receiver.eventSubscriber = new EventSubscriber(chatClient, context);
                            }
                            return ret;
                        });
                    }, 'ChatClient.startRealtimeNotifications');
                }
            case 'stopRealtimeNotifications':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            const ret = yield chatClient.stopRealtimeNotifications(...args);
                            if (receiver.eventSubscriber) {
                                receiver.eventSubscriber.unsubscribe();
                                receiver.eventSubscriber = undefined;
                            }
                            return ret;
                        });
                    }, 'ChatClient.stopRealtimeNotifications');
                }
            default:
                return Reflect.get(chatClient, prop);
        }
    }
};
/**
 * Creates a stateful ChatClient {@link StatefulChatClient} by proxying ChatClient
 * {@link @azure/communication-chat#ChatClient} with ProxyChatClient {@link ProxyChatClient} which then allows access
 * to state in a declarative way.
 *
 * @public
 */
const createStatefulChatClient = (args, options) => {
    return _createStatefulChatClientInner(args, options);
};
/**
 * This inner function is used to allow injection of TelemetryImplementationHint without changing the public API.
 *
 * @internal
 */
const _createStatefulChatClientInner = (args, options, telemetryImplementationHint = 'StatefulComponents') => {
    chatStatefulLogger.info(`Creating chat stateful client using library version: ${_getApplicationId(telemetryImplementationHint)}`);
    const tweakedOptions = Object.assign(Object.assign({}, options), { chatClientOptions: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.chatClientOptions), { userAgentOptions: {
                userAgentPrefix: _getApplicationId(telemetryImplementationHint)
            } }) });
    return _createStatefulChatClientWithDeps(new communicationChat.ChatClient(args.endpoint, args.credential, tweakedOptions.chatClientOptions), args, tweakedOptions);
};
/**
 * Internal implementation of {@link createStatefulChatClient} for dependency injection.
 *
 * Used by tests. Should not be exported out of this package.
 * @internal
 */
const _createStatefulChatClientWithDeps = (chatClient, args, options) => {
    const context = new ChatContext$1(options === null || options === void 0 ? void 0 : options.maxStateChangeListeners, /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */ args.credential, /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */ args.endpoint);
    let eventSubscriber;
    context.updateChatConfig(communicationCommon.getIdentifierKind(args.userId), args.displayName);
    const proxy = new Proxy(chatClient, proxyChatClient);
    Object.defineProperty(proxy, 'context', {
        configurable: false,
        get: () => context
    });
    Object.defineProperty(proxy, 'eventSubscriber', {
        configurable: false,
        get: () => eventSubscriber,
        set: (val) => {
            eventSubscriber = val;
        }
    });
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    Object.defineProperty(proxy, 'dispose', {
        configurable: false,
        value: () => context === null || context === void 0 ? void 0 : context.dispose()
    });
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    Object.defineProperty(proxy, 'downloadResourceToCache', {
        configurable: false,
        value: (threadId, messageId, resourceUrl) => context === null || context === void 0 ? void 0 : context.downloadResourceToCache(threadId, messageId, resourceUrl)
    });
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    Object.defineProperty(proxy, 'removeResourceFromCache', {
        configurable: false,
        value: (threadId, messageId, resourceUrl) => context === null || context === void 0 ? void 0 : context.removeResourceFromCache(threadId, messageId, resourceUrl)
    });
    Object.defineProperty(proxy, 'getState', {
        configurable: false,
        value: () => context === null || context === void 0 ? void 0 : context.getState()
    });
    Object.defineProperty(proxy, 'onStateChange', {
        configurable: false,
        value: (handler) => context === null || context === void 0 ? void 0 : context.onStateChange(handler)
    });
    Object.defineProperty(proxy, 'offStateChange', {
        configurable: false,
        value: (handler) => context === null || context === void 0 ? void 0 : context.offStateChange(handler)
    });
    return proxy;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$j = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (window && window.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
/**
 * Context of Chat, which is a centralized context for all state updates
 * @private
 */
class ChatContext {
    constructor(clientState, threadId) {
        this.emitter = new EventEmitter();
        const thread = clientState.threads[threadId];
        this.threadId = threadId;
        if (!thread) {
            throw 'Cannot find threadId, please initialize thread before use!';
        }
        this.state = {
            userId: clientState.userId,
            displayName: clientState.displayName,
            thread,
            latestErrors: clientState.latestErrors
        };
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    setError(error) {
        this.setState(Object.assign(Object.assign({}, this.state), { error }));
    }
    updateClientState(clientState) {
        const thread = clientState.threads[this.threadId];
        if (!thread) {
            throw 'Cannot find threadId, please make sure thread state is still in Stateful ChatClient.';
        }
        let updatedState = {
            userId: clientState.userId,
            displayName: clientState.displayName,
            thread,
            latestErrors: clientState.latestErrors
        };
        this.setState(updatedState);
    }
}
/**
 * @private
 */
class AzureCommunicationChatAdapter {
    constructor(chatClient, chatThreadClient) {
        this.emitter = new EventEmitter();
        this.bindAllPublicMethods();
        this.chatClient = chatClient;
        this.chatThreadClient = chatThreadClient;
        this.context = new ChatContext(chatClient.getState(), chatThreadClient.threadId);
        const onStateChange = (clientState) => {
            // unsubscribe when the instance gets disposed
            if (!this) {
                chatClient.offStateChange(onStateChange);
                return;
            }
            this.context.updateClientState(clientState);
        };
        this.handlers = createDefaultChatHandlers(chatClient, chatThreadClient);
        this.chatClient.onStateChange(onStateChange);
        this.subscribeAllEvents();
    }
    bindAllPublicMethods() {
        this.onStateChange = this.onStateChange.bind(this);
        this.offStateChange = this.offStateChange.bind(this);
        this.getState = this.getState.bind(this);
        this.dispose = this.dispose.bind(this);
        this.fetchInitialData = this.fetchInitialData.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.sendReadReceipt = this.sendReadReceipt.bind(this);
        this.sendTypingIndicator = this.sendTypingIndicator.bind(this);
        this.updateMessage = this.updateMessage.bind(this);
        this.deleteMessage = this.deleteMessage.bind(this);
        this.removeParticipant = this.removeParticipant.bind(this);
        this.setTopic = this.setTopic.bind(this);
        this.loadPreviousChatMessages = this.loadPreviousChatMessages.bind(this);
        this.on = this.on.bind(this);
        this.off = this.off.bind(this);
        /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
        this.downloadResourceToCache = this.downloadResourceToCache.bind(this);
        /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
        this.removeResourceFromCache = this.removeResourceFromCache.bind(this);
    }
    dispose() {
        this.unsubscribeAllEvents();
        /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
        this.chatClient.dispose();
    }
    fetchInitialData() {
        return __awaiter$j(this, void 0, void 0, function* () {
            // If get properties fails we dont want to try to get the participants after.
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$j(this, void 0, void 0, function* () {
                var _a, e_1, _b, _c;
                yield this.chatThreadClient.getProperties();
                try {
                    // Fetch all participants who joined before the local user.
                    for (var _d = true, _e = __asyncValues(this.chatThreadClient.listParticipants().byPage({
                        // Fetch 100 participants per page by default.
                        maxPageSize: 100
                        // eslint-disable-next-line curly
                    })), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                        _c = _f.value;
                        _d = false;
                        const _page = _c;
                        ;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }));
        });
    }
    getState() {
        return this.context.getState();
    }
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    sendMessage(content, options = {}) {
        return __awaiter$j(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$j(this, void 0, void 0, function* () {
                yield this.handlers.onSendMessage(content, options);
            }));
        });
    }
    sendReadReceipt(chatMessageId) {
        return __awaiter$j(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$j(this, void 0, void 0, function* () {
                yield this.handlers.onMessageSeen(chatMessageId);
            }));
        });
    }
    sendTypingIndicator() {
        return __awaiter$j(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$j(this, void 0, void 0, function* () {
                yield this.handlers.onTyping();
            }));
        });
    }
    removeParticipant(userId) {
        return __awaiter$j(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$j(this, void 0, void 0, function* () {
                yield this.handlers.onRemoveParticipant(userId);
            }));
        });
    }
    setTopic(topicName) {
        return __awaiter$j(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$j(this, void 0, void 0, function* () {
                yield this.handlers.updateThreadTopicName(topicName);
            }));
        });
    }
    loadPreviousChatMessages(messagesToLoad) {
        return __awaiter$j(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$j(this, void 0, void 0, function* () {
                return yield this.handlers.onLoadPreviousChatMessages(messagesToLoad);
            }));
        });
    }
    updateMessage(messageId, content, metadata, options) {
        return __awaiter$j(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$j(this, void 0, void 0, function* () {
                return yield this.handlers.onUpdateMessage(messageId, content);
            }));
        });
    }
    deleteMessage(messageId) {
        return __awaiter$j(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$j(this, void 0, void 0, function* () {
                return yield this.handlers.onDeleteMessage(messageId);
            }));
        });
    }
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    downloadResourceToCache(resourceDetails) {
        return __awaiter$j(this, void 0, void 0, function* () {
            this.chatClient.downloadResourceToCache(resourceDetails.threadId, resourceDetails.messageId, resourceDetails.resourceUrl);
        });
    }
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    removeResourceFromCache(resourceDetails) {
        this.chatClient.removeResourceFromCache(resourceDetails.threadId, resourceDetails.messageId, resourceDetails.resourceUrl);
    }
    messageReceivedListener(event) {
        const isCurrentChatAdapterThread = event.threadId === this.chatThreadClient.threadId;
        if (!isCurrentChatAdapterThread) {
            return;
        }
        const message = convertEventToChatMessage(event);
        this.emitter.emit('messageReceived', {
            message
        });
        const currentUserId = toFlatCommunicationIdentifier(this.chatClient.getState().userId);
        if ((message === null || message === void 0 ? void 0 : message.sender) && toFlatCommunicationIdentifier(message.sender) === currentUserId) {
            this.emitter.emit('messageSent', {
                message
            });
        }
    }
    messageEditedListener(event) {
        const isCurrentChatAdapterThread = event.threadId === this.chatThreadClient.threadId;
        if (!isCurrentChatAdapterThread) {
            return;
        }
        const message = convertEventToChatMessage(event);
        this.emitter.emit('messageEdited', {
            message
        });
    }
    messageDeletedListener(event) {
        const isCurrentChatAdapterThread = event.threadId === this.chatThreadClient.threadId;
        if (!isCurrentChatAdapterThread) {
            return;
        }
        const message = convertEventToChatMessage(event);
        this.emitter.emit('messageDeleted', {
            message
        });
    }
    messageReadListener({ chatMessageId, recipient }) {
        const message = this.getState().thread.chatMessages[chatMessageId];
        if (message) {
            this.emitter.emit('messageRead', {
                message,
                readBy: recipient
            });
        }
    }
    participantsAddedListener({ addedBy, participantsAdded }) {
        this.emitter.emit('participantsAdded', {
            addedBy,
            participantsAdded
        });
    }
    participantsRemovedListener({ removedBy, participantsRemoved }) {
        this.emitter.emit('participantsRemoved', {
            removedBy,
            participantsRemoved
        });
    }
    chatThreadPropertiesUpdatedListener(event) {
        this.emitter.emit('topicChanged', {
            topic: event.properties.topic
        });
    }
    subscribeAllEvents() {
        this.chatClient.on('chatThreadPropertiesUpdated', this.chatThreadPropertiesUpdatedListener.bind(this));
        this.chatClient.on('participantsAdded', this.participantsAddedListener.bind(this));
        this.chatClient.on('participantsRemoved', this.participantsRemovedListener.bind(this));
        this.chatClient.on('chatMessageReceived', this.messageReceivedListener.bind(this));
        this.chatClient.on('chatMessageEdited', this.messageEditedListener.bind(this));
        this.chatClient.on('chatMessageDeleted', this.messageDeletedListener.bind(this));
        this.chatClient.on('readReceiptReceived', this.messageReadListener.bind(this));
        this.chatClient.on('participantsRemoved', this.participantsRemovedListener.bind(this));
    }
    unsubscribeAllEvents() {
        this.chatClient.off('chatThreadPropertiesUpdated', this.chatThreadPropertiesUpdatedListener.bind(this));
        this.chatClient.off('participantsAdded', this.participantsAddedListener.bind(this));
        this.chatClient.off('participantsRemoved', this.participantsRemovedListener.bind(this));
        this.chatClient.off('chatMessageReceived', this.messageReceivedListener.bind(this));
        this.chatClient.off('chatMessageEdited', this.messageEditedListener.bind(this));
        this.chatClient.off('chatMessageDeleted', this.messageDeletedListener.bind(this));
        this.chatClient.off('readReceiptReceived', this.messageReadListener.bind(this));
        this.chatClient.off('participantsRemoved', this.participantsRemovedListener.bind(this));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    asyncTeeErrorToEventEmitter(f) {
        return __awaiter$j(this, void 0, void 0, function* () {
            try {
                return yield f();
            }
            catch (error) {
                if (isChatError(error)) {
                    this.emitter.emit('error', error);
                }
                throw error;
            }
        });
    }
}
const convertEventToChatMessage = (event) => {
    return {
        id: event.id,
        version: event.version,
        content: isChatMessageDeletedEvent(event) ? undefined : {
            message: event.message
        },
        type: convertEventType(event.type),
        sender: event.sender,
        senderDisplayName: event.senderDisplayName,
        sequenceId: '',
        createdOn: new Date(event.createdOn),
        editedOn: isChatMessageEditedEvent(event) ? event.editedOn : undefined,
        deletedOn: isChatMessageDeletedEvent(event) ? event.deletedOn : undefined
    };
};
const isChatMessageEditedEvent = (event) => {
    return 'editedOn' in event;
};
const isChatMessageDeletedEvent = (event) => {
    return 'deletedOn' in event;
};
// only text/html message type will be received from event
const convertEventType = (type) => {
    const lowerCaseType = type.toLowerCase();
    if (lowerCaseType === 'richtext/html' || lowerCaseType === 'html') {
        return 'html';
    }
    else {
        return 'text';
    }
};
/**
 * Create a {@link ChatAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link ChatAdapter} provided by this library.
 *
 * @public
 */
const createAzureCommunicationChatAdapter = ({ endpoint: endpointUrl, userId, displayName, credential, threadId }) => __awaiter$j(void 0, void 0, void 0, function* () {
    return _createAzureCommunicationChatAdapterInner(endpointUrl, userId, displayName, credential, threadId);
});
/**
 * This inner function is used to allow injection of TelemetryImplementationHint without changing the public API.
 *
 * @internal
 */
const _createAzureCommunicationChatAdapterInner = (endpoint, userId, displayName, credential, threadId, telemetryImplementationHint = 'Chat') => __awaiter$j(void 0, void 0, void 0, function* () {
    if (!_isValidIdentifier(userId)) {
        throw new Error('Provided userId is invalid. Please provide valid identifier object.');
    }
    const chatClient = _createStatefulChatClientInner({
        userId,
        displayName,
        endpoint,
        credential
    }, undefined, telemetryImplementationHint);
    const chatThreadClient = yield chatClient.getChatThreadClient(threadId);
    yield chatClient.startRealtimeNotifications();
    const adapter = yield createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient);
    return adapter;
});
/**
 * A custom React hook to simplify the creation of {@link ChatAdapter}.
 *
 * Similar to {@link createAzureCommunicationChatAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
const useAzureCommunicationChatAdapter = (args, afterCreate, beforeDispose) => {
    const { credential, displayName, endpoint, threadId, userId } = args;
    // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = React.useState(undefined);
    // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = React.useRef(undefined);
    const afterCreateRef = React.useRef(undefined);
    const beforeDisposeRef = React.useRef(undefined);
    // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    React.useEffect(() => {
        if (!credential || !displayName || !endpoint || !threadId || !userId) {
            return;
        }
        (() => __awaiter$j(void 0, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            let newAdapter = yield createAzureCommunicationChatAdapter({
                credential,
                displayName,
                endpoint,
                threadId,
                userId
            });
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            setAdapter(newAdapter);
        }))();
    }, 
    // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, credential, displayName, endpoint, threadId, userId]);
    // Dispose any existing adapter when the component unmounts.
    React.useEffect(() => {
        return () => {
            (() => __awaiter$j(void 0, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
};
/**
 * Create a {@link ChatAdapter} using the provided {@link StatefulChatClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient}.
 * Consider using {@link createAzureCommunicationChatAdapter} for a simpler API.
 *
 * @public
 */
function createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient) {
    return __awaiter$j(this, void 0, void 0, function* () {
        return new AzureCommunicationChatAdapter(chatClient, chatThreadClient);
    });
}
const isChatError = (e) => {
    return 'target' in e && e['target'] !== undefined && 'innerError' in e && e['innerError'] !== undefined;
};

var call$k={cameraLabel:"Camera",noCamerasLabel:"No cameras found",cameraPermissionDenied:"Your browser is blocking access to your camera",cameraTurnedOff:"Your camera is turned off",chatButtonLabel:"Chat",close:"Close",complianceBannerNowOnlyRecording:"You are now only recording this meeting.",complianceBannerNowOnlyTranscription:"You are now only transcribing this meeting.",complianceBannerRecordingAndTranscriptionSaved:"Recording and transcription are being saved.",complianceBannerRecordingAndTranscriptionStarted:"Recording and transcription have started.",complianceBannerRecordingAndTranscriptionStopped:"Recording and transcription have stopped.",complianceBannerRecordingSaving:"Recording is being saved.",complianceBannerRecordingStarted:"Recording has started.",complianceBannerRecordingStopped:"Recording has stopped.",complianceBannerTranscriptionStarted:"Transcription has started.",complianceBannerTranscriptionConsent:"By joining, you are giving consent for this meeting to be transcribed.",complianceBannerTranscriptionSaving:"Transcription is being saved.",complianceBannerTranscriptionStopped:"Transcription has stopped.",configurationPageTitle:"Start a call",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",defaultPlaceHolder:"Select an option",dismissSidePaneButtonLabel:"Close",videoEffectsPaneTitle:"Effects",videoEffectsPaneBackgroundSelectionTitle:"Background",configurationPageVideoEffectsButtonLabel:"Effects",unableToStartVideoEffect:"Unable to apply video effect.",blurBackgroundEffectButtonLabel:"Blur",blurBackgroundTooltip:"Blur Background",removeBackgroundEffectButtonLabel:"None",removeBackgroundTooltip:"Remove Background",cameraOffBackgroundEffectWarningText:"Your camera is off. Turn on camera to see video effect.",failedToJoinCallDueToNoNetworkMoreDetails:"Call was disconnected due to a network issue. Check your connection and join again.",failedToJoinCallDueToNoNetworkTitle:"Call disconnected",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"You were not granted entry in the call. If this was a mistake, re-join the call.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Dismissed from lobby",learnMore:"Learn more",leavingCallTitle:"Leaving...",leftCallMoreDetails:"If this was a mistake, re-join the call.",leftCallTitle:"You left the call",lobbyScreenConnectingToCallTitle:"Joining call",lobbyScreenWaitingToBeAdmittedTitle:"Waiting to be admitted",microphonePermissionDenied:"Your browser is blocking access to your microphone",microphoneToggleInLobbyNotAllowed:"Cannot mute or unmute while in lobby.",mutedMessage:"You're muted",networkReconnectMoreDetails:"Looks like something went wrong. We're trying to get back into the call.",networkReconnectTitle:"Hold on",notInvitedToRoomDetails:"You are not able to join this room because you do not have an invite.",notInvitedToRoomTitle:"Not invited to room",peopleButtonLabel:"People",selectedPeopleButtonLabel:"People Button Selected",peoplePaneTitle:"People",peoplePaneMoreButtonAriaLabel:"More",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call {numberOfPeople}",privacyPolicy:"Privacy policy",rejoinCallButtonLabel:"Re-join call",removedFromCallMoreDetails:"Another participant removed you from the call.",removedFromCallTitle:"You were removed",removeMenuLabel:"Remove",startSpotlightParticipantListMenuLabel:"Spotlight for everyone",addSpotlightParticipantListMenuLabel:"Add spotlight",stopSpotlightParticipantListMenuLabel:"Stop spotlighting",stopSpotlightOnSelfParticipantListMenuLabel:"Exit spotlight",spotlightLimitReachedParticipantListMenuTitle:"Spotlight limit reached",stopAllSpotlightMenuLabel:"Stop all spotlights",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",roomNotFoundDetails:"The room ID provided could not be found.",roomNotFoundTitle:"Room not found",roomNotValidDetails:"This room is not valid at this current time.",roomNotValidTitle:"Room not valid",inviteToRoomRemovedDetails:"Your invite to join this room was removed.",inviteToRoomRemovedTitle:"Invite to room removed",soundLabel:"Sound",noMicrophonesLabel:"No microphones found",noSpeakersLabel:"No speakers found",startCallButtonLabel:"Start call",openDialpadButtonLabel:"Dial phone number",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",moreButtonCallingLabel:"More",resumeCallButtonLabel:"Resume",resumingCallButtonLabel:"Resuming...",resumeCallButtonAriaLabel:"Resume call",resumingCallButtonAriaLabel:"Resume call",holdScreenLabel:"You're on hold",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number",outboundCallingNoticeString:"Calling...",participantJoinedNoticeString:"{displayName} joined",twoParticipantJoinedNoticeString:"{displayName1} and {displayName2} have joined",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} and {displayName3} have joined",participantLeftNoticeString:"{displayName} left",twoParticipantLeftNoticeString:"{displayName1} and {displayName2} have left",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} and {displayName3} have left",unnamedParticipantString:"unnamed participant",manyUnnamedParticipantsJoined:"unnamed participant and {numOfParticipants} other participants joined",manyUnnamedParticipantsLeft:"unnamed participant and {numOfParticipants} other participants left",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} and {numOfParticipants} other participants joined",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} and {numOfParticipants} other participants left",liveCaptionsLabel:"Live captions",captionsSettingsLabel:"Caption settings",startCaptionsButtonOnLabel:"Turn on captions",startCaptionsButtonOffLabel:"Turn off captions",startCaptionsButtonTooltipOnContent:"Turn off captions",startCaptionsButtonTooltipOffContent:"Turn on captions",captionsSettingsModalTitle:"Captions Settings",captionsSettingsSpokenLanguageDropdownLabel:"Spoken language",captionsSettingsCaptionLanguageDropdownLabel:"Captions language",captionsSettingsSpokenLanguageDropdownInfoText:"Language that everyone on this call is speaking.",captionsSettingsCaptionLanguageDropdownInfoText:"Captions will appear in this langugage.",captionsSettingsConfirmButtonLabel:"Confirm",captionsSettingsCancelButtonLabel:"Cancel",captionsSettingsModalAriaLabel:"Captions Setting Modal",captionsSettingsCloseModalButtonAriaLabel:"Close Captions Setting",captionsBannerMoreButtonCallingLabel:"More",captionsBannerMoreButtonTooltip:"More options",dismissModalAriaLabel:"Local and remote picture and picture, press enter to return to call",callRejectedTitle:"The call could not be completed",callRejectedMoreDetails:"The person you are trying to reach is unavailable. Please try again later.",callTimeoutTitle:"The call could not be completed",callTimeoutDetails:"The person you are trying to reach is unavailable. Please try again later.",callTimeoutBotTitle:"The call could not be completed",callTimeoutBotDetails:"The service that you are trying to reach is unavailable. Please try again later.",dtmfDialerButtonLabel:"Dialpad",dtmfDialerButtonTooltipOn:"Show dialpad",dtmfDialerButtonTooltipOff:"Hide dialpad",dtmfDialerMoreButtonLabelOn:"Show dialpad",dtmfDialerMoreButtonLabelOff:"Hide dialpad",spokenLanguageStrings:{"ar-ae":"Arabic - U.A.E.","ar-sa":"Arabic - Saudi Arabia","da-dk":"Danish","de-de":"German - Germany","en-au":"English - Australia","en-ca":"English - Canada","en-gb":"English - United Kingdom","en-in":"English - India","en-nz":"English - New Zealand","en-us":"English - United States","es-es":"Spanish - Spain (Modern Sort)","es-mx":"Spanish - Mexico","fi-fi":"Finnish","fr-ca":"French - Canada","fr-fr":"French - France","hi-in":"Hindi","it-it":"Italian - Italy","ja-jp":"Japanese","ko-kr":"Korean","nb-no":"Norwegian (Bokml)","nl-be":"Dutch - Belgium","nl-nl":"Dutch - Netherlands","pl-pl":"Polish","pt-br":"Portuguese - Brazil","ru-ru":"Russian","sv-se":"Swedish","zh-cn":"Chinese - People's Republic of China","zh-hk":"Chinese - Hong Kong SAR","cs-cz":"Czech","pt-pt":"Portuguese - Portugal","tr-tr":"Turkish","vi-vn":"Vietnamese","th-th":"Thai","he-il":"Hebrew","cy-gb":"Welsh","uk-ua":"Ukrainian","el-gr":"Greek","hu-hu":"Hungarian","ro-ro":"Romanian","sk-sk":"Slovak","zh-tw":"Chinese - Taiwan"},captionLanguageStrings:{ar:"Arabic",da:"Danish",de:"German",en:"English",es:"Spanish",fi:"Finnish","fr-ca":"French - Canada",fr:"French - France",hi:"Hindi",it:"Italian",ja:"Japanese",ko:"Korean",nb:"Norwegian (Bokml)",nl:"Dutch",pl:"Polish",pt:"Portuguese - Brazil",ru:"Russian",sv:"Swedish","zh-Hans":"Chinese (Simplified)","zh-Hant":"Chinese (Traditional)",cs:"Czech","pt-pt":"Portuguese - Portugal",tr:"Turkish",vi:"Vietnamese",th:"Thai",he:"Hebrew",cy:"Welsh",uk:"Ukrainian",el:"Greek",hu:"Hungarian",ro:"Romanian",sk:"Slovak"},captionsBannerSpinnerText:"Starting captions...",transferPageTransferorText:"Transferring...",transferPageTransferTargetText:"Connecting...",transferPageUnknownTransferorDisplayName:"Unknown",transferPageUnknownTransferTargetDisplayName:"Unknown",transferPageNoticeString:"You are being transferred",participantCouldNotBeReachedTitle:"Target participant is currently not available",participantCouldNotBeReachedMoreDetails:"Please contact participant when they are available",permissionToReachTargetParticipantNotAllowedTitle:"Permission to reach target participant is not allowed",permissionToReachTargetParticipantNotAllowedMoreDetails:"Please check that the target participant is in the same tenant",unableToResolveTenantTitle:"Unable to resolve tenant id for the target participant",unableToResolveTenantMoreDetails:"Please check the participant id is entered correctly",participantIdIsMalformedTitle:"Participant id is not in the correct format",participantIdIsMalformedMoreDetails:"Please check that the participant id is in the correct format",moreButtonGalleryControlLabel:"View",moreButtonGalleryPositionToggleLabel:"Move gallery to top",moreButtonGallerySpeakerLayoutLabel:"Speaker",moreButtonGalleryFloatingLocalLayoutLabel:"Dynamic",moreButtonGalleryDefaultLayoutLabel:"Gallery view",moreButtonGalleryFocusedContentLayoutLabel:"Focus on content",moreButtonLargeGalleryDefaultLayoutLabel:"Large Gallery",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Your camera has been disabled. You can no longer share video.",grantedDueToMeetingOption:"Your camera has been enabled. Turn it on if you'd like to share video."},unmuteMic:{lostDueToMeetingOption:"Your mic has been disabled. You can no longer unmute.",grantedDueToMeetingOption:"Your mic has been enabled. Unmute if you'd like to speak."},shareScreen:{lostDueToRoleChangeToAttendee:"Your role has been changed. Some actions, like sharing content, won't be available to you.",grantedDueToRoleChangeToPresenter:"You're a presenter. You can share content and facilitate the meeting."}},surveyTitle:"Help us improve",starSurveyHelperText:"How was the quality of the call?",starSurveyOneStarText:"The quality was bad.",starSurveyTwoStarText:"The quality was poor.",starSurveyThreeStarText:"The quality was good.",starSurveyFourStarText:"The quality was great.",starSurveyFiveStarText:"The quality was excellent.",surveyConfirmButtonLabel:"Send Feedback",starRatingAriaLabel:"Select {0} of {1} stars",surveySkipButtonLabel:"Skip",tagsSurveyQuestion:"What could have been better?",tagsSurveyTextFieldDefaultText:"Other, please specify",tagsSurveyHelperText:"Check any issues you experienced",surveyTextboxDefaultText:"Other, please specify",endOfSurveyText:"Thank you for your feedback!",surveyIssues:{overallRating:{callCannotJoin:"I could not join call",callCannotInvite:"I could not invite others into the call",hadToRejoin:"I had to rejoin the call",callEndedUnexpectedly:"Call ended for me unexpectedly",otherIssues:"I was having other issues with the call"},audioRating:{noLocalAudio:"The other side could not hear any sound",noRemoteAudio:"I could not hear any sound",echo:"I heard echos on the call",audioNoise:"I heard noise on the call",lowVolume:"Volume was low",audioStoppedUnexpectedly:"Audio stopped unexpectedly",distortedSpeech:"Audio was distorted",audioInterruption:"Audio was interrupted",otherIssues:"I was having other audio issues in this call"},videoRating:{noVideoReceived:"I could not see any video",noVideoSent:"Others could not see me",lowQuality:"Video quality was low",freezes:"Video frozen",stoppedUnexpectedly:"Video stopped unexpectedly",darkVideoReceived:"I can only see dark screens when others turn on their camera",audioVideoOutOfSync:"Audio and Video was out of sync",otherIssues:"I was having other video issues in this call"},screenshareRating:{noContentLocal:"Other people could not see my screenshare",noContentRemote:"I could not see other people's screenshare",cannotPresent:"I could not present my screen",lowQuality:"Screen share quality was low",freezes:"Screen share frozen",stoppedUnexpectedly:"Screen share stopped unexpectedly",largeDelay:"Screen share has a large delay",otherIssues:"I was having other screen share issues in this call"}},SurveyIssuesHeadingStrings:{overallRating:"Overall",audioRating:"Audio",videoRating:"Video",screenshareRating:"Presenting"},spotlightPrompt:{startSpotlightHeading:"Spotlight for everyone?",startSpotlightText:"You'll highlight this video for everyone in the meeting.",startSpotlightOnSelfText:"You'll highlight your video for everyone in the meeting.",startSpotlightConfirmButtonLabel:"Spotlight for everyone",startSpotlightCancelButtonLabel:"Cancel",stopSpotlightHeading:"Stop spotlighting this video?",stopSpotlightOnSelfHeading:"Exit spotlight?",stopSpotlightText:"This video will no longer be highlighted for everyone in the meeting.",stopSpotlightOnSelfText:"Your video will no longer be highlighted for everyone in the meeting.",stopSpotlightConfirmButtonLabel:"Stop spotlighting",stopSpotlightOnSelfConfirmButtonLabel:"Exit spotlight",stopSpotlightCancelButtonLabel:"Cancel"},exitSpotlightButtonLabel:"Exit spotlight",exitSpotlightButtonTooltip:"Exit spotlight"};var chat$k={chatListHeader:"In this chat",uploadFile:"Upload File"};var callWithChat$k={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"New Message",chatButtonTooltipClosedWithMessageCount:"Show chat ({unreadMessagesCount} unread)",chatButtonTooltipClose:"Hide chat",chatButtonTooltipOpen:"Show chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",dismissSidePaneButtonLabel:"Close",moreDrawerAudioDeviceMenuTitle:"Audio Device",moreDrawerButtonLabel:"More options",moreDrawerButtonTooltip:"More options",moreDrawerMicrophoneMenuTitle:"Microphone",moreDrawerSpeakerMenuTitle:"Speaker",moreDrawerCaptionsMenuTitle:"Live captions",moreDrawerSpokenLanguageMenuTitle:"Spoken language",moreDrawerCaptionLanguageMenuTitle:"Caption language",moreDrawerGalleryOptionsMenuTitle:"Gallery options",peopleButtonLabel:"People",selectedPeopleButtonLabel:"People Button Selected",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call",peoplePaneTitle:"People",pictureInPictureTileAriaLabel:"Video Feeds. Click to return to call screen.",removeMenuLabel:"Remove",openDialpadButtonLabel:"Dial phone number",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number"};var en_US = {call:call$k,chat:chat$k,callWithChat:callWithChat$k};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for English (US)
 *
 * @public
 */
const COMPOSITE_LOCALE_EN_US = {
    component: COMPONENT_LOCALE_EN_US,
    strings: en_US
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Context for providing localized strings to components
 *
 * @private
 */
const LocaleContext = React.createContext(COMPOSITE_LOCALE_EN_US);
/**
 * Provider to provide localized strings for this library's composites.
 *
 * @private
 */
const LocalizationProvider = (props) => {
    const { locale, children } = props;
    return React.createElement(LocaleContext.Provider, { value: locale },
        React.createElement(LocalizationProvider$1, { locale: locale.component }, children));
};
/**
 * @private
 */
const useLocale = () => React.useContext(LocaleContext);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const SpinnerIcon = () => React.createElement(react.Spinner, { size: react.SpinnerSize.large });
/**
 * The default set of icons used by the composites directly (i.e. not via the components defined in this library).
 *
 * @public
 */
const COMPOSITE_ONLY_ICONS = {
    ChevronLeft: undefined,
    Link: undefined,
    LobbyScreenConnectingToCall: React.createElement(SpinnerIcon, null),
    LobbyScreenWaitingToBeAdmitted: React.createElement(SpinnerIcon, null),
    LocalDeviceSettingsCamera: React.createElement(reactIcons.Video20Filled, null),
    LocalDeviceSettingsMic: React.createElement(reactIcons.Mic20Filled, null),
    LocalDeviceSettingsSpeaker: React.createElement(reactIcons.Speaker220Filled, null),
    LocalPreviewPlaceholder: React.createElement(reactIcons.VideoOff20Filled, null),
    LocalCameraSwitch: React.createElement(reactIcons.CameraSwitch24Regular, null),
    ControlBarChatButtonActive: React.createElement(reactIcons.Chat20Filled, null),
    ControlBarChatButtonInactive: React.createElement(reactIcons.Chat20Regular, null),
    /* @conditional-compile-remove(capabilities) */
    ControlButtonCameraProhibited: React.createElement(reactIcons.VideoProhibited20Filled, null),
    /* @conditional-compile-remove(capabilities) */
    ControlButtonMicProhibited: React.createElement(reactIcons.MicProhibited20Filled, null),
    ControlBarPeopleButton: React.createElement(reactIcons.People20Regular, null),
    MoreDrawerMicrophones: React.createElement(reactIcons.Mic20Regular, null),
    MoreDrawerPeople: React.createElement(reactIcons.People20Regular, null),
    MoreDrawerSpeakers: React.createElement(reactIcons.Speaker220Regular, null),
    MoreDrawerSelectedMicrophone: React.createElement(reactIcons.Mic20Filled, null),
    MoreDrawerSelectedSpeaker: React.createElement(reactIcons.Speaker220Filled, null),
    Muted: React.createElement(reactIcons.MicOff20Filled, null),
    NetworkReconnectIcon: React.createElement(reactIcons.CallMissed20Filled, null),
    NoticePageAccessDeniedTeamsMeeting: React.createElement(reactIcons.PersonDelete20Filled, null),
    NoticePageJoinCallFailedDueToNoNetwork: React.createElement(reactIcons.WifiWarning20Filled, null),
    NoticePageLeftCall: React.createElement(reactIcons.CallEnd20Filled, null),
    NoticePageRemovedFromCall: React.createElement(reactIcons.Info20Filled, null),
    /* @conditional-compile-remove(rooms) */
    NoticePageNotInvitedToRoom: React.createElement(reactIcons.Info20Filled, null),
    /* @conditional-compile-remove(rooms) */
    NoticePageRoomNotFound: React.createElement(reactIcons.Info20Filled, null),
    /* @conditional-compile-remove(rooms) */
    NoticePageRoomNotValid: React.createElement(reactIcons.Info20Filled, null),
    /* @conditional-compile-remove(calling-sounds) */
    NoticePageCallRejected: React.createElement(reactIcons.Info20Filled, null),
    NoticePageCallTimeout: React.createElement(reactIcons.Info20Filled, null),
    /* @conditional-compile-remove(rooms) */
    NoticePageInviteToRoomRemoved: React.createElement(reactIcons.Info20Filled, null),
    /* @conditional-compile-remove(video-background-effects) */
    BlurVideoBackground: React.createElement(reactIcons.VideoBackgroundEffect20Regular, null),
    /* @conditional-compile-remove(video-background-effects) */
    RemoveVideoBackgroundEffect: React.createElement(reactIcons.VideoPerson20Filled, null),
    GalleryOptions: React.createElement(reactIcons.Grid20Regular, null),
    OverflowGalleryTop: React.createElement(reactIcons.WindowHeaderHorizontal20Regular, null),
    SpeakerGalleryLayout: React.createElement(reactIcons.PersonSquare20Regular, null),
    DefaultGalleryLayout: React.createElement(reactIcons.TableSimple20Regular, null),
    FloatingLocalVideoGalleryLayout: React.createElement(reactIcons.BoardSplit20Regular, null),
    FocusedContentGalleryLayout: React.createElement(reactIcons.ContentView20Regular, null),
    LargeGalleryLayout: React.createElement(reactIcons.Table20Regular, null),
    /* @conditional-compile-remove(control-bar-button-injection) */
    DefaultCustomButton: React.createElement(reactIcons.Circle20Regular, null),
    DtmfDialpadButton: React.createElement(reactIcons.Dialpad20Regular, null)
};
/**
 * The default set of icons that are available to used in the Composites.
 *
 * @public
 */
const DEFAULT_COMPOSITE_ICONS = Object.assign(Object.assign({}, DEFAULT_COMPONENT_ICONS), COMPOSITE_ONLY_ICONS);
/**
 * Icon wrapper to use when including customizable icons inside the CallComposite.
 * This wrapper ensures the icon name is being type-checked helping ensure no typos
 * and ensure that icon is customizable through the composite API.
 *
 * @private
 */
const CallCompositeIcon = (props) => React.createElement(react.FontIcon, Object.assign({}, props));
/**
 * Icon wrapper to use when including customizable icons inside the CallWithChatComposite.
 * This wrapper ensures the icon name is being type-checked helping ensure no typos
 * and ensure that icon is customizable through the composite API.
 *
 * @private
 */
const CallWithChatCompositeIcon = (props) => React.createElement(react.FontIcon, Object.assign({}, props));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const globalLayerHostStyle = {
    position: 'fixed',
    zIndex: 1000000,
    inset: '0px',
    visibility: 'hidden'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A base provider {@link React.Context} to wrap components with other required providers
 * (e.g. icons, FluentThemeProvider, LocalizationProvider).
 *
 * Required providers are only wrapped once, with all other instances only passing children.
 *
 * @private
 */
const BaseProvider = (props) => {
    const { fluentTheme, rtl, locale } = props;
    const globalLayerHostId = reactHooks.useId('composite-global-hostId');
    /**
     * Pass only the children if we previously registered icons, and have previously wrapped the children in
     * FluentThemeProvider and LocalizationProvider
     */
    const alreadyWrapped = useBase();
    if (alreadyWrapped) {
        return React.createElement(React.Fragment, null, props.children);
    }
    /**
     * Before registering fluent icons, we should check DEFAULT_COMPOSITE_ICONS and strip out the key value pairs where value is undefined
     */
    const iconsToRegister = {};
    Object.entries(DEFAULT_COMPOSITE_ICONS).forEach(([key, value]) => {
        if (value) {
            iconsToRegister[key] = value;
        }
    });
    /**
     * We register the default icon mappings merged with custom icons provided through props
     * to ensure all icons render correctly.
     */
    react.registerIcons({
        icons: Object.assign(Object.assign({}, iconsToRegister), props.icons)
    });
    // we use Customizer to override default LayerHost injected to <body />
    // which stop polluting global dom tree and increase compatibility with react-full-screen
    const CompositeElement = React.createElement(FluentThemeProvider, { fluentTheme: fluentTheme, rtl: rtl },
        React.createElement("meta", { name: "viewport", content: "width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" }),
        React.createElement(react.Customizer, { scopedSettings: {
                Layer: {
                    hostId: globalLayerHostId
                }
            } },
            React.createElement(WithBackgroundColor, null, props.children)),
        React.createElement(react.LayerHost, { id: globalLayerHostId, className: react.mergeStyles(globalLayerHostStyle) }));
    const localizedElement = locale ? LocalizationProvider({
        locale,
        children: CompositeElement
    }) : CompositeElement;
    return React.createElement(BaseContext.Provider, { value: true }, localizedElement);
};
/**
 * @private
 */
const BaseContext = React.createContext(false);
/**
 * @private
 */
const useBase = () => React.useContext(BaseContext);
/**
 * @private
 * Provides a wrapper with a background color to ensure that composites always have a background color.
 * This is necessary to ensure that composites are not transparent,
 * and the background color of it's parent elements doesn't show through the composite.
 */
const WithBackgroundColor = (props) => {
    const { children } = props;
    const theme = react.useTheme();
    const className = react.mergeStyles({
        background: theme.semanticColors.bodyBackground,
        height: '100%',
        width: '100%',
        position: 'relative'
    });
    return React.createElement(react.Stack, { className: className }, children);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const ChatAdapterContext = React.createContext(undefined);
/**
 * @private
 */
const ChatAdapterProvider = (props) => {
    const { adapter } = props;
    return React.createElement(ChatAdapterContext.Provider, { value: adapter }, props.children);
};
/**
 * @private
 */
const useAdapter$1 = () => {
    const adapter = React.useContext(ChatAdapterContext);
    if (!adapter) {
        throw 'Cannot find adapter please initialize before usage.';
    }
    return adapter;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const UNSUPPORTED_CHAT_THREAD_TYPE = ['@thread.tacv2', '@thread.skype'];
/**
 * @private
 */
const TEAMS_LIMITATION_LEARN_MORE = 'https://learn.microsoft.com/en-us/azure/communication-services/concepts/join-teams-meeting#limitations-and-known-issues';
/**
 * @remarks
 * This value is publicly documented in the ChatComposite API documentation.
 * Changing this value will require updating the API documentation.
 */
const CHAT_CONTAINER_MIN_WIDTH_REM = 17.5;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const CHAT_CONTAINER_MAX_WIDTH_REM = 41.25;
const CHAT_CONTAINER_MIN_HEIGHT_REM = 13;
/**
 * @private
 * z-index to ensure that chat container has lower z-index than participant pane
 */
const CHAT_CONTAINER_ZINDEX = 1;
/**
 * @private
 */
const chatScreenContainerStyle = react.mergeStyles({
    height: '100%',
    width: '100%',
    minHeight: `${CHAT_CONTAINER_MIN_HEIGHT_REM}rem`,
    minWidth: `${CHAT_CONTAINER_MIN_WIDTH_REM}rem`
});
/**
 * @private
 */
const chatContainer = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'hidden',
    '*::-webkit-scrollbar': {
        width: '0.3rem',
        height: '0.3rem'
    },
    '.scroll::-webkit-scrollbar-track': {
        background: 'rgba(150, 150, 150)',
        borderRadius: '0.3rem'
    },
    '*::-webkit-scrollbar-thumb': {
        borderRadius: '10px',
        background: 'rgba(150, 150, 150)'
    }
});
/**
 * @private
 */
const chatArea = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'auto',
    position: 'relative' // Ensure that the absolute children components are positioned relative to the chat area
});
/**
 * @private
 */
const chatWrapper = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'hidden',
    zIndex: CHAT_CONTAINER_ZINDEX
});
/**
 * @private
 */
const chatHeaderContainerStyle = react.mergeStyles({
    width: '100%',
    paddingLeft: '1.5rem',
    paddingRight: '1.5rem',
    '@media screen and (max-width: 25rem)': {
        paddingLeft: '5%',
        paddingRight: '5%'
    },
    borderBottom: '0.063rem solid #DDDDDD'
});
/**
 * @private
 */
const topicNameLabelStyle = react.mergeStyles({
    fontSize: '1.1rem',
    lineHeight: '2.5rem',
    fontWeight: 600,
    marginRight: '0.125rem',
    textOverflow: 'ellipsis',
    overflowY: 'hidden'
});
/**
 * @private
 */
const messageThreadChatCompositeStyles = react.memoizeFunction((background) => ({
    root: {
        maxWidth: `${CHAT_CONTAINER_MAX_WIDTH_REM}rem`
    },
    chatContainer: {
        background: background
    }
}));
/**
 * @private
 */
const typingIndicatorContainerStyles = {
    padding: '0rem 0.25rem'
};
/**
 * @private
 */
const sendboxContainerStyles = {
    maxWidth: `${CHAT_CONTAINER_MAX_WIDTH_REM}rem`,
    width: '100%',
    alignSelf: 'center'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$i = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * An Avatar component made using the `Persona` component.
 * It allows you to specify a `userId` and a `dataProvider` to retrieve the `AvatarPersonaData`.
 * Read more about `Persona` component at https://developer.microsoft.com/fluentui#/controls/web/persona
 *
 * @private
 */
const AvatarPersona = (props) => {
    var _a, _b, _c, _d, _e, _f;
    const { userId, dataProvider, text, imageUrl, imageInitials, initialsColor, initialsTextColor, showOverflowTooltip } = props;
    const [data, setData] = React.useState();
    React.useEffect(() => {
        (() => __awaiter$i(void 0, void 0, void 0, function* () {
            if (dataProvider && userId) {
                const newData = yield dataProvider(userId);
                if (avatarDeepDifferenceCheck(data, newData)) {
                    setData(newData);
                }
            }
        }))();
    }, [data, dataProvider, userId]);
    /* @conditional-compile-remove(raise-hand) */
    let activePersona = '';
    /* @conditional-compile-remove(raise-hand) */
    if (props.allowActiveBorder) {
        // Display a border for raised handed participants in participant list
        activePersona = react.mergeStyles({
            border: 'solid 2px',
            borderColor: 'transparent',
            borderRadius: '50%',
            padding: '2px',
            boxSizing: 'content-box',
            margin: '-4px'
        });
        react.mergeStyles(activePersona, props.styles);
    }
    return React.createElement(react.Persona, Object.assign({}, props, { 
        /* @conditional-compile-remove(raise-hand) */ className: activePersona, text: (_a = data === null || data === void 0 ? void 0 : data.text) !== null && _a !== void 0 ? _a : text, imageUrl: (_b = data === null || data === void 0 ? void 0 : data.imageUrl) !== null && _b !== void 0 ? _b : imageUrl, imageInitials: (_c = data === null || data === void 0 ? void 0 : data.imageInitials) !== null && _c !== void 0 ? _c : imageInitials, initialsColor: (_d = data === null || data === void 0 ? void 0 : data.initialsColor) !== null && _d !== void 0 ? _d : initialsColor, initialsTextColor: (_f = (_e = data === null || data === void 0 ? void 0 : data.initialsTextColor) !== null && _e !== void 0 ? _e : initialsTextColor) !== null && _f !== void 0 ? _f : 'white', 
        // default disable tooltip unless specified
        showOverflowTooltip: showOverflowTooltip !== null && showOverflowTooltip !== void 0 ? showOverflowTooltip : false }));
};
const avatarDeepDifferenceCheck = (currentData, newData) => {
    return (currentData === null || currentData === void 0 ? void 0 : currentData.text) !== (newData === null || newData === void 0 ? void 0 : newData.text) || (currentData === null || currentData === void 0 ? void 0 : currentData.imageUrl) !== (newData === null || newData === void 0 ? void 0 : newData.imageUrl) || (currentData === null || currentData === void 0 ? void 0 : currentData.initialsColor) !== (newData === null || newData === void 0 ? void 0 : newData.initialsColor) || (currentData === null || currentData === void 0 ? void 0 : currentData.imageInitials) !== (newData === null || newData === void 0 ? void 0 : newData.imageInitials) || (currentData === null || currentData === void 0 ? void 0 : currentData.initialsTextColor) !== (newData === null || newData === void 0 ? void 0 : newData.initialsTextColor);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const ChatHeader = (props) => {
    return React.createElement(react.Stack, { className: chatHeaderContainerStyle, horizontal: true },
        React.createElement(react.Stack.Item, { align: "center" },
            React.createElement("div", { className: topicNameLabelStyle }, props.topic)));
};
const getTopicName = (state, props) => {
    var _a, _b;
    return ((_b = (_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.topic) || '';
};
/**
 * @private
 */
const getHeaderProps = reselect__namespace.createSelector([getTopicName], (topic) => {
    return {
        topic: topic
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A wrapper to return {@link FileUploadButton} component conditionally.
 * It will return `<></>` for stable builds.
 * @internal
 */
const FileUploadButtonWrapper = (props) => {
    return React.createElement(React.Fragment, null);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const useAdaptedSelector$1 = (selector, selectorProps) => {
    return useSelectorWithAdaptation$1(selector, adaptCompositeState$1, selectorProps);
};
/**
 * @private
 */
const useSelectorWithAdaptation$1 = (selector, adaptState, selectorProps) => {
    const adapter = useAdapter$1();
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const threadId = adapter.getState().thread.threadId;
    const threadConfigProps = React.useMemo(() => ({
        threadId
    }), [threadId]);
    const [props, setProps] = React.useState(selector(adaptState(adapter.getState()), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps));
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(adaptState(state), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        adapter.onStateChange(onStateChange);
        return () => {
            adapter.offStateChange(onStateChange);
        };
    }, [adaptState, adapter, selector, selectorProps, threadConfigProps]);
    return props;
};
const memoizeState$1 = memoizeOne((userId, displayName, threads, latestErrors) => ({
    userId,
    displayName,
    threads,
    latestErrors
}));
const memoizeThreads = memoizeOne((thread) => ({
    [thread.threadId]: thread
}));
const adaptCompositeState$1 = (compositeState) => {
    return memoizeState$1(compositeState.userId, compositeState.displayName, memoizeThreads(compositeState.thread), 
    // This is an unsafe type expansion.
    // compositeState.latestErrors can contain properties that are not valid in ChatErrors.
    //
    // But there is no way to check for valid property names at runtime:
    // - The set of valid property names is built from types in the @azure/communication-chat.
    //   Thus we don't have a literal array of allowed strings at runtime.
    // - Due to minification / uglification, the property names from the objects at runtime can't be used
    //   to compare against permissible values inferred from the types.
    //
    // This is not a huge problem -- it simply means that our adapted selector will include some extra operations
    // that are unknown to the UI component and data binding libraries. Generic handling of the errors (e.g.,
    // just displaying them in some UI surface) will continue to work for these operations. Handling of
    // specific operations (e.g., acting on errors related to permission issues) will ignore these operations.
    compositeState.latestErrors);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers$1 = (_component) => {
    return createCompositeHandlers$1(useAdapter$1());
};
const createCompositeHandlers$1 = memoizeOne((adapter) => ({
    onSendMessage: adapter.sendMessage,
    onLoadPreviousChatMessages: adapter.loadPreviousChatMessages,
    onMessageSeen: adapter.sendReadReceipt,
    onTyping: adapter.sendTypingIndicator,
    onRemoveParticipant: adapter.removeParticipant,
    updateThreadTopicName: adapter.setTopic,
    onUpdateMessage: (messageId, content, options) => {
        const metadata = options === null || options === void 0 ? void 0 : options.metadata;
        return adapter.updateMessage(messageId, content, metadata);
    },
    onDeleteMessage: adapter.deleteMessage
}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @private
 */
const usePropsFor$2 = (component) => {
    const selector = getSelector(component);
    if (!selector) {
        throw new Error("Can't find the selector for component, please check supported component list");
    }
    return Object.assign(Object.assign({}, useAdaptedSelector$1(selector)), useHandlers$1());
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const sidePaneContainerStyles = {
    root: {
        height: '100%',
        padding: '0.5rem 0.25rem',
        width: '21.5rem'
    }
};
/**
 * @private
 */
({
    root: Object.assign(Object.assign({}, sidePaneContainerStyles), { display: 'none' })
});
/**
 * @private
 */
const sidePaneHeaderStyles = {
    root: {
        lineHeight: '1.5rem',
        fontSize: '1.125rem',
        padding: '0.75rem 0.75rem 0.75rem 0.25rem',
        fontWeight: '600'
    }
};
/**
 * @private
 */
const sidePaneHeaderContainerStyles = {
    root: {
        margin: '0 0.25rem'
    }
};
/**
 * @private
 */
const paneBodyContainer = {
    root: {
        flexDirection: 'column',
        display: 'flex'
    }
};
/**
 * @private
 */
const scrollableContainer = {
    root: {
        flexBasis: '0',
        flexGrow: '1',
        overflowY: 'auto'
    }
};
/**
 * @private
 */
const scrollableContainerContents = {
    root: {
        flexGrow: '1',
        flexBasis: '0',
        maxWidth: '100%',
        // Create a new stacking context so that `pipStyles` can set zIndex above the container.
        position: 'relative'
    }
};
/**
 * @private
 */
const containerContextStyles = {
    root: {
        position: 'absolute',
        height: '100%',
        width: '100%'
    }
};
/**
 * @private
 */
const peoplePaneContainerTokens = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const participantListContainerPadding = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const participantListStack = react.mergeStyles({
    height: '100%'
});
/**
 * @private
 */
const participantListContainerStyle = react.mergeStyles({
    height: '100%',
    overflowY: 'auto',
    overflowX: 'hidden'
});
/**
 * @private
 */
const participantListStyle = {
    root: {
        padding: '0rem'
    },
    participantItemStyles: {
        root: {
            padding: '0.5rem'
        }
    }
};
/**
 * @private
 */
const participantListMobileStyle = {
    root: {
        padding: '0rem'
    },
    participantItemStyles: {
        root: {
            padding: '0.5rem 1rem'
        }
    }
};
/**
 * @private
 */
const displayNameStyles$1 = {
    root: {
        padding: '0.5rem',
        textOverflow: 'ellipsis',
        overflow: 'hidden'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const SendBox = (props) => {
    const { options, styles } = props;
    const sendBoxProps = usePropsFor$2(SendBox$1);
    const sendBoxStyles = React.useMemo(() => {
        return Object.assign({}, styles);
    }, [styles]);
    const simpleSendBox = React.useMemo(() => React.createElement(SendBox$1, Object.assign({}, sendBoxProps, { autoFocus: options === null || options === void 0 ? void 0 : options.autoFocus, styles: sendBoxStyles })), [sendBoxProps, options, sendBoxStyles]);
    return simpleSendBox;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$h = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const ChatScreen = (props) => {
    const { onFetchAvatarPersonaData, onRenderMessage, onRenderTypingIndicator, options, styles, fileSharing, formFactor } = props;
    const defaultNumberOfChatMessagesToReload = 5;
    /* @conditional-compile-remove(image-overlay) */
    const [overlayImageItem, setOverlayImageItem] = React.useState();
    /* @conditional-compile-remove(image-overlay) */
    const [isImageOverlayOpen, setIsImageOverlayOpen] = React.useState(false);
    const adapter = useAdapter$1();
    const theme = useTheme();
    React.useEffect(() => {
        // Initial data should be always fetched by the composite(or external caller) instead of the adapter
        const fetchData = () => __awaiter$h(void 0, void 0, void 0, function* () {
            // Fetch initial data for adapter
            yield adapter.fetchInitialData();
            // Fetch initial set of messages. Without fetching messages here, if the Composite's adapter is changed the message thread does not load new messages.
            yield adapter.loadPreviousChatMessages(defaultNumberOfChatMessagesToReload);
        });
        fetchData();
    }, [adapter]);
    const messageThreadProps = usePropsFor$2(MessageThread);
    const typingIndicatorProps = usePropsFor$2(TypingIndicator);
    const headerProps = useAdaptedSelector$1(getHeaderProps);
    const errorBarProps = usePropsFor$2(ErrorBar);
    /* @conditional-compile-remove(image-overlay) */
    React.useEffect(() => {
        if (overlayImageItem === undefined) {
            return;
        }
        const message = adapter.getState().thread.chatMessages[overlayImageItem.messageId];
        if (message === undefined) {
            return;
        }
        const resourceCache = message.resourceCache;
        if (overlayImageItem.imageSrc === '' && resourceCache && resourceCache[overlayImageItem.imageUrl]) {
            const fullSizeImageSrc = getResourceSourceUrl(resourceCache[overlayImageItem.imageUrl]);
            if (fullSizeImageSrc === undefined || fullSizeImageSrc === '' || overlayImageItem.imageSrc === fullSizeImageSrc) {
                return;
            }
            setOverlayImageItem(Object.assign(Object.assign({}, overlayImageItem), { imageSrc: fullSizeImageSrc }));
        }
        // Disable eslint because we are using the overlayImageItem in this effect but don't want to have it as a dependency, as it will cause an infinite loop.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [messageThreadProps.messages]);
    const getResourceSourceUrl = (result) => {
        let src = '';
        if (result.error || !result.sourceUrl) {
            src = 'blob://';
        }
        else {
            src = result.sourceUrl;
        }
        return src;
    };
    const onRenderAvatarCallback = React.useCallback((userId, defaultOptions) => {
        return React.createElement(AvatarPersona, Object.assign({ userId: userId, hidePersonaDetails: true }, defaultOptions, { dataProvider: onFetchAvatarPersonaData }));
    }, [onFetchAvatarPersonaData]);
    const messageThreadStyles = React.useMemo(() => {
        return Object.assign({}, messageThreadChatCompositeStyles(theme.semanticColors.bodyBackground), styles === null || styles === void 0 ? void 0 : styles.messageThread);
    }, [styles === null || styles === void 0 ? void 0 : styles.messageThread, theme.semanticColors.bodyBackground]);
    const typingIndicatorStyles = React.useMemo(() => {
        return Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.typingIndicator);
    }, [styles === null || styles === void 0 ? void 0 : styles.typingIndicator]);
    const userId = toFlatCommunicationIdentifier(adapter.getState().userId);
    const fileUploadButtonOnChange = React.useCallback((files) => {
        if (!files) {
            return;
        }
    }, [adapter, fileSharing, userId]);
    /* @conditional-compile-remove(image-overlay) */
    const onInlineImageClicked = React.useCallback((attachmentId, messageId) => {
        var _a, _b;
        const message = adapter.getState().thread.chatMessages[messageId];
        const inlinedImages = (_b = (_a = message.content) === null || _a === void 0 ? void 0 : _a.attachments) === null || _b === void 0 ? void 0 : _b.filter(attachment => {
            return attachment.attachmentType === 'image' && attachment.id === attachmentId;
        });
        if (!inlinedImages || inlinedImages.length <= 0) {
            return;
        }
        const attachment = inlinedImages[0];
        const resourceCache = message.resourceCache;
        let imageSrc = '';
        if (attachment.url) {
            if (resourceCache && resourceCache[attachment.url]) {
                imageSrc = getResourceSourceUrl(resourceCache[attachment.url]);
            }
            else {
                adapter.downloadResourceToCache({
                    threadId: adapter.getState().thread.threadId,
                    messageId: messageId,
                    resourceUrl: attachment.url
                });
            }
        }
        const titleIconRenderOptions = {
            text: message.senderDisplayName,
            size: react.PersonaSize.size32,
            showOverflowTooltip: false,
            imageAlt: message.senderDisplayName
        };
        const messageSenderId = message.sender !== undefined ? toFlatCommunicationIdentifier(message.sender) : userId;
        const titleIcon = onRenderAvatarCallback && onRenderAvatarCallback(messageSenderId, titleIconRenderOptions);
        const overlayImage = {
            title: message.senderDisplayName || '',
            titleIcon: titleIcon,
            attachmentId: attachment.id,
            imageSrc: imageSrc,
            messageId: messageId,
            imageUrl: attachment.url || ''
        };
        setIsImageOverlayOpen(true);
        setOverlayImageItem(overlayImage);
    }, [adapter, onRenderAvatarCallback, userId]);
    /* @conditional-compile-remove(image-overlay) */
    const inlineImageOptions = {
        onRenderInlineImage: (inlineImage, defaultOnRender) => {
            var _a, _b;
            const message = adapter.getState().thread.chatMessages[inlineImage.messageId];
            const attachment = (_b = (_a = message === null || message === void 0 ? void 0 : message.content) === null || _a === void 0 ? void 0 : _a.attachments) === null || _b === void 0 ? void 0 : _b.find(attachment => attachment.id === inlineImage.imageAttributes.id);
            if (attachment === undefined) {
                return defaultOnRender(inlineImage);
            }
            let pointerEvents = inlineImage.imageAttributes.src === '' ? 'none' : 'auto';
            const resourceCache = message.resourceCache;
            if (resourceCache && attachment.previewUrl && resourceCache[attachment.previewUrl] && resourceCache[attachment.previewUrl].error) {
                pointerEvents = 'none';
            }
            return React.createElement("span", { key: inlineImage.imageAttributes.id, onClick: () => onInlineImageClicked(inlineImage.imageAttributes.id || '', inlineImage.messageId), tabIndex: 0, role: "button", onKeyDown: e => {
                    if (e.key === 'Enter') {
                        onInlineImageClicked(inlineImage.imageAttributes.id || '', inlineImage.messageId);
                    }
                }, style: {
                    cursor: 'pointer',
                    pointerEvents
                } }, defaultOnRender(inlineImage));
        }
    };
    /* @conditional-compile-remove(image-overlay) */
    const onDownloadButtonClicked = React.useCallback((imageSrc) => {
        if (imageSrc === '') {
            return;
        }
        if (react.isIOS()) {
            window.open(imageSrc, '_blank');
        }
        else {
            // Create a new anchor element
            const a = document.createElement('a');
            // Set the href and download attributes for the anchor element
            a.href = imageSrc;
            a.download = (overlayImageItem === null || overlayImageItem === void 0 ? void 0 : overlayImageItem.attachmentId) || '';
            a.rel = 'noopener noreferrer';
            a.target = '_blank';
            // Programmatically click the anchor element to trigger the download
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    }, [overlayImageItem === null || overlayImageItem === void 0 ? void 0 : overlayImageItem.attachmentId]);
    const AttachFileButton = React.useCallback(() => {
        if (!(fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.uploadHandler)) {
            return null;
        }
        return React.createElement(FileUploadButtonWrapper, { accept: fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.accept, multiple: fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.multiple, onChange: fileUploadButtonOnChange });
    }, [fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.accept, fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.multiple, fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.uploadHandler, fileUploadButtonOnChange]);
    return React.createElement(react.Stack, { className: chatContainer, grow: true },
        (options === null || options === void 0 ? void 0 : options.topic) !== false && React.createElement(ChatHeader, Object.assign({}, headerProps)),
        React.createElement(react.Stack, { className: chatArea, tokens: participantListContainerPadding, horizontal: true, grow: true },
            React.createElement(react.Stack, { className: chatWrapper, grow: true },
                (options === null || options === void 0 ? void 0 : options.errorBar) !== false && React.createElement(ErrorBar, Object.assign({}, errorBarProps)),
                React.createElement(MessageThread, Object.assign({}, messageThreadProps, { onRenderAvatar: onRenderAvatarCallback, onRenderMessage: onRenderMessage, inlineImageOptions: inlineImageOptions, numberOfChatMessagesToReload: defaultNumberOfChatMessagesToReload, styles: messageThreadStyles })),
                React.createElement(react.Stack, { className: react.mergeStyles(sendboxContainerStyles) },
                    React.createElement("div", { className: react.mergeStyles(typingIndicatorContainerStyles) }, onRenderTypingIndicator ? onRenderTypingIndicator(typingIndicatorProps.typingUsers) : React.createElement(TypingIndicator, Object.assign({}, typingIndicatorProps, { styles: typingIndicatorStyles }))),
                    React.createElement(react.Stack, { horizontal: formFactor === 'mobile' },
                        formFactor === 'mobile' && React.createElement(react.Stack, { verticalAlign: "center" },
                            React.createElement(AttachFileButton, null)),
                        React.createElement(react.Stack, { grow: true },
                            React.createElement(SendBox, { options: options, styles: styles === null || styles === void 0 ? void 0 : styles.sendBox })),
                        formFactor !== 'mobile' && React.createElement(AttachFileButton, null))))), /* @conditional-compile-remove(image-overlay) */
        overlayImageItem && React.createElement(ImageOverlay, Object.assign({}, overlayImageItem, { isOpen: isImageOverlayOpen, onDismiss: () => {
                setOverlayImageItem(undefined);
                setIsImageOverlayOpen(false);
                adapter.removeResourceFromCache({
                    threadId: adapter.getState().thread.threadId,
                    messageId: overlayImageItem.messageId,
                    resourceUrl: overlayImageItem.imageUrl
                });
            }, onDownloadButtonClicked: onDownloadButtonClicked })));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A customizable UI composite for the chat experience.
 *
 * @remarks Chat composite min width and height are respectively 17.5rem and 20rem (280px and 320px, with default rem at 16px)
 *
 * @public
 */
const ChatComposite = (props) => {
    const { adapter, options, onFetchAvatarPersonaData, onRenderTypingIndicator, onRenderMessage, onFetchParticipantMenuItems } = props;
    return React.createElement("div", { className: chatScreenContainerStyle },
        React.createElement(BaseProvider, Object.assign({}, props),
            React.createElement(ChatAdapterProvider, { adapter: adapter },
                React.createElement(ChatScreen, { options: options, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onRenderTypingIndicator: onRenderTypingIndicator, onRenderMessage: onRenderMessage, onFetchParticipantMenuItems: onFetchParticipantMenuItems }))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const CallAdapterContext = React.createContext(undefined);
/**
 * @private
 */
const CallAdapterProvider = (props) => {
    const { adapter } = props;
    return React.createElement(CallAdapterContext.Provider, { value: adapter }, props.children);
};
/**
 * @private
 */
const useAdapter = () => {
    const adapter = React.useContext(CallAdapterContext);
    if (!adapter) {
        throw 'Cannot find adapter please initialize before usage.';
    }
    return adapter;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @private
 */
const useAdaptedSelector = (selector, selectorProps) => {
    return useSelectorWithAdaptation(selector, adaptCompositeState, selectorProps);
};
/**
 * @private
 */
const useSelectorWithAdaptation = (selector, adaptState, selectorProps) => {
    var _a;
    const adapter = useAdapter();
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const callId = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.id;
    const callConfigProps = React.useMemo(() => ({
        callId
    }), [callId]);
    const [props, setProps] = React.useState(selector(adaptState(adapter.getState()), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callConfigProps));
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(adaptState(state), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        adapter.onStateChange(onStateChange);
        return () => {
            adapter.offStateChange(onStateChange);
        };
    }, [adaptState, adapter, selector, selectorProps, callConfigProps]);
    return props;
};
const memoizeState = memoizeOne((userId, deviceManager, calls, latestErrors, displayName, alternateCallerId, environmentInfo) => ({
    userId,
    incomingCalls: {},
    incomingCallsEnded: {},
    callsEnded: {},
    deviceManager,
    callAgent: {
        displayName
    },
    calls,
    latestErrors
}));
const memoizeCalls = memoizeOne((call) => call ? {
    [call.id]: call
} : {});
const adaptCompositeState = (compositeState) => {
    return memoizeState(compositeState.userId, compositeState.devices, memoizeCalls(compositeState.call), 
    // This is an unsafe type expansion.
    // compositeState.latestErrors can contain properties that are not valid in CallErrors.
    //
    // But there is no way to check for valid property names at runtime:
    // - The set of valid property names is built from types in the @azure/communication-calling.
    //   Thus we don't have a literal array of allowed strings at runtime.
    // - Due to minification / uglification, the property names from the objects at runtime can't be used
    //   to compare against permissible values inferred from the types.
    //
    // This is not a huge problem -- it simply means that our adapted selector will include some extra operations
    // that are unknown to the UI component and data binding libraries. Generic handling of the errors (e.g.,
    // just displaying them in some UI surface) will continue to work for these operations. Handling of
    // specific operations (e.g., acting on errors related to permission issues) will ignore these operations.
    compositeState.latestErrors, compositeState.displayName);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Take the set of active errors, and filter to only those that are newer than previously dismissed errors or have never been dismissed.
 *
 * @private
 */
const filterLatestErrors = (activeErrors, trackedErrors) => {
    const filteredErrors = activeErrors.filter(activeError => {
        const trackedError = trackedErrors[activeError.type];
        return !trackedError || !trackedError.lastDismissedAt || trackedError.lastDismissedAt < trackedError.mostRecentlyActive;
    });
    return filteredErrors;
};
/**
 * Maintain a record of the most recently active error for each error type.
 *
 * @private
 */
const updateTrackedErrorsWithActiveErrors = (existingTrackedErrors, activeErrors) => {
    var _a, _b;
    const trackedErrors = {};
    // Only care about active errors. If errors are no longer active we do not track that they have been previously dismissed.
    for (const activeError of activeErrors) {
        const existingTrackedError = existingTrackedErrors[activeError.type];
        trackedErrors[activeError.type] = {
            mostRecentlyActive: (_b = (_a = activeError.timestamp) !== null && _a !== void 0 ? _a : existingTrackedError === null || existingTrackedError === void 0 ? void 0 : existingTrackedError.mostRecentlyActive) !== null && _b !== void 0 ? _b : new Date(Date.now()),
            lastDismissedAt: existingTrackedError === null || existingTrackedError === void 0 ? void 0 : existingTrackedError.lastDismissedAt
        };
    }
    return trackedErrors;
};
/**
 * Create a record for when the error was most recently dismissed for tracking dismissed errors.
 *
 * @private
 */
const trackErrorAsDismissed = (errorType, trackedErrors) => {
    const now = new Date(Date.now());
    const existingError = trackedErrors[errorType];
    return Object.assign(Object.assign({}, trackedErrors), { [errorType]: Object.assign(Object.assign({}, (existingError || {})), { lastDismissedAt: now }) });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Subset of CallCompositePages that represent an end call state.
 * @private
 */
const END_CALL_PAGES = ['accessDeniedTeamsMeeting', 'joinCallFailedDueToNoNetwork', 'leftCall', 'removedFromCall'];

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const ACCESS_DENIED_TEAMS_MEETING_SUB_CODE = 5854;
const REMOTE_PSTN_USER_HUNG_UP = 560000;
const REMOVED_FROM_CALL_SUB_CODES = [5000, 5300, REMOTE_PSTN_USER_HUNG_UP];
/* @conditional-compile-remove(calling-sounds) */
const CALL_REJECTED_CODE$1 = 603;
/* @conditional-compile-remove(rooms) */
/** @private */
const ROOM_NOT_FOUND_SUB_CODE = 5732;
/* @conditional-compile-remove(rooms) */
/** @private */
const ROOM_NOT_VALID_SUB_CODE = 5829;
/* @conditional-compile-remove(rooms) */
/** @private */
const NOT_INVITED_TO_ROOM_SUB_CODE = 5828;
/* @conditional-compile-remove(rooms) */
/** @private */
const INVITE_TO_ROOM_REMOVED_SUB_CODE = 5317;
/** @private */
const CALL_TIMEOUT_SUB_CODE = 10004;
/** @private */
const CALL_TIMEOUT_CODE = 487;
/** @private */
const BOT_TIMEOUT_CODE = 486;
/** @private */
const BOT_TIMEOUT_SUB_CODE = 10321;
/**
 * @private
 */
const isCameraOn = (state) => {
    if (state.call) {
        const stream = state.call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
        return !!stream;
    }
    else {
        if (state.devices.selectedCamera) {
            const previewOn = _isPreviewOn(state.devices);
            return previewOn;
        }
    }
    return false;
};
/**
 * Reduce the set of call controls visible on mobile.
 * For example do not show screenshare button.
 *
 * @private
 */
const reduceCallControlsForMobile = (callControlOptions) => {
    if (callControlOptions === false) {
        return false;
    }
    // Ensure call controls a valid object.
    const reduceCallControlOptions = callControlOptions === true ? {} : callControlOptions || {};
    // Set to compressed mode when composite is optimized for mobile
    reduceCallControlOptions.displayType = 'compact';
    // Do not show screen share button when composite is optimized for mobile unless the developer
    // has explicitly opted in.
    if (reduceCallControlOptions.screenShareButton !== true) {
        reduceCallControlOptions.screenShareButton = false;
    }
    return reduceCallControlOptions;
};
var CallEndReasons;
(function (CallEndReasons) {
    CallEndReasons[CallEndReasons["LEFT_CALL"] = 0] = "LEFT_CALL";
    CallEndReasons[CallEndReasons["ACCESS_DENIED"] = 1] = "ACCESS_DENIED";
    CallEndReasons[CallEndReasons["REMOVED_FROM_CALL"] = 2] = "REMOVED_FROM_CALL";
})(CallEndReasons || (CallEndReasons = {}));
const getCallEndReason = (call) => {
    var _a, _b, _c;
    const remoteParticipantsEndedArray = Array.from(Object.values(call.remoteParticipantsEnded));
    /**
     * Handle the special case in a PSTN call where removing the last user kicks the caller out of the call.
     * The code and subcode is the same as when a user is removed from a teams interop call.
     * Hence, we look at the last remote participant removed to determine if the last participant removed was a phone number.
     * If yes, the caller was kicked out of the call, but we need to show them that they left the call.
     * Note: This check will only work for 1:1 PSTN Calls. The subcode is different for 1:N PSTN calls, and we do not need to handle that case.
     */
    if (remoteParticipantsEndedArray.length === 1 && communicationCommon.isPhoneNumberIdentifier(remoteParticipantsEndedArray[0].identifier) && ((_a = call.callEndReason) === null || _a === void 0 ? void 0 : _a.subCode) !== REMOTE_PSTN_USER_HUNG_UP) {
        return CallEndReasons.LEFT_CALL;
    }
    if (((_b = call.callEndReason) === null || _b === void 0 ? void 0 : _b.subCode) && call.callEndReason.subCode === ACCESS_DENIED_TEAMS_MEETING_SUB_CODE) {
        return CallEndReasons.ACCESS_DENIED;
    }
    if (((_c = call.callEndReason) === null || _c === void 0 ? void 0 : _c.subCode) && REMOVED_FROM_CALL_SUB_CODES.includes(call.callEndReason.subCode)) {
        return CallEndReasons.REMOVED_FROM_CALL;
    }
    if (call.callEndReason) {
        // No error codes match, assume the user simply left the call regularly
        return CallEndReasons.LEFT_CALL;
    }
    throw new Error('No matching call end reason');
};
/**
 * Helper function for determine strings and icons for end call page
 * @private
 */
const getEndedCallPageProps = (locale, endedCall) => {
    var _a, _b, _c, _d;
    let title = locale.strings.call.leftCallTitle;
    let moreDetails = locale.strings.call.leftCallMoreDetails;
    let disableStartCallButton = false;
    let iconName = 'NoticePageLeftCall';
    /* @conditional-compile-remove(rooms) */
    switch ((_a = endedCall === null || endedCall === void 0 ? void 0 : endedCall.callEndReason) === null || _a === void 0 ? void 0 : _a.subCode) {
        case ROOM_NOT_FOUND_SUB_CODE:
            if (locale.strings.call.roomNotFoundTitle) {
                title = locale.strings.call.roomNotFoundTitle;
                moreDetails = locale.strings.call.roomNotFoundDetails;
                disableStartCallButton = true;
                iconName = 'NoticePageRoomNotFound';
            }
            break;
        case ROOM_NOT_VALID_SUB_CODE:
            if (locale.strings.call.roomNotValidTitle) {
                title = locale.strings.call.roomNotValidTitle;
                moreDetails = locale.strings.call.roomNotValidDetails;
                disableStartCallButton = true;
                iconName = 'NoticePageRoomNotValid';
            }
            break;
        case NOT_INVITED_TO_ROOM_SUB_CODE:
            if (locale.strings.call.notInvitedToRoomTitle) {
                title = locale.strings.call.notInvitedToRoomTitle;
                moreDetails = locale.strings.call.notInvitedToRoomDetails;
                disableStartCallButton = true;
                iconName = 'NoticePageNotInvitedToRoom';
            }
            break;
        case INVITE_TO_ROOM_REMOVED_SUB_CODE:
            if (locale.strings.call.inviteToRoomRemovedTitle) {
                title = locale.strings.call.inviteToRoomRemovedTitle;
                moreDetails = locale.strings.call.inviteToRoomRemovedDetails;
                disableStartCallButton = true;
                iconName = 'NoticePageInviteToRoomRemoved';
            }
            break;
        case CALL_TIMEOUT_SUB_CODE:
            if (((_b = endedCall === null || endedCall === void 0 ? void 0 : endedCall.callEndReason) === null || _b === void 0 ? void 0 : _b.code) === CALL_TIMEOUT_CODE && locale.strings.call.callTimeoutTitle) {
                title = locale.strings.call.callTimeoutTitle;
                moreDetails = locale.strings.call.callTimeoutDetails;
                disableStartCallButton = true;
                iconName = 'NoticePageCallTimeout';
            }
            break;
        case BOT_TIMEOUT_SUB_CODE:
            if (((_c = endedCall === null || endedCall === void 0 ? void 0 : endedCall.callEndReason) === null || _c === void 0 ? void 0 : _c.code) === BOT_TIMEOUT_CODE && locale.strings.call.callTimeoutBotTitle) {
                title = locale.strings.call.callTimeoutBotTitle;
                moreDetails = locale.strings.call.callTimeoutBotDetails;
                disableStartCallButton = true;
                iconName = 'NoticePageCallTimeout';
            }
            break;
    }
    /* @conditional-compile-remove(calling-sounds) */
    switch ((_d = endedCall === null || endedCall === void 0 ? void 0 : endedCall.callEndReason) === null || _d === void 0 ? void 0 : _d.code) {
        case CALL_REJECTED_CODE$1:
            if (locale.strings.call.callRejectedTitle) {
                title = locale.strings.call.callRejectedTitle;
                moreDetails = locale.strings.call.callRejectedMoreDetails;
                disableStartCallButton = true;
                iconName = 'NoticePageCallRejected';
            }
            break;
    }
    return {
        title,
        moreDetails,
        disableStartCallButton,
        iconName
    };
};
/**
 * Get the current call composite page based on the current call composite state
 *
 * @param Call - The current call state
 * @param previousCall - The state of the most recent previous call that has ended.
 *
 * @remarks - The previousCall state is needed to determine if the call has ended.
 * When the call ends a new call object is created, and so we must lookback at the
 * previous call state to understand how the call has ended. If there is no previous
 * call we know that this is a fresh call and can display the configuration page.
 *
 * @private
 */
const getCallCompositePage = (call, previousCall, transferCall, unsupportedBrowserInfo) => {
    /* @conditional-compile-remove(call-transfer) */
    if (transferCall !== undefined) {
        return 'transferring';
    }
    if (call) {
        // Must check for ongoing call *before* looking at any previous calls.
        // If the composite completes one call and joins another, the previous calls
        // will be populated, but not relevant for determining the page.
        // `_isInLobbyOrConnecting` needs to be checked first because `_isInCall` also returns true when call is in lobby.
        if (_isInLobbyOrConnecting(call === null || call === void 0 ? void 0 : call.state)) {
            return 'lobby';
            // `LocalHold` needs to be checked before `isInCall` since it is also a state that's considered in call.
        }
        else if ((call === null || call === void 0 ? void 0 : call.state) === 'LocalHold') {
            return 'call';
        }
        else if ((call === null || call === void 0 ? void 0 : call.state) === 'Disconnecting') {
            return 'leaving';
        }
        else if (_isInCall(call === null || call === void 0 ? void 0 : call.state)) {
            return 'call';
        }
        else {
            // When the call object has been constructed after clicking , but before 'connecting' has been
            // set on the call object, we continue to show the configuration screen.
            // The call object does not correctly reflect local device state until `call.state` moves to `connecting`.
            // Moving to the 'lobby' page too soon leads to components that depend on the `call` object to show incorrect
            // transitional state.
            return 'configuration';
        }
    }
    if (previousCall) {
        const reason = getCallEndReason(previousCall);
        switch (reason) {
            case CallEndReasons.ACCESS_DENIED:
                return 'accessDeniedTeamsMeeting';
            case CallEndReasons.REMOVED_FROM_CALL:
                return 'removedFromCall';
            case CallEndReasons.LEFT_CALL:
                if (previousCall.diagnostics.network.latest.noNetwork) {
                    return 'joinCallFailedDueToNoNetwork';
                }
                return 'leftCall';
        }
    }
    // No call state - show starting page (configuration)
    return 'configuration';
};
/** @private */
const IsCallEndedPage = (page) => END_CALL_PAGES.includes(page);
/**
 * Creates a new call control options object and sets the correct values for disabling
 * the buttons provided in the `disabledControls` array.
 * Returns a new object without changing the original object.
 * @param callControlOptions options for the call control component that need to be modified.
 * @param disabledControls An array of controls to disable.
 * @returns a copy of callControlOptions with disabledControls disabled
 * @private
 */
const disableCallControls = (callControlOptions, disabledControls) => {
    var _a;
    if (callControlOptions === false) {
        return false;
    }
    // Ensure we clone the prop if it is an object to ensure we do not mutate the original prop.
    let newOptions = (_a = (callControlOptions instanceof Object ? Object.assign({}, callControlOptions) : callControlOptions)) !== null && _a !== void 0 ? _a : {};
    if (newOptions === true || newOptions === undefined) {
        newOptions = disabledControls.reduce((acc, key) => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            // @ts-expect-error TODO: fix noImplicitAny error here
            // Not solveable at this time due to typescript limitations. The typing is too complex for typescript to
            // understand. Will need to revisit when either typescript or the calling component bindings are updated.
            acc[key] = {
                disabled: true
            };
            return acc;
        }, {});
    }
    else {
        disabledControls.forEach(key => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            // @ts-expect-error refer to above comment
            if (newOptions[key] !== false) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                // @ts-expect-error refer to above comment
                newOptions[key] = {
                    disabled: true
                };
            }
        });
    }
    return newOptions;
};
/**
 * Check if a disabled object is provided for a button and returns if the button is disabled.
 * A button is only disabled if is explicitly set to disabled.
 *
 * @param option
 * @returns whether a button is disabled
 * @private
 */
const isDisabled$3 = (option) => {
    if (option === undefined || typeof option === 'boolean') {
        return false;
    }
    return option.disabled;
};
/**
 * @private
 * This is the util function to create a participant modifier for remote participantList
 * It memoize previous original participant items and only update the changed participant
 * It takes in one modifier function to generate one single participant object, it returns undefined if the object keeps unmodified
 */
const createParticipantModifier = (createModifiedParticipant) => {
    let previousParticipantState = undefined;
    let modifiedParticipants = {};
    const memoizedParticipants = {};
    return (state) => {
        var _a, _b, _c, _d;
        // if root state is the same, we don't need to update the participants
        if (((_a = state.call) === null || _a === void 0 ? void 0 : _a.remoteParticipants) !== previousParticipantState) {
            modifiedParticipants = {};
            const originalParticipants = (_b = state.call) === null || _b === void 0 ? void 0 : _b.remoteParticipants;
            for (const key in originalParticipants) {
                const modifiedParticipant = createModifiedParticipant(key, originalParticipants[key]);
                if (modifiedParticipant === undefined) {
                    modifiedParticipants[key] = originalParticipants[key];
                    continue;
                }
                // Generate the new item if original cached item has been changed
                if (((_c = memoizedParticipants[key]) === null || _c === void 0 ? void 0 : _c.originalRef) !== originalParticipants[key]) {
                    memoizedParticipants[key] = {
                        newParticipant: modifiedParticipant,
                        originalRef: originalParticipants[key]
                    };
                }
                // the modified participant is always coming from the memoized cache, whether is was refreshed
                // from the previous closure or not
                modifiedParticipants[key] = memoizedParticipants[key].newParticipant;
            }
            previousParticipantState = (_d = state.call) === null || _d === void 0 ? void 0 : _d.remoteParticipants;
        }
        return Object.assign(Object.assign({}, state), { call: state.call ? Object.assign(Object.assign({}, state.call), { remoteParticipants: modifiedParticipants }) : undefined });
    };
};
/* @conditional-compile-remove(video-background-effects) */
/** @private */
const getBackgroundEffectFromSelectedEffect = (selectedEffect, VideoBackgroundEffectsDependency) => (selectedEffect === null || selectedEffect === void 0 ? void 0 : selectedEffect.effectName) === 'blur' ? VideoBackgroundEffectsDependency.createBackgroundBlurEffect() : (selectedEffect === null || selectedEffect === void 0 ? void 0 : selectedEffect.effectName) === 'replacement' ? VideoBackgroundEffectsDependency.createBackgroundReplacementEffect({
    backgroundImageUrl: selectedEffect.backgroundImageUrl
}) : undefined;
/**
 * @remarks this logic should mimic the onToggleCamera in the common call handlers.
 * @private
 */
const getSelectedCameraFromAdapterState = (state) => state.devices.selectedCamera || state.devices.cameras[0];
/**
 * Helper to determine if the adapter has a locator or targetCallees
 * @param locatorOrTargetCallees
 * @returns boolean to determine if the adapter has a locator or targetCallees, true is locator, false is targetCallees
 * @private
 */
const getLocatorOrTargetCallees = (locatorOrTargetCallees) => {
    return !!Array.isArray(locatorOrTargetCallees);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$g = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers = (_component) => {
    const adapter = useAdapter();
    const compositeHandlers = createCompositeHandlers(adapter);
    return compositeHandlers;
};
const createCompositeHandlers = memoizeOne((adapter) => {
    return {
        onCreateLocalStreamView: (options) => __awaiter$g(void 0, void 0, void 0, function* () {
            return yield adapter.createStreamView(undefined, options);
        }),
        onCreateRemoteStreamView: (userId, options) => __awaiter$g(void 0, void 0, void 0, function* () {
            return yield adapter.createStreamView(userId, options);
        }),
        onHangUp: (forEveryone) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.leaveCall(forEveryone);
        }),
        onSendDtmfTone: (dtmfTone) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.sendDtmfTone(dtmfTone);
        }),
        onRemoveParticipant: (userId) => __awaiter$g(void 0, void 0, void 0, function* () {
            if (typeof userId === 'string') {
                yield adapter.removeParticipant(userId);
            }
        }),
        /* @conditional-compile-remove(raise-hand) */
        onRaiseHand: () => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.raiseHand();
        }),
        /* @conditional-compile-remove(raise-hand) */
        onLowerHand: () => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.lowerHand();
        }),
        /* @conditional-compile-remove(raise-hand) */
        onToggleRaiseHand: () => __awaiter$g(void 0, void 0, void 0, function* () {
            var _a;
            ((_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.raiseHand.localParticipantRaisedHand) ? yield adapter.lowerHand() : yield adapter.raiseHand();
        }),
        onSelectCamera: (deviceInfo, options) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.setCamera(deviceInfo, options);
        }),
        onSelectMicrophone: (deviceInfo) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.setMicrophone(deviceInfo);
        }),
        onSelectSpeaker: (deviceInfo) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.setSpeaker(deviceInfo);
        }),
        onStartCall: (participants, options) => {
            const rawIds = participants.map(participant => toFlatCommunicationIdentifier(participant));
            return adapter.startCall(rawIds, options);
        },
        onStartScreenShare: () => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.startScreenShare();
        }),
        onStopScreenShare: () => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.stopScreenShare();
        }),
        onToggleCamera: (options) => __awaiter$g(void 0, void 0, void 0, function* () {
            isCameraOn(adapter.getState()) ? yield adapter.stopCamera() : yield adapter.startCamera(options);
        }),
        onToggleMicrophone: () => __awaiter$g(void 0, void 0, void 0, function* () {
            var _b;
            return ((_b = adapter.getState().call) === null || _b === void 0 ? void 0 : _b.isMuted) ? yield adapter.unmute() : yield adapter.mute();
        }),
        onToggleScreenShare: () => __awaiter$g(void 0, void 0, void 0, function* () {
            var _c;
            return ((_c = adapter.getState().call) === null || _c === void 0 ? void 0 : _c.isScreenSharingOn) ? yield adapter.stopScreenShare() : yield adapter.startScreenShare();
        }),
        onStartLocalVideo: () => __awaiter$g(void 0, void 0, void 0, function* () {
            if (adapter.getState().call) {
                return adapter.startCamera();
            }
        }),
        onDisposeLocalStreamView: () => __awaiter$g(void 0, void 0, void 0, function* () {
            return adapter.disposeLocalVideoStreamView();
        }),
        onDisposeRemoteStreamView: (userId) => __awaiter$g(void 0, void 0, void 0, function* () {
            return adapter.disposeStreamView(userId);
        }),
        onDisposeRemoteScreenShareStreamView: (userId) => __awaiter$g(void 0, void 0, void 0, function* () {
            return adapter.disposeScreenShareStreamView(userId);
        }),
        onDisposeRemoteVideoStreamView: (userId) => __awaiter$g(void 0, void 0, void 0, function* () {
            return adapter.disposeRemoteVideoStreamView(userId);
        }),
        /* @conditional-compile-remove(video-background-effects) */
        onRemoveVideoBackgroundEffects: () => __awaiter$g(void 0, void 0, void 0, function* () {
            return yield adapter.stopVideoBackgroundEffects();
        }),
        /* @conditional-compile-remove(video-background-effects) */
        onBlurVideoBackground: (backgroundBlurConfig) => __awaiter$g(void 0, void 0, void 0, function* () {
            const blurConfig = Object.assign({ effectName: 'blur' }, backgroundBlurConfig);
            return yield adapter.startVideoBackgroundEffect(blurConfig);
        }),
        /* @conditional-compile-remove(video-background-effects) */
        onReplaceVideoBackground: (backgroundReplacementConfig) => __awaiter$g(void 0, void 0, void 0, function* () {
            const replacementConfig = Object.assign({ effectName: 'replacement' }, backgroundReplacementConfig);
            return yield adapter.startVideoBackgroundEffect(replacementConfig);
        }),
        /* @conditional-compile-remove(close-captions) */
        onStartCaptions: (options) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.startCaptions(options);
        }),
        /* @conditional-compile-remove(close-captions) */
        onStopCaptions: () => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.stopCaptions();
        }),
        /* @conditional-compile-remove(close-captions) */
        onSetSpokenLanguage: (language) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.setSpokenLanguage(language);
        }),
        /* @conditional-compile-remove(close-captions) */
        onSetCaptionLanguage: (language) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield adapter.setCaptionLanguage(language);
        })
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const CaptionsSettingsModal = (props) => {
    /* @conditional-compile-remove(close-captions) */
    const CaptionsSettingsModalProps = useAdaptedSelector(_captionSettingsSelector);
    /* @conditional-compile-remove(close-captions) */
    const handlers = useHandlers();
    /* @conditional-compile-remove(close-captions) */
    const strings = useLocale().strings.call;
    /* @conditional-compile-remove(close-captions) */
    const modalStrings = {
        captionsSettingsModalTitle: strings.captionsSettingsModalTitle,
        captionsSettingsSpokenLanguageDropdownLabel: strings.captionsSettingsSpokenLanguageDropdownLabel,
        captionsSettingsCaptionLanguageDropdownLabel: strings.captionsSettingsCaptionLanguageDropdownLabel,
        captionsSettingsSpokenLanguageDropdownInfoText: strings.captionsSettingsSpokenLanguageDropdownInfoText,
        captionsSettingsCaptionLanguageDropdownInfoText: strings.captionsSettingsCaptionLanguageDropdownInfoText,
        captionsSettingsConfirmButtonLabel: strings.captionsSettingsConfirmButtonLabel,
        captionsSettingsCancelButtonLabel: strings.captionsSettingsCancelButtonLabel,
        captionsSettingsModalAriaLabel: strings.captionsSettingsModalAriaLabel,
        captionsSettingsCloseModalButtonAriaLabel: strings.captionsSettingsCloseModalButtonAriaLabel
    };
    /* @conditional-compile-remove(close-captions) */
    const spokenLanguageStrings = strings.spokenLanguageStrings;
    /* @conditional-compile-remove(close-captions) */
    const captionLanguageStrings = strings.captionLanguageStrings;
    /* @conditional-compile-remove(close-captions) */
    return React.createElement(_CaptionsSettingsModal, Object.assign({}, CaptionsSettingsModalProps, handlers, { strings: modalStrings, spokenLanguageStrings: spokenLanguageStrings, captionLanguageStrings: captionLanguageStrings, showModal: props.showCaptionsSettingsModal, onDismissCaptionsSettings: props.onDismissCaptionsSettings, changeCaptionLanguage: props.changeCaptionLanguage }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const MINIMUM_TOUCH_TARGET_HEIGHT_REM = 3;
/**
 * @private
 */
const groupCallLeaveButtonStyle = {
    root: {
        border: '0.125rem',
        borderRadius: 2,
        height: '2.1875rem',
        width: '6.5625rem'
    },
    flexContainer: {
        flexFlow: 'row'
    }
};
/**
 * @private
 */
const groupCallLeaveButtonCompressedStyle = {
    root: {
        border: '0',
        borderRadius: '0.5rem'
    },
    flexContainer: {
        flexFlow: 'row'
    }
};
/**
 * Styles that can be applied to ensure flyout items have the minimum touch target size.
 *
 * @private
 */
const buttonFlyoutIncreasedSizeStyles = {
    root: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        maxHeight: 'unset',
        overflow: 'hidden'
    },
    linkContent: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        maxHeight: 'unset'
    },
    icon: {
        maxHeight: 'unset',
        textAlign: 'center'
    },
    checkmarkIcon: {
        lineHeight: '2rem'
    }
};
/**
 * @private
 */
const participantButtonWithIncreasedTouchTargets = {
    menuStyles: {
        menuItemStyles: buttonFlyoutIncreasedSizeStyles,
        participantListStyles: {
            participantItemStyles: {
                root: {
                    height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`
                },
                participantSubMenuItemsStyles: buttonFlyoutIncreasedSizeStyles
            }
        }
    }
};
/**
 * @private
 */
const devicesButtonWithIncreasedTouchTargets = {
    menuStyles: {
        menuItemStyles: buttonFlyoutIncreasedSizeStyles
    }
};
/**
 * @private
 */
const controlButtonBaseStyle = {
    label: {
        minWidth: '2.25rem'
    }
};
/**
 * @private
 */
const concatButtonBaseStyles = (...styles) => {
    let result = controlButtonBaseStyle;
    styles.forEach(style => {
        result = react.concatStyleSets(result, style);
    });
    return result;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const icon$2 = () => React.createElement(reactIcons.MoreHorizontal20Filled, { key: 'chatOnIconKey', primaryFill: "currentColor" });
/**
 * @private
 */
const MoreButton = (props) => {
    return React.createElement(ControlBarButton, Object.assign({}, props, { labelKey: 'optionsButtonLabelKey', showLabel: props.showLabel, onRenderOnIcon: icon$2, onRenderOffIcon: icon$2, onClick: props.onClick, "data-ui-id": props['data-ui-id'] }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$f = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 *
 * @private
 */
const CaptionsBannerMoreButton = (props) => {
    /* @conditional-compile-remove(close-captions) */
    const localeStrings = useLocale();
    /* @conditional-compile-remove(close-captions) */
    const startCaptionsButtonProps = useAdaptedSelector(_startCaptionsButtonSelector);
    /* @conditional-compile-remove(close-captions) */
    const startCaptionsButtonHandlers = useHandlers();
    /* @conditional-compile-remove(close-captions) */
    const moreButtonStrings = React.useMemo(() => ({
        label: localeStrings.strings.call.captionsBannerMoreButtonCallingLabel,
        tooltipOffContent: localeStrings.strings.call.captionsBannerMoreButtonTooltip
    }), [localeStrings]);
    /* @conditional-compile-remove(close-captions) */
    const moreButtonContextualMenuItems = [];
    /* @conditional-compile-remove(close-captions) */
    const startCaptions = React.useCallback(() => __awaiter$f(void 0, void 0, void 0, function* () {
        yield startCaptionsButtonHandlers.onStartCaptions({
            spokenLanguage: startCaptionsButtonProps.currentSpokenLanguage
        });
    }), [startCaptionsButtonHandlers, startCaptionsButtonProps.currentSpokenLanguage]);
    /* @conditional-compile-remove(close-captions) */
    moreButtonContextualMenuItems.push({
        key: 'ToggleCaptionsKey',
        text: startCaptionsButtonProps.checked ? localeStrings.strings.call.startCaptionsButtonTooltipOnContent : localeStrings.strings.call.startCaptionsButtonTooltipOffContent,
        onClick: () => {
            startCaptionsButtonProps.checked ? startCaptionsButtonHandlers.onStopCaptions() : startCaptionsButtonProps.currentSpokenLanguage !== '' ? startCaptions() : props.onCaptionsSettingsClick && props.onCaptionsSettingsClick();
        },
        iconProps: {
            iconName: startCaptionsButtonProps.checked ? 'CaptionsOffIcon' : 'CaptionsIcon',
            styles: {
                root: {
                    lineHeight: 0
                }
            }
        },
        itemProps: {
            styles: buttonFlyoutIncreasedSizeStyles
        }
    });
    /* @conditional-compile-remove(close-captions) */
    if (props.onCaptionsSettingsClick) {
        moreButtonContextualMenuItems.push({
            key: 'openCaptionsSettingsKey',
            id: 'common-call-composite-captions-settings-button',
            text: localeStrings.strings.call.captionsSettingsLabel,
            onClick: props.onCaptionsSettingsClick,
            iconProps: {
                iconName: 'CaptionsSettingsIcon',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            itemProps: {
                styles: buttonFlyoutIncreasedSizeStyles
            },
            disabled: !startCaptionsButtonProps.checked
        });
    }
    /* @conditional-compile-remove(close-captions) */
    return React.createElement(MoreButton, Object.assign({}, props, { "data-ui-id": "captions-banner-more-button", strings: moreButtonStrings, menuIconProps: {
            hidden: true
        }, menuProps: {
            items: moreButtonContextualMenuItems,
            calloutProps: {
                preventDismissOnEvent: _preventDismissOnEvent
            }
        } }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(close-captions) */
const mobileViewBannerWidth = '90%';
/** @private */
const CaptionsBanner = (props) => {
    /* @conditional-compile-remove(close-captions) */
    const captionsBannerProps = useAdaptedSelector(_captionsBannerSelector);
    /* @conditional-compile-remove(close-captions) */
    const handlers = useHandlers();
    /* @conditional-compile-remove(close-captions) */
    const [isCaptionsSettingsOpen, setIsCaptionsSettingsOpen] = React.useState(false);
    /* @conditional-compile-remove(close-captions) */
    const onClickCaptionsSettings = () => {
        setIsCaptionsSettingsOpen(true);
    };
    /* @conditional-compile-remove(close-captions) */
    const onDismissCaptionsSettings = () => {
        setIsCaptionsSettingsOpen(false);
    };
    /* @conditional-compile-remove(close-captions) */
    const containerClassName = react.mergeStyles({
        position: 'relative'
    });
    /* @conditional-compile-remove(close-captions) */
    const floatingChildClassName = react.mergeStyles({
        position: 'absolute',
        right: 0,
        top: 0
    });
    /* @conditional-compile-remove(close-captions) */
    const strings = useLocale().strings.call;
    /* @conditional-compile-remove(close-captions) */
    const captionsBannerStrings = {
        captionsBannerSpinnerText: strings.captionsBannerSpinnerText
    };
    /* @conditional-compile-remove(close-captions) */
    const onRenderAvatar = React.useCallback((userId, options) => {
        return React.createElement(AvatarPersona, Object.assign({ userId: userId }, options, { dataProvider: props.onFetchAvatarPersonaData }));
    }, [props.onFetchAvatarPersonaData]);
    /* @conditional-compile-remove(close-captions) */
    const { innerWidth: width } = window;
    /* @conditional-compile-remove(close-captions) */
    const [windowWidth, setWindowWidth] = React.useState(width);
    /* @conditional-compile-remove(close-captions) */
    React.useEffect(() => {
        function handleResize() {
            setWindowWidth(window.innerWidth);
        }
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);
    /* @conditional-compile-remove(close-captions) */
    const desktopViewBannerWidth = windowWidth > 620 ? '35rem' : '80%';
    return React.createElement(React.Fragment, null, /* @conditional-compile-remove(close-captions) */
        isCaptionsSettingsOpen && React.createElement(CaptionsSettingsModal, { showCaptionsSettingsModal: isCaptionsSettingsOpen, onDismissCaptionsSettings: onDismissCaptionsSettings, changeCaptionLanguage: true }), /* @conditional-compile-remove(close-captions) */
        React.createElement("div", { className: containerClassName },
            React.createElement(react.Stack, { horizontalAlign: "center" },
                React.createElement(react.Stack.Item, { style: {
                        width: props.isMobile ? mobileViewBannerWidth : desktopViewBannerWidth
                    } },
                    React.createElement(_CaptionsBanner, Object.assign({}, captionsBannerProps, handlers, { onRenderAvatar: onRenderAvatar, formFactor: props.isMobile ? 'compact' : 'default', strings: captionsBannerStrings })))),
            !props.isMobile && captionsBannerProps.isCaptionsOn && React.createElement("div", { className: floatingChildClassName },
                React.createElement(CaptionsBannerMoreButton, { onCaptionsSettingsClick: onClickCaptionsSettings }))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const containerDivStyles = {
    position: 'relative',
    width: '100%',
    height: '100%'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * This minimum width is to make sure the side pane does not overlap with the composite when the screen is narrow.
 *
 * @private
 */
const compositeMinWidthRem = 30;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const usePropsFor$1 = (component) => {
    const selector = getSelector$1(component);
    if (!selector) {
        throw new Error("Can't find the selector for component, please check supported component list");
    }
    return Object.assign(Object.assign({}, useAdaptedSelector(selector)), useHandlers());
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const Camera = (props) => {
    var _a, _b, _c;
    const cameraButtonProps = usePropsFor$1(CameraButton);
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles((_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.styles]);
    /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(capabilities) */
    const adapter = useAdapter();
    /* @conditional-compile-remove(rooms) */
    const isRoomsCall = adapter.getState().isRoomsCall;
    /* @conditional-compile-remove(capabilities) */
    const turnVideoOnCapability = (_b = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.capabilitiesFeature) === null || _b === void 0 ? void 0 : _b.capabilities.turnVideoOn;
    return React.createElement(CameraButton, Object.assign({ "data-ui-id": "call-composite-camera-button" }, cameraButtonProps, { showLabel: props.displayType !== 'compact', styles: styles, enableDeviceSelectionMenu: props.splitButtonsForDeviceSelection, disableTooltip: props.disableTooltip, disabled: cameraButtonProps.disabled || props.disabled || ( /* @conditional-compile-remove(rooms) */isRoomsCall && ((_c = adapter.getState().call) === null || _c === void 0 ? void 0 : _c.role) === 'Unknown'), 
        /* @conditional-compile-remove(capabilities) */ onRenderOffIcon: turnVideoOnCapability && !turnVideoOnCapability.isPresent ? () => React.createElement(_HighContrastAwareIcon, { disabled: true, iconName: 'ControlButtonCameraProhibited' }) : undefined, 
        /* @conditional-compile-remove(video-background-effects) */ onClickVideoEffects: props.onClickVideoEffects, componentRef: props.componentRef }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const Devices = (props) => {
    var _a, _b;
    const devicesButtonProps = usePropsFor$1(DevicesButton);
    /* @conditional-compile-remove(rooms) */
    const adapter = useAdapter();
    /* @conditional-compile-remove(rooms) */
    const role = (_b = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.role) !== null && _b !== void 0 ? _b : 'Unknown';
    const augmentedDeviceButtonProps = React.useMemo(() => (Object.assign(Object.assign({}, devicesButtonProps), { 
        /* @conditional-compile-remove(rooms) */
        microphones: role === 'Consumer' ? [] : devicesButtonProps.microphones, 
        /* @conditional-compile-remove(rooms) */
        cameras: role === 'Consumer' ? [] : devicesButtonProps.cameras })), [devicesButtonProps, /* @conditional-compile-remove(rooms) */
        role]);
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles(props.increaseFlyoutItemSize ? devicesButtonWithIncreasedTouchTargets : {}, (_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.increaseFlyoutItemSize, props.styles]);
    /* @conditional-compile-remove(rooms) */
    const locale = useLocale();
    /* @conditional-compile-remove(rooms) */
    const onlyManageSpeakers = role === 'Consumer';
    /* @conditional-compile-remove(rooms) */
    const onRenderDevicesIcon = () => {
        return React.createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "OptionsSpeaker" });
    };
    return React.createElement(DevicesButton
    /* By setting `persistMenu?` to true, we prevent options menu from getting hidden every time a participant joins or leaves. */ , Object.assign({ 
        /* By setting `persistMenu?` to true, we prevent options menu from getting hidden every time a participant joins or leaves. */ persistMenu: true }, augmentedDeviceButtonProps, { showLabel: props.displayType !== 'compact', styles: styles, "data-ui-id": "calling-composite-devices-button", disabled: props.disabled, 
        /* @conditional-compile-remove(rooms) */ strings: getLabelFromRole(role, locale), 
        /* @conditional-compile-remove(rooms) */ onRenderIcon: onlyManageSpeakers ? onRenderDevicesIcon : undefined }));
};
/* @conditional-compile-remove(rooms) */
const getLabelFromRole = (role, locale) => {
    if (role === 'Consumer') {
        return {
            label: locale.component.strings.microphoneButton.speakerMenuTitle
        };
    }
    return undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const EndCall = (props) => {
    const compactMode = props.displayType === 'compact';
    const hangUpButtonProps = usePropsFor$1(EndCallButton);
    const styles = React.useMemo(() => { var _a; return react.concatStyleSets(compactMode ? groupCallLeaveButtonCompressedStyle : groupCallLeaveButtonStyle, (_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [compactMode, props.styles]);
    return React.createElement(EndCallButton, Object.assign({ "data-ui-id": "call-composite-hangup-button" }, hangUpButtonProps, { styles: styles, showLabel: !compactMode }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const useSelector$1 = (selector, selectorProps) => {
    // use selector with no adaptation
    return useSelectorWithAdaptation(selector, state => state, selectorProps);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const getDisplayName = (state) => state.displayName;
/**
 * @private
 */
const getEndedCall = (state) => state.endedCall;
/**
 * @private
 */
const getCallStatus = (state) => { var _a, _b; return (_b = (_a = state.call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None'; };
/**
 * @private
 */
const getDeviceManager = (state) => state.devices;
/**
 * @private
 */
const getIsScreenShareOn = (state) => { var _a, _b; return (_b = (_a = state.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn) !== null && _b !== void 0 ? _b : false; };
/* @conditional-compile-remove(raise-hand) */
/**
 * @private
 */
const getLocalParticipantRaisedHand = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.raiseHand.localParticipantRaisedHand; };
/**
 * @private
 */
const getMicrophones = (state) => state.devices.microphones;
/**
 * @private
 */
const getCameras = (state) => state.devices.cameras;
/* @conditional-compile-remove(capabilities) */
/**
 * @private
 */
const getRole = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.role; };
/**
 * @private
 */
const getPage = (state) => state.page;
/* @conditional-compile-remove(call-transfer) */
/**
 * @private
 */
const getTransferCall = (state) => state.acceptedTransferCallState;
/**
 * @private
 */
const getLocalMicrophoneEnabled = (state) => state.isLocalPreviewMicrophoneEnabled;
/**
 * @private
 */
const getLocalVideoStreams = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.localVideoStreams; };
/**
 * @private
 */
const getIsTranscriptionActive = (state) => { var _a; return !!((_a = state.call) === null || _a === void 0 ? void 0 : _a.transcription.isTranscriptionActive); };
/**
 * @private
 */
const getIsRecordingActive = (state) => { var _a; return !!((_a = state.call) === null || _a === void 0 ? void 0 : _a.recording.isRecordingActive); };
/**
 * @private
 */
const getUserFacingDiagnostics = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.diagnostics; };
/**
 * @private
 */
const getDominantSpeakerInfo = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.dominantSpeakers; };
/**
 * @private
 */
const getRemoteParticipants = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.remoteParticipants; };
/* @conditional-compile-remove(video-background-effects) */
/**
 * @private
 */
const getSelectedVideoEffect = (state) => state.selectedVideoBackgroundEffect;
/* @conditional-compile-remove(close-captions) */
/** @private */
const getCaptionsStatus = (state) => {
    var _a;
    return (_a = state.call) === null || _a === void 0 ? void 0 : _a.captionsFeature.isCaptionsFeatureActive;
};
/* @conditional-compile-remove(close-captions) */
/**
 * @private
 */
const getIsTeamsCall = (state) => state.isTeamsCall;
/* @conditional-compile-remove(capabilities) */
/**
 * @private
 */
const getLatestCapabilitiesChangedInfo = (state) => {
    var _a, _b;
    return (_b = (_a = state.call) === null || _a === void 0 ? void 0 : _a.capabilitiesFeature) === null || _b === void 0 ? void 0 : _b.latestCapabilitiesChangeInfo;
};
/**
 * @private
 */
const getTargetCallees = (state) => state.targetCallees;
/**
 * @private
 */
const getStartTime = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.startTime; };

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const Microphone = (props) => {
    var _a, _b, _c;
    const microphoneButtonProps = usePropsFor$1(MicrophoneButton);
    const callStatus = useSelector$1(getCallStatus);
    const isLocalMicrophoneEnabled = useSelector$1(getLocalMicrophoneEnabled);
    /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(capabilities) */
    const adapter = useAdapter();
    /* @conditional-compile-remove(rooms) */
    const isRoomsCall = adapter.getState().isRoomsCall;
    /* @conditional-compile-remove(capabilities) */
    const unmuteMicCapability = (_b = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.capabilitiesFeature) === null || _b === void 0 ? void 0 : _b.capabilities.unmuteMic;
    /**
     * When call is in connecting state, microphone button should be disabled.
     * This is due to to headless limitation where a call can not be muted/unmuted in lobby.
     */
    if (callStatus === 'Connecting') {
        // Lobby page should show the microphone status that was set on the local preview/configuration
        // page until the user successfully joins the call.
        microphoneButtonProps.checked = isLocalMicrophoneEnabled;
    }
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles((_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.styles]);
    // tab focus on MicrophoneButton on page load
    return React.createElement(MicrophoneButton, Object.assign({ "data-ui-id": "call-composite-microphone-button" }, microphoneButtonProps, { showLabel: props.displayType !== 'compact', disableTooltip: props.disableTooltip, styles: styles, enableDeviceSelectionMenu: props.splitButtonsForDeviceSelection, disabled: microphoneButtonProps.disabled || props.disabled || ( /* @conditional-compile-remove(rooms) */isRoomsCall && ((_c = adapter.getState().call) === null || _c === void 0 ? void 0 : _c.role) === 'Unknown'), 
        /* @conditional-compile-remove(capabilities) */ onRenderOffIcon: unmuteMicCapability && !unmuteMicCapability.isPresent ? () => React.createElement(_HighContrastAwareIcon, { disabled: true, iconName: 'ControlButtonMicProhibited' }) : undefined }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const Participants = (props) => {
    const participantsButtonProps = usePropsFor$1(ParticipantsButton);
    const participantsButtonStyles = React.useMemo(() => { var _a; return concatButtonBaseStyles(props.increaseFlyoutItemSize ? participantButtonWithIncreasedTouchTargets : {}, (_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.increaseFlyoutItemSize, props.styles]);
    return React.createElement(ParticipantsButton, Object.assign({ "data-ui-id": "call-composite-participants-button" }, participantsButtonProps, { showLabel: props.displayType !== 'compact', callInvitationURL: props.callInvitationURL, onFetchParticipantMenuItems: props.onFetchParticipantMenuItems, disabled: isDisabled$2(props.option) || props.disabled, styles: participantsButtonStyles, showParticipantOverflowTooltip: !props.isMobile }));
};
const isDisabled$2 = (option) => {
    if (option === undefined || option === true || option === false) {
        return false;
    }
    return option.disabled;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const ScreenShare = (props) => {
    var _a;
    const screenShareButtonProps = usePropsFor$1(ScreenShareButton);
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles((_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.styles]);
    /* @conditional-compile-remove(rooms) */
    const adapter = useAdapter();
    /* @conditional-compile-remove(rooms) */
    const isRoomsCall = adapter.getState().isRoomsCall;
    const screenShareButtonDisabled = () => {
        var _a;
        /* @conditional-compile-remove(capabilities) */ /* @conditional-compile-remove(PSTN-calls) */
        return (_a = screenShareButtonProps === null || screenShareButtonProps === void 0 ? void 0 : screenShareButtonProps.disabled) !== null && _a !== void 0 ? _a : isDisabled$1(props.option);
    };
    return React.createElement(ScreenShareButton, Object.assign({ "data-ui-id": "call-composite-screenshare-button" }, screenShareButtonProps, { showLabel: props.displayType !== 'compact', disabled: screenShareButtonDisabled() || props.disabled || ( /* @conditional-compile-remove(rooms) */isRoomsCall && ((_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.role) === 'Unknown'), styles: styles }));
};
const isDisabled$1 = (option) => {
    if (option === undefined || option === true || option === false) {
        return false;
    }
    return option.disabled;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const controlBarContainerStyles = {
    paddingTop: '0.25rem',
    paddingBottom: '0.25rem'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const VIDEO_GALLERY_Z_INDEX = 1;
// The control bar must be in a higher z-band than the video gallery so the drop shadow appears on top of the video gallery
/** @private */
const CONTROL_BAR_Z_INDEX = VIDEO_GALLERY_Z_INDEX + 1;
// The notification container should be in the highest z-band to ensure it shows on top of all other content.
const NOTIFICATION_CONTAINER_Z_INDEX = Math.max(CONTROL_BAR_Z_INDEX, VIDEO_GALLERY_Z_INDEX) + 1;
/** @private */
const DRAWER_Z_INDEX = NOTIFICATION_CONTAINER_Z_INDEX + 1;
/**
 * @private
 */
const callControlsContainerStyles = react.mergeStyles(controlBarContainerStyles, {
    zIndex: CONTROL_BAR_Z_INDEX
});
const containerStyle$2 = {
    width: '100%',
    position: 'relative',
    minHeight: '13rem' // linked to minimum space allocated to media gallery
};
/**
 * @private
 */
const containerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, containerStyle$2), { minWidth: '30rem' }));
/**
 * @private
 */
const containerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, containerStyle$2), { minWidth: '17.5rem' }));
/**
 * @private
 */
const galleryParentContainerStyles = (backgroundColor) => ({
    root: {
        zIndex: VIDEO_GALLERY_Z_INDEX,
        width: '100%',
        background: backgroundColor
    }
});
/**
 * @private
 */
const mediaGalleryContainerStyles$1 = {
    root: {
        height: '100%'
    }
};
/**
 * @private
 */
const notificationsContainerStyles = {
    root: {
        width: '100%',
        position: 'absolute',
        top: 0,
        left: 0,
        padding: '1rem',
        zIndex: NOTIFICATION_CONTAINER_Z_INDEX,
        pointerEvents: 'none' // to allow the operation of controls underneath the notification container
    }
};
/**
 * @private
 */
const bannerNotificationStyles = {
    root: {
        zIndex: NOTIFICATION_CONTAINER_Z_INDEX,
        pointerEvents: 'auto' // to allow the dismissal or error and warning bars in the notification container
    }
};
/**
 * @private
 */
const callArrangementContainerStyles = (verticalControlBar) => {
    return {
        root: {
            width: '100%',
            height: '100%',
            flexDirection: verticalControlBar ? 'unset' : 'column-reverse' // to allow first initial keyboard focus on ControlBar
        }
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(raise-hand) */
/** @private */
const RaiseHand = (props) => {
    const raiseHandButtonProps = usePropsFor$1(RaiseHandButton);
    const callStatus = useSelector$1(getCallStatus);
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles((_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.styles]);
    let raiseHandButtonDisabled = isDisabled(props.option);
    if (_isInLobbyOrConnecting(callStatus)) {
        raiseHandButtonDisabled = true;
    }
    return React.createElement(RaiseHandButton, Object.assign({ "data-ui-id": "call-composite-raisehand-button" }, raiseHandButtonProps, { showLabel: props.displayType !== 'compact', disabled: raiseHandButtonDisabled || props.disabled, styles: styles }));
};
/* @conditional-compile-remove(raise-hand) */
const isDisabled = (option) => {
    if (option === undefined || option === true || option === false) {
        return false;
    }
    return option.disabled;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// eslint-disable-next-line no-restricted-imports
/**
 * Max number of Custom Buttons in primary and secondary ControlBar
 * Does not include existing buttons in the controlBar.
 *
 * @private
 */
const CUSTOM_BUTTON_OPTIONS = {
    MAX_PRIMARY_DESKTOP_CUSTOM_BUTTONS: 3,
    MAX_PRIMARY_MOBILE_CUSTOM_BUTTONS: 1,
    MAX_SECONDARY_DESKTOP_CUSTOM_BUTTONS: 2
};
/** @private */
const generateCustomCallControlBarButton = (onFetchCustomButtonProps, displayType) => {
    const allButtonProps = onFetchCustomButtonProps === null || onFetchCustomButtonProps === void 0 ? void 0 : onFetchCustomButtonProps.map(callback => callback({
        displayType
    }));
    return {
        primary: generateCustomControlBarButtons('primary', allButtonProps),
        secondary: generateCustomControlBarButtons('secondary', allButtonProps),
        overflow: generateCustomControlBarButtons('overflow', allButtonProps)
    };
};
/** @private */
const generateCustomControlBarButtons = (placement, customButtons) => customButtons ? customButtons.filter(buttonProps => buttonProps.placement === placement).map((buttonProps, i) => internalProps => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    // onRenderButton is a custom prop that can be passed to override the default rendering of the button
    // This is useful for custom buttons that need to render more than just an icon and label and is used
    // for CallWithChat button notification badge. However, onRenderButton is not a public prop and is
    // not documented in the API. This is a temporary solution and will need to be revisited.
    if ('onRenderButton' in buttonProps) {
        return buttonProps['onRenderButton'](internalProps);
    }
    return React.createElement(ControlBarButton, { ariaDescription: (_b = (_a = buttonProps.strings) === null || _a === void 0 ? void 0 : _a.ariaDescription) !== null && _b !== void 0 ? _b : internalProps.ariaDescription, ariaLabel: (_f = (_d = (_c = buttonProps.strings) === null || _c === void 0 ? void 0 : _c.ariaLabel) !== null && _d !== void 0 ? _d : (_e = buttonProps.strings) === null || _e === void 0 ? void 0 : _e.tooltipContent) !== null && _f !== void 0 ? _f : internalProps.ariaLabel, disabled: (_g = buttonProps.disabled) !== null && _g !== void 0 ? _g : internalProps.disabled, id: (_h = buttonProps.id) !== null && _h !== void 0 ? _h : internalProps.id, key: `${buttonProps.placement}_${i}`, onClick: (_j = buttonProps.onItemClick) !== null && _j !== void 0 ? _j : internalProps.onClick, onRenderIcon: () => { var _a, _b, _c; return React.createElement(react.Icon, { iconName: (_c = (_a = buttonProps.iconName) !== null && _a !== void 0 ? _a : (_b = internalProps.iconProps) === null || _b === void 0 ? void 0 : _b.iconName) !== null && _c !== void 0 ? _c : 'DefaultCustomButton' }); }, showLabel: (_k = buttonProps.showLabel) !== null && _k !== void 0 ? _k : internalProps.showLabel, styles: react.mergeStyleSets(internalProps.styles), strings: buttonProps.strings });
}) : [];
/** @private */
const generateCustomDrawerButtons = (placement, customButtons) => customButtons ? customButtons.filter(buttonProps => buttonProps.placement === placement).map((buttonProps, i) => {
    var _a, _b;
    return (Object.assign(Object.assign({}, buttonProps), { disabled: buttonProps.disabled, iconProps: {
            iconName: (_a = buttonProps.iconName) !== null && _a !== void 0 ? _a : 'DefaultCustomButton',
            styles: {
                root: {
                    lineHeight: 0
                }
            }
        }, id: buttonProps.id, itemKey: `${buttonProps.placement}_${i}`, onItemClick: buttonProps.onItemClick, text: (_b = buttonProps.strings) === null || _b === void 0 ? void 0 : _b.label }));
}) : [];
/** @private */
const generateCustomCallDrawerButtons = (onFetchCustomButtonProps, displayType) => {
    const customButtons = onFetchCustomButtonProps === null || onFetchCustomButtonProps === void 0 ? void 0 : onFetchCustomButtonProps.map(callback => callback({
        displayType
    }));
    return {
        primary: generateCustomDrawerButtons('primary', customButtons),
        secondary: generateCustomDrawerButtons('secondary', customButtons),
        overflow: generateCustomDrawerButtons('overflow', customButtons)
    };
};
/** @private */
const generateCustomCallDesktopOverflowButtons = (onFetchCustomButtonProps, displayType) => {
    const customButtons = onFetchCustomButtonProps === null || onFetchCustomButtonProps === void 0 ? void 0 : onFetchCustomButtonProps.map(callback => callback({
        displayType
    }));
    return {
        primary: generateCustomDrawerButtons('primary', customButtons).map(drawerMenuItemToContextualMenuItem),
        secondary: generateCustomDrawerButtons('secondary', customButtons).map(drawerMenuItemToContextualMenuItem),
        overflow: generateCustomDrawerButtons('overflow', customButtons).map(drawerMenuItemToContextualMenuItem)
    };
};
/** @private */
const drawerMenuItemToContextualMenuItem = (item) => (Object.assign(Object.assign({}, item), { key: item.itemKey, onClick: item.onItemClick ? ev => {
        var _a;
        (_a = item.onItemClick) === null || _a === void 0 ? void 0 : _a.call(item, ev);
    } : undefined, subMenuProps: item.subMenuProps ? {
        items: item.subMenuProps.map(drawerMenuItemToContextualMenuItem)
    } : undefined }));
/** @private */
const onFetchCustomButtonPropsTrampoline = (options) => {
    let response = undefined;
    response = options === null || options === void 0 ? void 0 : options.onFetchCustomButtonProps;
    return response;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// Enforce a background color on control bar to ensure it matches the composite background color.
const controlBarStyles = react.memoizeFunction((background) => ({
    root: {
        background: background
    }
}));
const inferCallControlOptions = (mobileView, callControlOptions) => {
    if (callControlOptions === false) {
        return {};
    }
    const options = callControlOptions === true || callControlOptions === undefined ? {} : callControlOptions;
    if (mobileView) {
        // Set options to always not show screen share button for mobile
        options.screenShareButton = false;
    }
    return options;
};
/**
 * @private
 */
const CallControls = (props) => {
    var _a, _b;
    const options = React.useMemo(() => inferCallControlOptions(!!props.isMobile, props.options), [props.isMobile, props.options]);
    /* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(rooms) */
    const adapter = useAdapter();
    /* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */ /* @conditional-compile-remove(raise-hand) */
    const localeStrings = useLocale();
    /* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */ /* @conditional-compile-remove(raise-hand) */
    const moreButtonStrings = React.useMemo(() => ({
        label: localeStrings.strings.call.moreButtonCallingLabel,
        tooltipOffContent: localeStrings.strings.callWithChat.moreDrawerButtonTooltip
    }), [localeStrings]);
    /* @conditional-compile-remove(raise-hand) */
    const raiseHandButtonProps = usePropsFor$1(RaiseHandButton);
    const devicesButtonProps = usePropsFor$1(DevicesButton);
    let numberOfButtons = 0;
    const screenShareButtonIsEnabled = isEnabled$2(options === null || options === void 0 ? void 0 : options.screenShareButton);
    if (screenShareButtonIsEnabled) {
        numberOfButtons++;
    }
    const microphoneButtonIsEnabled = isEnabled$2(options === null || options === void 0 ? void 0 : options.microphoneButton);
    if (microphoneButtonIsEnabled) {
        numberOfButtons++;
    }
    const cameraButtonIsEnabled = isEnabled$2(options === null || options === void 0 ? void 0 : options.cameraButton);
    if (cameraButtonIsEnabled) {
        numberOfButtons++;
    }
    if (isEnabled$2(options === null || options === void 0 ? void 0 : options.endCallButton)) {
        numberOfButtons++;
    }
    const showParticipantsButtonInControlBar = isEnabled$2(options === null || options === void 0 ? void 0 : options.participantsButton);
    if (showParticipantsButtonInControlBar) {
        numberOfButtons++;
    }
    const moreButtonContextualMenuItems = () => {
        const items = [];
        if (props.isMobile && props.onPeopleButtonClicked && isEnabled$2(options === null || options === void 0 ? void 0 : options.participantsButton)) {
            items.push({
                key: 'peopleButtonKey',
                text: localeStrings.component.strings.participantsButton.label,
                onClick: () => {
                    if (props.onPeopleButtonClicked) {
                        props.onPeopleButtonClicked();
                    }
                },
                iconProps: {
                    iconName: 'ControlButtonParticipantsContextualMenuItem',
                    styles: {
                        root: {
                            lineHeight: 0
                        }
                    }
                },
                itemProps: {
                    styles: buttonFlyoutIncreasedSizeStyles
                },
                disabled: isDisabled$3(options === null || options === void 0 ? void 0 : options.participantsButton),
                ['data-ui-id']: 'call-composite-more-menu-people-button'
            });
        }
        return items;
    };
    const customDrawerButtons = React.useMemo(() => generateCustomCallDesktopOverflowButtons(onFetchCustomButtonPropsTrampoline(typeof options === 'object' ? options : undefined), typeof options === 'object' ? options.displayType : undefined), [options]);
    const moreButtonMenuItems = moreButtonContextualMenuItems();
    let showMoreButton = isEnabled$2(options === null || options === void 0 ? void 0 : options.moreButton) && moreButtonMenuItems.length > 0;
    if (showMoreButton) {
        numberOfButtons++;
    }
    const customButtons = React.useMemo(() => generateCustomCallControlBarButton(onFetchCustomButtonPropsTrampoline(options), options === null || options === void 0 ? void 0 : options.displayType), [options]);
    numberOfButtons += React.Children.count(customButtons['primary']) + React.Children.count(customButtons['secondary']);
    let showDevicesButtonInControlBar = isEnabled$2(options === null || options === void 0 ? void 0 : options.devicesButton);
    if (showDevicesButtonInControlBar && (props.isMobile ? numberOfButtons < 5 : true)) {
        numberOfButtons++;
    }
    else {
        showDevicesButtonInControlBar = false;
        showMoreButton = isEnabled$2(options === null || options === void 0 ? void 0 : options.moreButton);
    }
    /* @conditional-compile-remove(raise-hand) */
    const raiseHandButtonIsEnabled = isEnabled$2(options === null || options === void 0 ? void 0 : options.raiseHandButton);
    /* @conditional-compile-remove(raise-hand) */
    let showRaiseHandButtonInControlBar = raiseHandButtonIsEnabled;
    /* @conditional-compile-remove(rooms) */
    const role = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.role;
    /* @conditional-compile-remove(rooms) */
    const hideRaiseHandButtonInRoomsCall = adapter.getState().isRoomsCall && role && ['Consumer', 'Unknown'].includes(role);
    /* @conditional-compile-remove(raise-hand) */
    if (showRaiseHandButtonInControlBar && (props.isMobile ? numberOfButtons < 5 : true)) {
        numberOfButtons++;
    }
    else {
        // If more button is not present but enabled then replace previous button (devices button) with more button
        if (!showMoreButton && isEnabled$2(options === null || options === void 0 ? void 0 : options.moreButton)) {
            showMoreButton = true;
            showDevicesButtonInControlBar = false;
        }
        showRaiseHandButtonInControlBar = false;
    }
    if (!showDevicesButtonInControlBar) {
        const devicesButtonMenu = generateDefaultDeviceMenuProps(devicesButtonProps, localeStrings.component.strings.devicesButton);
        moreButtonMenuItems.push({
            key: 'devicesButtonKey',
            text: localeStrings.component.strings.devicesButton.label,
            iconProps: {
                iconName: 'ControlButtonOptions',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            subMenuProps: devicesButtonMenu,
            ['data-ui-id']: 'call-composite-more-menu-devices-button'
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    if (!showRaiseHandButtonInControlBar && /* @conditional-compile-remove(rooms) */ !hideRaiseHandButtonInRoomsCall) {
        moreButtonMenuItems.push({
            key: 'raiseHandButtonKey',
            text: raiseHandButtonProps.checked ? localeStrings.component.strings.raiseHandButton.onLabel : localeStrings.component.strings.raiseHandButton.offLabel,
            onClick: () => {
                if (raiseHandButtonProps.onToggleRaiseHand) {
                    raiseHandButtonProps.onToggleRaiseHand();
                }
            },
            iconProps: {
                iconName: 'RaiseHandContextualMenuItem',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            itemProps: {
                styles: buttonFlyoutIncreasedSizeStyles
            },
            disabled: isDisabled$3(options === null || options === void 0 ? void 0 : options.raiseHandButton),
            ['data-ui-id']: 'call-composite-more-menu-raise-hand-button'
        });
    }
    // Custom Buttons in More Button Menu should always be the last items pushed into the moreButtonMenuItems array
    if (customDrawerButtons['primary']) {
        customDrawerButtons['primary'].slice(props.isMobile ? CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_MOBILE_CUSTOM_BUTTONS : CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_DESKTOP_CUSTOM_BUTTONS).forEach(element => {
            moreButtonMenuItems.push(Object.assign({ itemProps: {
                    styles: buttonFlyoutIncreasedSizeStyles
                } }, element));
        });
    }
    if (customDrawerButtons['secondary']) {
        customDrawerButtons['secondary'].forEach(element => {
            moreButtonMenuItems.push(Object.assign({ itemProps: {
                    styles: buttonFlyoutIncreasedSizeStyles
                } }, element));
        });
    }
    if (customDrawerButtons['overflow']) {
        customDrawerButtons['overflow'].forEach(element => {
            moreButtonMenuItems.push(Object.assign({ itemProps: {
                    styles: buttonFlyoutIncreasedSizeStyles
                } }, element));
        });
    }
    const theme = react.useTheme();
    // when props.options is false then we want to hide the whole control bar.
    if (props.options === false) {
        return React.createElement(React.Fragment, null);
    }
    return React.createElement(react.Stack, { horizontalAlign: "center", className: callControlsContainerStyles },
        React.createElement(react.Stack.Item, null,
            React.createElement(ControlBar, { layout: props.displayVertical ? 'vertical' : 'horizontal', styles: controlBarStyles(theme.semanticColors.bodyBackground) },
                microphoneButtonIsEnabled && React.createElement(Microphone, { displayType: options === null || options === void 0 ? void 0 : options.displayType, disabled: isDisabled$3(options === null || options === void 0 ? void 0 : options.microphoneButton) }),
                cameraButtonIsEnabled && React.createElement(Camera, { displayType: options === null || options === void 0 ? void 0 : options.displayType, disabled: isDisabled$3(options === null || options === void 0 ? void 0 : options.cameraButton) }), /* @conditional-compile-remove(raise-hand) */
                showRaiseHandButtonInControlBar && /* @conditional-compile-remove(rooms) */ !hideRaiseHandButtonInRoomsCall && React.createElement(RaiseHand, { displayType: options === null || options === void 0 ? void 0 : options.displayType }),
                screenShareButtonIsEnabled && React.createElement(ScreenShare, { option: options === null || options === void 0 ? void 0 : options.screenShareButton, displayType: options === null || options === void 0 ? void 0 : options.displayType, disabled: isDisabled$3(options === null || options === void 0 ? void 0 : options.screenShareButton) }),
                showParticipantsButtonInControlBar && React.createElement(Participants, { option: options === null || options === void 0 ? void 0 : options.participantsButton, callInvitationURL: props.callInvitationURL, onFetchParticipantMenuItems: props.onFetchParticipantMenuItems, displayType: options === null || options === void 0 ? void 0 : options.displayType, increaseFlyoutItemSize: props.increaseFlyoutItemSize, isMobile: props.isMobile, disabled: isDisabled$3(options === null || options === void 0 ? void 0 : options.participantsButton) }),
                showDevicesButtonInControlBar && React.createElement(Devices, { displayType: options === null || options === void 0 ? void 0 : options.displayType, increaseFlyoutItemSize: props.increaseFlyoutItemSize, disabled: isDisabled$3(options === null || options === void 0 ? void 0 : options.devicesButton) }), (_b = customButtons['primary']) === null || _b === void 0 ? void 0 :
                _b.slice(0, props.isMobile ? CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_MOBILE_CUSTOM_BUTTONS : CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_DESKTOP_CUSTOM_BUTTONS).map((CustomButton, i) => {
                    return React.createElement(CustomButton, { key: `primary-custom-button-${i}`, 
                        // styles={commonButtonStyles}
                        showLabel: (options === null || options === void 0 ? void 0 : options.displayType) !== 'compact', disableTooltip: props.isMobile });
                }), /* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */ /* @conditional-compile-remove(raise-hand) */
                showMoreButton && React.createElement(MoreButton, { disableTooltip: props.isMobile, "data-ui-id": "common-call-composite-more-button", strings: moreButtonStrings, menuIconProps: {
                        hidden: true
                    }, menuProps: {
                        items: moreButtonMenuItems
                    }, showLabel: (options === null || options === void 0 ? void 0 : options.displayType) !== 'compact' }),
                isEnabled$2(options === null || options === void 0 ? void 0 : options.endCallButton) && React.createElement(EndCall, { displayType: options === null || options === void 0 ? void 0 : options.displayType }))));
};
const isEnabled$2 = (option) => option !== false;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const icon$1 = () => React.createElement(CallCompositeIcon, { iconName: 'ControlBarPeopleButton' });
/**
 * @private
 */
const PeopleButton = (props) => {
    const { strings, onRenderOnIcon, onRenderOffIcon, onClick } = props;
    const theme = useTheme();
    const styles = React.useMemo(() => {
        var _a;
        return react.concatStyleSets({
            rootChecked: {
                background: theme.palette.neutralLight
            }
        }, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    }, [props.styles, theme.palette.neutralLight]);
    return React.createElement(ControlBarButton, Object.assign({}, props, { strings: strings, labelKey: 'peopleButtonLabelKey', onRenderOnIcon: onRenderOnIcon !== null && onRenderOnIcon !== void 0 ? onRenderOnIcon : icon$1, onRenderOffIcon: onRenderOffIcon !== null && onRenderOffIcon !== void 0 ? onRenderOffIcon : icon$1, onClick: onClick, styles: styles }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * The hook to bypass limitation of conditional build for CallWithChatComposite
 * Remove this and use useLocale() instead when merge CallWithChatComposite from beta
 *
 * @private
 */
const useCallWithChatCompositeStrings = () => {
    const locale = useLocale();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return locale.strings.callWithChat;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const mediaGallerySelector = reselect__namespace.createSelector([getLocalVideoStreams], localVideoStreams => {
    var _a, _b;
    return {
        isVideoStreamOn: !!((_b = (_a = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(stream => stream.mediaStreamType === 'Video')) === null || _a === void 0 ? void 0 : _a.view) === null || _b === void 0 ? void 0 : _b.target)
    };
});
/**
 * Custom selector for this hook to retrieve all the participants that are currently
 * connected to the call.
 */
const getRemoteParticipantsConnectedSelector = reselect__namespace.createSelector([getRemoteParticipants], remoteParticipants => {
    const participants = Object.values(remoteParticipants !== null && remoteParticipants !== void 0 ? remoteParticipants : {});
    return participants.filter(p => p.state === 'Connected');
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * sets the announcement string whenever a Participant comes or goes from a call to be
 * used by the system narrator.
 *
 * @returns string to be used by the narrator and Announcer component
 *
 * @internal
 */
const useParticipantChangedAnnouncement = () => {
    const locale = useLocale().strings.call;
    const strings = React.useMemo(() => {
        return {
            participantJoinedNoticeString: locale.participantJoinedNoticeString,
            twoParticipantJoinedNoticeString: locale.twoParticipantJoinedNoticeString,
            threeParticipantJoinedNoticeString: locale.threeParticipantJoinedNoticeString,
            participantLeftNoticeString: locale.participantLeftNoticeString,
            twoParticipantLeftNoticeString: locale.twoParticipantLeftNoticeString,
            threeParticipantLeftNoticeString: locale.threeParticipantLeftNoticeString,
            unnamedParticipantString: locale.unnamedParticipantString,
            manyParticipantsJoined: locale.manyParticipantsJoined,
            manyParticipantsLeft: locale.manyParticipantsLeft,
            manyUnnamedParticipantsJoined: locale.manyUnnamedParticipantsJoined,
            manyUnnamedParticipantsLeft: locale.manyUnnamedParticipantsLeft
        };
    }, [locale]);
    const [announcerString, setAnnouncerString] = React.useState('');
    const currentParticipants = useSelector$1(getRemoteParticipantsConnectedSelector);
    /**
     * We want to use a useRef here since we want to not fire this hook based on the previous participants
     * this allows this value to be used in the hook without being in the dependency array.
     *
     * Note: By definition if this hook is used in another component it is not pure anymore.
     */
    const previousParticipants = React.useRef(currentParticipants);
    const resetAnnoucement = (string) => {
        setAnnouncerString(string);
    };
    React.useMemo(() => {
        const currentIds = currentParticipants.map(p => toFlatCommunicationIdentifier(p.identifier));
        const previousIds = previousParticipants.current.map(p => toFlatCommunicationIdentifier(p.identifier));
        const whoJoined = currentParticipants.filter(p => !previousIds.includes(toFlatCommunicationIdentifier(p.identifier)));
        const whoLeft = previousParticipants.current.filter(p => !currentIds.includes(toFlatCommunicationIdentifier(p.identifier)));
        if (whoJoined.length > 0) {
            resetAnnoucement(createAnnouncementString('joined', whoJoined, strings));
        }
        if (whoLeft.length > 0) {
            resetAnnoucement(createAnnouncementString('left', whoLeft, strings));
        }
        // Update cached value at the end.
        previousParticipants.current = currentParticipants;
    }, [currentParticipants, strings]);
    return announcerString;
};
/**
 * Generates the announcement string for when a participant joins or leaves a call.
 */
const createAnnouncementString = (direction, participants, strings) => {
    var _a, _b, _c;
    /**
     * If there are no participants return empty string.
     */
    if (participants.length === 0) {
        return '';
    }
    /**
     * Filter participants into two arrays to put all the unnamed participants at the back of the
     * names being announced.
     */
    const unnamedParticipants = participants.filter(p => !p.displayName);
    const namedParicipants = participants.filter(p => p.displayName);
    const sortedParticipants = namedParicipants.concat(unnamedParticipants);
    /**
     * if there are only unnamed participants present in the array announce a special unnamed participants
     * only string.
     */
    if (sortedParticipants.filter(p => p.displayName).length === 0 && sortedParticipants.length > 1) {
        return _formatString(direction === 'joined' ? strings.manyUnnamedParticipantsJoined : strings.manyUnnamedParticipantsLeft, {
            numOfParticipants: (sortedParticipants.length - 1).toString()
        });
    }
    const participantNames = sortedParticipants.map(p => { var _a; return (_a = p.displayName) !== null && _a !== void 0 ? _a : strings.unnamedParticipantString; });
    switch (sortedParticipants.length) {
        case 1:
            return _formatString(direction === 'joined' ? strings.participantJoinedNoticeString : strings.participantLeftNoticeString, {
                displayName: participantNames[0]
            });
        case 2:
            return _formatString(direction === 'joined' ? strings.twoParticipantJoinedNoticeString : strings.twoParticipantLeftNoticeString, {
                displayName1: participantNames[0],
                displayName2: participantNames[1]
            });
        case 3:
            return _formatString(direction === 'joined' ? strings.threeParticipantJoinedNoticeString : strings.threeParticipantLeftNoticeString, {
                displayName1: participantNames[0],
                displayName2: participantNames[1],
                displayName3: participantNames[2]
            });
    }
    /**
     * If we have more than 3 participants joining we need to do something more to announce them
     * appropriately.
     *
     * We don't want to announce every name when more than 3 participants join at once so
     * we parse out the first 3 names we have and announce those with the number of others.
     */
    const numberOfExtraParticipants = sortedParticipants.length - 3;
    return _formatString(direction === 'joined' ? strings.manyParticipantsJoined : strings.manyParticipantsLeft, {
        displayName1: (_a = sortedParticipants[0].displayName) !== null && _a !== void 0 ? _a : strings.unnamedParticipantString,
        displayName2: (_b = sortedParticipants[1].displayName) !== null && _b !== void 0 ? _b : strings.unnamedParticipantString,
        displayName3: (_c = sortedParticipants[2].displayName) !== null && _c !== void 0 ? _c : strings.unnamedParticipantString,
        numOfParticipants: numberOfExtraParticipants.toString()
    });
};
/**
 * determines if the media gallery should be replaced by the dtmf dialer
 * @param callees Target callees to determine if the dtmf dialer should be shown
 * @param remoteParticipants Remote participants to determine if the dtmf dialer should be shown if there are participants in the call
 * when joining
 * @returns whether the dialer should be the gallery content or not
 */
const showDtmfDialer = (callees, remoteParticipants) => {
    let showDtmfDialer = false;
    callees === null || callees === void 0 ? void 0 : callees.forEach(callee => {
        if (communicationCommon.isMicrosoftTeamsAppIdentifier(callee) || communicationCommon.isPhoneNumberIdentifier(callee)) {
            showDtmfDialer = true;
        }
    });
    if (remoteParticipants) {
        remoteParticipants.forEach(participant => {
            if (!('phoneNumber' in participant.identifier || 'teamsAppId' in participant.identifier)) {
                showDtmfDialer = false;
            }
        });
    }
    return showDtmfDialer;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$e = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 *
 * @private
 */
const DesktopMoreButton = (props) => {
    var _a, _b;
    /*@conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */
    const localeStrings = useLocale();
    /* @conditional-compile-remove(close-captions) */
    const startCaptionsButtonProps = useAdaptedSelector(_startCaptionsButtonSelector);
    /* @conditional-compile-remove(close-captions) */
    const startCaptionsButtonHandlers = useHandlers();
    /* @conditional-compile-remove(close-captions) */
    const startCaptions = React.useCallback(() => __awaiter$e(void 0, void 0, void 0, function* () {
        yield startCaptionsButtonHandlers.onStartCaptions({
            spokenLanguage: startCaptionsButtonProps.currentSpokenLanguage
        });
    }), [startCaptionsButtonHandlers, startCaptionsButtonProps.currentSpokenLanguage]);
    const [focusedContentOn, setFocusedContentOn] = React.useState(false);
    const [previousLayout, setPreviousLayout] = React.useState((_a = props.userSetGalleryLayout) !== null && _a !== void 0 ? _a : 'floatingLocalVideo');
    const callees = useSelector$1(getTargetCallees);
    const allowDtmfDialer = showDtmfDialer(callees);
    const [dtmfDialerChecked, setDtmfDialerChecked] = React.useState((_b = props.dtmfDialerPresent) !== null && _b !== void 0 ? _b : false);
    /* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */
    const moreButtonStrings = React.useMemo(() => ({
        label: localeStrings.strings.call.moreButtonCallingLabel,
        tooltipOffContent: localeStrings.strings.callWithChat.moreDrawerButtonTooltip
    }), [localeStrings]);
    const moreButtonContextualMenuItems = [];
    /* @conditional-compile-remove(close-captions) */
    const menuSubIconStyleSet = {
        root: {
            height: 'unset',
            lineHeight: '100%',
            width: '1.25rem'
        }
    };
    // is captions feature is active
    /* @conditional-compile-remove(close-captions) */
    if (props.isCaptionsSupported) {
        const captionsContextualMenuItems = [];
        moreButtonContextualMenuItems.push({
            key: 'liveCaptionsKey',
            id: 'common-call-composite-captions-button',
            text: localeStrings.strings.call.liveCaptionsLabel,
            iconProps: {
                iconName: 'CaptionsIcon',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            itemProps: {
                styles: buttonFlyoutIncreasedSizeStyles
            },
            disabled: props.disableButtonsForHoldScreen,
            subMenuProps: {
                id: 'captions-contextual-menu',
                items: captionsContextualMenuItems,
                calloutProps: {
                    preventDismissOnEvent: _preventDismissOnEvent
                }
            },
            submenuIconProps: {
                iconName: 'HorizontalGalleryRightButton',
                styles: menuSubIconStyleSet
            }
        });
        captionsContextualMenuItems.push({
            key: 'ToggleCaptionsKey',
            id: 'common-call-composite-captions-toggle-button',
            text: startCaptionsButtonProps.checked ? localeStrings.strings.call.startCaptionsButtonTooltipOnContent : localeStrings.strings.call.startCaptionsButtonTooltipOffContent,
            onClick: () => {
                startCaptionsButtonProps.checked ? startCaptionsButtonHandlers.onStopCaptions() : startCaptionsButtonProps.currentSpokenLanguage !== '' ? startCaptions() : props.onCaptionsSettingsClick && props.onCaptionsSettingsClick();
            },
            iconProps: {
                iconName: startCaptionsButtonProps.checked ? 'CaptionsOffIcon' : 'CaptionsIcon',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            itemProps: {
                styles: buttonFlyoutIncreasedSizeStyles
            },
            disabled: props.disableButtonsForHoldScreen
        });
        if (props.onCaptionsSettingsClick) {
            captionsContextualMenuItems.push({
                key: 'openCaptionsSettingsKey',
                id: 'common-call-composite-captions-settings-button',
                text: localeStrings.strings.call.captionsSettingsLabel,
                onClick: props.onCaptionsSettingsClick,
                iconProps: {
                    iconName: 'CaptionsSettingsIcon',
                    styles: {
                        root: {
                            lineHeight: 0
                        }
                    }
                },
                itemProps: {
                    styles: buttonFlyoutIncreasedSizeStyles
                },
                disabled: props.disableButtonsForHoldScreen || !startCaptionsButtonProps.checked
            });
        }
    }
    const dtmfDialerScreenOption = {
        key: 'dtmfDialerScreenKey',
        itemProps: {
            styles: buttonFlyoutIncreasedSizeStyles
        },
        text: !dtmfDialerChecked ? localeStrings.strings.call.dtmfDialerMoreButtonLabelOn : localeStrings.strings.call.dtmfDialerMoreButtonLabelOff,
        onClick: () => {
            props.onSetDialpadPage && props.onSetDialpadPage();
            setDtmfDialerChecked(!dtmfDialerChecked);
        },
        iconProps: {
            iconName: 'DtmfDialpadButton',
            styles: {
                root: {
                    lineHeight: 0
                }
            }
        }
    };
    /**
     * Only render the dtmf dialer if the dialpad for PSTN calls is not present
     */
    if (props.onSetDialpadPage && allowDtmfDialer) {
        moreButtonContextualMenuItems.push(dtmfDialerScreenOption);
    }
    if (props.onUserSetOverflowGalleryPositionChange) {
        const galleryOptions = {
            key: 'overflowGalleryPositionKey',
            iconProps: {
                iconName: 'GalleryOptions',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            itemProps: {
                styles: buttonFlyoutIncreasedSizeStyles
            },
            submenuIconProps: {
                styles: menuSubIconStyleSet
            },
            text: localeStrings.strings.call.moreButtonGalleryControlLabel,
            disabled: props.disableButtonsForHoldScreen,
            subMenuProps: {
                items: [{
                        key: 'dynamicSelectionKey',
                        text: localeStrings.strings.call.moreButtonGalleryFloatingLocalLayoutLabel,
                        canCheck: true,
                        itemProps: {
                            styles: buttonFlyoutIncreasedSizeStyles
                        },
                        isChecked: props.userSetGalleryLayout === 'floatingLocalVideo',
                        onClick: () => {
                            props.onUserSetGalleryLayout && props.onUserSetGalleryLayout('floatingLocalVideo');
                            setFocusedContentOn(false);
                        },
                        iconProps: {
                            iconName: 'FloatingLocalVideoGalleryLayout',
                            styles: {
                                root: {
                                    lineHeight: 0
                                }
                            }
                        }
                    }, {
                        key: 'speakerSelectionKey',
                        text: localeStrings.strings.call.moreButtonGallerySpeakerLayoutLabel,
                        canCheck: true,
                        itemProps: {
                            styles: buttonFlyoutIncreasedSizeStyles
                        },
                        isChecked: props.userSetGalleryLayout === 'speaker',
                        onClick: () => {
                            props.onUserSetGalleryLayout && props.onUserSetGalleryLayout('speaker');
                            setFocusedContentOn(false);
                        },
                        iconProps: {
                            iconName: 'SpeakerGalleryLayout',
                            styles: {
                                root: {
                                    lineHeight: 0
                                }
                            }
                        }
                    }, {
                        key: 'focusedContentSelectionKey',
                        text: localeStrings.strings.call.moreButtonGalleryFocusedContentLayoutLabel,
                        canCheck: true,
                        itemProps: {
                            styles: buttonFlyoutIncreasedSizeStyles
                        },
                        isChecked: focusedContentOn,
                        onClick: () => {
                            var _a;
                            if (focusedContentOn === false) {
                                setPreviousLayout((_a = props.userSetGalleryLayout) !== null && _a !== void 0 ? _a : 'floatingLocalVideo');
                                props.onUserSetGalleryLayout && props.onUserSetGalleryLayout('focusedContent');
                                setFocusedContentOn(true);
                            }
                            else {
                                props.onUserSetGalleryLayout && props.onUserSetGalleryLayout(previousLayout);
                                setFocusedContentOn(false);
                            }
                        },
                        iconProps: {
                            iconName: 'FocusedContentGalleryLayout',
                            styles: {
                                root: {
                                    lineHeight: 0
                                }
                            }
                        }
                    }],
                calloutProps: {
                    preventDismissOnEvent: _preventDismissOnEvent
                }
            }
        };
        moreButtonContextualMenuItems.push(galleryOptions);
    }
    /* @conditional-compile-remove(control-bar-button-injection) */
    const customDrawerButtons = React.useMemo(() => generateCustomCallDesktopOverflowButtons(onFetchCustomButtonPropsTrampoline(typeof props.callControls === 'object' ? props.callControls : undefined), typeof props.callControls === 'object' ? props.callControls.displayType : undefined), [props.callControls]);
    /* @conditional-compile-remove(control-bar-button-injection) */
    customDrawerButtons['primary'].slice(CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_DESKTOP_CUSTOM_BUTTONS).forEach(element => {
        moreButtonContextualMenuItems.push(Object.assign({ itemProps: {
                styles: buttonFlyoutIncreasedSizeStyles
            } }, element));
    });
    /* @conditional-compile-remove(control-bar-button-injection) */
    customDrawerButtons['secondary'].slice(CUSTOM_BUTTON_OPTIONS.MAX_SECONDARY_DESKTOP_CUSTOM_BUTTONS).forEach(element => {
        moreButtonContextualMenuItems.push(Object.assign({ itemProps: {
                styles: buttonFlyoutIncreasedSizeStyles
            } }, element));
    });
    /* @conditional-compile-remove(control-bar-button-injection) */
    customDrawerButtons['overflow'].forEach(element => {
        moreButtonContextualMenuItems.push(Object.assign({ itemProps: {
                styles: buttonFlyoutIncreasedSizeStyles
            } }, element));
    });
    return React.createElement(MoreButton, Object.assign({}, props, { "data-ui-id": "common-call-composite-more-button", 
        /*@conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */ strings: moreButtonStrings, menuIconProps: {
            hidden: true
        }, menuProps: {
            items: moreButtonContextualMenuItems,
            calloutProps: {
                preventDismissOnEvent: _preventDismissOnEvent
            }
        } }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 *  hidden button to set first tab keypress focus on a specific grouping.
 *  On mount, button is autofocused then immediately hidden
 */
const HiddenFocusStartPoint = () => {
    const [isMounted, setIsMounted] = React.useState(false);
    React.useEffect(() => {
        setIsMounted(true);
    }, []);
    return React.createElement(react.DefaultButton, { autoFocus: true, ariaHidden: true, styles: isMounted ? invisibleHiddenFocusStartPoint : hiddenFocusStartPointStyles, tabIndex: -1 });
};
/** @private */
const hiddenFocusStartPointStyles = {
    root: {
        width: '0',
        height: '0',
        margin: '0',
        minHeight: '0',
        minWidth: '0',
        maxHeight: '0',
        maxWidth: '0',
        opacity: '0',
        outline: 'none',
        padding: '0',
        position: 'absolute'
    }
};
/** @private */
const invisibleHiddenFocusStartPoint = {
    root: {
        display: 'none'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const icon = () => React.createElement(CallCompositeIcon, { iconName: 'DtmfDialpadButton' });
/**
 * Button for showing and hiding the dtmf dialer in the Call composite.
 * To be used only if the more button control is disabled. This button will replace
 * it in the control bar unless it is also disabled.
 * @private
 */
const DtmfDialpadButton = (props) => {
    const { strings, onRenderOnIcon, onRenderOffIcon, onClick, displayType } = props;
    const theme = react.useTheme();
    const locale = useLocale();
    const dialpadButtonStrings = {
        label: locale.strings.call.dtmfDialerButtonLabel,
        tooltipOnContent: locale.strings.call.dtmfDialerButtonTooltipOn,
        tooltipOffContent: locale.strings.call.dtmfDialerButtonTooltipOff
    };
    const styles = React.useMemo(() => {
        var _a;
        return react.concatStyleSets({
            rootChecked: {
                background: theme.palette.neutralLight
            }
        }, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    }, [props.styles, theme.palette.neutralLight]);
    return React.createElement(ControlBarButton, Object.assign({}, props, { strings: strings ? strings : dialpadButtonStrings, showLabel: displayType !== 'compact', labelKey: 'dtmfDialpadButtonLabelKey', onRenderOnIcon: onRenderOnIcon !== null && onRenderOnIcon !== void 0 ? onRenderOnIcon : icon, onRenderOffIcon: onRenderOffIcon !== null && onRenderOffIcon !== void 0 ? onRenderOffIcon : icon, onClick: onClick, styles: styles }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const inferCommonCallControlOptions = (mobileView, commonCallControlOptions) => {
    if (commonCallControlOptions === false) {
        return false;
    }
    const options = commonCallControlOptions === true || commonCallControlOptions === undefined ? {} : commonCallControlOptions;
    if (mobileView) {
        // Set to compressed mode when composite is optimized for mobile
        options.displayType = 'compact';
        // Set options to always not show screen share button for mobile
        options.screenShareButton = false;
    }
    return options;
};
/**
 * @private
 */
const CommonCallControlBar = (props) => {
    var _a, _b, _c;
    const theme = react.useTheme();
    const rtl = theme.rtl;
    const controlBarContainerRef = React.useRef(null);
    const sidepaneControlsRef = React.useRef(null);
    const controlBarSizeRef = React.useRef(null);
    const [controlBarButtonsWidth, setControlBarButtonsWidth] = React.useState(0);
    const [panelsButtonsWidth, setPanelsButtonsWidth] = React.useState(0);
    const [controlBarContainerWidth, setControlBarContainerWidth] = React.useState(0);
    const [totalButtonsWidth, setTotalButtonsWidth] = React.useState(0);
    const [isOutOfSpace, setIsOutOfSpace] = React.useState(false);
    const callWithChatStrings = useCallWithChatCompositeStrings();
    const options = inferCommonCallControlOptions(props.mobileView, props.callControls);
    /* @conditional-compile-remove(close-captions) */
    const [showCaptionsSettingsModal, setShowCaptionsSettingsModal] = React.useState(false);
    const handleResize = React.useCallback(() => {
        setControlBarButtonsWidth(controlBarContainerRef.current ? controlBarContainerRef.current.offsetWidth : 0);
        setPanelsButtonsWidth(sidepaneControlsRef.current ? sidepaneControlsRef.current.offsetWidth : 0);
        setControlBarContainerWidth(controlBarSizeRef.current ? controlBarSizeRef.current.offsetWidth : 0);
    }, []);
    // on load set inital width
    React.useEffect(() => {
        setControlBarButtonsWidth(controlBarContainerRef.current ? controlBarContainerRef.current.offsetWidth : 0);
        setPanelsButtonsWidth(sidepaneControlsRef.current ? sidepaneControlsRef.current.offsetWidth : 0);
        setControlBarContainerWidth(controlBarSizeRef.current ? controlBarSizeRef.current.offsetWidth : 0);
    }, []);
    // get the current width of control bar buttons and panel control buttons when browser size change
    React.useEffect(() => {
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [handleResize]);
    /* when size change, reset total buttons width and compare with the control bar container width
    if the total width of those buttons exceed container width, do not center the control bar buttons based on parent container width
    Instead let them take up the remaining white space on the left */
    React.useEffect(() => {
        // white space on the left when control bar buttons are centered based on container width + control bar buttons width + panel control buttons width
        setTotalButtonsWidth((controlBarContainerWidth - controlBarButtonsWidth) / 2 + controlBarButtonsWidth + panelsButtonsWidth);
    }, [controlBarButtonsWidth, panelsButtonsWidth, controlBarContainerWidth]);
    React.useEffect(() => {
        setIsOutOfSpace(totalButtonsWidth > controlBarContainerWidth);
    }, [totalButtonsWidth, controlBarContainerWidth]);
    /* @conditional-compile-remove(close-captions) */
    const openCaptionsSettingsModal = React.useCallback(() => {
        setShowCaptionsSettingsModal(true);
    }, []);
    /* @conditional-compile-remove(close-captions) */
    const onDismissCaptionsSettings = React.useCallback(() => {
        setShowCaptionsSettingsModal(false);
    }, []);
    const peopleButtonStrings = React.useMemo(() => ({
        label: callWithChatStrings.peopleButtonLabel,
        selectedLabel: callWithChatStrings.selectedPeopleButtonLabel,
        tooltipOffContent: callWithChatStrings.peopleButtonTooltipOpen,
        tooltipOnContent: callWithChatStrings.peopleButtonTooltipClose
    }), [callWithChatStrings]);
    const moreButtonStrings = React.useMemo(() => ({
        label: callWithChatStrings.moreDrawerButtonLabel,
        tooltipContent: callWithChatStrings.moreDrawerButtonTooltip
    }), [callWithChatStrings]);
    const centerContainerStyles = React.useMemo(() => {
        const styles = !props.mobileView ? desktopControlBarStyles : {};
        return react.mergeStyleSets(styles, {
            root: {
                // Enforce a background color on control bar to ensure it matches the composite background color.
                background: theme.semanticColors.bodyBackground
            }
        });
    }, [props.mobileView, theme.semanticColors.bodyBackground]);
    const screenShareButtonStyles = React.useMemo(() => !props.mobileView ? getDesktopScreenShareButtonStyles(theme) : undefined, [props.mobileView, theme]);
    const commonButtonStyles = React.useMemo(() => !props.mobileView ? getDesktopCommonButtonStyles(theme) : undefined, [props.mobileView, theme]);
    const endCallButtonStyles = React.useMemo(() => !props.mobileView ? getDesktopEndCallButtonStyles(theme) : undefined, [props.mobileView, theme]);
    const controlBarWrapperDesktopStyles = React.useMemo(
    // only center control bar buttons based on parent container if there are enough space on the screen and not mobile
    () => !props.mobileView && !isOutOfSpace ? rtl ? wrapperDesktopRtlStyles : wrapperDesktopStyles : {}, [props.mobileView, rtl, isOutOfSpace]);
    // only center control bar buttons based on parent container if there are enough space on the screen and not mobile
    const controlBarDesktopContainerStyles = React.useMemo(() => !props.mobileView && !isOutOfSpace ? {
        position: 'relative',
        minHeight: '4.5rem',
        width: '100%'
    } : {}, [props.mobileView, isOutOfSpace]);
    const customButtons = React.useMemo(() => generateCustomCallControlBarButton(onFetchCustomButtonPropsTrampoline(options !== false ? options : undefined), options !== false ? options === null || options === void 0 ? void 0 : options.displayType : undefined), [options]);
    // when options is false then we want to hide the whole control bar.
    if (options === false) {
        return React.createElement(React.Fragment, null);
    }
    const sideButtonsPresent = isEnabled$1(options.peopleButton) || isEnabled$1(options.chatButton) || customButtons['secondary'] !== undefined;
    const screenShareButtonIsEnabled = isEnabled$1(options === null || options === void 0 ? void 0 : options.screenShareButton);
    const microphoneButtonIsEnabled = isEnabled$1(options === null || options === void 0 ? void 0 : options.microphoneButton);
    const cameraButtonIsEnabled = isEnabled$1(options === null || options === void 0 ? void 0 : options.cameraButton);
    const showDesktopMoreButton = /*@conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */ isEnabled$1(options === null || options === void 0 ? void 0 : options.moreButton) && (/* @conditional-compile-remove(close-captions) */ props.isCaptionsSupported || props.onUserSetGalleryLayout);
    /*@conditional-compile-remove(rooms) */
    const role = (_a = props.callAdapter.getState().call) === null || _a === void 0 ? void 0 : _a.role;
    /*@conditional-compile-remove(rooms) */
    const hideRaiseHandButtonInRoomsCall = props.callAdapter.getState().isRoomsCall && role && ['Consumer', 'Unknown'].includes(role);
    return React.createElement("div", { ref: controlBarSizeRef },
        React.createElement(CallAdapterProvider, { adapter: props.callAdapter }, /* @conditional-compile-remove(close-captions) */ showCaptionsSettingsModal && React.createElement(CaptionsSettingsModal, { showCaptionsSettingsModal: showCaptionsSettingsModal, onDismissCaptionsSettings: onDismissCaptionsSettings, changeCaptionLanguage: props.isCaptionsOn })),
        React.createElement(react.Stack, { horizontal: true, reversed: !props.mobileView && !isOutOfSpace, horizontalAlign: "space-between", className: react.mergeStyles(callControlsContainerStyles, controlBarContainerStyles, controlBarDesktopContainerStyles) },
            React.createElement(react.Stack.Item, { grow: true, className: react.mergeStyles(controlBarWrapperDesktopStyles) },
                React.createElement(CallAdapterProvider, { adapter: props.callAdapter },
                    React.createElement(react.Stack, { horizontalAlign: "center" },
                        React.createElement(HiddenFocusStartPoint, null),
                        React.createElement(react.Stack.Item, null,
                            React.createElement("div", { ref: controlBarContainerRef },
                                React.createElement(ControlBar, { layout: props.displayVertical ? 'vertical' : 'horizontal', styles: centerContainerStyles },
                                    microphoneButtonIsEnabled && React.createElement(Microphone, { displayType: options.displayType, styles: commonButtonStyles, splitButtonsForDeviceSelection: !props.mobileView, disableTooltip: props.mobileView }),
                                    cameraButtonIsEnabled && React.createElement(Camera, { displayType: options.displayType, styles: commonButtonStyles, splitButtonsForDeviceSelection: !props.mobileView, onClickVideoEffects: props.onClickVideoEffects, componentRef: props.cameraButtonRef, disableTooltip: props.mobileView }), /* @conditional-compile-remove(raise-hand) */
                                    !props.mobileView && isEnabled$1(options.raiseHandButton) && /* @conditional-compile-remove(rooms) */ !hideRaiseHandButtonInRoomsCall && React.createElement(RaiseHand, { displayType: options.displayType, styles: commonButtonStyles }),
                                    showDtmfDialerButton(options) && props.onSetDialpadPage !== undefined && React.createElement(DtmfDialpadButton, { styles: commonButtonStyles, displayType: options.displayType, onClick: () => {
                                            if (props.onSetDialpadPage !== undefined) {
                                                props.onSetDialpadPage();
                                            }
                                        } }),
                                    screenShareButtonIsEnabled && React.createElement(ScreenShare, { option: options.screenShareButton, displayType: options.displayType, styles: screenShareButtonStyles }), (_b = customButtons['primary']) === null || _b === void 0 ? void 0 :
                                    _b.slice(0, props.mobileView ? CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_MOBILE_CUSTOM_BUTTONS : CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_DESKTOP_CUSTOM_BUTTONS).map((CustomButton, i) => {
                                        return React.createElement(CustomButton, { key: `primary-custom-button-${i}`, styles: commonButtonStyles, showLabel: options.displayType !== 'compact', disableTooltip: props.mobileView });
                                    }),
                                    props.mobileView && React.createElement(MoreButton, { "data-ui-id": "common-call-composite-more-button", strings: moreButtonStrings, onClick: props.onMoreButtonClicked, disabled: props.disableButtonsForLobbyPage, disableTooltip: props.mobileView }),
                                    !props.mobileView && showDesktopMoreButton && React.createElement(DesktopMoreButton, { disableButtonsForHoldScreen: props.disableButtonsForHoldScreen, styles: commonButtonStyles, callControls: props.callControls, 
                                        /* @conditional-compile-remove(close-captions) */ isCaptionsSupported: props.isCaptionsSupported, 
                                        /* @conditional-compile-remove(close-captions) */ onCaptionsSettingsClick: openCaptionsSettingsModal, onUserSetOverflowGalleryPositionChange: props.onUserSetOverflowGalleryPositionChange, onUserSetGalleryLayout: props.onUserSetGalleryLayout, userSetGalleryLayout: props.userSetGalleryLayout, dtmfDialerPresent: props.dtmfDialerPresent, onSetDialpadPage: props.onSetDialpadPage }),
                                    React.createElement(EndCall, { displayType: "compact", styles: endCallButtonStyles }))))))),
            !props.mobileView && sideButtonsPresent && React.createElement(react.Stack.Item, null,
                React.createElement("div", { ref: sidepaneControlsRef },
                    React.createElement(react.Stack, { horizontal: true, className: !props.mobileView ? react.mergeStyles(desktopButtonContainerStyle) : undefined },
                        isEnabled$1(options === null || options === void 0 ? void 0 : options.peopleButton) && React.createElement(PeopleButton, { checked: props.peopleButtonChecked, ariaLabel: props.peopleButtonChecked ? peopleButtonStrings === null || peopleButtonStrings === void 0 ? void 0 : peopleButtonStrings.selectedLabel : peopleButtonStrings === null || peopleButtonStrings === void 0 ? void 0 : peopleButtonStrings.label, showLabel: options.displayType !== 'compact', onClick: props.onPeopleButtonClicked, "data-ui-id": "common-call-composite-people-button", disabled: props.disableButtonsForLobbyPage || props.disableButtonsForHoldScreen || isDisabled$3(options.peopleButton), strings: peopleButtonStrings, styles: commonButtonStyles, componentRef: props.peopleButtonRef }), (_c = customButtons['secondary']) === null || _c === void 0 ? void 0 :
                        _c.slice(0, CUSTOM_BUTTON_OPTIONS.MAX_SECONDARY_DESKTOP_CUSTOM_BUTTONS).map((CustomButton, i) => {
                            return React.createElement(CustomButton, { key: `secondary-custom-button-${i}`, styles: commonButtonStyles, showLabel: options.displayType !== 'compact' });
                        }))))));
};
const desktopButtonContainerStyle = {
    padding: '0.75rem',
    columnGap: '0.5rem'
};
const desktopControlBarStyles = {
    root: desktopButtonContainerStyle
};
const wrapperDesktopStyles = {
    position: 'absolute',
    left: '50%',
    transform: 'translate(-50%, 0)'
};
const wrapperDesktopRtlStyles = {
    position: 'absolute',
    right: '50%',
    transform: 'translate(-50%, 0)'
};
/** @private */
const getDesktopCommonButtonStyles = (theme) => ({
    root: {
        border: `solid 1px ${theme.palette.neutralQuaternaryAlt}`,
        borderRadius: theme.effects.roundedCorner4,
        minHeight: '2.5rem',
        maxWidth: '12rem' // allot extra space than the regular ControlBarButton. This is to give extra room to have the icon beside the text.
    },
    flexContainer: {
        display: 'flex',
        flexFlow: 'row nowrap'
    },
    textContainer: {
        // Override the default so that label doesn't introduce a new block.
        display: 'inline',
        // Ensure width is set to permit child to show ellipsis when there is a label that is too long
        maxWidth: '100%'
    },
    label: {
        fontSize: theme.fonts.medium.fontSize,
        // Ensure there is enough space between the icon and text to allow for the unread messages badge in the chat button
        marginLeft: '0.625rem',
        // Ensure letters that go above and below the standard text line like 'g', 'y', 'j' are not clipped
        lineHeight: '1.5rem',
        // Do not allow very long button texts to ruin the control bar experience, instead ensure long text is truncated and shows ellipsis
        display: 'block',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        overflow: 'hidden'
    },
    splitButtonMenuButton: {
        border: `solid 1px ${theme.palette.neutralQuaternaryAlt}`,
        borderTopRightRadius: theme.effects.roundedCorner4,
        borderBottomRightRadius: theme.effects.roundedCorner4,
        borderTopLeftRadius: '0',
        borderBottomLeftRadius: '0'
    },
    splitButtonMenuButtonChecked: {
        // Default colors the menu half similarly for :hover and when button is checked.
        // To align with how the left-half is styled, override the checked style.
        background: 'none'
    }
});
const getDesktopScreenShareButtonStyles = (theme) => {
    const overrideStyles = {
        border: 'none',
        background: theme.palette.themePrimary,
        color: theme.palette.white,
        '* > svg': {
            fill: theme.palette.white
        },
        '@media (forced-colors: active)': {
            border: '1px solid',
            borderColor: theme.palette.black
        }
    };
    const overrides = {
        rootChecked: overrideStyles,
        rootCheckedHovered: overrideStyles
    };
    return react.concatStyleSets(getDesktopCommonButtonStyles(theme), overrides);
};
const getDesktopEndCallButtonStyles = (theme) => {
    const overrides = {
        root: {
            // Suppress border around the dark-red button.
            border: 'none'
        },
        rootFocused: {
            '@media (forced-colors: active)': {
                background: 'highlight',
                color: 'highlightText',
                borderColor: theme.palette.black,
                borderRadius: 'unset',
                outline: `3px solid ${theme.palette.black}`
            }
        },
        icon: {
            '@media (forced-colors: active)': {
                ':focused': {
                    color: theme.palette.white
                }
            }
        }
    };
    return react.concatStyleSets(getDesktopCommonButtonStyles(theme), overrides);
};
const isEnabled$1 = (option) => option !== false;
const showDtmfDialerButton = (options) => {
    if (options.moreButton === false && options.dtmfDialerButton !== false) {
        return true;
    }
    else {
        return false;
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Notify the user that they're muted.
 */
function MutedNotification(props) {
    const locale = useLocale();
    const theme = react.useTheme();
    return React.createElement(react.Stack, { horizontal: true, horizontalAlign: "center", className: react.mergeStyles(props.speakingWhileMuted === true ? isSpeakingAndMutedAnimationStyles : isNotSpeakingAndMutedAnimationStyles) },
        React.createElement(react.Stack, { horizontal: true, className: react.mergeStyles(stackStyle(theme)) },
            React.createElement(CallCompositeIcon, { iconName: "Muted", className: react.mergeStyles(iconStyle(theme)) }),
            React.createElement(react.Text, { className: react.mergeStyles(textStyle(theme)), "aria-live": 'polite' }, locale.strings.call.mutedMessage)));
}
const stackStyle = (theme) => {
    return {
        background: theme.palette.black,
        gap: `1rem`,
        padding: `1rem`,
        borderRadius: theme.effects.roundedCorner4,
        width: 'fit-content',
        opacity: 0.8
    };
};
const iconStyle = (theme) => {
    return {
        color: theme.palette.white,
        maxHeight: '1.25rem'
    };
};
const textStyle = (theme) => {
    return {
        color: theme.palette.white,
        fontSize: `1rem`
    };
};
const isSpeakingAndMutedAnimationStyles = Object.assign({}, react.AnimationStyles.fadeIn100);
const isNotSpeakingAndMutedAnimationStyles = Object.assign(Object.assign({}, react.AnimationStyles.fadeOut200), { display: 'none' });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const callStatusSelector = reselect.createSelector([getCallStatus, getIsScreenShareOn], (callStatus, isScreenShareOn) => {
    return {
        callStatus,
        isScreenShareOn
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const captionSettingsDrawerStyles = (theme) => ({
    root: {
        overflow: 'auto'
    },
    drawerSurfaceStyles: {
        drawerContentContainer: {
            root: {
                span: {
                    fontWeight: 400,
                    fontSize: _pxToRem(14),
                    lineHeight: _pxToRem(22),
                    color: theme.palette.neutralDark
                }
            }
        }
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const CaptionLanguageSettingsDrawer = (props) => {
    var _a;
    /* @conditional-compile-remove(close-captions) */
    const theme = useTheme();
    /* @conditional-compile-remove(close-captions) */
    const onDrawerItemClick = React.useCallback((languageCode) => {
        props.selectLanguage(languageCode);
    }, [props]);
    /* @conditional-compile-remove(close-captions) */
    const drawerItems = React.useMemo(() => {
        var _a;
        return _getKeys((_a = props.supportedLanguageStrings) !== null && _a !== void 0 ? _a : []).map(languageCode => ({
            itemKey: languageCode,
            text: props.supportedLanguageStrings ? props.supportedLanguageStrings[languageCode] : languageCode,
            onItemClick: () => onDrawerItemClick(languageCode),
            secondaryIconProps: props.currentLanguage === languageCode ? {
                iconName: 'Accept'
            } : undefined
        }));
    }, [props.currentLanguage, props.supportedLanguageStrings, onDrawerItemClick]);
    const sortedDrawerItems = React.useMemo(() => {
        const copy = [...drawerItems];
        return copy.sort((a, b) => a.text && b.text && a.text > b.text ? 1 : -1);
    }, [drawerItems]);
    /* @conditional-compile-remove(close-captions) */
    return React.createElement(_DrawerMenu, { heading: (_a = props.strings) === null || _a === void 0 ? void 0 : _a.menuTitle, items: sortedDrawerItems !== null && sortedDrawerItems !== void 0 ? sortedDrawerItems : [], onLightDismiss: () => {
            props.setCurrentLanguage(props.currentLanguage);
            props.onLightDismiss();
        }, styles: captionSettingsDrawerStyles(theme) });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const themedToggleButtonStyle = (theme, checked) => {
    if (checked) {
        return {
            root: {
                margin: 0
            },
            pill: {
                backgroundColor: `${theme.palette.themePrimary} !important`
            },
            thumb: {
                backgroundColor: `${theme.palette.white} !important`
            }
        };
    }
    return {
        root: {
            margin: 0
        }
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const SpokenLanguageSettingsDrawer = (props) => {
    var _a;
    /* @conditional-compile-remove(close-captions) */
    const theme = useTheme();
    /* @conditional-compile-remove(close-captions) */
    const onDrawerItemClick = React.useCallback((languageCode) => {
        props.selectLanguage(languageCode);
    }, [props]);
    /* @conditional-compile-remove(close-captions) */
    const drawerItems = React.useMemo(() => {
        var _a;
        return _getKeys((_a = props.supportedLanguageStrings) !== null && _a !== void 0 ? _a : []).map(languageCode => ({
            itemKey: languageCode,
            text: props.supportedLanguageStrings ? props.supportedLanguageStrings[languageCode] : languageCode,
            onItemClick: () => onDrawerItemClick(languageCode),
            secondaryIconProps: props.currentLanguage === languageCode ? {
                iconName: 'Accept'
            } : undefined
        }));
    }, [props.currentLanguage, props.supportedLanguageStrings, onDrawerItemClick]);
    const sortedDrawerItems = React.useMemo(() => {
        const copy = [...drawerItems];
        return copy.sort((a, b) => a.text && b.text && a.text > b.text ? 1 : -1);
    }, [drawerItems]);
    /* @conditional-compile-remove(close-captions) */
    return React.createElement(_DrawerMenu, { heading: (_a = props.strings) === null || _a === void 0 ? void 0 : _a.menuTitle, items: sortedDrawerItems !== null && sortedDrawerItems !== void 0 ? sortedDrawerItems : [], onLightDismiss: () => {
            props.setCurrentLanguage(props.currentLanguage);
            props.onLightDismiss();
        }, styles: captionSettingsDrawerStyles(theme) });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$d = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const inferCallWithChatControlOptions = (callWithChatControls) => {
    if (callWithChatControls === false) {
        return false;
    }
    const options = callWithChatControls === true || callWithChatControls === undefined ? {} : callWithChatControls;
    return options;
};
/** @private */
const MoreDrawer = (props) => {
    var _a, _b, _c, _d, _e, _f;
    /* @conditional-compile-remove(close-captions) */
    const theme = react.useTheme();
    /* @conditional-compile-remove(rooms) */
    const callAdapter = useAdapter();
    const drawerMenuItems = [];
    const { speakers, onSelectSpeaker, onLightDismiss } = props;
    /* @conditional-compile-remove(PSTN-calls) */ /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */ /* @conditional-compile-remove(raise-hand) */
    const localeStrings = useLocale();
    const callees = useSelector$1(getTargetCallees);
    const allowDtmfDialer = showDtmfDialer(callees);
    const [dtmfDialerChecked, setDtmfDialerChecked] = React.useState((_a = props.dtmfDialerPresent) !== null && _a !== void 0 ? _a : false);
    /* @conditional-compile-remove(raise-hand) */
    const raiseHandButtonProps = usePropsFor$1(RaiseHandButton);
    const onSpeakerItemClick = React.useCallback((_ev, itemKey) => {
        const selected = speakers === null || speakers === void 0 ? void 0 : speakers.find(speaker => speaker.id === itemKey);
        if (selected) {
            // This is unsafe - we're only passing in part of the argument to the handler.
            // But this is a known issue in our state.
            onSelectSpeaker(selected);
        }
        onLightDismiss();
    }, [speakers, onSelectSpeaker, onLightDismiss]);
    const drawerSelectionOptions = inferCallWithChatControlOptions(props.callControls);
    if (props.speakers && props.speakers.length > 0) {
        drawerMenuItems.push({
            itemKey: 'speakers',
            disabled: props.disableButtonsForHoldScreen,
            text: props.strings.speakerMenuTitle,
            iconProps: {
                iconName: 'MoreDrawerSpeakers'
            },
            subMenuProps: props.speakers.map(speaker => ({
                itemKey: speaker.id,
                iconProps: {
                    iconName: isDeviceSelected(speaker, props.selectedSpeaker) ? 'MoreDrawerSelectedSpeaker' : 'MoreDrawerSpeakers'
                },
                text: speaker.name,
                onItemClick: onSpeakerItemClick,
                secondaryIconProps: isDeviceSelected(speaker, props.selectedSpeaker) ? {
                    iconName: 'Accept'
                } : undefined
            })),
            secondaryText: (_b = props.selectedSpeaker) === null || _b === void 0 ? void 0 : _b.name
        });
    }
    const { microphones, onSelectMicrophone } = props;
    const onMicrophoneItemClick = React.useCallback((_ev, itemKey) => {
        const selected = microphones === null || microphones === void 0 ? void 0 : microphones.find(mic => mic.id === itemKey);
        if (selected) {
            // This is unsafe - we're only passing in part of the argument to the handler.
            // But this is a known issue in our state.
            onSelectMicrophone(selected);
        }
        onLightDismiss();
    }, [microphones, onSelectMicrophone, onLightDismiss]);
    if (props.microphones && props.microphones.length > 0) {
        // Set props as Microphone if speakers can be enumerated else set as Audio Device
        const speakersAvailable = props.speakers && props.speakers.length > 0;
        const itemKey = speakersAvailable ? 'microphones' : 'audioDevices';
        const text = speakersAvailable ? props.strings.microphoneMenuTitle : props.strings.audioDeviceMenuTitle;
        const iconName = speakersAvailable ? 'MoreDrawerMicrophones' : 'MoreDrawerSpeakers';
        const selectedIconName = speakersAvailable ? 'MoreDrawerSelectedMicrophone' : 'MoreDrawerSelectedSpeaker';
        drawerMenuItems.push({
            itemKey: itemKey,
            disabled: props.disableButtonsForHoldScreen,
            text: text,
            iconProps: {
                iconName: iconName
            },
            subMenuProps: props.microphones.map(mic => ({
                itemKey: mic.id,
                iconProps: {
                    iconName: isDeviceSelected(mic, props.selectedMicrophone) ? selectedIconName : iconName
                },
                text: mic.name,
                onItemClick: onMicrophoneItemClick,
                secondaryIconProps: isDeviceSelected(mic, props.selectedMicrophone) ? {
                    iconName: 'Accept'
                } : undefined,
                disabled: drawerSelectionOptions !== false ? isDisabled$3(drawerSelectionOptions.microphoneButton) : undefined
            })),
            secondaryText: (_c = props.selectedMicrophone) === null || _c === void 0 ? void 0 : _c.name
        });
    }
    const dtmfDialerScreenOption = {
        itemKey: 'dtmfDialerScreenKey',
        text: !dtmfDialerChecked ? localeStrings.strings.call.dtmfDialerMoreButtonLabelOn : localeStrings.strings.call.dtmfDialerMoreButtonLabelOff,
        onItemClick: () => {
            if (props.onSetDialpadPage) {
                props.onSetDialpadPage();
            }
            setDtmfDialerChecked(!dtmfDialerChecked);
            onLightDismiss();
        },
        iconProps: {
            iconName: 'DtmfDialpadButton',
            styles: {
                root: {
                    lineHeight: 0
                }
            }
        }
    };
    /**
     * Only render the dtmf dialer if the dialpad for PSTN calls is not present
     */
    if (props.onSetDialpadPage && allowDtmfDialer) {
        drawerMenuItems.push(dtmfDialerScreenOption);
    }
    const galleryLayoutOptions = {
        itemKey: 'galleryPositionKey',
        iconProps: {
            iconName: 'GalleryOptions',
            styles: {
                root: {
                    lineHeight: 0
                }
            }
        },
        disabled: props.disableButtonsForHoldScreen,
        text: localeStrings.strings.call.moreButtonGalleryControlLabel,
        subMenuProps: [{
                itemKey: 'dynamicSelectionKey',
                text: localeStrings.strings.call.moreButtonGalleryFloatingLocalLayoutLabel,
                onItemClick: () => {
                    props.onUserSetGalleryLayout && props.onUserSetGalleryLayout('floatingLocalVideo');
                    onLightDismiss();
                },
                iconProps: {
                    iconName: 'FloatingLocalVideoGalleryLayout',
                    styles: {
                        root: {
                            lineHeight: 0
                        }
                    }
                },
                secondaryIconProps: props.userSetGalleryLayout === 'floatingLocalVideo' ? {
                    iconName: 'Accept'
                } : undefined
            }, {
                itemKey: 'focusedContentSelectionKey',
                text: localeStrings.strings.call.moreButtonGalleryFocusedContentLayoutLabel,
                onItemClick: () => {
                    props.onUserSetGalleryLayout && props.onUserSetGalleryLayout('focusedContent');
                    onLightDismiss();
                },
                iconProps: {
                    iconName: 'FocusedContentGalleryLayout',
                    styles: {
                        root: {
                            lineHeight: 0
                        }
                    }
                },
                secondaryIconProps: props.userSetGalleryLayout === 'focusedContent' ? {
                    iconName: 'Accept'
                } : undefined
            }]
    };
    drawerMenuItems.push(galleryLayoutOptions);
    if (drawerSelectionOptions !== false && isEnabled(drawerSelectionOptions === null || drawerSelectionOptions === void 0 ? void 0 : drawerSelectionOptions.peopleButton)) {
        drawerMenuItems.push({
            itemKey: 'people',
            id: 'call-composite-drawer-people-button',
            text: props.strings.peopleButtonLabel,
            iconProps: {
                iconName: 'MoreDrawerPeople'
            },
            onItemClick: props.onPeopleButtonClicked,
            disabled: isDisabled$3(drawerSelectionOptions.peopleButton) || props.disableButtonsForHoldScreen
        });
    }
    /*@conditional-compile-remove(rooms) */
    const role = (_d = callAdapter.getState().call) === null || _d === void 0 ? void 0 : _d.role;
    /*@conditional-compile-remove(rooms) */
    const hideRaiseHandButtonInRoomsCall = callAdapter.getState().isRoomsCall && role && ['Consumer', 'Unknown'].includes(role);
    /* @conditional-compile-remove(raise-hand) */
    if (drawerSelectionOptions !== false && isEnabled(drawerSelectionOptions === null || drawerSelectionOptions === void 0 ? void 0 : drawerSelectionOptions.raiseHandButton) && /*@conditional-compile-remove(rooms) */ !hideRaiseHandButtonInRoomsCall) {
        const raiseHandIcon = raiseHandButtonProps.checked ? 'LowerHandContextualMenuItem' : 'RaiseHandContextualMenuItem';
        drawerMenuItems.push({
            itemKey: 'raiseHandButtonKey',
            disabled: props.disableButtonsForHoldScreen || isDisabled$3(drawerSelectionOptions.raiseHandButton),
            text: raiseHandButtonProps.checked ? localeStrings.component.strings.raiseHandButton.onLabel : localeStrings.component.strings.raiseHandButton.offLabel,
            onItemClick: () => {
                if (raiseHandButtonProps.onToggleRaiseHand) {
                    raiseHandButtonProps.onToggleRaiseHand();
                }
                onLightDismiss();
            },
            iconProps: {
                iconName: raiseHandIcon,
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            }
        });
    }
    /* @conditional-compile-remove(close-captions) */
    //Captions drawer menu
    const supportedSpokenLanguageStrings = useLocale().strings.call.spokenLanguageStrings;
    /* @conditional-compile-remove(close-captions) */
    //Captions drawer menu
    const supportedCaptionLanguageStrings = useLocale().strings.call.captionLanguageStrings;
    /* @conditional-compile-remove(close-captions) */
    const captionSettingsProp = useAdaptedSelector(_captionSettingsSelector);
    /* @conditional-compile-remove(close-captions) */
    const startCaptionsButtonHandlers = useHandlers();
    /* @conditional-compile-remove(close-captions) */
    const captionSettingsHandlers = useHandlers();
    /* @conditional-compile-remove(close-captions) */
    const [isSpokenLanguageDrawerOpen, setIsSpokenLanguageDrawerOpen] = React.useState(false);
    /* @conditional-compile-remove(close-captions) */
    const [isCaptionLanguageDrawerOpen, setIsCaptionLanguageDrawerOpen] = React.useState(false);
    /* @conditional-compile-remove(close-captions) */
    const [currentSpokenLanguage, setCurrentSpokenLanguage] = React.useState((_e = captionSettingsProp.currentSpokenLanguage) !== null && _e !== void 0 ? _e : 'en-us');
    /* @conditional-compile-remove(close-captions) */
    const [currentCaptionLanguage, setCurrentCaptionLanguage] = React.useState((_f = captionSettingsProp.currentCaptionLanguage) !== null && _f !== void 0 ? _f : _spokenLanguageToCaptionLanguage[currentSpokenLanguage]);
    /* @conditional-compile-remove(close-captions) */
    const onToggleChange = React.useCallback(() => __awaiter$d(void 0, void 0, void 0, function* () {
        if (!captionSettingsProp.isCaptionsFeatureActive) {
            yield startCaptionsButtonHandlers.onStartCaptions({
                spokenLanguage: currentSpokenLanguage
            });
        }
        else {
            startCaptionsButtonHandlers.onStopCaptions();
        }
    }), [captionSettingsProp.isCaptionsFeatureActive, startCaptionsButtonHandlers, currentSpokenLanguage]);
    /* @conditional-compile-remove(close-captions) */
    if (props.isCaptionsSupported) {
        const captionsDrawerItems = [];
        const spokenLanguageString = supportedSpokenLanguageStrings ? supportedSpokenLanguageStrings[currentSpokenLanguage] : currentSpokenLanguage;
        const captionLanguageString = supportedCaptionLanguageStrings ? supportedCaptionLanguageStrings[currentCaptionLanguage] : currentCaptionLanguage;
        drawerMenuItems.push({
            itemKey: 'captions',
            id: 'common-call-composite-captions-button',
            disabled: props.disableButtonsForHoldScreen,
            text: props.strings.captionsMenuTitle,
            iconProps: {
                iconName: 'CaptionsIcon'
            },
            subMenuProps: captionsDrawerItems
        });
        captionsDrawerItems.push({
            itemKey: 'ToggleCaptionsKey',
            text: captionSettingsProp.isCaptionsFeatureActive ? localeStrings.strings.call.startCaptionsButtonTooltipOnContent : localeStrings.strings.call.startCaptionsButtonTooltipOffContent,
            iconProps: {
                iconName: captionSettingsProp.isCaptionsFeatureActive ? 'CaptionsOffIcon' : 'CaptionsIcon',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            onItemClick: onToggleChange,
            disabled: props.disableButtonsForHoldScreen,
            secondaryComponent: React.createElement(react.Stack, { verticalFill: true, verticalAlign: "center" },
                React.createElement(react.Toggle, { id: "common-call-composite-captions-toggle-button", checked: captionSettingsProp.isCaptionsFeatureActive, styles: themedToggleButtonStyle(theme, captionSettingsProp.isCaptionsFeatureActive), onChange: onToggleChange }))
        });
        captionsDrawerItems.push({
            itemKey: 'ChangeSpokenLanguage',
            text: props.strings.spokenLanguageMenuTitle,
            id: 'common-call-composite-captions-spoken-settings-button',
            secondaryText: spokenLanguageString,
            iconProps: {
                iconName: 'ChangeSpokenLanguageIcon',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            disabled: props.disableButtonsForHoldScreen || !captionSettingsProp.isCaptionsFeatureActive,
            onItemClick: () => {
                setIsSpokenLanguageDrawerOpen(true);
            },
            secondaryIconProps: {
                iconName: 'ChevronRight',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            }
        });
        captionsDrawerItems.push({
            itemKey: 'ChangeCaptionLanguage',
            text: props.strings.captionLanguageMenuTitle,
            id: 'common-call-composite-captions-subtitle-settings-button',
            secondaryText: captionLanguageString,
            iconProps: {
                iconName: 'ChangeCaptionLanguageIcon',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            },
            disabled: props.disableButtonsForHoldScreen || !captionSettingsProp.isCaptionsFeatureActive,
            onItemClick: () => {
                setIsCaptionLanguageDrawerOpen(true);
            },
            secondaryIconProps: {
                iconName: 'ChevronRight',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            }
        });
    }
    /* @conditional-compile-remove(control-bar-button-injection) */
    const customDrawerButtons = React.useMemo(() => generateCustomCallDrawerButtons(onFetchCustomButtonPropsTrampoline(drawerSelectionOptions !== false ? drawerSelectionOptions : undefined), drawerSelectionOptions !== false ? drawerSelectionOptions === null || drawerSelectionOptions === void 0 ? void 0 : drawerSelectionOptions.displayType : undefined), [drawerSelectionOptions]);
    /* @conditional-compile-remove(control-bar-button-injection) */
    customDrawerButtons['primary'].slice(CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_MOBILE_CUSTOM_BUTTONS).forEach(element => {
        drawerMenuItems.push(element);
    });
    /* @conditional-compile-remove(control-bar-button-injection) */
    customDrawerButtons['secondary'].forEach(element => {
        drawerMenuItems.push(element);
    });
    /* @conditional-compile-remove(control-bar-button-injection) */
    customDrawerButtons['overflow'].forEach(element => {
        drawerMenuItems.push(element);
    });
    /* @conditional-compile-remove(close-captions) */
    return React.createElement(React.Fragment, null,
        isSpokenLanguageDrawerOpen && props.isCaptionsSupported && React.createElement(SpokenLanguageSettingsDrawer, { onLightDismiss: props.onLightDismiss, selectLanguage: setCurrentSpokenLanguage, setCurrentLanguage: captionSettingsHandlers.onSetSpokenLanguage, currentLanguage: currentSpokenLanguage, strings: {
                menuTitle: props.strings.spokenLanguageMenuTitle
            }, supportedLanguageStrings: supportedSpokenLanguageStrings }),
        isCaptionLanguageDrawerOpen && props.isCaptionsSupported && React.createElement(CaptionLanguageSettingsDrawer, { onLightDismiss: props.onLightDismiss, selectLanguage: setCurrentCaptionLanguage, setCurrentLanguage: captionSettingsHandlers.onSetCaptionLanguage, currentLanguage: currentCaptionLanguage, strings: {
                menuTitle: props.strings.captionLanguageMenuTitle
            }, supportedLanguageStrings: supportedCaptionLanguageStrings }),
        !isSpokenLanguageDrawerOpen && !isCaptionLanguageDrawerOpen && React.createElement(_DrawerMenu, { items: drawerMenuItems, onLightDismiss: props.onLightDismiss }));
};
const isDeviceSelected = (speaker, selectedSpeaker) => !!selectedSpeaker && speaker.id === selectedSpeaker.id;
const isEnabled = (option) => option !== false;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const moreDrawerSelector = reselect__namespace.createSelector([getDeviceManager], deviceManager => {
    return {
        microphones: deviceManager.microphones,
        speakers: deviceManager.speakers,
        selectedMicrophone: deviceManager.selectedMicrophone,
        selectedSpeaker: deviceManager.selectedSpeaker
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const PreparedMoreDrawer = (props) => {
    const strings = useCallWithChatCompositeStrings();
    const moreDrawerStrings = React.useMemo(() => ({
        peopleButtonLabel: strings.peopleButtonLabel,
        audioDeviceMenuTitle: strings.moreDrawerAudioDeviceMenuTitle,
        microphoneMenuTitle: strings.moreDrawerMicrophoneMenuTitle,
        speakerMenuTitle: strings.moreDrawerSpeakerMenuTitle,
        /* @conditional-compile-remove(close-captions) */
        captionsMenuTitle: strings.moreDrawerCaptionsMenuTitle,
        /* @conditional-compile-remove(close-captions) */
        spokenLanguageMenuTitle: strings.moreDrawerSpokenLanguageMenuTitle,
        /* @conditional-compile-remove(close-captions) */
        captionLanguageMenuTitle: strings.moreDrawerCaptionLanguageMenuTitle,
        galleryOptionsMenuTitle: strings.moreDrawerGalleryOptionsMenuTitle
    }), [strings]);
    const deviceProps = useSelector$1(moreDrawerSelector);
    const callHandlers = useHandlers();
    return React.createElement(MoreDrawer, Object.assign({}, props, deviceProps, callHandlers, { strings: moreDrawerStrings }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const DEFAULT_Z_INDEX = 1;
const mainScreenContainerStyle = {
    height: '100%',
    width: '100%'
};
/**
 * @private
 */
const mainScreenContainerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, mainScreenContainerStyle), { minWidth: '30rem', 
    // max of min-width of composite pages (Call page)
    minHeight: '22rem' // max height of min-height of composite pages (Configuration page)
 }));
/**
 * @private
 */
const mainScreenContainerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, mainScreenContainerStyle), { minWidth: '17.5rem', 
    // max of min-width of composite pages (Call page)
    minHeight: '13rem' // max height of min-height of composite pages (Configuration page & Call page)
 }));
/**
 * @private
 * Drawer styles to be used to house the _DrawerComponent on top of other content on the screen.
 * @param zIndex: this defaults to DEFAULT_Z_INDEX if unset
 */
const drawerContainerStyles = (zIndex = DEFAULT_Z_INDEX) => ({
    root: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        // Any zIndex > 0 will work because this is the only absolutely
        // positioned element in the container.
        zIndex: zIndex
    }
});
/**
 * @private
 * Page container style for leaving page
 */
const leavingPageStyle = (palette) => ({
    background: palette.neutralLighterAlt
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const SIDE_PANE_PADDING_LR_REM = 0.25;
/**
 * @private
 */
const mobilePaneStyle = {
    root: {
        width: '100%',
        height: '100%'
    }
};
/**
 * @private
 */
react.concatStyleSets(mobilePaneStyle, {
    root: {
        display: 'none'
    }
});
/**
 * @private
 */
const mobilePaneControlBarStyle = {
    root: {
        height: '3rem'
    }
};
/**
 * @private
 */
const mobilePaneBackButtonStyles = {
    root: {
        border: 'none',
        minWidth: '2.5rem',
        maxWidth: '2.875rem',
        height: '100%',
        background: 'none',
        padding: '0 1rem'
    },
    rootChecked: {
        background: 'none'
    },
    rootCheckedHovered: {
        background: 'none'
    }
};
/**
 * @private
 */
const mobilePaneHiddenIconStyles = react.concatStyleSets(mobilePaneBackButtonStyles, {
    root: {
        visibility: 'hidden'
    }
});
/**
 * @private
 */
const mobilePaneButtonStyles = {
    root: {
        border: 'none',
        borderBottom: '0.125rem solid transparent',
        width: '8rem',
        height: '100%',
        background: 'none',
        padding: '0'
    },
    rootChecked: {
        background: 'none'
    },
    rootCheckedHovered: {
        background: 'none'
    },
    flexContainer: {
        flexFlow: 'column',
        display: 'contents'
    },
    label: {
        fontSize: '1rem',
        fontWeight: 100,
        lineHeight: '2rem',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
    },
    labelChecked: {
        fontWeight: 600
    }
};
/**
 * @private
 */
const hiddenStyles = {
    root: {
        display: 'none'
    }
};
/**
 * @private
 */
const sidePaneStyles = (maxWidth, minWidth) => ({
    root: {
        height: 'auto',
        width: '100%',
        padding: `0.5rem ${SIDE_PANE_PADDING_LR_REM}rem`,
        maxWidth: maxWidth !== null && maxWidth !== void 0 ? maxWidth : '21.5rem',
        minWidth: minWidth !== null && minWidth !== void 0 ? minWidth : `${CHAT_CONTAINER_MIN_WIDTH_REM + SIDE_PANE_PADDING_LR_REM * 2}rem`
    }
});
/**
 * @private
 */
const availableSpaceStyles = {
    root: {
        width: '100%',
        height: '100%'
    }
};
/**
 * @private
 */
const sidePaneTokens = {
    childrenGap: '0.5rem'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Context for side pane interaction
 *
 * @private
 */
const SidePaneContext = React.createContext({});
/**
 * Provider to provide localized strings for this library's composites.
 *
 * @private
 */
const SidePaneProvider = (props) => {
    return React.createElement(SidePaneContext.Provider, { value: props }, props.children);
};
/** @private */
const useSidePaneContext = () => React.useContext(SidePaneContext);
/** @private */
const useIsSidePaneOpen = () => {
    const { sidePaneRenderer, overrideSidePane } = useSidePaneContext();
    return !!(sidePaneRenderer || (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive));
};
/** @private */
const useIsParticularSidePaneOpen = (sidePaneId) => {
    const isSidePaneOpen = useIsSidePaneOpen();
    const { sidePaneRenderer } = useSidePaneContext();
    return isSidePaneOpen && (sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id) === sidePaneId;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Legacy header to be removed when we make a breaking change.
 * @private
 */
const PeopleAndChatHeader = (props) => {
    const { onClose, onChatButtonClicked, onPeopleButtonClicked, activeTab } = props;
    const theme = useTheme();
    const strings = useLocale().strings.call;
    const haveMultipleTabs = onChatButtonClicked && onPeopleButtonClicked;
    const mobilePaneButtonStylesThemed = React.useMemo(() => {
        return react.concatStyleSets(mobilePaneButtonStyles, {
            root: {
                width: '100%'
            },
            label: {
                fontSize: theme.fonts.medium.fontSize,
                fontWeight: theme.fonts.medium.fontWeight
            }
        }, haveMultipleTabs ? {
            rootChecked: {
                borderBottom: `0.125rem solid ${theme.palette.themePrimary}`
            }
        } : {});
    }, [theme, haveMultipleTabs]);
    return React.createElement(react.Stack, { horizontal: true, grow: true, styles: mobilePaneControlBarStyle },
        React.createElement(react.DefaultButton, { ariaLabel: strings.returnToCallButtonAriaLabel, ariaDescription: strings.returnToCallButtonAriaDescription, onClick: onClose, styles: mobilePaneBackButtonStyles, onRenderIcon: () => React.createElement(CallWithChatCompositeIcon, { iconName: "ChevronLeft" }), autoFocus: true }),
        React.createElement(react.Stack.Item, { grow: true, role: "tablist" },
            React.createElement(react.FocusZone, { direction: react.FocusZoneDirection.horizontal, className: react.mergeStyles(availableSpaceStyles.root) },
                React.createElement(react.Stack, { horizontal: true, styles: availableSpaceStyles },
                    React.createElement(react.Stack.Item, { grow: true }, onChatButtonClicked && React.createElement(react.DefaultButton, { onClick: onChatButtonClicked, styles: mobilePaneButtonStylesThemed, checked: activeTab === 'chat', "aria-selected": activeTab === 'chat', role: 'tab', disabled: props.disableChatButton }, strings.chatButtonLabel)),
                    React.createElement(react.Stack.Item, { grow: true }, onPeopleButtonClicked && React.createElement(react.DefaultButton, { onClick: onPeopleButtonClicked, styles: mobilePaneButtonStylesThemed, checked: activeTab === 'people', "aria-selected": activeTab === 'people', role: 'tab', disabled: props.disablePeopleButton }, strings.peopleButtonLabel))))),
        props.onHeaderMenuClick ? React.createElement(react.DefaultButton, { ariaLabel: strings.peoplePaneMoreButtonAriaLabel, styles: react.concatStyleSets(mobilePaneBackButtonStyles, {
                icon: {
                    display: 'flex',
                    alignItems: 'center'
                }
            }), iconProps: {
                iconName: 'PeoplePaneMoreButton'
            }, onClick: props.onHeaderMenuClick }) : ( /* Hidden icon to take the same space as the actual back button on the left. */React.createElement(react.DefaultButton, { styles: mobilePaneHiddenIconStyles, onRenderIcon: () => React.createElement(CallWithChatCompositeIcon, { iconName: "ChevronLeft" }) })));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const SidePane = (props) => {
    var _a;
    const { sidePaneRenderer, overrideSidePane } = useSidePaneContext();
    const renderingHiddenOverrideContent = (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.renderer.contentRenderer) && overrideSidePane.persistRenderingWhenClosed && !overrideSidePane.isActive;
    const renderingOnlyHiddenContent = renderingHiddenOverrideContent && !sidePaneRenderer;
    const widthConstrainedStyles = React.useMemo(() => sidePaneStyles(props.maxWidth, props.minWidth), [props.maxWidth, props.minWidth]);
    const paneStyles = renderingOnlyHiddenContent ? hiddenStyles : props.mobileView ? availableSpaceStyles : widthConstrainedStyles;
    const Header = (_a = ((overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive) ? overrideSidePane.renderer.headerRenderer : sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.headerRenderer)) !== null && _a !== void 0 ? _a : EmptyElement;
    /**
     * Legacy code to support old behavior of showing chat and people tab headers on mobile side pane.
     * To be removed in breaking change.
     */
    const overrideSidePaneId = (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive) ? overrideSidePane.renderer.id : undefined;
    const { updateSidePaneRenderer } = props;
    const closePane = React.useCallback(() => {
        updateSidePaneRenderer(undefined);
    }, [updateSidePaneRenderer]);
    const LegacyHeader = React.useMemo(() => {
        var _a;
        return React.createElement(PeopleAndChatHeader, { onClose: overrideSidePaneId === 'chat' ? (_a = props.onChatButtonClicked) !== null && _a !== void 0 ? _a : noop : closePane, activeTab: (sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id) === 'people' ? 'people' : 'chat', 
            // legacy arguments to be removed in breaking change:
            disablePeopleButton: props.disablePeopleButton, disableChatButton: props.disableChatButton, onPeopleButtonClicked: (sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id) === 'people' ? noop : props.onPeopleButtonClicked, onChatButtonClicked: overrideSidePaneId === 'chat' ? noop : props.onChatButtonClicked, onHeaderMenuClick: props.onHeaderMenuClick });
    }, [overrideSidePaneId, props.onChatButtonClicked, props.onPeopleButtonClicked, props.disablePeopleButton, props.disableChatButton, props.onHeaderMenuClick, sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id, closePane]);
    const HeaderToRender = props.mobileView && (overrideSidePaneId === 'chat' || (sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id) === 'people') ? LegacyHeader : Header();
    const ContentRender = (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive) ? undefined : sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.contentRenderer;
    const OverrideContentRender = (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive) || (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.persistRenderingWhenClosed) ? overrideSidePane.renderer.contentRenderer : undefined;
    if (!ContentRender && !OverrideContentRender) {
        return React.createElement(EmptyElement, null);
    }
    return React.createElement(react.Stack, { verticalFill: true, grow: true, styles: paneStyles, "data-ui-id": "SidePane", tokens: props.mobileView ? {} : sidePaneTokens },
        HeaderToRender,
        React.createElement(react.Stack.Item, { verticalFill: true, grow: true, styles: paneBodyContainer },
            React.createElement(react.Stack, { verticalFill: true, styles: scrollableContainer },
                ContentRender && React.createElement(react.Stack.Item, { verticalFill: true, styles: scrollableContainerContents },
                    React.createElement(react.Stack, { styles: containerContextStyles },
                        React.createElement(ContentRender, null))),
                OverrideContentRender && React.createElement(react.Stack.Item, { verticalFill: true, styles: !(overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive) && (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.persistRenderingWhenClosed) ? hiddenStyles : scrollableContainerContents },
                    React.createElement(react.Stack, { styles: containerContextStyles },
                        React.createElement(OverrideContentRender, null))))));
};
// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => { };
const EmptyElement = () => React.createElement(React.Fragment, null);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const SidePaneHeader = (props) => {
    const theme = useTheme();
    const sidePaneCloseButtonStyles = React.useMemo(() => ({
        root: {
            minWidth: '1.5rem',
            padding: '0.5rem 0.25rem',
            marginRight: '0.25rem',
            backgroundColor: theme.semanticColors.bodyBackground
        },
        icon: {
            color: theme.palette.neutralSecondary
        },
        iconHovered: {
            color: theme.palette.neutralSecondary
        },
        iconPressed: {
            color: theme.palette.neutralSecondary
        }
    }), [theme.palette.neutralSecondary, theme.semanticColors.bodyBackground]);
    if (props.mobileView) {
        return React.createElement(SidePaneMobileHeader, Object.assign({}, props));
    }
    return React.createElement(react.Stack, { horizontal: true, horizontalAlign: "space-between", styles: sidePaneHeaderContainerStyles, verticalAlign: "center" },
        React.createElement(react.Stack.Item, { role: "heading", styles: sidePaneHeaderStyles }, props.headingText),
        React.createElement(react.Stack.Item, null,
            React.createElement(react.CommandBarButton, { ariaLabel: props.dismissSidePaneButtonAriaLabel, styles: sidePaneCloseButtonStyles, iconProps: {
                    iconName: 'cancel'
                }, onClick: props.onClose })));
};
const SidePaneMobileHeader = (props) => {
    const { headingText, dismissSidePaneButtonAriaLabel, dismissSidePaneButtonAriaDescription, onClose } = props;
    const theme = useTheme();
    const mobilePaneButtonStylesThemed = React.useMemo(() => {
        return react.concatStyleSets(mobilePaneButtonStyles, {
            root: {
                width: '100%'
            },
            label: {
                fontSize: theme.fonts.medium.fontSize,
                fontWeight: theme.fonts.medium.fontWeight
            }
        });
    }, [theme]);
    return React.createElement(react.Stack, { horizontal: true, grow: true, styles: mobilePaneControlBarStyle },
        React.createElement(react.DefaultButton, { ariaLabel: dismissSidePaneButtonAriaLabel, ariaDescription: dismissSidePaneButtonAriaDescription, onClick: onClose, styles: mobilePaneBackButtonStyles, onRenderIcon: () => React.createElement(CallWithChatCompositeIcon, { iconName: "ChevronLeft" }), autoFocus: true }),
        React.createElement(react.Stack.Item, { grow: true },
            React.createElement(react.DefaultButton, { checked: true, styles: mobilePaneButtonStylesThemed }, headingText)),
        React.createElement(react.DefaultButton, { styles: mobilePaneHiddenIconStyles, ariaHidden: true, onRenderIcon: () => React.createElement(CallWithChatCompositeIcon, { iconName: "ChevronLeft" }) }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const ParticipantListWithHeading = (props) => {
    const { onFetchAvatarPersonaData, onFetchParticipantMenuItems, title, participantListProps } = props;
    const subheadingUniqueId = reactHooks.useId();
    const theme = react.useTheme();
    const subheadingStyleThemed = React.useMemo(() => ({
        root: {
            color: theme.palette.neutralSecondary,
            margin: props.isMobile ? '0.5rem 1rem' : '0.5rem',
            fontSize: theme.fonts.smallPlus.fontSize
        }
    }), [theme.palette.neutralSecondary, theme.fonts.smallPlus.fontSize, props.isMobile]);
    return React.createElement(react.Stack, { className: participantListStack },
        React.createElement(react.Stack.Item, { styles: subheadingStyleThemed, "aria-label": title, id: subheadingUniqueId }, paneTitleTrampoline(title !== null && title !== void 0 ? title : '')),
        React.createElement(react.FocusZone, { className: participantListContainerStyle, shouldFocusOnMount: true },
            React.createElement(ParticipantList$k, Object.assign({}, participantListProps, { styles: props.isMobile ? participantListMobileStyle : participantListStyle, onRenderAvatar: (userId, options) => React.createElement(React.Fragment, null,
                    React.createElement(AvatarPersona, Object.assign({ "data-ui-id": "chat-composite-participant-custom-avatar", userId: userId }, options, { hidePersonaDetails: !!(options === null || options === void 0 ? void 0 : options.text), dataProvider: onFetchAvatarPersonaData, 
                        /* @conditional-compile-remove(raise-hand) */ allowActiveBorder: true })),
                    (options === null || options === void 0 ? void 0 : options.text) && React.createElement(react.Text, { nowrap: true, styles: displayNameStyles$1 }, options === null || options === void 0 ? void 0 : options.text)), onFetchParticipantMenuItems: onFetchParticipantMenuItems, showParticipantOverflowTooltip: !props.isMobile, participantAriaLabelledBy: subheadingUniqueId }))));
};
const paneTitleTrampoline = (paneTitle, totalParticipantCount) => {
    const participantCountString = totalParticipantCount ? {
        numberOfPeople: `(${totalParticipantCount})`
    } : {
        numberOfPeople: ' '
    };
    return _formatString(paneTitle, participantCountString);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
/**
 * @private
 */
const peoplePaneContainerStyle = {
    root: {
        position: 'relative',
        maxHeight: '100%',
        overflow: 'hidden'
    }
};
/**
 * @private
 */
const participantListContainerStyles = {
    root: {
        overflowY: 'scroll'
    }
};
/**
 * @private
 */
const copyLinkButtonContainerStyles = {
    root: {
        width: '100%',
        padding: '0.5rem 1rem'
    }
};
/**
 * @private
 */
const copyLinkButtonStackStyles = {
    root: {
        marginLeft: '0.5rem',
        marginRight: '0.5rem'
    }
};
/**
 * @private
 */
const copyLinkButtonStyles = {
    root: {
        height: '2.5rem',
        width: '100%'
    },
    textContainer: {
        display: 'contents'
    }
};
/**
 * @private
 */
const linkIconStyles = {
    marginRight: '0.5rem'
};
/**
 * @private
 */
const themedCopyLinkButtonStyles = (mobileView, theme) => ({
    root: {
        minHeight: mobileView ? '3rem' : '2.5rem',
        borderRadius: mobileView ? theme.effects.roundedCorner6 : theme.effects.roundedCorner4
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Convert IContextualMenuItem to _DrawerMenuItemProps
 * @param contextualMenu - IContextualMenuItem to convert
 * @param onDrawerMenuItemClick - callback to call when converted DrawerMenuItem is clicked
 * @returns DrawerMenuItem
 * @private
 */
const convertContextualMenuItemToDrawerMenuItem = (contextualMenu, onDrawerMenuItemClick) => {
    return {
        itemKey: contextualMenu.key,
        onItemClick: () => {
            var _a;
            (_a = contextualMenu.onClick) === null || _a === void 0 ? void 0 : _a.call(contextualMenu);
            onDrawerMenuItemClick();
        },
        iconProps: contextualMenu.iconProps,
        text: contextualMenu.text,
        disabled: contextualMenu.disabled
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const AddPeopleButton = (props) => {
    const { inviteLink, mobileView, strings, participantList } = props;
    const theme = react.useTheme();
    const [copyInviteLinkAnnouncerStrings, setCopyInviteLinkAnnouncerStrings] = React.useState('');
    const copyLinkButtonStylesThemed = React.useMemo(() => react.concatStyleSets(copyLinkButtonStyles, themedCopyLinkButtonStyles(mobileView, theme)), [mobileView, theme]);
    /**
     * sets the announcement string for when the link is copied.
     */
    const toggleAnnouncerString = React.useCallback(() => {
        setCopyInviteLinkAnnouncerStrings(strings.copyInviteLinkActionedAriaLabel);
        /**
         * Clears the announcer string after the user clicks the
         * copyInviteLink button allowing it to be re-announced.
         */
        setTimeout(() => {
            setCopyInviteLinkAnnouncerStrings('');
        }, 3000);
    }, [strings.copyInviteLinkActionedAriaLabel]);
    if (mobileView) {
        return React.createElement(react.Stack, null, inviteLink && React.createElement(react.Stack.Item, { styles: copyLinkButtonContainerStyles },
            React.createElement(Announcer, { announcementString: copyInviteLinkAnnouncerStrings, ariaLive: 'polite' }),
            React.createElement(react.PrimaryButton, { onClick: () => {
                    copy(inviteLink !== null && inviteLink !== void 0 ? inviteLink : '');
                    toggleAnnouncerString();
                }, styles: copyLinkButtonStylesThemed, onRenderIcon: () => React.createElement(CallWithChatCompositeIcon, { iconName: "Link", style: linkIconStyles }), text: strings.copyInviteLinkButtonLabel })));
    }
    else {
        return React.createElement(react.Stack, { tokens: peoplePaneContainerTokens, "data-ui-id": "people-pane-content", verticalFill: true },
            inviteLink && React.createElement(react.Stack, { styles: copyLinkButtonStackStyles },
                React.createElement(Announcer, { announcementString: copyInviteLinkAnnouncerStrings, ariaLive: 'polite' }),
                React.createElement(react.DefaultButton, { text: strings.copyInviteLinkButtonLabel, onRenderIcon: () => React.createElement(CallWithChatCompositeIcon, { iconName: "Link", style: linkIconStyles }), onClick: () => {
                        copy(inviteLink !== null && inviteLink !== void 0 ? inviteLink : '');
                        toggleAnnouncerString();
                    }, styles: copyLinkButtonStylesThemed })),
            React.createElement(react.Stack.Item, { grow: true, styles: {
                    root: {
                        overflowY: 'hidden'
                    }
                } }, participantList));
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$c = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const PeoplePaneContent = (props) => {
    const { inviteLink, onFetchParticipantMenuItems, setDrawerMenuItems } = props;
    const adapter = useAdapter();
    const localeStrings = useLocale();
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    const getStrings = () => {
        return localeStrings.strings.callWithChat;
    };
    const strings = getStrings();
    const removeParticipantFromCall = React.useCallback((participantId) => __awaiter$c(void 0, void 0, void 0, function* () {
        yield adapter.removeParticipant(participantId);
    }), [adapter]);
    const participantListDefaultProps = usePropsFor$1(ParticipantList$k);
    const removeButtonAllowed = hasRemoveParticipantsPermissionTrampoline(adapter);
    const setDrawerMenuItemsForParticipant = React.useMemo(() => {
        return (participant) => {
            if (participant) {
                let contextualMenuItems = createDefaultContextualMenuItems(participant, strings, removeButtonAllowed && participant.isRemovable ? participantListDefaultProps.onRemoveParticipant : undefined, participantListDefaultProps.myUserId);
                if (onFetchParticipantMenuItems) {
                    contextualMenuItems = onFetchParticipantMenuItems(participant.userId, participantListDefaultProps.myUserId, contextualMenuItems);
                }
                const drawerMenuItems = contextualMenuItems.map((contextualMenu) => convertContextualMenuItemToDrawerMenuItem(contextualMenu, () => setDrawerMenuItems([])));
                setDrawerMenuItems(drawerMenuItems);
            }
        };
    }, [strings, participantListDefaultProps.onRemoveParticipant, participantListDefaultProps.myUserId, removeButtonAllowed, onFetchParticipantMenuItems, setDrawerMenuItems]);
    const participantListProps = React.useMemo(() => {
        const onRemoveAParticipant = (participantId) => __awaiter$c(void 0, void 0, void 0, function* () { return removeParticipantFromCall(participantId); });
        return Object.assign(Object.assign({}, participantListDefaultProps), { 
            // Passing undefined callback for mobile to avoid context menus for participants in ParticipantList are clicked
            onRemoveParticipant: props.mobileView ? undefined : onRemoveAParticipant, 
            // We want the drawer menu items to appear when participants in ParticipantList are clicked
            onParticipantClick: props.mobileView ? setDrawerMenuItemsForParticipant : undefined });
    }, [participantListDefaultProps, props.mobileView, setDrawerMenuItemsForParticipant, removeParticipantFromCall]);
    const participantList = React.createElement(ParticipantListWithHeading, { isMobile: props.mobileView, participantListProps: participantListProps, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData, onFetchParticipantMenuItems: props.mobileView ? undefined : onFetchParticipantMenuItems, title: strings.peoplePaneSubTitle });
    if (props.mobileView) {
        return React.createElement(react.Stack, { verticalFill: true, styles: peoplePaneContainerStyle, tokens: peoplePaneContainerTokens, "data-ui-id": "people-pane-content" },
            React.createElement(react.Stack.Item, { grow: true, styles: participantListContainerStyles }, participantList),
            React.createElement(AddPeopleButton, { inviteLink: inviteLink, mobileView: props.mobileView, participantList: participantList, strings: strings }));
    }
    return React.createElement(AddPeopleButton, { inviteLink: inviteLink, mobileView: props.mobileView, participantList: participantList, strings: strings });
};
/**
 * Create default contextual menu items for particant
 * @param participant - participant to create contextual menu items for
 * @param strings - localized strings for menu item text
 * @param onRemoveParticipant - callback to remove participant
 * @param localParticipantUserId - Local participant user id
 * @returns - IContextualMenuItem[]
 */
const createDefaultContextualMenuItems = (participant, strings, onRemoveParticipant, localParticipantUserId) => {
    const menuItems = [];
    if (onRemoveParticipant && (participant === null || participant === void 0 ? void 0 : participant.userId) !== localParticipantUserId) {
        menuItems.push({
            key: 'remove',
            text: strings.removeMenuLabel,
            onClick: () => {
                if (participant === null || participant === void 0 ? void 0 : participant.userId) {
                    onRemoveParticipant === null || onRemoveParticipant === void 0 ? void 0 : onRemoveParticipant(participant === null || participant === void 0 ? void 0 : participant.userId);
                }
            },
            iconProps: {
                iconName: 'UserRemove'
            },
            'data-ui-id': 'participant-list-remove-participant-button'
        });
    }
    return menuItems;
};
/**
 * @private
 */
const hasRemoveParticipantsPermissionTrampoline = (adapter) => {
    var _a;
    /* @conditional-compile-remove(rooms) */
    const role = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.role;
    /* @conditional-compile-remove(rooms) */
    const canRemove = role === 'Presenter' || role === 'Unknown' || role === undefined;
    /* @conditional-compile-remove(rooms) */
    return canRemove;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const PEOPLE_SIDE_PANE_ID = 'people';
/** @private */
const usePeoplePane = (props) => {
    const { updateSidePaneRenderer, inviteLink, onFetchAvatarPersonaData, onFetchParticipantMenuItems, setDrawerMenuItems, mobileView, peopleButtonRef } = props;
    const closePane = React.useCallback(() => {
        var _a;
        updateSidePaneRenderer(undefined);
        (_a = peopleButtonRef === null || peopleButtonRef === void 0 ? void 0 : peopleButtonRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, [peopleButtonRef, updateSidePaneRenderer]);
    const localeStrings = useLocale().strings.call;
    const onRenderHeader = React.useCallback(() => React.createElement(SidePaneHeader, { onClose: closePane, headingText: localeStrings.peoplePaneTitle, dismissSidePaneButtonAriaLabel: localeStrings.dismissSidePaneButtonLabel, mobileView: mobileView !== null && mobileView !== void 0 ? mobileView : false }), [mobileView, closePane, localeStrings]);
    let _onFetchParticipantMenuItems = onFetchParticipantMenuItems;
    const onRenderContent = React.useCallback(() => {
        return React.createElement(PeoplePaneContent, { inviteLink: inviteLink, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onFetchParticipantMenuItems: _onFetchParticipantMenuItems, setDrawerMenuItems: setDrawerMenuItems, mobileView: mobileView });
    }, [inviteLink, mobileView, onFetchAvatarPersonaData, _onFetchParticipantMenuItems, setDrawerMenuItems]);
    const sidePaneRenderer = React.useMemo(() => ({
        headerRenderer: onRenderHeader,
        contentRenderer: onRenderContent,
        id: PEOPLE_SIDE_PANE_ID
    }), [onRenderContent, onRenderHeader]);
    const openPane = React.useCallback(() => {
        updateSidePaneRenderer(sidePaneRenderer);
    }, [sidePaneRenderer, updateSidePaneRenderer]);
    const isOpen = useIsParticularSidePaneOpen(PEOPLE_SIDE_PANE_ID);
    // Update pane renderer if it is open and the openPane dep changes
    React.useEffect(() => {
        if (isOpen) {
            openPane();
        }
    }, [isOpen, openPane]);
    return {
        openPeoplePane: openPane,
        closePeoplePane: closePane,
        isPeoplePaneOpen: isOpen
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(video-background-effects) */
/* @conditional-compile-remove(video-background-effects) */
/**
 * @private
 */
const activeVideoBackgroundEffectSelector = reselect__namespace.createSelector([getSelectedVideoEffect], (selectedVideoBackgroundEffect) => {
    if (selectedVideoBackgroundEffect && (selectedVideoBackgroundEffect.effectName === 'blur' || selectedVideoBackgroundEffect.effectName === 'none')) {
        return selectedVideoBackgroundEffect.effectName;
    }
    else if (selectedVideoBackgroundEffect && selectedVideoBackgroundEffect.effectName === 'replacement') {
        return selectedVideoBackgroundEffect === null || selectedVideoBackgroundEffect === void 0 ? void 0 : selectedVideoBackgroundEffect.key;
    }
    return 'none';
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const localVideoSelector = reselect__namespace.createSelector([callStatusSelector, getDeviceManager, getLocalVideoStreams], (callStatus, deviceManager, localVideoStreams) => {
    var _a, _b;
    let localVideoStream;
    if (_isInCall(callStatus.callStatus)) {
        localVideoStream = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(i => i.mediaStreamType === 'Video');
    }
    else if (_isPreviewOn(deviceManager)) {
        // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
        // handle cases where 'Preview' view is in progress and not necessary completed.
        localVideoStream = deviceManager.unparentedViews[0];
    }
    return {
        isAvailable: !!localVideoStream,
        isMirrored: (_a = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
        renderElement: (_b = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _b === void 0 ? void 0 : _b.target,
        /* @conditional-compile-remove(video-background-effects) */
        activeVideoEffects: localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.videoEffects
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$b = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Pane that is used to show video effects button
 * @private
 */
/** @beta */
const VideoEffectsPaneContent = (props) => {
    var _a;
    const { onDismissError, activeVideoEffectError, 
    /* @conditional-compile-remove(video-background-effects) */
    activeVideoEffectChange } = props;
    /* @conditional-compile-remove(video-background-effects) */
    const locale = useLocale();
    /* @conditional-compile-remove(video-background-effects) */
    const adapter = useAdapter();
    /* @conditional-compile-remove(video-background-effects) */
    const strings = locale.strings.call;
    /* @conditional-compile-remove(video-background-effects) */
    const activeVideoEffects = (_a = useSelector$1(localVideoSelector).activeVideoEffects) === null || _a === void 0 ? void 0 : _a.activeEffects;
    /* @conditional-compile-remove(video-background-effects) */
    const selectableVideoEffects = React.useMemo(() => {
        const videoEffects = [{
                itemKey: 'none',
                iconProps: {
                    iconName: 'RemoveVideoBackgroundEffect'
                },
                title: strings.removeBackgroundEffectButtonLabel,
                tooltipProps: {
                    content: strings.removeBackgroundTooltip
                }
            }, {
                itemKey: 'blur',
                iconProps: {
                    iconName: 'BlurVideoBackground'
                },
                title: strings.blurBackgroundEffectButtonLabel,
                tooltipProps: {
                    content: strings.blurBackgroundTooltip
                }
            }];
        const videoEffectImages = adapter.getState().videoBackgroundImages;
        if (videoEffectImages) {
            videoEffectImages.forEach((img) => {
                var _a;
                videoEffects.push({
                    itemKey: img.key,
                    backgroundProps: {
                        url: img.url
                    },
                    tooltipProps: {
                        content: (_a = img.tooltipText) !== null && _a !== void 0 ? _a : ''
                    }
                });
            });
        }
        return videoEffects;
    }, [strings, adapter]);
    /* @conditional-compile-remove(video-background-effects) */
    const onEffectChange = React.useCallback((effectKey) => __awaiter$b(void 0, void 0, void 0, function* () {
        if (effectKey === 'blur') {
            const blurEffect = {
                effectName: effectKey
            };
            activeVideoEffectChange({
                type: 'blur',
                timestamp: new Date(Date.now())
            });
            yield adapter.startVideoBackgroundEffect(blurEffect);
            adapter.updateSelectedVideoBackgroundEffect(blurEffect);
        }
        else if (effectKey === 'none') {
            const noneEffect = {
                effectName: effectKey
            };
            yield adapter.stopVideoBackgroundEffects();
            adapter.updateSelectedVideoBackgroundEffect(noneEffect);
        }
        else {
            const backgroundImg = selectableVideoEffects.find(effect => {
                return effect.itemKey === effectKey;
            });
            if (backgroundImg && backgroundImg.backgroundProps) {
                const replaceEffect = {
                    effectName: 'replacement',
                    key: effectKey,
                    backgroundImageUrl: backgroundImg.backgroundProps.url
                };
                activeVideoEffectChange({
                    type: 'replacement',
                    timestamp: new Date(Date.now())
                });
                yield adapter.startVideoBackgroundEffect(replaceEffect);
                adapter.updateSelectedVideoBackgroundEffect(replaceEffect);
            }
        }
    }), [adapter, activeVideoEffectChange, selectableVideoEffects]);
    /* @conditional-compile-remove(video-background-effects) */
    if (activeVideoEffectError && activeVideoEffects && activeVideoEffects.length === 0) {
        const noneEffect = {
            effectName: 'none'
        };
        adapter.updateSelectedVideoBackgroundEffect(noneEffect);
    }
    return VideoEffectsPaneTrampoline(onDismissError, activeVideoEffectError, /* @conditional-compile-remove(video-background-effects) */ selectableVideoEffects, /* @conditional-compile-remove(video-background-effects) */ onEffectChange);
};
const VideoEffectsPaneTrampoline = (onDismissError, activeVideoEffectError, selectableVideoEffects, onEffectChange) => {
    /* @conditional-compile-remove(video-background-effects) */
    const selectedEffect = useSelector$1(activeVideoBackgroundEffectSelector);
    /* @conditional-compile-remove(video-background-effects) */
    const isCameraOn = useSelector$1(localVideoSelector).isAvailable;
    /* @conditional-compile-remove(video-background-effects) */
    const showWarning = !isCameraOn && selectedEffect !== 'none';
    /* @conditional-compile-remove(video-background-effects) */
    const locale = useLocale();
    /* @conditional-compile-remove(video-background-effects) */
    return React.createElement(react.Stack, { tokens: {
            childrenGap: '0.75rem'
        }, className: react.mergeStyles({
            paddingLeft: '0.5rem'
        }) },
        activeVideoEffectError && isCameraOn && React.createElement(react.MessageBar, { messageBarType: react.MessageBarType.error, onDismiss: () => onDismissError(activeVideoEffectError) }, locale.strings.call.unableToStartVideoEffect),
        showWarning && React.createElement(react.MessageBar, { messageBarType: react.MessageBarType.warning }, locale.strings.call.cameraOffBackgroundEffectWarningText),
        React.createElement(_VideoBackgroundEffectsPicker, { label: locale.strings.call.videoEffectsPaneBackgroundSelectionTitle, styles: backgroundPickerStyles, options: selectableVideoEffects !== null && selectableVideoEffects !== void 0 ? selectableVideoEffects : [], onChange: onEffectChange, selectedEffectKey: selectedEffect }));
};
/* @conditional-compile-remove(video-background-effects) */
const backgroundPickerStyles = {
    label: {
        fontSize: '0.75rem',
        lineHeight: '0.5rem',
        fontWeight: '400'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const VIDEO_EFFECTS_SIDE_PANE_ID = 'videoeffects';
/** @private */
const VIDEO_EFFECTS_SIDE_PANE_WIDTH_REM = 17.5;
/** @private */
const useVideoEffectsPane = (updateSidePaneRenderer, mobileView, latestErrors, onDismissError, cameraButtonRef) => {
    const closePane = React.useCallback(() => {
        var _a;
        updateSidePaneRenderer(undefined);
        (_a = cameraButtonRef === null || cameraButtonRef === void 0 ? void 0 : cameraButtonRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, [cameraButtonRef, updateSidePaneRenderer]);
    /* @conditional-compile-remove(video-background-effects) */
    const locale = useLocale();
    const onRenderHeader = React.useCallback(() => {
        var _a, _b;
        return React.createElement(SidePaneHeader, { onClose: closePane, 
            /* @conditional-compile-remove(video-background-effects) */ headingText: locale.strings.call.videoEffectsPaneTitle, 
            /* @conditional-compile-remove(video-background-effects) */ dismissSidePaneButtonAriaLabel: (_b = (_a = locale.strings.call.dismissSidePaneButtonLabel) !== null && _a !== void 0 ? _a : locale.strings.callWithChat.dismissSidePaneButtonLabel) !== null && _b !== void 0 ? _b : 'Close', mobileView: mobileView });
    }, [closePane, /* @conditional-compile-remove(video-background-effects) */ locale.strings, mobileView]);
    /* @conditional-compile-remove(video-background-effects) */
    const latestVideoEffectError = latestErrors.find(error => error.type === 'unableToStartVideoEffect');
    const onRenderContent = React.useCallback(() => {
        return React.createElement(VideoEffectsPaneContent, { onDismissError: onDismissError, 
            /* @conditional-compile-remove(video-background-effects) */ activeVideoEffectError: latestVideoEffectError, activeVideoEffectChange: () => {
                // Clear any existing video effects error when the user clicks on a new video effect
                /* @conditional-compile-remove(video-background-effects) */
                latestVideoEffectError && (onDismissError === null || onDismissError === void 0 ? void 0 : onDismissError(latestVideoEffectError));
            } });
    }, [
        latestVideoEffectError, onDismissError
    ]);
    const sidePaneRenderer = React.useMemo(() => ({
        headerRenderer: onRenderHeader,
        contentRenderer: onRenderContent,
        id: VIDEO_EFFECTS_SIDE_PANE_ID
    }), [onRenderContent, onRenderHeader]);
    const openPane = React.useCallback(() => {
        updateSidePaneRenderer(sidePaneRenderer);
    }, [sidePaneRenderer, updateSidePaneRenderer]);
    const isOpen = useIsParticularSidePaneOpen(VIDEO_EFFECTS_SIDE_PANE_ID);
    // Update pane renderer if it is open and the openPane dep changes
    React.useEffect(() => {
        if (isOpen) {
            openPane();
        }
    }, [isOpen, openPane]);
    const togglePane = React.useCallback(() => {
        if (isOpen) {
            closePane();
        }
        else {
            openPane();
        }
    }, [closePane, isOpen, openPane]);
    return {
        openVideoEffectsPane: openPane,
        closeVideoEffectsPane: closePane,
        toggleVideoEffectsPane: togglePane,
        isVideoEffectsPaneOpen: isOpen
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const LocalAndRemotePIP = (props) => {
    var _a, _b;
    const { localParticipant, dominantRemoteParticipant, onCreateLocalStreamView, onDisposeLocalStreamView, onCreateRemoteStreamView, onDisposeRemoteStreamView } = props;
    const localVideoTileProps = React.useMemo(() => {
        var _a, _b;
        return ({
            onCreateLocalStreamView,
            onDisposeLocalStreamView,
            localVideoViewOptions: localVideoViewOptions$3,
            displayName: localParticipant.displayName,
            showLabel: false,
            showMuteIndicator: false,
            showCameraSwitcherInLocalPreview: false,
            isAvailable: (_a = localParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable,
            renderElement: (_b = localParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.renderElement,
            /* @conditional-compile-remove(raise-hand) */
            raisedHand: localParticipant.raisedHand
        });
    }, [localParticipant.displayName, (_a = localParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable, (_b = localParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.renderElement, onCreateLocalStreamView, onDisposeLocalStreamView, /* @conditional-compile-remove(raise-hand) */
        localParticipant.raisedHand]);
    const remoteVideoTileProps = React.useMemo(() => {
        var _a, _b, _c;
        return !dominantRemoteParticipant ? undefined : {
            remoteParticipant: dominantRemoteParticipant,
            onCreateRemoteStreamView,
            onDisposeRemoteStreamView,
            remoteVideoViewOptions: remoteVideoViewOptions$1,
            displayName: dominantRemoteParticipant === null || dominantRemoteParticipant === void 0 ? void 0 : dominantRemoteParticipant.displayName,
            showLabel: false,
            showMuteIndicator: false,
            isAvailable: (_a = dominantRemoteParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable,
            isReceiving: (_b = dominantRemoteParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.isReceiving,
            renderElement: (_c = dominantRemoteParticipant.videoStream) === null || _c === void 0 ? void 0 : _c.renderElement,
            userId: dominantRemoteParticipant.userId,
            key: dominantRemoteParticipant.userId
        };
    }, [dominantRemoteParticipant, onCreateRemoteStreamView, onDisposeRemoteStreamView]);
    const locale = useLocale();
    const ariaLabel = locale.strings.callWithChat.pictureInPictureTileAriaLabel;
    const strings = React.useMemo(() => ({
        rootAriaLabel: ariaLabel
    }), [ariaLabel]);
    // If there are no remote participants, show the local participant as the primary tile
    const primaryTileProps = React.useMemo(() => ({
        children: remoteVideoTileProps ? React.createElement(_RemoteVideoTile, Object.assign({}, remoteVideoTileProps, { strings: locale.component.strings.videoGallery })) : React.createElement(_LocalVideoTile, Object.assign({}, localVideoTileProps)),
        // TODO: when the calling SDK provides height/width stream information - update this to reflect the stream orientation.
        orientation: 'portrait'
    }), [localVideoTileProps, remoteVideoTileProps, locale.component.strings.videoGallery]);
    // If we are showing the local participant as the primary tile, show nothing for the secondary tile
    const secondaryTileProps = React.useMemo(() => remoteVideoTileProps ? {
        children: React.createElement(_LocalVideoTile, Object.assign({}, localVideoTileProps, { personaMinSize: 20 })),
        // TODO: when the calling SDK provides height/width stream information - update this to reflect the stream orientation.
        orientation: 'portrait'
    } : undefined, [localVideoTileProps, remoteVideoTileProps]);
    return React.createElement(_PictureInPictureInPicture, { onClick: props.onClick, strings: strings, primaryTile: primaryTileProps, secondaryTile: secondaryTileProps });
};
const localVideoViewOptions$3 = {
    scalingMode: 'Crop',
    isMirrored: true
};
const remoteVideoViewOptions$1 = {
    scalingMode: 'Crop',
    isMirrored: false
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Get the most dominant remote participant, if no dominant speaker IDs exist, this uses
 * one of the remote participants with no bias towards which one.
 *
 * @private
 */
const dominantRemoteParticipantSelector = reselect__namespace.createSelector([getRemoteParticipants, getDominantSpeakerInfo], (remoteParticipants, dominantSpeakerInfo) => {
    const dominantSpeakers = _dominantSpeakersWithFlatId(dominantSpeakerInfo);
    const dominantRemoteParticipant = remoteParticipants && Object.keys(remoteParticipants).length > 0 ? findDominantRemoteParticipant(remoteParticipants, dominantSpeakers !== null && dominantSpeakers !== void 0 ? dominantSpeakers : []) : undefined;
    return dominantRemoteParticipant ? _videoGalleryRemoteParticipantsMemo(updateUserDisplayNamesTrampoline(Object.values(dominantRemoteParticipant)))[0] : undefined;
});
const findDominantRemoteParticipant = (remoteParticipants, dominantSpeakerIds) => {
    let dominantRemoteParticipantId = dominantSpeakerIds[0];
    // Fallback to using the first remote participant if there are no dominant speaker IDs
    // or if the dominant speaker is no longer available in the list of remoteParticipantIds
    const remoteParticipantIds = Object.keys(remoteParticipants);
    if (!dominantRemoteParticipantId || !remoteParticipantIds.includes(dominantRemoteParticipantId)) {
        dominantRemoteParticipantId = remoteParticipantIds[0];
    }
    return {
        dominantRemoteParticipantId: remoteParticipants[dominantRemoteParticipantId]
    };
};
const updateUserDisplayNamesTrampoline = (remoteParticipants) => {
    return remoteParticipants;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Picture in picture in picture needs to display the most-dominant remote speaker, as well as the local participant video.
 * @private
 */
const localAndRemotePIPSelector = reselect__namespace.createSelector([getDisplayName, dominantRemoteParticipantSelector, localVideoSelector, /* @conditional-compile-remove(raise-hand) */ getLocalParticipantRaisedHand], (displayName, dominantRemoteParticipant, localVideoStreamInfo, /* @conditional-compile-remove(raise-hand) */ raisedHand) => {
    return {
        localParticipant: {
            displayName,
            videoStream: localVideoStreamInfo,
            /* @conditional-compile-remove(raise-hand) */
            raisedHand: raisedHand
        },
        dominantRemoteParticipant
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Default Modal PIP related pixel measurements used for ModalLocalAndremotePIP and common/utils.
 *
 * @private
 */
const MODAL_PIP_DEFAULT_PX = {
    rightPositionPx: 16,
    topPositionPx: 52,
    widthPx: 88,
    heightPx: 128
};
/**
 * @private
 */
const getPipStyles = (theme) => ({
    modal: {
        main: Object.assign(Object.assign({ borderRadius: theme.effects.roundedCorner4, boxShadow: theme.effects.elevation8, 
            // Above the message thread / people pane.
            zIndex: 2 }, (theme.rtl ? {
            left: _pxToRem(MODAL_PIP_DEFAULT_PX.rightPositionPx)
        } : {
            right: _pxToRem(MODAL_PIP_DEFAULT_PX.rightPositionPx)
        })), { top: _pxToRem(MODAL_PIP_DEFAULT_PX.topPositionPx) })
    }
});
/**
 * @private
 */
const PIPContainerStyle = {
    root: {
        position: 'absolute',
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        ':focus-within': {
            outline: '1px solid #00000000'
        }
    }
};
/**
 * @private
 */
const hiddenStyle = react.concatStyleSets(PIPContainerStyle, {
    root: {
        display: 'none'
    }
});
/**
 * @private
 */
const modalStyle = {
    main: {
        minWidth: 'min-content',
        minHeight: 'min-content',
        position: 'absolute',
        overflow: 'hidden',
        // pointer events for root Modal div set to auto to make LocalAndRemotePIP interactive
        pointerEvents: 'auto',
        touchAction: 'none'
    },
    root: {
        width: '100%',
        height: '100%',
        // pointer events for root Modal div set to none to make descendants interactive
        pointerEvents: 'none',
        ':focus-within': {
            outline: '3px solid #00000000',
            outlineOffset: '-3px'
        }
    }
};
/**
 * Styles for layer host to bound the modal wrapping PiPiP in the mobile pane.
 * @private
 */
const modalLayerHostStyle = {
    display: 'flex',
    position: 'absolute',
    left: 0,
    top: 0,
    width: '100%',
    height: '100%',
    overflow: 'hidden',
    zIndex: '100000',
    // pointer events for layerHost set to none to make descendants interactive
    pointerEvents: 'none'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Drag options for Modal in {@link ModalLocalAndRemotePIP} component
 */
const DRAG_OPTIONS = {
    moveMenuItemText: 'Move',
    closeMenuItemText: 'Close',
    menu: react.ContextualMenu,
    keepInBounds: true
};
/**
 * A wrapping component with a draggable {@link LocalAndRemotePIP} component that is bound to a LayerHost component with id
 * specified by `modalLayerHostId` prop
 * @private
 */
const ModalLocalAndRemotePIP = (props) => {
    var _a, _b;
    const rootStyles = props.hidden ? hiddenStyle : PIPContainerStyle;
    /* @conditional-compile-remove(rooms) */
    const adapter = useAdapter();
    /* @conditional-compile-remove(rooms) */
    const role = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.role;
    const locale = useLocale();
    const pictureInPictureProps = useSelector$1(localAndRemotePIPSelector);
    const [touchStartTouches, setTouchStartTouches] = React.useState(null);
    const onTouchEnd = React.useCallback((event) => {
        var _a;
        if (touchStartTouches && touchStartTouches.length === 1 && event.changedTouches.length === 1) {
            const touchStartTouch = touchStartTouches[0];
            const touchEndTouch = event.changedTouches[0];
            if (Math.abs(touchStartTouch.clientX - touchEndTouch.clientX) < 10 && Math.abs(touchStartTouch.clientY - touchEndTouch.clientY) < 10) {
                (_a = props.onDismissSidePane) === null || _a === void 0 ? void 0 : _a.call(props);
            }
        }
    }, [props, touchStartTouches]);
    const onTouchStart = React.useCallback((event) => {
        setTouchStartTouches(event.touches);
    }, []);
    const onKeyDown = React.useCallback((event) => {
        var _a;
        if (event.key === 'Enter' || event.key === ' ') {
            (_a = props.onDismissSidePane) === null || _a === void 0 ? void 0 : _a.call(props);
        }
    }, [props]);
    const pictureInPictureHandlers = useHandlers();
    const localAndRemotePIP = React.useMemo(() => {
        var _a, _b, _c, _d, _e;
        /* @conditional-compile-remove(rooms) */
        if (role === 'Consumer' && ((_a = pictureInPictureProps.dominantRemoteParticipant) === null || _a === void 0 ? void 0 : _a.userId)) {
            return React.createElement(react.Stack, { tabIndex: 0, "aria-label": (_c = (_b = props.strings) === null || _b === void 0 ? void 0 : _b.dismissModalAriaLabel) !== null && _c !== void 0 ? _c : '', onKeyDown: onKeyDown },
                React.createElement(_RemoteVideoTile, Object.assign({ strings: locale.component.strings.videoGallery }, pictureInPictureProps.dominantRemoteParticipant, { remoteParticipant: pictureInPictureProps.dominantRemoteParticipant })));
        }
        return React.createElement(react.Stack, { tabIndex: 0, "aria-label": (_e = (_d = props.strings) === null || _d === void 0 ? void 0 : _d.dismissModalAriaLabel) !== null && _e !== void 0 ? _e : '', onKeyDown: onKeyDown },
            React.createElement(LocalAndRemotePIP, Object.assign({}, pictureInPictureProps, pictureInPictureHandlers)));
    }, [/* @conditional-compile-remove(rooms) */ role, onKeyDown, pictureInPictureProps, props, pictureInPictureHandlers, locale.component.strings.videoGallery]);
    /* @conditional-compile-remove(rooms) */
    if (role === 'Consumer' && !pictureInPictureProps.dominantRemoteParticipant) {
        return null;
    }
    const modalStylesThemed = react.concatStyleSets(modalStyle, (_b = props.styles) === null || _b === void 0 ? void 0 : _b.modal);
    return React.createElement(react.Stack, { styles: rootStyles },
        React.createElement(react.Stack, { onTouchStart: onTouchStart, onTouchEnd: onTouchEnd },
            React.createElement(_ModalClone, { isOpen: true, isModeless: true, dragOptions: DRAG_OPTIONS, styles: modalStylesThemed, layerProps: {
                    hostId: props.modalLayerHostId
                }, minDragPosition: props.minDragPosition, maxDragPosition: props.maxDragPosition }, 
            // Only render LocalAndRemotePIP when this component is NOT hidden because VideoGallery needs to have
            // possession of the dominant remote participant video stream
            !props.hidden && localAndRemotePIP)));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
// Use document.getElementById until Fluent's Stack supports componentRef property: https://github.com/microsoft/fluentui/issues/20410
const useMinMaxDragPosition = (modalLayerHostId, rtl) => {
    const modalHostRef = React.useRef(document.getElementById(modalLayerHostId));
    const modalHostWidth = _useContainerWidth(modalHostRef);
    const modalHostHeight = _useContainerHeight(modalHostRef);
    const minDragPosition = React.useMemo(() => modalHostWidth === undefined ? undefined : {
        x: rtl ? -1 * MODAL_PIP_DEFAULT_PX.rightPositionPx : MODAL_PIP_DEFAULT_PX.rightPositionPx - modalHostWidth + MODAL_PIP_DEFAULT_PX.widthPx,
        y: -1 * MODAL_PIP_DEFAULT_PX.topPositionPx
    }, [modalHostWidth, rtl]);
    const maxDragPosition = React.useMemo(() => modalHostWidth === undefined || modalHostHeight === undefined ? undefined : {
        x: rtl ? modalHostWidth - MODAL_PIP_DEFAULT_PX.rightPositionPx - MODAL_PIP_DEFAULT_PX.widthPx : MODAL_PIP_DEFAULT_PX.rightPositionPx,
        y: modalHostHeight - MODAL_PIP_DEFAULT_PX.topPositionPx - MODAL_PIP_DEFAULT_PX.heightPx
    }, [modalHostHeight, modalHostWidth, rtl]);
    return {
        minDragPosition: minDragPosition,
        maxDragPosition: maxDragPosition
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(capabilities) */
/* @conditional-compile-remove(capabilities) */
/**
 * Notification bar for capabilities changed
 * @private
 */
const CapabilitiesChangedNotificationBar = (props) => {
    const locale = useLocale();
    return React.createElement(react.Stack, { "data-ui-id": "capabilities-changed-notification-bar-stack" }, props.capabilitiesChangedNotifications.map(notification => {
        const message = getCapabilityChangedNotificationString(notification, locale.strings.call.capabilityChangedNotification);
        if (!message) {
            return null;
        }
        const iconProps = getCustomMessageBarIconProps(notification);
        return React.createElement(react.MessageBar, { key: notification.capabilityName, styles: messageBarStyles, messageBarType: react.MessageBarType.warning, dismissIconProps: {
                iconName: 'ErrorBarClear'
            }, onDismiss: () => props.onDismissNotification(notification), messageBarIconProps: iconProps }, message);
    }));
};
/* @conditional-compile-remove(capabilities) */
const getCapabilityChangedNotificationString = (notification, strings) => {
    var _a, _b, _c, _d, _e, _f;
    switch (notification.capabilityName) {
        case 'turnVideoOn':
            if (notification.changedReason === 'MeetingOptionOrOrganizerPolicyChanged') {
                return notification.isPresent ? (_a = strings === null || strings === void 0 ? void 0 : strings.turnVideoOn) === null || _a === void 0 ? void 0 : _a.grantedDueToMeetingOption : (_b = strings === null || strings === void 0 ? void 0 : strings.turnVideoOn) === null || _b === void 0 ? void 0 : _b.lostDueToMeetingOption;
            }
            break;
        case 'unmuteMic':
            if (notification.changedReason === 'MeetingOptionOrOrganizerPolicyChanged') {
                return notification.isPresent ? (_c = strings === null || strings === void 0 ? void 0 : strings.unmuteMic) === null || _c === void 0 ? void 0 : _c.grantedDueToMeetingOption : (_d = strings === null || strings === void 0 ? void 0 : strings.unmuteMic) === null || _d === void 0 ? void 0 : _d.lostDueToMeetingOption;
            }
            break;
        case 'shareScreen':
            if (notification.isPresent && notification.changedReason === 'RoleChanged' && notification.role === 'Presenter') {
                return (_e = strings === null || strings === void 0 ? void 0 : strings.shareScreen) === null || _e === void 0 ? void 0 : _e.grantedDueToRoleChangeToPresenter;
            }
            if (!notification.isPresent && notification.changedReason === 'RoleChanged' && notification.role === 'Attendee') {
                return (_f = strings === null || strings === void 0 ? void 0 : strings.shareScreen) === null || _f === void 0 ? void 0 : _f.lostDueToRoleChangeToAttendee;
            }
            break;
    }
    return undefined;
};
/* @conditional-compile-remove(capabilities) */
const getCustomMessageBarIconProps = (notification) => {
    let iconName = undefined;
    switch (notification.capabilityName) {
        case 'turnVideoOn':
            if (notification.isPresent) {
                iconName = 'ControlButtonCameraOn';
            }
            else {
                iconName = 'ControlButtonCameraProhibited';
            }
            break;
        case 'unmuteMic':
            if (notification.isPresent) {
                iconName = 'ControlButtonMicOn';
            }
            else {
                iconName = 'ControlButtonMicProhibited';
            }
            break;
        default:
            return undefined;
    }
    return {
        iconName,
        styles: {
            root: {
                '> *': {
                    height: '1rem',
                    width: '1rem'
                }
            }
        }
    };
};
/* @conditional-compile-remove(capabilities) */
const messageBarStyles = {
    innerText: {
        alignSelf: 'center'
    },
    icon: {
        height: 0
    },
    content: {
        lineHeight: 'inherit'
    },
    dismissal: {
        height: 0,
        paddingTop: '0.8rem'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const CallArrangement = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const containerClassName = React.useMemo(() => {
        return props.mobileView ? containerStyleMobile : containerStyleDesktop;
    }, [props.mobileView]);
    const theme = useTheme();
    const callGalleryStyles = React.useMemo(() => galleryParentContainerStyles(theme.palette.neutralLighterAlt), [theme.palette.neutralLighterAlt]);
    const peopleButtonRef = React.useRef(null);
    const cameraButtonRef = React.useRef(null);
    const containerRef = React.useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const containerHeight = _useContainerHeight(containerRef);
    const isInLobby = _isInLobbyOrConnecting(useSelector$1(callStatusSelector).callStatus);
    const { updateSidePaneRenderer } = props;
    const adapter = useAdapter();
    const [drawerMenuItems, setDrawerMenuItems] = React.useState([]);
    const peoplePaneProps = React.useMemo(() => {
        var _a;
        return ({
            updateSidePaneRenderer,
            setDrawerMenuItems,
            inviteLink: props.callControlProps.callInvitationURL,
            onFetchParticipantMenuItems: (_a = props.callControlProps) === null || _a === void 0 ? void 0 : _a.onFetchParticipantMenuItems,
            mobileView: props.mobileView,
            peopleButtonRef
        });
    }, [updateSidePaneRenderer, props.callControlProps.callInvitationURL, (_a = props.callControlProps) === null || _a === void 0 ? void 0 : _a.onFetchParticipantMenuItems, props.mobileView, peopleButtonRef]);
    const locale = useLocale();
    const spotlightPeoplePaneProps = React.useMemo(() => {
        return {};
    }, []);
    const { isPeoplePaneOpen, openPeoplePane, closePeoplePane } = usePeoplePane(Object.assign(Object.assign({}, peoplePaneProps), spotlightPeoplePaneProps));
    const togglePeoplePane = React.useCallback(() => {
        if (isPeoplePaneOpen) {
            closePeoplePane();
        }
        else {
            openPeoplePane();
        }
    }, [closePeoplePane, isPeoplePaneOpen, openPeoplePane]);
    const isSidePaneOpen = useIsSidePaneOpen();
    const [renderGallery, setRenderGallery] = React.useState(!isSidePaneOpen && props.mobileView);
    React.useEffect(() => {
        if (isSidePaneOpen && props.mobileView) {
            setRenderGallery(false);
        }
        else {
            setRenderGallery(true);
        }
    }, [props.mobileView, isSidePaneOpen]);
    const modalStrings = {
        dismissModalAriaLabel: locale.strings.call.dismissModalAriaLabel
    };
    const isMobileWithActivePane = props.mobileView && isSidePaneOpen;
    const callCompositeContainerCSS = React.useMemo(() => {
        return {
            display: isMobileWithActivePane ? 'none' : 'flex',
            minWidth: props.mobileView ? 'unset' : `${compositeMinWidthRem}rem`,
            width: '100%',
            height: '100%',
            position: 'relative'
        };
    }, [isMobileWithActivePane, props.mobileView]);
    /* @conditional-compile-remove(video-background-effects) */
    const onResolveVideoEffectDependency = adapter.getState().onResolveVideoEffectDependency;
    /* @conditional-compile-remove(video-background-effects) */
    const { openVideoEffectsPane } = useVideoEffectsPane(props.updateSidePaneRenderer, props.mobileView, props.latestErrors, props.onDismissError, cameraButtonRef);
    const [showDrawer, setShowDrawer] = React.useState(false);
    const onMoreButtonClicked = React.useCallback(() => {
        setShowDrawer(true);
    }, []);
    const closeDrawer = React.useCallback(() => {
        setShowDrawer(false);
    }, []);
    const onMoreDrawerPeopleClicked = React.useCallback(() => {
        setShowDrawer(false);
        togglePeoplePane();
    }, [togglePeoplePane]);
    const drawerContainerStylesValue = React.useMemo(() => drawerContainerStyles(DRAWER_Z_INDEX), []);
    /* @conditional-compile-remove(rooms) */
    const role = (_b = adapter.getState().call) === null || _b === void 0 ? void 0 : _b.role;
    let canUnmute = true;
    /* @conditional-compile-remove(rooms) */
    canUnmute = role !== 'Consumer' ? true : false;
    let filteredLatestErrors = props.errorBarProps !== false ? props.latestErrors : [];
    /* @conditional-compile-remove(video-background-effects) */
    const isCameraOn = useSelector$1(localVideoSelector).isAvailable;
    /* @conditional-compile-remove(rooms) */
    // TODO: move this logic to the error bar selector once role is plumbed from the headless SDK
    if (role === 'Consumer' && props.errorBarProps) {
        filteredLatestErrors = filteredLatestErrors.filter(e => e.type !== 'callCameraAccessDenied' && e.type !== 'callCameraAccessDeniedSafari');
    }
    /* @conditional-compile-remove(video-background-effects) */
    const isVideoPaneOpen = useIsParticularSidePaneOpen(VIDEO_EFFECTS_SIDE_PANE_ID);
    /* @conditional-compile-remove(video-background-effects) */
    if ((isVideoPaneOpen || !isCameraOn) && props.errorBarProps) {
        filteredLatestErrors = filteredLatestErrors.filter(e => e.type !== 'unableToStartVideoEffect');
    }
    /* @conditional-compile-remove(close-captions) */
    const isTeamsCall = useSelector$1(getIsTeamsCall);
    /* @conditional-compile-remove(close-captions) */
    const hasJoinedCall = useSelector$1(getCallStatus) === 'Connected';
    /* @conditional-compile-remove(close-captions) */
    const isCaptionsOn = useSelector$1(getCaptionsStatus);
    const minMaxDragPosition = useMinMaxDragPosition(props.modalLayerHostId);
    const pipStyles = React.useMemo(() => getPipStyles(theme), [theme]);
    const verticalControlBar = props.mobileView && containerWidth && containerHeight && containerWidth / containerHeight > 1 ? true : false;
    /* @conditional-compile-remove(capabilities) */
    // Filter out shareScreen capability notifications if on mobile
    const filteredCapabilitesChangedNotifications = props.mobileView ? (_c = props.capabilitiesChangedNotificationBarProps) === null || _c === void 0 ? void 0 : _c.capabilitiesChangedNotifications.filter(notification => notification.capabilityName !== 'shareScreen') : (_d = props.capabilitiesChangedNotificationBarProps) === null || _d === void 0 ? void 0 : _d.capabilitiesChangedNotifications;
    return React.createElement("div", { ref: containerRef, className: react.mergeStyles(containerDivStyles), id: props.id },
        React.createElement(react.Stack, { verticalFill: true, horizontalAlign: "stretch", className: containerClassName, "data-ui-id": props.dataUiId },
            React.createElement(react.Stack, { reversed: true, horizontal: verticalControlBar, grow: true, styles: callArrangementContainerStyles(verticalControlBar) },
                ((_e = props.callControlProps) === null || _e === void 0 ? void 0 : _e.options) !== false && !isMobileWithActivePane && React.createElement(react.Stack, { verticalAlign: 'center', className: react.mergeStyles({
                        zIndex: CONTROL_BAR_Z_INDEX,
                        padding: verticalControlBar ? '0.25rem' : 'unset'
                    }) }, isLegacyCallControlEnabled((_f = props.callControlProps) === null || _f === void 0 ? void 0 : _f.options) ? React.createElement(CallControls, Object.assign({}, props.callControlProps, { containerWidth: containerWidth, containerHeight: containerHeight, isMobile: props.mobileView, displayVertical: verticalControlBar })) : React.createElement(CommonCallControlBar, Object.assign({}, props.callControlProps, { callControls: props.callControlProps.options, callAdapter: adapter, mobileView: props.mobileView, disableButtonsForLobbyPage: isInLobby, peopleButtonChecked: isPeoplePaneOpen, onPeopleButtonClicked: togglePeoplePane, onMoreButtonClicked: onMoreButtonClicked, 
                    /* @conditional-compile-remove(close-captions) */ isCaptionsSupported: isTeamsCall && hasJoinedCall, 
                    /* @conditional-compile-remove(close-captions) */ isCaptionsOn: isCaptionsOn, 
                    /* @conditional-compile-remove(video-background-effects) */ onClickVideoEffects: onResolveVideoEffectDependency ? openVideoEffectsPane : undefined, displayVertical: verticalControlBar, onUserSetOverflowGalleryPositionChange: props.onUserSetOverflowGalleryPositionChange, onUserSetGalleryLayout: props.onUserSetGalleryLayoutChange, userSetGalleryLayout: props.userSetGalleryLayout, onSetDialpadPage: props.onSetDialpadPage, dtmfDialerPresent: props.dtmfDialerPresent, peopleButtonRef: peopleButtonRef, cameraButtonRef: cameraButtonRef }))),
                ((_g = props.callControlProps) === null || _g === void 0 ? void 0 : _g.options) !== false && showDrawer && React.createElement(react.Stack, { styles: drawerContainerStylesValue },
                    React.createElement(PreparedMoreDrawer, { callControls: props.callControlProps.options, onLightDismiss: closeDrawer, onPeopleButtonClicked: onMoreDrawerPeopleClicked, isCaptionsSupported: isTeamsCall && hasJoinedCall, onUserSetGalleryLayout: props.onUserSetGalleryLayoutChange, userSetGalleryLayout: props.userSetGalleryLayout, onSetDialpadPage: props.onSetDialpadPage, dtmfDialerPresent: props.dtmfDialerPresent })),
                React.createElement(react.Stack, { horizontal: true, grow: true },
                    React.createElement(react.Stack.Item, { style: callCompositeContainerCSS },
                        React.createElement(react.Stack.Item, { styles: callGalleryStyles, grow: true },
                            React.createElement(react.Stack, { verticalFill: true, styles: mediaGalleryContainerStyles$1 },
                                React.createElement(react.Stack.Item, { styles: notificationsContainerStyles },
                                    React.createElement(react.Stack, { styles: bannerNotificationStyles },
                                        React.createElement(_ComplianceBanner, Object.assign({}, props.complianceBannerProps))),
                                    props.errorBarProps !== false && React.createElement(react.Stack, { styles: bannerNotificationStyles },
                                        React.createElement(ErrorBar, Object.assign({}, props.errorBarProps, { onDismissError: props.onDismissError, activeErrorMessages: filteredLatestErrors }))), /* @conditional-compile-remove(capabilities) */
                                    props.capabilitiesChangedNotificationBarProps && props.capabilitiesChangedNotificationBarProps.capabilitiesChangedNotifications.length > 0 && React.createElement(react.Stack, { styles: bannerNotificationStyles },
                                        React.createElement(CapabilitiesChangedNotificationBar, Object.assign({}, props.capabilitiesChangedNotificationBarProps, { capabilitiesChangedNotifications: filteredCapabilitesChangedNotifications !== null && filteredCapabilitesChangedNotifications !== void 0 ? filteredCapabilitesChangedNotifications : [] }))),
                                    canUnmute && !!props.mutedNotificationProps && React.createElement(MutedNotification, Object.assign({}, props.mutedNotificationProps))),
                                renderGallery && props.onRenderGalleryContent && props.onRenderGalleryContent(), /* @conditional-compile-remove(close-captions) */
                                React.createElement(CaptionsBanner, { isMobile: props.mobileView, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData })))),
                    React.createElement(SidePane, { mobileView: props.mobileView, 
                        /* @conditional-compile-remove(video-background-effects) */ maxWidth: isVideoPaneOpen ? `${VIDEO_EFFECTS_SIDE_PANE_WIDTH_REM}rem` : undefined, minWidth: isVideoPaneOpen ? `${VIDEO_EFFECTS_SIDE_PANE_WIDTH_REM}rem` : undefined, updateSidePaneRenderer: props.updateSidePaneRenderer, onPeopleButtonClicked: props.mobileView && !shouldShowPeopleTabHeaderButton(props.callControlProps.options) ? undefined : togglePeoplePane, disablePeopleButton: typeof props.callControlProps.options !== 'boolean' && isDisabled$3((_h = props.callControlProps.options) === null || _h === void 0 ? void 0 : _h.participantsButton), onChatButtonClicked: (_j = props.mobileChatTabHeader) === null || _j === void 0 ? void 0 : _j.onClick, disableChatButton: (_k = props.mobileChatTabHeader) === null || _k === void 0 ? void 0 : _k.disabled }),
                    props.mobileView && React.createElement(ModalLocalAndRemotePIP, { modalLayerHostId: props.modalLayerHostId, hidden: !isSidePaneOpen, styles: pipStyles, strings: modalStrings, minDragPosition: minMaxDragPosition.minDragPosition, maxDragPosition: minMaxDragPosition.maxDragPosition, onDismissSidePane: () => {
                            closePeoplePane();
                            if (props.onCloseChatPane) {
                                props.onCloseChatPane();
                            }
                        } }),
                    drawerMenuItems.length > 0 && React.createElement(react.Stack, { styles: drawerContainerStyles() },
                        React.createElement(_DrawerMenu, { onLightDismiss: () => setDrawerMenuItems([]), items: drawerMenuItems }))))));
};
const isLegacyCallControlEnabled = (options) => {
    return !!options && options !== true && (options === null || options === void 0 ? void 0 : options.legacyControlBarExperience) === true;
};
const shouldShowPeopleTabHeaderButton = (callControls) => {
    if (callControls === undefined || callControls === true) {
        return true;
    }
    if (callControls === false) {
        return false;
    }
    return callControls.participantsButton !== false && callControls.peopleButton !== false;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Provides data attributes to {@link LocalVideoCameraCycleButton} component.
 * @public
 */
const localVideoCameraCycleButtonSelector = reselect.createSelector([getDeviceManager], deviceManager => {
    return {
        cameras: deviceManager.cameras,
        selectedCamera: deviceManager.selectedCamera
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const VideoGalleryStyles = {
    root: {
        height: '100%',
        minHeight: '10rem',
        // space affordance to ensure media gallery is never collapsed
        minWidth: '6rem'
    }
};
const localVideoViewOptions$2 = {
    scalingMode: 'Crop',
    isMirrored: true
};
const remoteVideoViewOptions = {
    scalingMode: 'Crop'
};
/**
 * @private
 */
const MediaGallery = (props) => {
    var _a, _b, _c;
    const videoGalleryProps = usePropsFor$1(VideoGallery);
    const cameraSwitcherCameras = useSelector$1(localVideoCameraCycleButtonSelector);
    const cameraSwitcherCallback = useHandlers();
    const announcerString = useParticipantChangedAnnouncement();
    /* @conditional-compile-remove(rooms) */
    const adapter = useAdapter();
    /* @conditional-compile-remove(rooms) */
    const userRole = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.role;
    /* @conditional-compile-remove(rooms) */
    const isRoomsCall = adapter.getState().isRoomsCall;
    /* @conditional-compile-remove(vertical-gallery) */ /* @conditional-compile-remove(rooms) */
    const containerRef = React.useRef(null);
    /* @conditional-compile-remove(vertical-gallery) */ /* @conditional-compile-remove(rooms) */
    const containerWidth = _useContainerWidth(containerRef);
    /* @conditional-compile-remove(vertical-gallery) */ /* @conditional-compile-remove(rooms) */
    const containerHeight = _useContainerHeight(containerRef);
    /* @conditional-compile-remove(click-to-call) */ /* @conditional-compile-remove(rooms) */ /* @conditional-compile-remove(vertical-gallery) */
    const containerAspectRatio = containerWidth && containerHeight ? containerWidth / containerHeight : 0;
    const layoutBasedOnTilePosition = localVideoTileLayoutTrampoline(/* @conditional-compile-remove(click-to-call) */ (_b = props.localVideoTileOptions) === null || _b === void 0 ? void 0 : _b.position);
    const cameraSwitcherProps = React.useMemo(() => {
        return Object.assign(Object.assign({}, cameraSwitcherCallback), cameraSwitcherCameras);
    }, [cameraSwitcherCallback, cameraSwitcherCameras]);
    const onRenderAvatar = React.useCallback((userId, options) => {
        return React.createElement(react.Stack, { className: react.mergeStyles({
                position: 'absolute',
                height: '100%',
                width: '100%'
            }) },
            React.createElement(react.Stack, { styles: {
                    root: {
                        margin: 'auto',
                        maxHeight: '100%'
                    }
                } }, (options === null || options === void 0 ? void 0 : options.coinSize) && React.createElement(AvatarPersona, Object.assign({ userId: userId }, options, { dataProvider: props.onFetchAvatarPersonaData }))));
    }, [props.onFetchAvatarPersonaData]);
    const remoteVideoTileMenuOptions = React.useMemo(() => {
        var _a;
        return ((_a = props.remoteVideoTileMenuOptions) === null || _a === void 0 ? void 0 : _a.isHidden) ? false : props.isMobile ? {
            kind: 'drawer',
            hostId: props.drawerMenuHostId
        } : {
            kind: 'contextual'
        };
    }, [(_c = props.remoteVideoTileMenuOptions) === null || _c === void 0 ? void 0 : _c.isHidden, props.isMobile, props.drawerMenuHostId]);
    /* @conditional-compile-remove(vertical-gallery) */
    const overflowGalleryPosition = React.useMemo(() => {
        return containerWidth && containerHeight && containerWidth / containerHeight >= 16 / 9 ? 'verticalRight' : 'horizontalBottom';
    }, [containerWidth, containerHeight]);
    const VideoGalleryMemoized = React.useMemo(() => {
        const layoutBasedOnUserSelection = () => {
            return props.localVideoTileOptions ? layoutBasedOnTilePosition : props.userSetGalleryLayout;
        };
        return React.createElement(VideoGallery, Object.assign({}, videoGalleryProps, { localVideoViewOptions: localVideoViewOptions$2, remoteVideoViewOptions: remoteVideoViewOptions, styles: VideoGalleryStyles, layout: layoutBasedOnUserSelection(), showCameraSwitcherInLocalPreview: props.isMobile, localVideoCameraCycleButtonProps: cameraSwitcherProps, onRenderAvatar: onRenderAvatar, remoteVideoTileMenu: remoteVideoTileMenuOptions, 
            /* @conditional-compile-remove(vertical-gallery) */ overflowGalleryPosition: overflowGalleryPosition, 
            /* @conditional-compile-remove(rooms) */ localVideoTileSize: props.localVideoTileOptions === false || userRole === 'Consumer' || isRoomsCall && userRole === 'Unknown' ? 'hidden' : props.isMobile && containerAspectRatio < 1 ? '9:16' : '16:9' }));
    }, [videoGalleryProps, props.isMobile, /* @conditional-compile-remove(rooms) */
        props.localVideoTileOptions, cameraSwitcherProps, onRenderAvatar, remoteVideoTileMenuOptions, /* @conditional-compile-remove(vertical-gallery) */
        overflowGalleryPosition, /* @conditional-compile-remove(rooms) */
        userRole, /* @conditional-compile-remove(rooms) */
        isRoomsCall, /* @conditional-compile-remove(vertical-gallery) */
        containerAspectRatio, props.userSetGalleryLayout, layoutBasedOnTilePosition]);
    return React.createElement("div", { ref: containerRef, style: mediaGalleryContainerStyles },
        React.createElement(Announcer, { announcementString: announcerString, ariaLive: 'polite' }),
        VideoGalleryMemoized);
};
const mediaGalleryContainerStyles = {
    width: '100%',
    height: '100%'
};
const localVideoTileLayoutTrampoline = (localTileOptions) => {
    /* @conditional-compile-remove(click-to-call) */
    return localTileOptions === 'grid' ? 'default' : 'floatingLocalVideo';
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// By default, absolute positioned elements are overlayed over static ones.
// So we need to explicitly layer the background and contents.
const OVERLAY_BACKGROUND_ZINDEX = 0;
const OVERLAY_CONTENT_ZINDEX = OVERLAY_BACKGROUND_ZINDEX + 1;
/**
 * @private
 */
const containerStyles = {
    root: {
        height: '100%',
        width: '100%',
        position: 'relative'
    }
};
/**
 * @private
 */
const overlayBackgroundStyles = (palette, isVideoReady) => {
    return {
        position: 'absolute',
        height: '100%',
        width: '100%',
        background: isVideoReady ? 'black' : palette.neutralLighterAlt,
        opacity: isVideoReady ? 0.6 : 1,
        zIndex: OVERLAY_BACKGROUND_ZINDEX
    };
};
/**
 * @private
 */
const overlayContentStyles = {
    height: '100%',
    width: '100%',
    zIndex: OVERLAY_CONTENT_ZINDEX
};
/**
 * @private
 */
const videoTileStyles = {
    root: {
        height: '100%',
        width: '100%'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const onRenderEmptyPlaceholder = () => React.createElement(React.Fragment, null);
const localVideoViewOptions$1 = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * @private
 */
const ExpandedLocalVideoTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const renderElement = videoStream === null || videoStream === void 0 ? void 0 : videoStream.renderElement;
    const palette = useTheme().palette;
    React.useEffect(() => {
        if (videoStream && isVideoReady) {
            props.onCreateLocalStreamView && props.onCreateLocalStreamView(localVideoViewOptions$1).catch(err => console.log('Can not render video', err));
        }
    }, [isVideoReady, videoStream, props, renderElement]);
    return React.createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", styles: containerStyles, grow: true },
        React.createElement(VideoTile, { styles: videoTileStyles, renderElement: renderElement ? React.createElement(StreamMedia, { videoStreamElement: renderElement }) : undefined, onRenderPlaceholder: onRenderEmptyPlaceholder }, props.overlayContent && React.createElement(React.Fragment, null,
            React.createElement(react.Stack, { className: react.mergeStyles(overlayBackgroundStyles(palette, isVideoReady)) }),
            React.createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(overlayContentStyles) }, props.overlayContent))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const containerStyle$1 = {
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem',
    gap: `1.5rem`
};
/**
 * @private
 */
const titleContainerStyle = {
    gap: `1rem`
};
/**
 * @private
 */
const titleStyle$1 = (palette, isVideoReady) => ({
    fontSize: '1.25rem',
    fontWeight: react.FontWeights.semibold,
    color: isVideoReady ? 'white' : palette.neutralPrimary,
    textAlign: 'center'
});
/**
 * @private
 */
const moreDetailsStyle$1 = (palette, isVideoReady) => ({
    fontSize: '1rem',
    color: isVideoReady ? 'white' : palette.neutralPrimary,
    textAlign: 'center'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const NetworkReconnectTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const palette = useTheme().palette;
    const strings = useLocale().strings.call;
    const handlers = useHandlers();
    return React.createElement(ExpandedLocalVideoTile, Object.assign({ localParticipantVideoStream: props.localParticipantVideoStream, overlayContent: React.createElement(react.Stack, { verticalFill: true, horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(containerStyle$1), "aria-atomic": true },
            React.createElement(react.Stack, { horizontal: true, className: react.mergeStyles(titleContainerStyle) },
                React.createElement(CallCompositeIcon, { iconName: "NetworkReconnectIcon", className: react.mergeStyles(titleStyle$1(palette, isVideoReady)) }),
                React.createElement(react.Text, { className: react.mergeStyles(titleStyle$1(palette, isVideoReady)), "aria-live": 'assertive' }, strings.networkReconnectTitle)),
            React.createElement(react.Text, { className: react.mergeStyles(moreDetailsStyle$1(palette, isVideoReady)), "aria-live": 'assertive' }, strings.networkReconnectMoreDetails)) }, handlers));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const complianceBannerSelector = reselect__namespace.createSelector([getIsTranscriptionActive, getIsRecordingActive], (isTranscriptionActive, isRecordingActive) => {
    return {
        callTranscribeState: isTranscriptionActive,
        callRecordState: isRecordingActive
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const mutedNotificationSelector = reselect__namespace.createSelector([getUserFacingDiagnostics], diagnostics => {
    var _a;
    return {
        speakingWhileMuted: !!((_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.speakingWhileMicrophoneIsMuted) === null || _a === void 0 ? void 0 : _a.value)
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const lobbySelector = reselect__namespace.createSelector([localVideoSelector], localVideoStreamInfo => {
    return {
        localParticipantVideoStream: localVideoStreamInfo
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const networkReconnectTileSelector = reselect__namespace.createSelector([getUserFacingDiagnostics, lobbySelector], (diagnostics, lobbyProps) => {
    var _a;
    return {
        networkReconnectValue: (_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReconnect) === null || _a === void 0 ? void 0 : _a.value,
        localParticipantVideoStream: lobbyProps.localParticipantVideoStream
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 */
const getMinutes = (time) => {
    return Math.floor(getSeconds(time) / 60);
};
/**
 * @internal
 */
const getSeconds = (time) => {
    return Math.floor(time / 1000);
};
/**
 * @internal
 */
const getHours = (time) => {
    return Math.floor(getMinutes(time) / 60);
};
/**
 * @internal
 */
const getReadableTime = (time) => {
    const hours = getHours(time);
    const readableMinutes = ('0' + getMinutes(time) % 60).slice(-2);
    const readableSeconds = ('0' + getSeconds(time) % 60).slice(-2);
    return `${hours > 0 ? hours + ':' : ''}${readableMinutes}:${readableSeconds}`;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * styles for hold pane timer
 *
 * @private
 */
const DtmfDialpadContentTimerStyles = {
    root: {
        color: 'inherit',
        fontWeight: 600,
        fontSize: _pxToRem(20),
        lineHeight: _pxToRem(28),
        margin: 'auto'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$a = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const DtmfDialpadPageContent = (props) => {
    var _a, _b;
    const { adapter } = props;
    const adapterState = adapter.getState();
    const theme = react.useTheme();
    const calleeId = (_a = adapterState.targetCallees) === null || _a === void 0 ? void 0 : _a[0];
    const remoteParticipants = (_b = adapterState.call) === null || _b === void 0 ? void 0 : _b.remoteParticipants;
    let calleeName;
    if (remoteParticipants) {
        const remoteParticipantValues = Object.values(remoteParticipants);
        if (calleeId && communicationCommon.isPhoneNumberIdentifier(calleeId)) {
            calleeName = calleeId.phoneNumber;
        }
        else {
            calleeName = remoteParticipantValues.find(p => p.identifier === calleeId);
        }
    }
    return React.createElement(react.Stack, { style: {
            height: '100%',
            width: '100%',
            background: theme.palette.white
        } },
        React.createElement(react.Stack, { verticalAlign: 'center', style: {
                margin: 'auto'
            } },
            React.createElement(DtmfDialerContentTimer, null),
            React.createElement(react.Text, { style: {
                    margin: 'auto'
                } }, calleeName && calleeName !== 'Unnamed participant' ? calleeName === null || calleeName === void 0 ? void 0 : calleeName.toString() : ''),
            React.createElement(Dialpad, { onSendDtmfTone: (tone) => __awaiter$a(void 0, void 0, void 0, function* () {
                    yield adapter.sendDtmfTone(tone);
                }), longPressTrigger: props.mobileView ? 'touch' : 'mouseAndTouch', dialpadMode: 'dtmf' })));
};
const DtmfDialerContentTimer = () => {
    const [time, setTime] = React.useState(0);
    const elapsedTime = getReadableTime(time);
    const statefulStartTime = useSelector$1(getStartTime);
    const startTime = React.useMemo(() => {
        return statefulStartTime !== null && statefulStartTime !== void 0 ? statefulStartTime : new Date(Date.now());
    }, [statefulStartTime]);
    React.useEffect(() => {
        const interval = setInterval(() => {
            var _a;
            setTime((_a = new Date(Date.now()).getTime() - (startTime === null || startTime === void 0 ? void 0 : startTime.getTime())) !== null && _a !== void 0 ? _a : 0);
        }, 10);
        return () => {
            clearInterval(interval);
        };
    }, [startTime]);
    return React.createElement(react.Text, { styles: DtmfDialpadContentTimerStyles }, elapsedTime);
};
/**
 * @internal
 */
const DtmfDialpadPage = (props) => {
    const adapter = useAdapter();
    return React.createElement(DtmfDialpadPageContent, { adapter: adapter, mobileView: props.mobileView });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const CallPage = (props) => {
    const { callInvitationURL, onFetchAvatarPersonaData, onFetchParticipantMenuItems, options, mobileView, galleryLayout = 'floatingLocalVideo', onUserSetGalleryLayoutChange, userSetOverflowGalleryPosition = 'Responsive', onSetUserSetOverflowGalleryPosition, onCloseChatPane } = props;
    // To use useProps to get these states, we need to create another file wrapping Call,
    // It seems unnecessary in this case, so we get the updated states using this approach.
    const { callStatus } = useSelector$1(callStatusSelector);
    const mediaGalleryProps = useSelector$1(mediaGallerySelector);
    const mediaGalleryHandlers = useHandlers();
    const complianceBannerProps = useSelector$1(complianceBannerSelector);
    const errorBarProps = usePropsFor$1(ErrorBar);
    const mutedNotificationProps = useSelector$1(mutedNotificationSelector);
    const networkReconnectTileProps = useSelector$1(networkReconnectTileSelector);
    const remoteParticipantsConnected = useSelector$1(getRemoteParticipantsConnectedSelector);
    const callees = useSelector$1(getTargetCallees);
    const renderDtmfDialerFromStart = showDtmfDialer(callees, remoteParticipantsConnected);
    const [dtmfDialerPresent, setDtmfDialerPresent] = React.useState(renderDtmfDialerFromStart);
    const strings = useLocale().strings.call;
    // Reduce the controls shown when mobile view is enabled.
    const callControlOptions = mobileView ? reduceCallControlsForMobile(options === null || options === void 0 ? void 0 : options.callControls) : options === null || options === void 0 ? void 0 : options.callControls;
    const drawerMenuHostId = reactHooks.useId('drawerMenuHost');
    const onRenderGalleryContentTrampoline = () => {
        if (dtmfDialerPresent) {
            return React.createElement(DtmfDialpadPage, { mobileView: props.mobileView, modalLayerHostId: props.modalLayerHostId, options: props.options, updateSidePaneRenderer: props.updateSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader, latestErrors: props.latestErrors, onDismissError: props.onDismissError, 
                /* @conditional-compile-remove(capabilities) */ capabilitiesChangedNotificationBarProps: props.capabilitiesChangedNotificationBarProps, onSetDialpadPage: () => setDtmfDialerPresent(!dtmfDialerPresent), dtmfDialerPresent: dtmfDialerPresent });
        }
        else {
            return React.createElement(MediaGallery, Object.assign({ isMobile: mobileView }, mediaGalleryProps, mediaGalleryHandlers, { onFetchAvatarPersonaData: onFetchAvatarPersonaData, remoteVideoTileMenuOptions: options === null || options === void 0 ? void 0 : options.remoteVideoTileMenuOptions, drawerMenuHostId: drawerMenuHostId, 
                /* @conditional-compile-remove(click-to-call) */ localVideoTileOptions: options === null || options === void 0 ? void 0 : options.localVideoTile, userSetOverflowGalleryPosition: userSetOverflowGalleryPosition, userSetGalleryLayout: galleryLayout }));
        }
    };
    return React.createElement(React.Fragment, null,
        React.createElement(CallArrangement, { id: drawerMenuHostId, complianceBannerProps: Object.assign(Object.assign({}, complianceBannerProps), { strings }), errorBarProps: (options === null || options === void 0 ? void 0 : options.errorBar) !== false && errorBarProps, mutedNotificationProps: mutedNotificationProps, callControlProps: {
                callInvitationURL: callInvitationURL,
                onFetchParticipantMenuItems: onFetchParticipantMenuItems,
                options: callControlOptions,
                increaseFlyoutItemSize: mobileView
            }, 
            /* @conditional-compile-remove(one-to-n-calling) */ /* @conditional-compile-remove(close-captions) */ onFetchAvatarPersonaData: onFetchAvatarPersonaData, mobileView: mobileView, modalLayerHostId: props.modalLayerHostId, onRenderGalleryContent: () => _isInCall(callStatus) ? isNetworkHealthy(networkReconnectTileProps.networkReconnectValue) ? onRenderGalleryContentTrampoline() : React.createElement(NetworkReconnectTile, Object.assign({}, networkReconnectTileProps)) : React.createElement(React.Fragment, null), updateSidePaneRenderer: props.updateSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader, onCloseChatPane: onCloseChatPane, dataUiId: 'call-page', latestErrors: props.latestErrors, onDismissError: props.onDismissError, onUserSetOverflowGalleryPositionChange: onSetUserSetOverflowGalleryPosition, onUserSetGalleryLayoutChange: onUserSetGalleryLayoutChange, userSetGalleryLayout: galleryLayout, 
            /* @conditional-compile-remove(capabilities) */ capabilitiesChangedNotificationBarProps: props.capabilitiesChangedNotificationBarProps, onSetDialpadPage: () => setDtmfDialerPresent(!dtmfDialerPresent), dtmfDialerPresent: dtmfDialerPresent }));
};
/**
 * @private
 */
const isNetworkHealthy = (value) => {
    // We know that the value is actually of type DiagnosticQuality for this diagnostic.
    // We ignore any boolen values, considering the network to still be healthy.
    // Thus, only DiagnosticQuality.Poor or .Bad indicate network problems.
    return value === true || value === false || value === undefined || value === communicationCalling.DiagnosticQuality.Good;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const DROPDOWN_HEIGHT_REM = 2.25;
/**
 * @private
 */
const mainStackTokens = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const soundStackTokens = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const dropDownStyles = (theme) => ({
    caretDownWrapper: {
        height: `${DROPDOWN_HEIGHT_REM}rem`,
        lineHeight: `${DROPDOWN_HEIGHT_REM}rem`
    },
    dropdownItem: {
        fontSize: '0.875rem',
        height: `${DROPDOWN_HEIGHT_REM}rem`,
        background: theme.palette.white
    },
    dropdown: {
        height: `${DROPDOWN_HEIGHT_REM}rem`,
        width: '100%',
        svg: {
            verticalAlign: 'top'
        }
    },
    title: {
        fontSize: '0.875rem',
        height: `${DROPDOWN_HEIGHT_REM}rem`,
        lineHeight: '2rem',
        borderRadius: '0.25rem',
        border: `1px solid ${theme.palette.neutralQuaternaryAlt}`
    },
    label: {
        fontWeight: 600,
        fontSize: '0.875rem',
        // Add z-index to ensure labels are rendered above the configuration section background
        zIndex: 1
    },
    errorMessage: {
        fontSize: '0.875rem'
    }
});
/**
 * @private
 */
const dropDownTitleIconStyles = react.mergeStyles({
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    minWidth: '0',
    maxWidth: '100%',
    overflowWrap: 'break-word',
    margin: '.063rem'
});
/**
 * @private
 */
const optionIconStyles = react.mergeStyles({
    marginRight: '8px',
    verticalAlign: 'text-top'
});

/**
 * @private
 */
const ConfigurationPageCameraDropdown = (props) => {
    return props.cameraGrantedDropdown;
};

/**
 * @private
 */
const ConfigurationPageMicDropdown = (props) => {
    return props.micGrantedDropdown;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** @private */
const CONFIGURATION_PAGE_SECTION_MIN_WIDTH_REM = 11;
/** @private */
const CONFIGURATION_PAGE_SECTION_MAX_WIDTH_REM = 20.625;
/** @private */
const CONFIGURATION_PAGE_SECTION_HEIGHT_REM = 13.625;
const LOGO_HEIGHT_REM = 3;
/**
 * @private
 */
const configurationStackTokensDesktop = {
    childrenGap: '1.5rem'
};
/**
 * @private
 */
const configurationStackTokensMobile = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const deviceConfigurationStackTokens = {
    childrenGap: '1.5rem'
};
/** @private */
const configurationContainerStyle = (desktop, backgroundImageUrl) => ({
    root: {
        height: '100%',
        width: '100%',
        padding: desktop ? '2rem 1rem 2rem 1rem' : '1rem 1rem 2rem 1rem',
        minWidth: desktop ? '25rem' // sum of min-width from children + ChildrenGap * (nb of children - 1) + padding * 2 = (11 + 11) + (2 * 1) + 0.5 * 2
            : '16rem',
        // from LocalPreview: ControlBar width + 0.5 * 2 for spacing + padding * 2 = 14 + 0.5 * 2 + 0.5 * 2
        minHeight: desktop ? '22rem' // max height of SelectionContainer + padding * 2 = 21 + 0.5 * 2
            : '13rem',
        '::before': !backgroundImageUrl ? undefined : Object.assign({ content: '""', position: 'absolute', top: 0, left: 0, zIndex: 0, width: '100%', height: '100%', backgroundImage: `url(${backgroundImageUrl})`, backgroundSize: 'cover', backgroundPosition: 'center' }, react.AnimationStyles.fadeIn500)
    }
});
/**
 * @private
 */
const configurationSectionStyle = {
    root: {
        width: '100%',
        minWidth: `${CONFIGURATION_PAGE_SECTION_MIN_WIDTH_REM}rem`,
        maxWidth: `${CONFIGURATION_PAGE_SECTION_MAX_WIDTH_REM}rem`
    }
};
/**
 * @private
 */
const selectionContainerStyle = (theme, noSpeakerDropdownShown) => react.mergeStyles({
    width: '100%',
    height: noSpeakerDropdownShown ? 'auto' : `${CONFIGURATION_PAGE_SECTION_HEIGHT_REM}rem`,
    padding: '1rem',
    borderRadius: theme.effects.roundedCorner6,
    border: `0.0625rem solid ${theme.palette.neutralLight}`,
    overflow: 'hidden',
    // do not let child background overflow the curved corners
    boxShadow: theme.effects.elevation4,
    // Style the background of the container to have partial transparency.
    // Using `before:` pseudo-element to avoid having to wrap the content in an extra div.
    // Ideally rgba would be used but we cannot garauntee the format of theme.palette.white
    // to parse it correctly.
    position: 'relative',
    ':before': {
        content: '""',
        position: 'absolute',
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        zIndex: 0,
        background: theme.palette.white,
        opacity: 0.9
    }
});
/**
 * @private
 */
const titleContainerStyleDesktop = (theme) => react.mergeStyles({
    fontSize: '1.2rem',
    lineHeight: '1rem',
    fontWeight: 600
}, configurationPageTextDecoration(theme));
/**
 * @private
 */
const titleContainerStyleMobile = (theme) => react.mergeStyles({
    fontSize: '1.0625rem',
    lineHeight: '1.375rem',
    fontWeight: 600,
    textAlign: 'center'
}, configurationPageTextDecoration(theme));
/**
 * Ensure configuration page text is legible on top of a background image.
 * @private
 */
const configurationPageTextDecoration = (theme) => {
    return {
        textShadow: `0px 0px 8px ${theme.palette.whiteTranslucent40}`,
        fill: theme.semanticColors.bodyText,
        stroke: theme.palette.whiteTranslucent40,
        paintOrder: 'stroke fill',
        strokeWidth: _pxToRem(1.5),
        text: {
            letterSpacing: '-0.02rem' // cope with extra width due to stroke width
        },
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'auto',
            fill: theme.palette.neutralQuaternaryAlt,
            textShadow: 'none',
            stroke: 'none'
        }
    };
};
/**
 * @private
 */
const callDetailsContainerStyles = {
    root: {
        textAlign: 'center',
        maxWidth: _pxToRem(700),
        alignSelf: 'center'
    }
};
const callDetailsStyle = (theme) => ({
    fontSize: '0.9375',
    lineHeight: '1.25rem',
    textShadow: `0px 0px 8px ${theme.palette.whiteTranslucent40}`,
    marginTop: '-0.33rem' // compensate for extra padding around the CallTitle that avoids the SVG shadowing being cut off
});
/**
 * @private
 */
const callDetailsStyleDesktop = (theme) => react.mergeStyles(callDetailsStyle(theme));
/**
 * @private
 */
const callDetailsStyleMobile = (theme) => react.mergeStyles(callDetailsStyle(theme), {
    marginBottom: '0.5rem',
    textAlign: 'center'
});
/**
 * @private
 */
const startCallButtonContainerStyleDesktop = {
    root: {
        paddingTop: '1.125rem'
    }
};
/**
 * @private
 */
const startCallButtonContainerStyleMobile = {
    root: {
        textAlign: 'center'
    }
};
/**
 * @private
 */
const startCallButtonStyleMobile = react.mergeStyles({
    width: '100%',
    maxWidth: 'unset',
    borderRadius: '0.25rem'
});
/**
 * @private
 */
const startCallButtonStyleDesktop = react.mergeStyles({
    borderRadius: '0.25rem',
    width: 'auto',
    height: '2.25rem'
});
/** @private */
const cameraAndVideoEffectsContainerStyleDesktop = {
    root: {
        alignItems: 'center'
    }
};
/**
 * @private
 */
const effectsButtonStyles = (theme) => {
    return {
        root: {
            background: 'transparent',
            border: 'none',
            color: theme.palette.themePrimary,
            // Top and bottom padding needs to be 5px to match the label padding
            padding: '5px 0.25rem',
            ':hover, :focus': {
                color: theme.palette.themePrimary
            },
            svg: {
                height: '1rem',
                width: '1rem'
            }
        },
        rootChecked: {
            color: theme.palette.themePrimary
        },
        rootHovered: {
            color: theme.palette.themePrimary
        },
        rootPressed: {
            color: theme.palette.themePrimary
        },
        rootFocused: {
            color: theme.palette.themePrimary
        }
    };
};
/** @private */
const fillWidth = react.mergeStyles({
    width: '100%',
    position: 'relative'
});
/** @private */
const configurationCenteredContent = (fillsHeight, hasLogo) => react.mergeStyles({
    width: '100%',
    position: 'relative',
    // If the content does not fill the height, center it vertically.
    // We do not include the logo in the centering per design. This allows it to fade
    // in and not shift the content. To exclude the logo, we subtract the logo height
    // and margin from the actual height. This allows the flex box's natural centering
    // to appropriately center the content.
    height: `calc(100% - ${!fillsHeight && hasLogo ? `${LOGO_HEIGHT_REM}rem` : '0rem'})`
});
/** @private */
const panelStyles = {
    content: {
        display: 'flex',
        flexBasis: '100%',
        paddingLeft: '0rem',
        // remove default padding
        paddingRight: '0rem' // remove default padding
    },
    commands: {
        paddingTop: '0rem' // remove default padding
    },
    scrollableContent: {
        display: 'flex',
        flexDirection: 'column',
        height: '100%'
    }
};
/** @private */
const panelFocusProps = {
    forceFocusInsideTrap: false
};
/**
 * @private
 */
const logoStyles = (shape) => ({
    root: {
        overflow: 'initial',
        // prevent the image being clipped
        display: 'flex',
        justifyContent: 'center'
    },
    image: {
        height: `${LOGO_HEIGHT_REM}rem`,
        borderRadius: shape === 'circle' ? '100%' : undefined,
        aspectRatio: shape === 'circle' ? '1 / 1' : undefined,
        objectFit: shape === 'circle' ? 'cover' : undefined
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const getDropDownList = (list) => {
    // Remove duplicates
    const noDuplicates = new Map();
    for (const item of list) {
        noDuplicates.set(item.id, item);
    }
    const dropdownList = [];
    for (const item of noDuplicates.values()) {
        dropdownList.push({
            key: item.id,
            text: item.name === '' ? item.deviceType : item.name
        });
    }
    return dropdownList;
};
const getOptionIcon = (type) => {
    if (type === 'Camera') {
        return React.createElement(CallCompositeIcon, { iconName: "LocalDeviceSettingsCamera", className: optionIconStyles });
    }
    else if (type === 'Microphone') {
        return React.createElement(CallCompositeIcon, { iconName: "LocalDeviceSettingsMic", className: optionIconStyles });
    }
    else if (type === 'Speaker') {
        return React.createElement(CallCompositeIcon, { iconName: "LocalDeviceSettingsSpeaker", className: optionIconStyles });
    }
    else {
        return undefined;
    }
};
const onRenderTitle = (iconType, props) => {
    const icon = props && getOptionIcon(iconType);
    return props ? React.createElement("div", { className: dropDownTitleIconStyles },
        icon,
        React.createElement("span", null, props[0].text)) : React.createElement(React.Fragment, null);
};
const localVideoViewOptions = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * @private
 */
const LocalDeviceSettings = (props) => {
    var _a, _b;
    const theme = useTheme();
    const locale = useLocale();
    /* @conditional-compile-remove(call-readiness) */ /* @conditional-compile-remove(video-background-effects) */ /* @conditional-compile-remove(rooms) */
    const adapter = useAdapter();
    /* @conditional-compile-remove(video-background-effects) */
    const onResolveVideoEffectDependency = adapter.getState().onResolveVideoEffectDependency;
    const defaultPlaceHolder = locale.strings.call.defaultPlaceHolder;
    const cameraLabel = locale.strings.call.cameraLabel;
    const soundLabel = locale.strings.call.soundLabel;
    const noSpeakersLabel = locale.strings.call.noSpeakersLabel;
    const noCameraLabel = locale.strings.call.noCamerasLabel;
    const noMicLabel = locale.strings.call.noMicrophonesLabel;
    /* @conditional-compile-remove(rooms) */
    const role = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.role;
    const cameraPermissionGranted = props.cameraPermissionGranted;
    const micPermissionGranted = props.microphonePermissionGranted;
    let roleCanUseCamera = true;
    let roleCanUseMic = true;
    /* @conditional-compile-remove(rooms) */
    roleCanUseCamera = role === 'Consumer' ? false : true;
    /* @conditional-compile-remove(rooms) */
    roleCanUseMic = role === 'Consumer' ? false : true;
    // TODO: speaker permission is tied to microphone permission (when you request 'audio' permission using the SDK) its
    // actually granting access to query both microphone and speaker. However the browser popup asks you explicity for
    // 'microphone'. This needs investigation on how we want to handle this and maybe needs follow up with SDK team.
    const hasCameras = props.cameras.length > 0;
    const hasMicrophones = props.microphones.length > 0;
    const hasSpeakers = props.speakers.length > 0;
    const cameraGrantedDropdown = React.createElement(react.Dropdown, { "data-ui-id": "call-composite-local-camera-settings", "aria-labelledby": 'call-composite-local-camera-settings-label', placeholder: hasCameras ? defaultPlaceHolder : noCameraLabel, options: cameraPermissionGranted ? getDropDownList(props.cameras) : [{
                key: 'deniedOrUnknown',
                text: ''
            }], styles: dropDownStyles(theme), disabled: !cameraPermissionGranted || !hasCameras, errorMessage: props.cameraPermissionGranted === undefined || props.cameraPermissionGranted ? undefined : locale.strings.call.cameraPermissionDenied, defaultSelectedKey: micPermissionGranted ? props.selectedCamera ? props.selectedCamera.id : props.cameras ? (_b = props.cameras[0]) === null || _b === void 0 ? void 0 : _b.id : '' : 'deniedOrUnknown', onChange: (event, option, index) => {
            props.onSelectCamera(props.cameras[index !== null && index !== void 0 ? index : 0], localVideoViewOptions);
        }, onRenderTitle: (props) => onRenderTitle('Camera', props) });
    const micGrantedDropdown = React.createElement(React.Fragment, null, roleCanUseMic && React.createElement(react.Dropdown, { "aria-labelledby": 'call-composite-local-sound-settings-label', placeholder: hasMicrophones ? defaultPlaceHolder : noMicLabel, styles: dropDownStyles(theme), disabled: !micPermissionGranted || !hasMicrophones, errorMessage: props.microphonePermissionGranted === undefined || props.microphonePermissionGranted ? undefined : locale.strings.call.microphonePermissionDenied, options: micPermissionGranted ? getDropDownList(props.microphones) : [{
                key: 'deniedOrUnknown',
                text: ''
            }], defaultSelectedKey: micPermissionGranted ? props.selectedMicrophone ? props.selectedMicrophone.id : defaultDeviceId(props.microphones) : 'deniedOrUnknown', onChange: (event, option, index) => {
            props.onSelectMicrophone(props.microphones[index !== null && index !== void 0 ? index : 0]);
        }, onRenderTitle: (props) => onRenderTitle('Microphone', props) }));
    const speakerDropdown = React.createElement(react.Dropdown, { "aria-labelledby": 'call-composite-local-sound-settings-label', placeholder: hasSpeakers ? defaultPlaceHolder : noSpeakersLabel, styles: dropDownStyles(theme), disabled: props.speakers.length === 0, options: getDropDownList(props.speakers), defaultSelectedKey: props.selectedSpeaker ? props.selectedSpeaker.id : defaultDeviceId(props.speakers), onChange: (event, option, index) => {
            props.onSelectSpeaker(props.speakers[index !== null && index !== void 0 ? index : 0]);
        }, onRenderTitle: (props) => onRenderTitle('Speaker', props) });
    const SafariBrowserSpeakerDropdownTrampoline = () => {
        return speakerDropdown;
    };
    return React.createElement(react.Stack, { "data-ui-id": "call-composite-device-settings", tokens: mainStackTokens },
        roleCanUseCamera && React.createElement(react.Stack, null,
            React.createElement(react.Stack, { horizontal: true, horizontalAlign: "space-between", styles: cameraAndVideoEffectsContainerStyleDesktop },
                React.createElement(react.Label, { id: 'call-composite-local-camera-settings-label', className: react.mergeStyles(dropDownStyles(theme).label), disabled: !cameraPermissionGranted }, cameraLabel), /* @conditional-compile-remove(video-background-effects) */
                onResolveVideoEffectDependency && React.createElement(react.DefaultButton, { iconProps: {
                        iconName: 'ConfigurationScreenVideoEffectsButton'
                    }, styles: effectsButtonStyles(theme), onClick: props.onClickVideoEffects, "data-ui-id": 'call-config-video-effects-button' }, locale.strings.call.configurationPageVideoEffectsButtonLabel)),
            React.createElement(ConfigurationPageCameraDropdown, { cameraGrantedDropdown: cameraGrantedDropdown, cameraPermissionGranted: cameraPermissionGranted !== null && cameraPermissionGranted !== void 0 ? cameraPermissionGranted : false })),
        React.createElement(react.Stack, null,
            React.createElement(react.Label, { id: 'call-composite-local-sound-settings-label', className: react.mergeStyles(dropDownStyles(theme).label), disabled: !micPermissionGranted }, soundLabel),
            React.createElement(react.Stack, { "data-ui-id": "call-composite-sound-settings", tokens: soundStackTokens },
                React.createElement(ConfigurationPageMicDropdown, { micGrantedDropdown: micGrantedDropdown, micPermissionGranted: micPermissionGranted !== null && micPermissionGranted !== void 0 ? micPermissionGranted : false }),
                React.createElement(SafariBrowserSpeakerDropdownTrampoline, null))));
};
const defaultDeviceId = (devices) => {
    if (devices.length === 0) {
        return '';
    }
    const defaultDevice = devices.find(device => device.isSystemDefault);
    if (defaultDevice) {
        return defaultDevice.id;
    }
    return devices[0].id;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const videoCameraIconStyle = react.mergeStyles({
    marginRight: '0.375rem',
    fontSize: '1.375rem'
});
/**
 * @private
 */
const buttonStyle = react.mergeStyles({
    fontWeight: 600,
    fontSize: '0.875rem',
    // 14px
    height: '2.75rem',
    width: '100%'
});
/**
 * @private
 */
const buttonWithIconStyles = {
    textContainer: {
        display: 'contents'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const StartCallButton = (props) => {
    const { rejoinCall } = props;
    const locale = useLocale();
    return React.createElement(react.PrimaryButton, Object.assign({}, props, { "data-ui-id": "call-composite-start-call-button", className: react.mergeStyles(buttonStyle, props.className), styles: buttonWithIconStyles, text: rejoinCall ? locale.strings.call.rejoinCallButtonLabel : locale.strings.call.startCallButtonLabel, onRenderIcon: props.hideIcon ? undefined : () => React.createElement(reactIcons.Video20Filled, { className: videoCameraIconStyle }) }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const devicePermissionSelector = reselect__namespace.createSelector([getDeviceManager], deviceManager => {
    return {
        video: deviceManager.deviceAccess ? deviceManager.deviceAccess.video : undefined,
        audio: deviceManager.deviceAccess ? deviceManager.deviceAccess.audio : undefined
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const localPreviewSelector = reselect__namespace.createSelector([getDeviceManager], deviceManager => {
    // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
    // handle cases where 'Preview' view is in progress and not necessary completed.
    const view = deviceManager.cameras.length > 0 &&
        // This ensures that the video stream is reset if camera devices are removed.
        deviceManager.unparentedViews.length > 0 && deviceManager.unparentedViews[0].view;
    return {
        videoStreamElement: view ? view.target : null
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const localPreviewContainerStyle = (theme) => ({
    borderRadius: theme.effects.roundedCorner6,
    overflow: 'hidden' // do not let child background overflow the curved corners
});
/**
 * @private
 */
const localPreviewContainerStyleDesktop = (theme) => react.mergeStyles(localPreviewContainerStyle(theme), {
    width: '100%',
    height: `${CONFIGURATION_PAGE_SECTION_HEIGHT_REM}rem`,
    minWidth: `${CONFIGURATION_PAGE_SECTION_MIN_WIDTH_REM}rem`,
    maxWidth: `${CONFIGURATION_PAGE_SECTION_MAX_WIDTH_REM}rem`,
    border: `0.0625rem solid ${theme.palette.neutralLight}`,
    borderRadius: theme.effects.roundedCorner6,
    boxShadow: theme.effects.elevation4
});
/**
 * @private
 */
const localPreviewContainerStyleMobile = (theme) => react.mergeStyles(localPreviewContainerStyle(theme), {
    width: '100%',
    height: '100%',
    minHeight: `${CONFIGURATION_PAGE_SECTION_HEIGHT_REM}rem`
});
/**
 * @private
 */
const cameraOffLabelStyle = react.mergeStyles({
    fontSize: '0.75rem' // 12px
});
/**
 * @private
 */
const localPreviewTileStyle = {
    root: {
        '@media (forced-colors: active)': {
            borderColor: '#FFFFFF',
            border: '1px solid'
        }
    }
};
/**
 * @private
 */
const localPreviewButtonStyle = {
    root: {
        '@media (forced-colors: active)': {
            ':focus': {
                border: '1px solid !important' // we need bang important to override fluents colours
            },
            ':focus::after': {
                border: 'unset !important',
                // we need bang important to override fluents colours
                outline: 'unset !important'
            }
        }
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$9 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const LocalPreview = (props) => {
    const locale = useLocale();
    const cameraButtonProps = usePropsFor$1(CameraButton);
    const localPreviewProps = useSelector$1(localPreviewSelector);
    const devicesButtonProps = usePropsFor$1(DevicesButton);
    const { audio: microphonePermissionGranted, video: cameraPermissionGranted } = useSelector$1(devicePermissionSelector);
    const isLocalMicrophoneEnabled = useSelector$1(getLocalMicrophoneEnabled);
    const adapter = useAdapter();
    const onToggleMic = React.useCallback(() => __awaiter$9(void 0, void 0, void 0, function* () {
        isLocalMicrophoneEnabled ? adapter.mute() : adapter.unmute();
    }), [adapter, isLocalMicrophoneEnabled]);
    const hasNoSpeakers = !devicesButtonProps.speakers.length;
    const hasNoDevices = devicesButtonProps.cameras.length === 0 && devicesButtonProps.microphones.length === 0 && devicesButtonProps.speakers.length === 0;
    const hasCameras = devicesButtonProps.cameras.length > 0;
    const hasMicrophones = devicesButtonProps.microphones.length > 0;
    const theme = useTheme();
    const onRenderPlaceholder = React.useCallback(() => {
        return React.createElement(react.Stack, { className: react.mergeStyles({
                width: '100%',
                height: '100%',
                // The text should be centered in the local preview with the camera icon
                // appearing above the text. To compensate for the camera icon's height,
                // we add a negative margin to the top of the container.
                marginTop: '-0.8rem'
            }), verticalAlign: "center" },
            React.createElement(react.Stack.Item, { align: "center" },
                React.createElement(CallCompositeIcon, { iconName: "LocalPreviewPlaceholder", className: react.mergeStyles(cameraOffLabelStyle, {
                        color: theme.palette.neutralTertiary
                    }) })),
            React.createElement(react.Stack.Item, { align: "center" },
                React.createElement(react.Text, { className: react.mergeStyles(cameraOffLabelStyle, {
                        color: theme.palette.neutralSecondary
                    }) }, locale.strings.call.cameraTurnedOff)));
    }, [theme, locale.strings.call.cameraTurnedOff]);
    const devicesButtonStyles = props.mobileView ? {
        menuStyles: {
            menuItemStyles: buttonFlyoutIncreasedSizeStyles
        }
    } : undefined;
    return React.createElement(react.Stack, { "data-ui-id": "call-composite-local-preview", className: props.mobileView ? localPreviewContainerStyleMobile(theme) : localPreviewContainerStyleDesktop(theme) },
        React.createElement(VideoTile, { styles: localPreviewTileStyle, renderElement: (localPreviewProps === null || localPreviewProps === void 0 ? void 0 : localPreviewProps.videoStreamElement) ? React.createElement(StreamMedia, { videoStreamElement: localPreviewProps.videoStreamElement }) : undefined, onRenderPlaceholder: onRenderPlaceholder },
            React.createElement(ControlBar, { layout: "floatingBottom" },
                React.createElement(MicrophoneButton, { "data-ui-id": "call-composite-local-device-settings-microphone-button", checked: isLocalMicrophoneEnabled, onToggleMicrophone: onToggleMic, disabled: !microphonePermissionGranted || !hasMicrophones, showLabel: true, 
                    // disable tooltip as it obscures list of devices on mobile
                    strings: props.mobileView ? {
                        tooltipOnContent: '',
                        tooltipOffContent: '',
                        tooltipDisabledContent: ''
                    } : {}, styles: localPreviewButtonStyle }),
                React.createElement(CameraButton, Object.assign({ "data-ui-id": "call-composite-local-device-settings-camera-button" }, cameraButtonProps, { showLabel: true, disabled: !cameraPermissionGranted || !hasCameras, 
                    // disable tooltip as it obscures list of devices on mobile
                    strings: props.mobileView ? {
                        tooltipOnContent: '',
                        tooltipOffContent: '',
                        tooltipDisabledContent: '',
                        tooltipVideoLoadingContent: ''
                    } : {}, styles: localPreviewButtonStyle })),
                props.showDevicesButton && React.createElement(DevicesButton, Object.assign({ "data-ui-id": "call-composite-local-device-settings-options-button" }, devicesButtonProps, { 
                    // disable button whilst all other buttons are disabled
                    disabled: !microphonePermissionGranted && !cameraPermissionGranted && hasNoSpeakers || hasNoDevices, showLabel: true, 
                    // disable tooltip as it obscures list of devices on mobile
                    strings: props.mobileView ? {
                        tooltipContent: ''
                    } : {}, styles: devicesButtonStyles })))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const ConfigurationPageErrorBar = (props) => {
    const { errorBarProps } = props;
    return React.createElement(ErrorBar, Object.assign({}, errorBarProps, { onDismissError: props.onDismissError }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * An SVG element component that wraps inner text to fit the width of the SVG.
 * @private
 */
const SvgWithWordWrapping = (props) => {
    const { width, text, lineHeightPx, bufferHeightPx } = props;
    const svgRef = React.useRef(null);
    const calculationTextElement = React.useRef(null);
    const visibleTextElement = React.useRef(null);
    const [height, setHeight] = React.useState(0);
    // useLayoutEffect ensures that the calculationTextElement is rendered before being used for calculations.
    // Using useLayoutEffect over useEffect ensures we do not get a layout shift when the visibleTextElement is rendered
    // and the height is updated. This is because useLayoutEffect runs synchronously after DOM mutations but
    // before the browser has a chance to paint. See https://reactjs.org/docs/hooks-reference.html#uselayouteffect
    // for more details.
    React.useLayoutEffect(() => {
        if (text && calculationTextElement.current && visibleTextElement.current) {
            const numLines = convertTextToWrappedText(calculationTextElement.current, visibleTextElement.current, width, lineHeightPx);
            setHeight(numLines * lineHeightPx);
        }
    }, [width, lineHeightPx, text]);
    return React.createElement("svg", { width: width, height: height + bufferHeightPx, ref: svgRef, xmlns: "http://www.w3.org/2000/svg" },
        React.createElement("text", { height: 0, ref: calculationTextElement, style: {
                visibility: 'hidden'
            } }, text),
        React.createElement("text", { ref: visibleTextElement, x: "0", y: bufferHeightPx / 4, role: "heading", "aria-level": 1 }));
};
/**
 * Wrap text in tspan elements to fit the width of the SVG
 * @param baseTextElement The text element to create the wrapped text from.
 * @param outputTextElement The text element to insert the wrapped text into.
 * @param maxWidth The maximum width of the text element.
 * @param lineHeightPx The height of each line in pixels.
 * @returns The number of lines of text.
 */
const convertTextToWrappedText = (inputTextElement, outputTextElement, maxWidth, lineHeightPx) => {
    var _a, _b;
    const words = (_b = (_a = inputTextElement.textContent) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];
    if (words.length === 0 || words[0] === '') {
        throw new Error('Text element must contain text');
    }
    // The current line being built.
    let line = '';
    // Running total of the number of lines.
    let numLines = 0;
    // First, clear the output text element.
    outputTextElement.textContent = '';
    // Iterate through each word and create a tspan element for each line.
    for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const testWidth = inputTextElement.getSubStringLength(0, testLine.length);
        if (testWidth > maxWidth && i > 0) {
            const newLine = constructTSpanLine(line, lineHeightPx);
            outputTextElement.appendChild(newLine);
            line = words[i] + ' ';
            numLines++;
        }
        else {
            line = testLine;
        }
    }
    // Add the last line.
    const newLine = constructTSpanLine(line, lineHeightPx);
    outputTextElement.appendChild(newLine);
    numLines++;
    // Return the number of lines to calculate the height of the SVG.
    return numLines;
};
/**
 * Create a tspan element for a line of text, with text set to be centered.
 * @param line The line of text.
 * @param lineHeightPx The height of each line in pixels.
 * @returns The tspan element.
 */
const constructTSpanLine = (line, lineHeightPx) => {
    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
    tspan.textContent = line;
    tspan.setAttribute('x', '50%');
    tspan.setAttribute('dy', `${lineHeightPx}px`);
    tspan.setAttribute('text-anchor', 'middle');
    return tspan;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$8 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const ConfigurationPage = (props) => {
    var _a, _b, _c;
    const { startCallHandler, mobileView, modalLayerHostId } = props;
    const theme = useTheme();
    const options = useAdaptedSelector(getSelector$1(DevicesButton));
    const localDeviceSettingsHandlers = useHandlers();
    const { video: cameraPermissionGranted, audio: microphonePermissionGranted } = useSelector$1(devicePermissionSelector);
    const errorBarProps = usePropsFor$1(ErrorBar);
    const adapter = useAdapter();
    const deviceState = adapter.getState().devices;
    let disableStartCallButton = !microphonePermissionGranted || ((_a = deviceState.microphones) === null || _a === void 0 ? void 0 : _a.length) === 0;
    /* @conditional-compile-remove(rooms) */
    const role = (_b = adapter.getState().call) === null || _b === void 0 ? void 0 : _b.role;
    /* @conditional-compile-remove(video-background-effects) */
    const isCameraOn = useSelector$1(localVideoSelector).isAvailable;
    let filteredLatestErrors = props.latestErrors;
    /* @conditional-compile-remove(rooms) */
    // TODO: move this logic to the error bar selector once role is plumbed from the headless SDK
    if (role !== 'Consumer') {
        filteredLatestErrors = filteredLatestErrors.filter(e => e.type !== 'callCameraAccessDenied' && e.type !== 'callCameraAccessDeniedSafari');
    }
    /* @conditional-compile-remove(video-background-effects) */
    if ((useIsParticularSidePaneOpen('videoeffects') || !isCameraOn) && errorBarProps) {
        filteredLatestErrors = filteredLatestErrors.filter(e => e.type !== 'unableToStartVideoEffect');
    }
    /* @conditional-compile-remove(rooms) */
    if (role === 'Consumer') {
        // If user's role permissions do not allow access to the microphone button then DO NOT disable the start call button
        // because microphone device permission is not needed for the user's role
        disableStartCallButton = false;
    }
    const locale = useLocale();
    const title = locale.strings.call.configurationPageTitle.length > 0 ? React.createElement(react.Stack.Item, { className: mobileView ? titleContainerStyleMobile(theme) : titleContainerStyleDesktop(theme) },
        React.createElement(SvgWithWordWrapping, { width: mobileView ? 325 : 445, lineHeightPx: 16 * 1.5, bufferHeightPx: 16, text: locale.strings.call.configurationPageTitle })) : React.createElement(React.Fragment, null);
    const callDescription = locale.strings.call.configurationPageCallDetails && React.createElement(react.Stack.Item, { className: mobileView ? callDetailsStyleMobile(theme) : callDetailsStyleDesktop(theme) }, locale.strings.call.configurationPageCallDetails);
    let mobileWithPreview = mobileView;
    /* @conditional-compile-remove(rooms) */
    mobileWithPreview = mobileWithPreview && role !== 'Consumer'; // When permission API is not available, we want to show screen saying checking for access (disappears on its own)
    // then based on permission setting, we show permission denied or nothing
    /* @conditional-compile-remove(video-background-effects) */
    const { toggleVideoEffectsPane, closeVideoEffectsPane, isVideoEffectsPaneOpen } = useVideoEffectsPane(props.updateSidePaneRenderer, mobileView, props.latestErrors, props.onDismissError);
    const startCall = React.useCallback(() => __awaiter$8(void 0, void 0, void 0, function* () {
        /* @conditional-compile-remove(video-background-effects) */
        closeVideoEffectsPane();
        startCallHandler();
    }), [startCallHandler, /* @conditional-compile-remove(video-background-effects) */ closeVideoEffectsPane]);
    const panelLayerProps = React.useMemo(() => ({
        hostId: modalLayerHostId
    }), [modalLayerHostId]);
    const filteredErrorBarProps = React.useMemo(() => (Object.assign(Object.assign({}, errorBarProps), { activeErrorMessages: filteredLatestErrors })), [errorBarProps, filteredLatestErrors]);
    const containerStyles = React.useMemo(() => {
        var _a;
        return configurationContainerStyle(!mobileView, /* @conditional-compile-remove(custom-branding) */ (_a = props.backgroundImage) === null || _a === void 0 ? void 0 : _a.url);
    }, [mobileView, /* @conditional-compile-remove(custom-branding) */ (_c = props.backgroundImage) === null || _c === void 0 ? void 0 : _c.url]);
    return React.createElement(react.Stack, { styles: containerStyles },
        React.createElement(react.Stack, { styles: bannerNotificationStyles },
            React.createElement(ConfigurationPageErrorBar, { errorBarProps: filteredErrorBarProps, onDismissError: props.onDismissError })),
        React.createElement(react.Stack, { verticalFill: true, grow: true, horizontal: true, className: fillWidth },
            React.createElement(react.Stack, { className: configurationCenteredContent(mobileWithPreview, /* @conditional-compile-remove(custom-branding) */ !!props.logo), verticalAlign: "center", verticalFill: mobileWithPreview, tokens: mobileWithPreview ? configurationStackTokensMobile : configurationStackTokensDesktop },
                React.createElement(react.Stack.Item, { styles: callDetailsContainerStyles },
                    React.createElement(Logo
                    /* @conditional-compile-remove(custom-branding) */ , { 
                        /* @conditional-compile-remove(custom-branding) */ logo: props.logo }),
                    title,
                    callDescription),
                React.createElement(react.Stack, { horizontal: !mobileWithPreview, horizontalAlign: mobileWithPreview ? 'stretch' : 'center', verticalFill: mobileWithPreview, tokens: deviceConfigurationStackTokens },
                    localPreviewTrampoline(mobileWithPreview, /* @conditional-compile-remove(rooms) */ !!(role === 'Consumer')),
                    React.createElement(react.Stack, { styles: mobileView ? undefined : configurationSectionStyle },
                        !mobileWithPreview && React.createElement(react.Stack, { className: mobileView ? undefined : selectionContainerStyle(theme, isSafariBrowserEnvironmentTrampoline()) },
                            React.createElement(LocalDeviceSettings, Object.assign({}, options, localDeviceSettingsHandlers, { cameraPermissionGranted: cameraPermissionGrantedTrampoline(cameraPermissionGranted), microphonePermissionGranted: micPermissionGrantedTrampoline(microphonePermissionGranted), onClickVideoEffects: toggleVideoEffectsPane }))),
                        React.createElement(react.Stack, { styles: mobileWithPreview ? startCallButtonContainerStyleMobile : startCallButtonContainerStyleDesktop, horizontalAlign: mobileWithPreview ? 'stretch' : 'end' },
                            React.createElement(StartCallButton, { className: mobileWithPreview ? startCallButtonStyleMobile : startCallButtonStyleDesktop, onClick: startCall, disabled: disableStartCallButton, hideIcon: true }))))),
            React.createElement(react.Panel
            /* @conditional-compile-remove(video-background-effects) */ , { 
                /* @conditional-compile-remove(video-background-effects) */ isOpen: isVideoEffectsPaneOpen, hasCloseButton: false, isBlocking: false, isHiddenOnDismiss: false, styles: panelStyles, focusTrapZoneProps: panelFocusProps, layerProps: panelLayerProps, type: react.PanelType.custom, 
                /* @conditional-compile-remove(video-background-effects) */ customWidth: `${VIDEO_EFFECTS_SIDE_PANE_WIDTH_REM}rem` },
                React.createElement(SidePane, { mobileView: props.mobileView, updateSidePaneRenderer: props.updateSidePaneRenderer, maxWidth: `${VIDEO_EFFECTS_SIDE_PANE_WIDTH_REM}rem`, minWidth: `${VIDEO_EFFECTS_SIDE_PANE_WIDTH_REM}rem` }))));
};
const localPreviewTrampoline = (mobileView, doNotShow) => {
    /* @conditional-compile-remove(rooms) */
    if (doNotShow) {
        return undefined;
    }
    return React.createElement(LocalPreview, { mobileView: mobileView, showDevicesButton: mobileView });
};
const cameraPermissionGrantedTrampoline = (cameraPermissionGranted, videoState) => {
    return cameraPermissionGranted;
};
const micPermissionGrantedTrampoline = (microphonePermissionGranted, audioState) => {
    return microphonePermissionGranted;
};
const Logo = (props) => {
    if (!props.logo) {
        return React.createElement(React.Fragment, null);
    }
    return React.createElement(react.Image, { styles: logoStyles(props.logo.shape), src: props.logo.url, alt: props.logo.alt });
};
const isSafariBrowserEnvironmentTrampoline = (environmentInfo) => {
    return false;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const containerStyle = {
    maxWidth: '22.5rem',
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem'
};
/**
 * @private
 */
const containerItemGap = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const rejoinCallButtonContainerStyles = {
    root: {
        paddingTop: '1.125rem',
        borderRadius: '0.25rem'
    }
};
/**
 * @private
 */
const titleStyles = {
    fontSize: '1.25rem',
    fontWeight: 600
};
/**
 * @private
 */
const moreDetailsStyles = {
    fontSize: '1rem'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Generic page with a title and more details text for serving up a notice to the user.
 *
 * @private
 */
function NoticePage(props) {
    const adapter = useAdapter();
    const callees = useSelector$1(getTargetCallees);
    return React.createElement(react.Stack, { className: react.mergeStyles(props.pageStyle), verticalFill: true, verticalAlign: "center", horizontalAlign: "center", "data-ui-id": props.dataUiId, "aria-atomic": true },
        React.createElement(react.Stack, { className: react.mergeStyles(containerStyle), tokens: containerItemGap },
            props.iconName && React.createElement(CallCompositeIcon, { iconName: props.iconName }),
            React.createElement(react.Text, { className: react.mergeStyles(titleStyles), "aria-live": "assertive" }, props.title),
            React.createElement(react.Text, { className: react.mergeStyles(moreDetailsStyles), "aria-live": "assertive" }, props.moreDetails),
            !props.disableStartCallButton && React.createElement(react.Stack, { styles: rejoinCallButtonContainerStyles },
                React.createElement(StartCallButton, { onClick: () => {
                        if (callees && callees.length > 0) {
                            adapter.startCall(callees);
                        }
                        else {
                            adapter.joinCall();
                        }
                    }, disabled: false, rejoinCall: true, autoFocus: true }))));
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const overlayContainerStyle = {
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem'
};
/**
 * @private
 */
const titleStyle = (palette, isVideoReady) => {
    return {
        fontSize: '1rem',
        color: isVideoReady ? 'white' : palette.themePrimary,
        textAlign: 'center'
    };
};
/**
 * @private
 */
const moreDetailsStyle = (palette, isVideoReady) => ({
    fontSize: '0.75rem',
    color: isVideoReady ? 'white' : palette.themePrimary,
    textAlign: 'center'
});
/**
 * @private
 */
const localCameraSwitcherContainerStyles = {
    root: {
        position: 'absolute',
        top: '0rem',
        right: '0rem'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const LobbyTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const cameraSwitcherCameras = useSelector$1(localVideoCameraCycleButtonSelector);
    const cameraSwitcherCallback = useHandlers();
    const palette = useTheme().palette;
    const handlers = useHandlers();
    return React.createElement(ExpandedLocalVideoTile, Object.assign({ localParticipantVideoStream: props.localParticipantVideoStream, overlayContent: props.overlayProps ? React.createElement(react.Stack, { verticalFill: true, horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(overlayContainerStyle), "aria-atomic": true },
            props.showLocalVideoCameraCycleButton && isVideoReady && React.createElement(react.Stack.Item, { styles: localCameraSwitcherContainerStyles },
                React.createElement(LocalVideoCameraCycleButton, Object.assign({}, cameraSwitcherCallback, cameraSwitcherCameras, { size: 'large' }))),
            React.createElement(react.Stack.Item, { className: react.mergeStyles(titleStyle(palette, isVideoReady)) }, props.overlayProps.overlayIcon),
            React.createElement(react.Text, { className: react.mergeStyles(titleStyle(palette, isVideoReady)), "aria-live": "assertive", "data-ui-id": "lobbyScreenTitle" }, props.overlayProps.title),
            props.overlayProps.moreDetails && React.createElement(react.Text, { className: react.mergeStyles(moreDetailsStyle(palette, isVideoReady)), "aria-live": "assertive" }, props.overlayProps.moreDetails)) : undefined }, handlers));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const LobbyPage = (props) => {
    var _a, _b, _c, _d;
    const errorBarProps = usePropsFor$1(ErrorBar);
    const lobbyProps = useSelector$1(lobbySelector);
    const strings = useLocale().strings.call;
    const callState = useSelector$1(getCallStatus);
    const inLobby = callState === 'InLobby';
    const participants = (_a = useSelector$1(getRemoteParticipants)) !== null && _a !== void 0 ? _a : {};
    // Reduce the controls shown when mobile view is enabled.
    let callControlOptions = props.mobileView ? reduceCallControlsForMobile((_b = props.options) === null || _b === void 0 ? void 0 : _b.callControls) : (_c = props.options) === null || _c === void 0 ? void 0 : _c.callControls;
    callControlOptions = disableCallControls(callControlOptions, ['screenShareButton', 'participantsButton']);
    return React.createElement(CallArrangement, { complianceBannerProps: {
            strings
        }, errorBarProps: ((_d = props.options) === null || _d === void 0 ? void 0 : _d.errorBar) !== false && errorBarProps, callControlProps: {
            options: callControlOptions,
            increaseFlyoutItemSize: props.mobileView
        }, mobileView: props.mobileView, modalLayerHostId: props.modalLayerHostId, onRenderGalleryContent: () => React.createElement(LobbyTile, Object.assign({}, lobbyProps, { showLocalVideoCameraCycleButton: props.mobileView, overlayProps: overlayProps(strings, inLobby, Object.values(participants)) })), dataUiId: 'lobby-page', updateSidePaneRenderer: props.updateSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader, latestErrors: props.latestErrors, onDismissError: props.onDismissError });
};
const overlayProps = (strings, inLobby, remoteParticipants) => {
    /**
     * Only grab the first participant because there will only be one in this situation.
     * when starting a call with multiple people the call goes to the connected state and composite goes directly to
     * videoGallery.
     *
     * We also need to check the participant state since in a group call the remote participants array will populate just before
     * the user joins. In this situation we also check the participant states. in a groupCall the state of the participants
     * will be 'Idle'.
     */
    const outboundCallParticipant = remoteParticipants[0] && ['Ringing', 'Connecting'].includes(remoteParticipants[0].state) && remoteParticipants.length === 1 ? remoteParticipants[0] : undefined;
    return inLobby ? overlayPropsWaitingToBeAdmitted(strings) : outboundCallParticipant ? overlayPropsOutboundCall(strings, outboundCallParticipant) : overlayPropsConnectingToCall(strings);
};
const overlayPropsConnectingToCall = (strings) => ({
    title: strings.lobbyScreenConnectingToCallTitle,
    moreDetails: strings.lobbyScreenConnectingToCallMoreDetails,
    overlayIcon: React.createElement(CallCompositeIcon, { iconName: "LobbyScreenConnectingToCall" })
});
const overlayPropsWaitingToBeAdmitted = (strings) => ({
    title: strings.lobbyScreenWaitingToBeAdmittedTitle,
    moreDetails: strings.lobbyScreenWaitingToBeAdmittedMoreDetails,
    overlayIcon: React.createElement(CallCompositeIcon, { iconName: "LobbyScreenWaitingToBeAdmitted" })
});
const overlayPropsOutboundCall = (strings, participant) => {
    var _a;
    if (communicationCommon.isPhoneNumberIdentifier(participant.identifier)) {
        return {
            title: participant.identifier.phoneNumber,
            moreDetails: strings.outboundCallingNoticeString
        };
    }
    else {
        return {
            title: (_a = strings.outboundCallingNoticeString) !== null && _a !== void 0 ? _a : ''
        };
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const pageContainer = {
    width: '100%',
    height: '100%'
};
/**
 * @private
 */
const avatarStyles = {
    opacity: 0.4
};
/**
 * @private
 */
const tileContainerStyles = {
    position: 'absolute',
    top: '0',
    left: '0',
    width: '100%',
    height: '100%',
    minWidth: '100%',
    minHeight: '100%',
    objectPosition: 'center',
    objectFit: 'cover',
    zIndex: 0
};
/**
 * @private
 */
const tileContentStyles = {
    width: '100%',
    position: 'absolute',
    top: '50%',
    transform: 'translate(0, -50%)',
    display: 'flex',
    justifyContent: 'center'
};
/**
 * @private
 */
const defaultPersonaStyles = {
    root: {
        margin: 'auto'
    }
};
/**
 * @private
 */
const displayNameStyles = {
    textAlign: 'center',
    fontSize: '1.5rem',
    fontWeight: 400
};
/**
 * @private
 */
const spinnerStyles = {
    circle: {
        borderWidth: '0.125rem'
    }
};
/**
 * @private
 */
const statusTextStyles = {
    textAlign: 'center',
    fontSize: '1rem'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const TransferPage = (props) => {
    var _a, _b, _c, _d, _e;
    const errorBarProps = usePropsFor$1(ErrorBar);
    const strings = useLocale().strings.call;
    const remoteParticipants = useSelector$1(getRemoteParticipants);
    /* @conditional-compile-remove(call-transfer) */
    const transferCall = useSelector$1(getTransferCall);
    /* @conditional-compile-remove(call-transfer) */
    const [announcerString, setAnnouncerString] = React.useState(undefined);
    // Reduce the controls shown when mobile view is enabled.
    const callControlOptions = props.mobileView ? reduceCallControlsForMobile((_a = props.options) === null || _a === void 0 ? void 0 : _a.callControls) : (_b = props.options) === null || _b === void 0 ? void 0 : _b.callControls;
    const transferor = React.useMemo(() => { var _a; return remoteParticipants ? (_a = Object.values(remoteParticipants)) === null || _a === void 0 ? void 0 : _a[0] : undefined; }, [remoteParticipants]);
    /* @conditional-compile-remove(call-transfer) */
    const transferTarget = React.useMemo(() => { var _a; return (transferCall === null || transferCall === void 0 ? void 0 : transferCall.remoteParticipants) ? (_a = Object.values(transferCall.remoteParticipants)) === null || _a === void 0 ? void 0 : _a[0] : undefined; }, [transferCall]);
    /* @conditional-compile-remove(call-transfer) */
    const pageSubject = React.useMemo(() => {
        if (transferCall && (transferTarget === null || transferTarget === void 0 ? void 0 : transferTarget.displayName)) {
            return 'transferTarget';
        }
        return 'transferor';
    }, [transferCall, transferTarget === null || transferTarget === void 0 ? void 0 : transferTarget.displayName]);
    /* @conditional-compile-remove(call-transfer) */
    React.useEffect(() => {
        setAnnouncerString(strings.transferPageNoticeString);
    }, [strings.transferPageNoticeString]);
    let transferTileParticipant = transferor;
    /* @conditional-compile-remove(call-transfer) */
    if (pageSubject === 'transferTarget') {
        transferTileParticipant = transferTarget;
    }
    let transferParticipantDisplayName = (_c = transferor === null || transferor === void 0 ? void 0 : transferor.displayName) !== null && _c !== void 0 ? _c : strings.transferPageUnknownTransferorDisplayName;
    /* @conditional-compile-remove(call-transfer) */
    if (pageSubject === 'transferTarget') {
        transferParticipantDisplayName = (_d = transferTarget === null || transferTarget === void 0 ? void 0 : transferTarget.displayName) !== null && _d !== void 0 ? _d : strings.transferPageUnknownTransferTargetDisplayName;
    }
    return React.createElement(react.Stack, { className: react.mergeStyles(pageContainer) }, /* @conditional-compile-remove(call-transfer) */
        React.createElement(Announcer, { announcementString: announcerString, ariaLive: "polite" }),
        React.createElement(CallArrangement, { complianceBannerProps: {
                strings
            }, 
            // Ignore errors from before current call. This avoids old errors from showing up when a user re-joins a call.
            errorBarProps: ((_e = props.options) === null || _e === void 0 ? void 0 : _e.errorBar) !== false && errorBarProps, callControlProps: {
                options: callControlOptions,
                increaseFlyoutItemSize: props.mobileView
            }, mobileView: props.mobileView, modalLayerHostId: props.modalLayerHostId, onRenderGalleryContent: () => React.createElement(TransferTile, { userId: transferTileParticipant ? toFlatCommunicationIdentifier(transferTileParticipant === null || transferTileParticipant === void 0 ? void 0 : transferTileParticipant.identifier) : undefined, displayName: transferParticipantDisplayName, initialsName: transferParticipantDisplayName, 
                /* @conditional-compile-remove(call-transfer) */ statusText: pageSubject === 'transferTarget' ? strings.transferPageTransferTargetText : strings.transferPageTransferorText, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData }), dataUiId: 'transfer-page', updateSidePaneRenderer: props.updateSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader, latestErrors: props.latestErrors, onDismissError: props.onDismissError }));
};
const TransferTile = (props) => {
    const { displayName, initialsName, userId, onFetchAvatarPersonaData, statusText } = props;
    const [personaSize, setPersonaSize] = React.useState();
    const tileRef = React.useRef(null);
    const observer = React.useRef(new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        const personaSize = Math.min(width, height) / 2;
        setPersonaSize(Math.max(Math.min(personaSize, 150), 32));
    }));
    React.useLayoutEffect(() => {
        if (tileRef.current) {
            observer.current.observe(tileRef.current);
        }
        const currentObserver = observer.current;
        return () => currentObserver.disconnect();
    }, [observer, tileRef]);
    const placeholderOptions = React.useMemo(() => ({
        userId,
        text: initialsName !== null && initialsName !== void 0 ? initialsName : displayName,
        coinSize: personaSize,
        styles: defaultPersonaStyles,
        hidePersonaDetails: true
    }), [userId, initialsName, displayName, personaSize]);
    const defaultOnRenderAvatar = React.useCallback(() => {
        return personaSize ? React.createElement(AvatarPersona, Object.assign({}, placeholderOptions, { dataProvider: onFetchAvatarPersonaData, className: react.mergeStyles(avatarStyles) })) : React.createElement(React.Fragment, null);
    }, [placeholderOptions, onFetchAvatarPersonaData, personaSize]);
    const defaultAvatar = React.useMemo(() => defaultOnRenderAvatar(), [defaultOnRenderAvatar]);
    return React.createElement("div", { ref: tileRef, className: react.mergeStyles(tileContainerStyles), "data-is-focusable": true },
        React.createElement(react.Stack, { className: react.mergeStyles(tileContentStyles), tokens: {
                childrenGap: '1rem'
            } },
            React.createElement(react.Stack, { horizontalAlign: "center", tokens: {
                    childrenGap: '0.5rem'
                } },
                defaultAvatar,
                React.createElement(react.Text, { className: react.mergeStyles(displayNameStyles) }, displayName)),
            React.createElement(react.Stack, { horizontal: true, horizontalAlign: "center", verticalAlign: "center", tokens: {
                    childrenGap: '0.5rem'
                } },
                React.createElement(react.Spinner, { size: react.SpinnerSize.large, className: react.mergeStyles(spinnerStyles) }),
                React.createElement(react.Text, { className: react.mergeStyles(statusTextStyles) }, statusText))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const deviceCountSelector = reselect.createSelector([getCameras, getMicrophones], (cameras, microphones) => {
    return {
        camerasCount: cameras.length,
        microphonesCount: microphones.length
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(capabilities) */
/* @conditional-compile-remove(capabilities) */
/**
 * @private
 */
const capabilitiesChangedInfoAndRoleSelector = reselect__namespace.createSelector([getLatestCapabilitiesChangedInfo, getRole], (capabilitiesChangeInfo, participantRole) => {
    return {
        capabilitiesChangeInfo,
        participantRole
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(capabilities) */
/* @conditional-compile-remove(capabilities) */
/**
 * Create a record for when the notification was most recently dismissed for tracking dismissed notifications.
 *
 * @private
 */
const useTrackedCapabilityChangedNotifications = (capabilitiesChangedAndRoleInfo) => {
    const [trackedCapabilityChangedNotifications, setTrackedCapabilityChangedNotifications] = React.useState({});
    // Initialize a share screen capability changed notification with 'RoleChanged' reason so that the initial
    // share screen capability changed info from the Calling SDK when joining Teams interop will be ignored because
    // being able to share screen is assumed by default. This is inline with what Teams is doing.
    const activeNotifications = React.useRef({
        shareScreen: {
            capabilityName: 'shareScreen',
            isPresent: true,
            changedReason: 'RoleChanged'
        }
    });
    React.useEffect(() => {
        activeNotifications.current = updateLatestCapabilityChangedNotificationMap(capabilitiesChangedAndRoleInfo, activeNotifications.current);
        setTrackedCapabilityChangedNotifications(prev => updateTrackedCapabilityChangedNotificationsWithActiveNotifications(prev, Object.values(activeNotifications.current)));
    }, [capabilitiesChangedAndRoleInfo]);
    const onDismissCapabilityChangedNotification = React.useCallback((notification) => {
        setTrackedCapabilityChangedNotifications(prev => trackCapabilityChangedNotificationAsDismissed(notification.capabilityName, prev));
    }, []);
    const latestCapabilityChangedNotifications = React.useMemo(() => filterLatestCapabilityChangedNotifications(Object.values(activeNotifications.current), trackedCapabilityChangedNotifications), [trackedCapabilityChangedNotifications]);
    return {
        capabilitiesChangedNotifications: latestCapabilityChangedNotifications,
        onDismissNotification: onDismissCapabilityChangedNotification
    };
};
/* @conditional-compile-remove(capabilities) */
/**
 * Take the set of active notifications, and filter to only those that are newer than previously dismissed notifications or have never been dismissed.
 *
 * @private
 */
const filterLatestCapabilityChangedNotifications = (activeNotifications, trackedNotifications) => {
    const filteredNotifications = activeNotifications.filter(activeNotification => {
        const trackedNotification = trackedNotifications[activeNotification.capabilityName];
        return !trackedNotification || !trackedNotification.lastDismissedAt || trackedNotification.lastDismissedAt < trackedNotification.mostRecentlyActive;
    });
    return filteredNotifications;
};
/* @conditional-compile-remove(capabilities) */
/**
 * Maintain a record of the most recently active notification for each capability name.
 *
 * @private
 */
const updateTrackedCapabilityChangedNotificationsWithActiveNotifications = (existingTrackedNotifications, activeNotifications) => {
    var _a, _b;
    const trackedNotifications = {};
    // Only care about active notifications. If notifications are no longer active we do not track that they have been previously dismissed.
    for (const activeNotification of activeNotifications) {
        const existingTrackedNotification = existingTrackedNotifications[activeNotification.capabilityName];
        trackedNotifications[activeNotification.capabilityName] = {
            mostRecentlyActive: (_b = (_a = activeNotification.timestamp) !== null && _a !== void 0 ? _a : existingTrackedNotification === null || existingTrackedNotification === void 0 ? void 0 : existingTrackedNotification.mostRecentlyActive) !== null && _b !== void 0 ? _b : new Date(Date.now()),
            lastDismissedAt: existingTrackedNotification === null || existingTrackedNotification === void 0 ? void 0 : existingTrackedNotification.lastDismissedAt
        };
    }
    return trackedNotifications;
};
/* @conditional-compile-remove(capabilities) */
/**
 * Create a record for when the notification was most recently dismissed for tracking dismissed notifications.
 *
 * @private
 */
const trackCapabilityChangedNotificationAsDismissed = (capabilityName, trackedNotifications) => {
    const now = new Date(Date.now());
    const existingNotification = trackedNotifications[capabilityName];
    return Object.assign(Object.assign({}, trackedNotifications), { [capabilityName]: Object.assign(Object.assign({}, (existingNotification || {})), { lastDismissedAt: now }) });
};
/* @conditional-compile-remove(capabilities) */
const updateLatestCapabilityChangedNotificationMap = (capabilitiesChangedInfoAndRole, activeNotifications) => {
    var _a, _b;
    if (!capabilitiesChangedInfoAndRole.capabilitiesChangeInfo) {
        return activeNotifications;
    }
    for (const [capabilityKey, newCapabilityValue] of Object.entries(capabilitiesChangedInfoAndRole.capabilitiesChangeInfo.newValue)) {
        // Cast is safe because we are iterating over the enum keys on the object.entries where
        // newCapabilityValue typing is correctly returned. Object.entries limitations
        // always returns string for the key
        const capabilityName = capabilityKey;
        // If the active notification for a capability has the same `isPresent` value and the same reason as the new
        // capability value from the SDK then we will not create a new notification to avoid redundancy
        if (activeNotifications[capabilityName] && newCapabilityValue.isPresent === ((_a = activeNotifications[capabilityName]) === null || _a === void 0 ? void 0 : _a.isPresent) && capabilitiesChangedInfoAndRole.capabilitiesChangeInfo.reason === ((_b = activeNotifications[capabilityName]) === null || _b === void 0 ? void 0 : _b.changedReason)) {
            continue;
        }
        const newCapabilityChangeNotification = {
            capabilityName: capabilityName,
            isPresent: newCapabilityValue.isPresent,
            changedReason: capabilitiesChangedInfoAndRole.capabilitiesChangeInfo.reason,
            role: capabilitiesChangedInfoAndRole.participantRole,
            timestamp: new Date(Date.now())
        };
        activeNotifications[capabilityName] = newCapabilityChangeNotification;
    }
    return activeNotifications;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(rooms) */
/**
 * @private
 */
const useEndedCallConsoleErrors = (endedCall) => {
    var _a;
    /* @conditional-compile-remove(rooms) */
    React.useEffect(() => {
        var _a;
        switch ((_a = endedCall === null || endedCall === void 0 ? void 0 : endedCall.callEndReason) === null || _a === void 0 ? void 0 : _a.subCode) {
            case ROOM_NOT_FOUND_SUB_CODE:
                console.error('Call ended because the room id provided through the adapter locator could not be found');
                break;
            case ROOM_NOT_VALID_SUB_CODE:
                console.error('Call ended because this room is currently not valid.');
                break;
            case NOT_INVITED_TO_ROOM_SUB_CODE:
                console.error('Call ended because you are not invited to this room.');
                break;
            case INVITE_TO_ROOM_REMOVED_SUB_CODE:
                console.error('Call ended because your invite to this room has been removed.');
                break;
        }
    }, [(_a = endedCall === null || endedCall === void 0 ? void 0 : endedCall.callEndReason) === null || _a === void 0 ? void 0 : _a.subCode]);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$7 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const isShowing = (overrideSidePane) => {
    return !!(overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive);
};
const MainScreen = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const adapter = useAdapter();
    const { camerasCount, microphonesCount } = useSelector$1(deviceCountSelector);
    const hasCameras = camerasCount > 0;
    const hasMicrophones = microphonesCount > 0;
    React.useEffect(() => {
        (() => __awaiter$7(void 0, void 0, void 0, function* () {
            var _a;
            const constrain = getQueryOptions({
                /* @conditional-compile-remove(rooms) */ role: (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.role
            });
            yield adapter.askDevicePermission(constrain);
            adapter.queryCameras();
            adapter.queryMicrophones();
            adapter.querySpeakers();
        }))();
    }, [adapter,
        // Ensure we re-ask for permissions if the number of devices goes from 0 -> n during a call
        // as we cannot request permissions when there are no devices.
        hasCameras, hasMicrophones]);
    const { callInvitationUrl, onFetchAvatarPersonaData, onFetchParticipantMenuItems } = props;
    const page = useSelector$1(getPage);
    const endedCall = useSelector$1(getEndedCall);
    const [sidePaneRenderer, setSidePaneRenderer] = React.useState();
    const [injectedSidePaneProps, setInjectedSidePaneProps] = React.useState();
    const [userSetGalleryLayout, setUserSetGalleryLayout] = React.useState((_c = (_b = (_a = props.options) === null || _a === void 0 ? void 0 : _a.galleryOptions) === null || _b === void 0 ? void 0 : _b.layout) !== null && _c !== void 0 ? _c : 'floatingLocalVideo');
    const [userSetOverflowGalleryPosition, setUserSetOverflowGalleryPosition] = React.useState('Responsive');
    const overridePropsRef = React.useRef(props.overrideSidePane);
    React.useEffect(() => {
        setInjectedSidePaneProps(props.overrideSidePane);
        // When the injected side pane is opened, clear the previous side pane active state.
        // this ensures when the injected side pane is "closed", the previous side pane is not "re-opened".
        if (!isShowing(overridePropsRef.current) && isShowing(props.overrideSidePane)) {
            setSidePaneRenderer(undefined);
        }
        overridePropsRef.current = props.overrideSidePane;
    }, [props.overrideSidePane]);
    const onSidePaneIdChange = props.onSidePaneIdChange;
    React.useEffect(() => {
        onSidePaneIdChange === null || onSidePaneIdChange === void 0 ? void 0 : onSidePaneIdChange(sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id);
    }, [sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id, onSidePaneIdChange]);
    // When the call ends ensure the side pane is set to closed to prevent the side pane being open if the call is re-joined.
    React.useEffect(() => {
        const closeSidePane = () => {
            setSidePaneRenderer(undefined);
        };
        adapter.on('callEnded', closeSidePane);
        return () => {
            adapter.off('callEnded', closeSidePane);
        };
    }, [adapter]);
    /* @conditional-compile-remove(capabilities) */
    const capabilitiesChangedInfoAndRole = useSelector$1(capabilitiesChangedInfoAndRoleSelector);
    /* @conditional-compile-remove(capabilities) */
    const capabilitiesChangedNotificationBarProps = useTrackedCapabilityChangedNotifications(capabilitiesChangedInfoAndRole);
    // Track the last dismissed errors of any error kind to prevent errors from re-appearing on subsequent page navigation
    // This works by tracking the most recent timestamp of any active error type.
    // And then tracking when that error type was last dismissed.
    const activeErrors = usePropsFor$1(ErrorBar).activeErrorMessages;
    const [trackedErrors, setTrackedErrors] = React.useState({});
    React.useEffect(() => {
        setTrackedErrors(prev => updateTrackedErrorsWithActiveErrors(prev, activeErrors));
    }, [activeErrors]);
    const onDismissError = React.useCallback((error) => {
        setTrackedErrors(prev => trackErrorAsDismissed(error.type, prev));
    }, []);
    const latestErrors = React.useMemo(() => filterLatestErrors(activeErrors, trackedErrors), [activeErrors, trackedErrors]);
    const callees = useSelector$1(getTargetCallees);
    const locale = useLocale();
    const palette = useTheme().palette;
    const leavePageStyle = React.useMemo(() => leavingPageStyle(palette), [palette]);
    let pageElement;
    switch (page) {
        case 'configuration':
            pageElement = React.createElement(ConfigurationPage, { mobileView: props.mobileView, startCallHandler: () => {
                    if (callees) {
                        adapter.startCall(callees);
                    }
                    else {
                        adapter.joinCall({
                            microphoneOn: 'keep',
                            cameraOn: 'keep'
                        });
                    }
                }, updateSidePaneRenderer: setSidePaneRenderer, latestErrors: latestErrors, onDismissError: onDismissError, modalLayerHostId: props.modalLayerHostId, capabilitiesChangedNotificationBarProps: capabilitiesChangedNotificationBarProps, 
                /* @conditional-compile-remove(custom-branding) */ logo: (_e = (_d = props.options) === null || _d === void 0 ? void 0 : _d.branding) === null || _e === void 0 ? void 0 : _e.logo, 
                /* @conditional-compile-remove(custom-branding) */ backgroundImage: (_g = (_f = props.options) === null || _f === void 0 ? void 0 : _f.branding) === null || _g === void 0 ? void 0 : _g.backgroundImage });
            break;
        case 'accessDeniedTeamsMeeting':
            pageElement = React.createElement(NoticePage, { iconName: "NoticePageAccessDeniedTeamsMeeting", title: locale.strings.call.failedToJoinTeamsMeetingReasonAccessDeniedTitle, moreDetails: locale.strings.call.failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails, dataUiId: 'access-denied-teams-meeting-page' });
            break;
        case 'removedFromCall':
            pageElement = React.createElement(NoticePage, { iconName: "NoticePageRemovedFromCall", title: locale.strings.call.removedFromCallTitle, moreDetails: locale.strings.call.removedFromCallMoreDetails, dataUiId: 'removed-from-call-page' });
            break;
        case 'joinCallFailedDueToNoNetwork':
            pageElement = React.createElement(NoticePage, { iconName: "NoticePageJoinCallFailedDueToNoNetwork", title: locale.strings.call.failedToJoinCallDueToNoNetworkTitle, moreDetails: locale.strings.call.failedToJoinCallDueToNoNetworkMoreDetails, dataUiId: 'join-call-failed-due-to-no-network-page' });
            break;
        case 'leaving':
            pageElement = React.createElement(NoticePage, { title: (_h = locale.strings.call.leavingCallTitle) !== null && _h !== void 0 ? _h : 'Leaving...', dataUiId: 'leaving-page', pageStyle: leavePageStyle, disableStartCallButton: true });
            break;
        case 'leftCall':
            {
                const { title, moreDetails, disableStartCallButton, iconName } = getEndedCallPageProps(locale, endedCall);
                pageElement = React.createElement(NoticePage, { iconName: iconName, title: title, moreDetails: callees ? '' : moreDetails, dataUiId: 'left-call-page', disableStartCallButton: disableStartCallButton });
                break;
            }
        case 'lobby':
            pageElement = React.createElement(LobbyPage, { mobileView: props.mobileView, modalLayerHostId: props.modalLayerHostId, options: props.options, updateSidePaneRenderer: setSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader, latestErrors: latestErrors, onDismissError: onDismissError, 
                /* @conditional-compile-remove(capabilities) */ capabilitiesChangedNotificationBarProps: capabilitiesChangedNotificationBarProps });
            break;
        /* @conditional-compile-remove(call-transfer) */
        case 'transferring':
            pageElement = React.createElement(TransferPage, { mobileView: props.mobileView, modalLayerHostId: props.modalLayerHostId, options: props.options, updateSidePaneRenderer: setSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader, onFetchAvatarPersonaData: onFetchAvatarPersonaData, latestErrors: latestErrors, onDismissError: onDismissError, 
                /* @conditional-compile-remove(capabilities) */ capabilitiesChangedNotificationBarProps: capabilitiesChangedNotificationBarProps });
            break;
        case 'call':
            pageElement = React.createElement(CallPage, { callInvitationURL: callInvitationUrl, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onFetchParticipantMenuItems: onFetchParticipantMenuItems, mobileView: props.mobileView, modalLayerHostId: props.modalLayerHostId, options: props.options, updateSidePaneRenderer: setSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader, onCloseChatPane: props.onCloseChatPane, latestErrors: latestErrors, onDismissError: onDismissError, galleryLayout: userSetGalleryLayout, onUserSetGalleryLayoutChange: setUserSetGalleryLayout, onSetUserSetOverflowGalleryPosition: setUserSetOverflowGalleryPosition, userSetOverflowGalleryPosition: userSetOverflowGalleryPosition, 
                /* @conditional-compile-remove(capabilities) */ capabilitiesChangedNotificationBarProps: capabilitiesChangedNotificationBarProps });
            break;
    }
    useEndedCallConsoleErrors(endedCall);
    if (!pageElement) {
        throw new Error('Invalid call composite page');
    }
    return React.createElement(SidePaneProvider, { sidePaneRenderer: sidePaneRenderer, overrideSidePane: injectedSidePaneProps }, pageElement);
};
/**
 * A customizable UI composite for calling experience.
 *
 * @remarks Call composite min width/height are as follow:
 * - mobile: 17.5rem x 21rem (280px x 336px, with default rem at 16px)
 * - desktop: 30rem x 22rem (480px x 352px, with default rem at 16px)
 *
 * @public
 */
const CallComposite = (props) => React.createElement(CallCompositeInner, Object.assign({}, props));
/** @private */
const CallCompositeInner = (props) => {
    const { adapter, callInvitationUrl, onFetchAvatarPersonaData, onFetchParticipantMenuItems, options, formFactor = 'desktop' } = props;
    const mobileView = formFactor === 'mobile';
    const modalLayerHostId = reactHooks.useId('modalLayerhost');
    const mainScreenContainerClassName = React.useMemo(() => {
        return mobileView ? mainScreenContainerStyleMobile : mainScreenContainerStyleDesktop;
    }, [mobileView]);
    return React.createElement("div", { className: mainScreenContainerClassName },
        React.createElement(BaseProvider, Object.assign({}, props),
            React.createElement(CallAdapterProvider, { adapter: adapter },
                React.createElement(MainScreen, { callInvitationUrl: callInvitationUrl, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onFetchParticipantMenuItems: onFetchParticipantMenuItems, mobileView: mobileView, modalLayerHostId: modalLayerHostId, options: options, onSidePaneIdChange: props.onSidePaneIdChange, overrideSidePane: props.overrideSidePane, mobileChatTabHeader: props.mobileChatTabHeader, onCloseChatPane: props.onCloseChatPane }),
                // This layer host is for ModalLocalAndRemotePIP in SidePane. This LayerHost cannot be inside the SidePane
                // because when the SidePane is hidden, ie. style property display is 'none', it takes up no space. This causes problems when dragging
                // the Modal because the draggable bounds thinks it has no space and will always return to its initial position after dragging.
                // Additionally, this layer host cannot be in the Call Arrangement as it needs to be rendered before useMinMaxDragPosition() in
                // common/utils useRef is called.
                // Warning: this is fragile and works because the call arrangement page is only rendered after the call has connected and thus this
                // LayerHost will be guaranteed to have rendered (and subsequently mounted in the DOM). This ensures the DOM element will be available
                // before the call to `document.getElementById(modalLayerHostId)` is made.
                React.createElement(react.LayerHost, { id: modalLayerHostId, className: react.mergeStyles(modalLayerHostStyle) }))));
};
const getQueryOptions = (options) => {
    /* @conditional-compile-remove(rooms) */
    if (options.role === 'Consumer') {
        return {
            video: false,
            audio: true
        };
    }
    return {
        video: true,
        audio: true
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const compositeLogger = logger.createClientLogger('communication-react:composite');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
class ParticipantSubscriber {
    constructor(participant, emitter) {
        this.isMutedChangedHandler = () => {
            this.emitter.emit('isMutedChanged', {
                participantId: this.participant.identifier,
                isMuted: this.participant.isMuted
            });
        };
        this.displayNameChangedHandler = () => {
            this.emitter.emit('displayNameChanged', {
                participantId: this.participant.identifier,
                displayName: this.participant.displayName
            });
        };
        this.isSpeakingChangedHandler = () => {
            this.emitter.emit('isSpeakingChanged', {
                participantId: this.participant.identifier,
                isSpeaking: this.participant.isSpeaking
            });
        };
        this.videoStreamsUpdatedHandler = (event) => {
            this.emitter.emit('videoStreamsUpdated', event);
        };
        this.participant = participant;
        this.emitter = emitter;
        this.subscribeParticipantEvents();
    }
    subscribeParticipantEvents() {
        this.participant.on('isMutedChanged', this.isMutedChangedHandler);
        this.participant.on('displayNameChanged', this.displayNameChangedHandler);
        this.participant.on('isSpeakingChanged', this.isSpeakingChangedHandler);
        this.participant.on('videoStreamsUpdated', this.videoStreamsUpdatedHandler);
    }
    unsubscribeAll() {
        this.participant.off('isMutedChanged', this.isMutedChangedHandler);
        this.participant.off('displayNameChanged', this.displayNameChangedHandler);
        this.participant.off('isSpeakingChanged', this.isSpeakingChangedHandler);
        this.participant.off('videoStreamsUpdated', this.videoStreamsUpdatedHandler);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
class DiagnosticsForwarder {
    constructor(emitter, call) {
        this.unsubscribe = () => {
            this._diagnostics.network.off('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
            this._diagnostics.media.off('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
        };
        this._diagnostics = call.feature(communicationCalling.Features.UserFacingDiagnostics);
        this._emitter = emitter;
        this.subscribe();
    }
    subscribe() {
        this._diagnostics.network.on('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
        this._diagnostics.media.on('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
    }
    networkDiagnosticsChanged(args) {
        const event = Object.assign({ type: 'network' }, args);
        this._emitter.emit('diagnosticChanged', event);
    }
    mediaDiagnosticsChanged(args) {
        const event = Object.assign({ type: 'media' }, args);
        this._emitter.emit('diagnosticChanged', event);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 *
 * This is used to create correct handler for generic agent type
 */
function createHandlers(callClient, callAgent, deviceManager, call, /* @conditional-compile-remove(video-background-effects) */ options) {
    // Call can be either undefined or ACS Call
    if ((!call || call && _isACSCall())) {
        return createDefaultCallingHandlers(callClient, callAgent, deviceManager, call, /* @conditional-compile-remove(video-background-effects) */ options);
    }
    throw new Error('Unhandled agent type');
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$6 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const createProfileStateModifier = (onFetchProfile, notifyUpdate) => {
    const cachedDisplayName = {};
    return (state) => {
        var _a;
        const originalParticipants = (_a = state.call) === null || _a === void 0 ? void 0 : _a.remoteParticipants;
        (() => __awaiter$6(void 0, void 0, void 0, function* () {
            let shouldNotifyUpdates = false;
            for (const key in originalParticipants) {
                if (cachedDisplayName[key]) {
                    continue;
                }
                const profile = yield onFetchProfile(key, {
                    displayName: originalParticipants[key].displayName
                });
                if ((profile === null || profile === void 0 ? void 0 : profile.displayName) && originalParticipants[key].displayName !== (profile === null || profile === void 0 ? void 0 : profile.displayName)) {
                    cachedDisplayName[key] = profile === null || profile === void 0 ? void 0 : profile.displayName;
                    shouldNotifyUpdates = true;
                }
            }
            // notify update only when there is a change, which most likely will trigger modifier and setState again
            shouldNotifyUpdates && notifyUpdate();
        }))();
        const participantsModifier = createParticipantModifier((id, participant) => {
            if (cachedDisplayName[id]) {
                return Object.assign(Object.assign({}, participant), { displayName: cachedDisplayName[id] });
            }
            return undefined;
        });
        return participantsModifier(state);
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* @conditional-compile-remove(calling-sounds) */
const CALL_REJECTED_CODE = 603;
const CALL_ENDED_CODE = 0;
const CALL_TRANSFER_SUBCODE = 7015;
/**
 * @private
 */
class CallingSoundSubscriber {
    constructor(call, callee, sounds) {
        this.onCallStateChanged = () => {
            this.call.on('stateChanged', () => {
                var _a, _b, _c, _d, _e, _f, _g;
                if (shouldPlayRinging(this.call, this.callee) && ((_a = this.soundsLoaded) === null || _a === void 0 ? void 0 : _a.callRingingSound)) {
                    this.soundsLoaded.callRingingSound.loop = true;
                    this.playSound(this.soundsLoaded.callRingingSound);
                }
                if (!shouldPlayRinging(this.call, this.callee) && ((_b = this.soundsLoaded) === null || _b === void 0 ? void 0 : _b.callRingingSound)) {
                    this.soundsLoaded.callRingingSound.loop = false;
                    this.soundsLoaded.callRingingSound.pause();
                }
                if (this.call.state === 'Disconnected') {
                    if (((_c = this.soundsLoaded) === null || _c === void 0 ? void 0 : _c.callBusySound) && ((_d = this.call.callEndReason) === null || _d === void 0 ? void 0 : _d.code) === CALL_REJECTED_CODE) {
                        this.playSound(this.soundsLoaded.callBusySound);
                    }
                    else if (((_e = this.soundsLoaded) === null || _e === void 0 ? void 0 : _e.callEndedSound) && ((_f = this.call.callEndReason) === null || _f === void 0 ? void 0 : _f.code) === CALL_ENDED_CODE && ((_g = this.call.callEndReason) === null || _g === void 0 ? void 0 : _g.subCode) !== CALL_TRANSFER_SUBCODE) {
                        this.playSound(this.soundsLoaded.callEndedSound);
                    }
                }
            });
        };
        this.call = call;
        this.callee = callee;
        if (sounds) {
            this.soundsLoaded = this.loadSounds(sounds);
            this.subscribeCallSoundEvents();
        }
    }
    subscribeCallSoundEvents() {
        this.onCallStateChanged();
    }
    unsubscribeAll() {
        var _a, _b;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.off('stateChanged', this.onCallStateChanged);
        if ((_b = this.soundsLoaded) === null || _b === void 0 ? void 0 : _b.callRingingSound) {
            this.soundsLoaded.callRingingSound.pause();
        }
    }
    loadSounds(sounds) {
        var _a, _b, _c;
        let callEndedSound;
        if (sounds === null || sounds === void 0 ? void 0 : sounds.callEnded) {
            callEndedSound = new Audio((_a = sounds === null || sounds === void 0 ? void 0 : sounds.callEnded) === null || _a === void 0 ? void 0 : _a.url);
            callEndedSound.preload = 'auto';
        }
        let callRingingSound;
        if (sounds === null || sounds === void 0 ? void 0 : sounds.callRinging) {
            callRingingSound = new Audio((_b = sounds === null || sounds === void 0 ? void 0 : sounds.callRinging) === null || _b === void 0 ? void 0 : _b.url);
            callRingingSound.preload = 'auto';
        }
        let callBusySound;
        if (sounds === null || sounds === void 0 ? void 0 : sounds.callBusy) {
            callBusySound = new Audio((_c = sounds === null || sounds === void 0 ? void 0 : sounds.callBusy) === null || _c === void 0 ? void 0 : _c.url);
            callBusySound.preload = 'auto';
        }
        return {
            callEndedSound,
            callRingingSound,
            callBusySound
        };
    }
    playSound(sound) {
        sound.play().catch(e => {
            console.error(e, 'Failed to play sound, check loader config to make sure it is correct');
        });
    }
}
/**
 * Helper function to allow the calling sound subscriber to determine when to play the ringing
 * sound when making an outbound call.
 */
const shouldPlayRinging = (call, callee) => {
    /* @conditional-compile-remove(calling-sounds) */
    if (callee && callee.length >= 1 && !communicationCommon.isPhoneNumberIdentifier(callee[0]) && (call.state === 'Ringing' || call.state === 'Connecting')) {
        return true;
    }
    else {
        return false;
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$5 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/** Context of call, which is a centralized context for all state updates */
class CallContext {
    constructor(clientState, isTeamsCall, /* @conditional-compile-remove(rooms) */ isRoomsCall, options, targetCallees) {
        var _a, _b, _c, _d;
        this.emitter = new EventEmitter.EventEmitter();
        this.state = {
            isLocalPreviewMicrophoneEnabled: false,
            userId: clientState.userId,
            displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName,
            devices: clientState.deviceManager,
            call: undefined,
            /* @conditional-compile-remove(calling-sounds) */ targetCallees: targetCallees,
            page: 'configuration',
            latestErrors: clientState.latestErrors,
            isTeamsCall,
            /* @conditional-compile-remove(rooms) */ isRoomsCall,
            /* @conditional-compile-remove(video-background-effects) */ videoBackgroundImages: (_b = options === null || options === void 0 ? void 0 : options.videoBackgroundOptions) === null || _b === void 0 ? void 0 : _b.videoBackgroundImages,
            /* @conditional-compile-remove(video-background-effects) */
            onResolveVideoEffectDependency: (_c = options === null || options === void 0 ? void 0 : options.videoBackgroundOptions) === null || _c === void 0 ? void 0 : _c.onResolveDependency,
            /* @conditional-compile-remove(video-background-effects) */ selectedVideoBackgroundEffect: undefined,
            cameraStatus: undefined,
            /* @conditional-compile-remove(calling-sounds) */ sounds: options === null || options === void 0 ? void 0 : options.callingSounds
        };
        this.emitter.setMaxListeners((_d = options === null || options === void 0 ? void 0 : options.maxListeners) !== null && _d !== void 0 ? _d : 50);
        this.bindPublicMethods();
        this.displayNameModifier = (options === null || options === void 0 ? void 0 : options.onFetchProfile) ? createProfileStateModifier(options.onFetchProfile, () => {
            this.setState(this.getState());
        }) : undefined;
    }
    bindPublicMethods() { }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = this.displayNameModifier ? this.displayNameModifier(state) : state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    setIsLocalMicrophoneEnabled(isLocalPreviewMicrophoneEnabled) {
        this.setState(Object.assign(Object.assign({}, this.state), { isLocalPreviewMicrophoneEnabled }));
    }
    // This is the key to find current call object in client state
    setCurrentCallId(callId) {
        this.callId = callId;
    }
    /* @conditional-compile-remove(calling-sounds) */
    setTargetCallee(targetCallees) {
        this.setState(Object.assign(Object.assign({}, this.state), { targetCallees }));
    }
    onCallEnded(handler) {
        this.emitter.on('callEnded', handler);
    }
    offCallEnded(handler) {
        this.emitter.off('callEnded', handler);
    }
    updateClientState(clientState) {
        var _a;
        let call = this.callId ? clientState.calls[this.callId] : undefined;
        const latestEndedCall = clientState.callsEnded ? findLatestEndedCall(clientState.callsEnded) : undefined;
        // As the state is transitioning to a new state, trigger appropriate callback events.
        const oldPage = this.state.page;
        /* @conditional-compile-remove(call-transfer) */
        const latestAcceptedTransfer = (call === null || call === void 0 ? void 0 : call.transfer.acceptedTransfers) ? findLatestAcceptedTransfer(call.transfer.acceptedTransfers) : undefined;
        /* @conditional-compile-remove(call-transfer) */
        const transferCall = latestAcceptedTransfer ? clientState.calls[latestAcceptedTransfer.callId] : undefined;
        const newPage = getCallCompositePage(call, latestEndedCall, /* @conditional-compile-remove(call-transfer) */ transferCall);
        if (!IsCallEndedPage(oldPage) && IsCallEndedPage(newPage)) {
            this.emitter.emit('callEnded', {
                callId: this.callId
            });
            // Reset the callId to undefined as the call has ended.
            this.setCurrentCallId(undefined);
            // Make sure that the call is set to undefined in the state.
            call = undefined;
        }
        if (this.state.page) {
            this.setState(Object.assign(Object.assign({}, this.state), { userId: clientState.userId, displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName, call, page: newPage, endedCall: latestEndedCall, devices: clientState.deviceManager, latestErrors: clientState.latestErrors, cameraStatus: (call === null || call === void 0 ? void 0 : call.localVideoStreams.find(s => s.mediaStreamType === 'Video')) || clientState.deviceManager.unparentedViews.find(s => s.mediaStreamType === 'Video') ? 'On' : 'Off', 
                /* @conditional-compile-remove(call-transfer) */ acceptedTransferCallState: transferCall }));
        }
    }
    /* @conditional-compile-remove(video-background-effects) */
    setBackroundPickerImages(videoBackgroundImages) {
        this.setState(Object.assign(Object.assign({}, this.state), { videoBackgroundImages }));
    }
    /* @conditional-compile-remove(video-background-effects) */
    setSelectedVideoBackgroundEffect(selectedVideoBackgroundEffect) {
        this.setState(Object.assign(Object.assign({}, this.state), { selectedVideoBackgroundEffect }));
    }
    /* @conditional-compile-remove(call-transfer) */
    setAcceptedTransferCall(call) {
        this.setState(Object.assign(Object.assign({}, this.state), { acceptedTransferCallState: call }));
    }
}
const findLatestEndedCall = (calls) => {
    var _a, _b, _c, _d;
    const callStates = Object.values(calls);
    if (callStates.length === 0) {
        return undefined;
    }
    let latestCall = callStates[0];
    for (const call of callStates.slice(1)) {
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) > ((_d = (_c = latestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            latestCall = call;
        }
    }
    return latestCall;
};
/* @conditional-compile-remove(call-transfer) */
const findLatestAcceptedTransfer = (acceptedTransfers) => {
    var _a, _b, _c, _d;
    const acceptedTransferValues = Object.values(acceptedTransfers);
    if (acceptedTransferValues.length === 0) {
        return undefined;
    }
    let latestAcceptedTransfer = acceptedTransferValues[0];
    for (const acceptedTransfer of acceptedTransferValues.slice(1)) {
        if (((_b = (_a = acceptedTransfer.timestamp) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) > ((_d = (_c = latestAcceptedTransfer.timestamp) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            latestAcceptedTransfer = acceptedTransfer;
        }
    }
    return latestAcceptedTransfer;
};
/**
 * @private
 */
class AzureCommunicationCallAdapter {
    get call() {
        return this._call;
    }
    set call(newCall) {
        this.resetDiagnosticsForwarder(newCall);
        this._call = newCall;
    }
    constructor(callClient, locatorOrTargetCalless, callAgent, deviceManager, options) {
        var _a;
        this.participantSubscribers = new Map();
        this.emitter = new EventEmitter.EventEmitter();
        this.isMyMutedChanged = () => {
            var _a;
            this.emitter.emit('isMutedChanged', {
                participantId: this.getState().userId,
                isMuted: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isMuted
            });
        };
        this.bindPublicMethods();
        this.callClient = callClient;
        this.callAgent = callAgent;
        this.targetCallees = getLocatorOrTargetCallees(locatorOrTargetCalless) === true ? locatorOrTargetCalless : undefined;
        this.locator = getLocatorOrTargetCallees(locatorOrTargetCalless) === false ? locatorOrTargetCalless : undefined;
        this.deviceManager = deviceManager;
        const isTeamsMeeting = this.locator ? 'meetingLink' in this.locator : false;
        /* @conditional-compile-remove(rooms) */
        const isRoomsCall = this.locator ? 'roomId' in this.locator : false;
        /* @conditional-compile-remove(video-background-effects) */
        this.onResolveVideoBackgroundEffectsDependency = (_a = options === null || options === void 0 ? void 0 : options.videoBackgroundOptions) === null || _a === void 0 ? void 0 : _a.onResolveDependency;
        this.context = new CallContext(callClient.getState(), isTeamsMeeting, /* @conditional-compile-remove(rooms) */ isRoomsCall, /* @conditional-compile-remove(video-background-effects) */ options, this.targetCallees);
        this.context.onCallEnded(endCallData => this.emitter.emit('callEnded', endCallData));
        const onStateChange = (clientState) => {
            var _a, _b, _c;
            // unsubscribe when the instance gets disposed
            if (!this) {
                callClient.offStateChange(onStateChange);
                return;
            }
            // `updateClientState` searches for the current call from all the calls in the state using a cached `call.id`
            // from the call object. `call.id` can change during a call. We must update the cached `call.id` before
            // calling `updateClientState` so that we find the correct state object for the call even when `call.id`
            // has changed.
            // https://github.com/Azure/communication-ui-library/pull/1820
            if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id) {
                this.context.setCurrentCallId(this.call.id);
            }
            // If the call connects we need to clean up any previous unparentedViews
            if ((((_b = this.call) === null || _b === void 0 ? void 0 : _b.state) === 'InLobby' || ((_c = this.call) === null || _c === void 0 ? void 0 : _c.state) === 'Connected') && this.callClient.getState().deviceManager.unparentedViews.length > 0) {
                this.callClient.getState().deviceManager.unparentedViews.forEach(view => {
                    this.callClient.disposeView(undefined, undefined, view);
                });
            }
            this.context.updateClientState(clientState);
        };
        this.handlers = createHandlers(callClient, callAgent, deviceManager, undefined, /* @conditional-compile-remove(video-background-effects) */ {
            onResolveVideoBackgroundEffectsDependency: this.onResolveVideoBackgroundEffectsDependency
        });
        this.onClientStateChange = onStateChange;
        this.subscribeDeviceManagerEvents();
        this.callClient.onStateChange(onStateChange);
        /* @conditional-compile-remove(call-transfer) */
        if (this.callAgent.kind === 'CallAgent') {
            const onCallsUpdated = (args) => {
                var _a;
                if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id) {
                    const removedCall = args.removed.find(call => { var _a; return call.id === ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id); });
                    if (removedCall) {
                        const removedCallState = this.callClient.getState().callsEnded[removedCall.id];
                        const latestAcceptedTransfer = findLatestAcceptedTransfer(removedCallState.transfer.acceptedTransfers);
                        const _callAgent = callAgent;
                        const transferCall = _callAgent.calls.find((call) => call.id === (latestAcceptedTransfer === null || latestAcceptedTransfer === void 0 ? void 0 : latestAcceptedTransfer.callId));
                        if (transferCall) {
                            this.processNewCall(transferCall);
                        }
                    }
                }
            };
            this.callAgent.on('callsUpdated', onCallsUpdated);
        }
    }
    // TODO: update this to include the 'selectedCameraChanged' when calling adds it to the device manager
    subscribeDeviceManagerEvents() {
        this.deviceManager.on('selectedMicrophoneChanged', () => {
            this.emitter.emit('selectedMicrophoneChanged');
        });
        this.deviceManager.on('selectedSpeakerChanged', () => {
            this.emitter.emit('selectedSpeakerChanged');
        });
    }
    bindPublicMethods() {
        this.onStateChange.bind(this);
        this.offStateChange.bind(this);
        this.getState.bind(this);
        this.dispose.bind(this);
        this.joinCall.bind(this);
        this.leaveCall.bind(this);
        this.setCamera.bind(this);
        this.setMicrophone.bind(this);
        this.setSpeaker.bind(this);
        this.askDevicePermission.bind(this);
        this.queryCameras.bind(this);
        this.queryMicrophones.bind(this);
        this.querySpeakers.bind(this);
        this.startCamera.bind(this);
        this.stopCamera.bind(this);
        this.mute.bind(this);
        this.unmute.bind(this);
        this.startCall.bind(this);
        this.startScreenShare.bind(this);
        this.stopScreenShare.bind(this);
        /* @conditional-compile-remove(raise-hand) */
        this.raiseHand.bind(this);
        this.lowerHand.bind(this);
        this.removeParticipant.bind(this);
        this.createStreamView.bind(this);
        this.disposeStreamView.bind(this);
        this.disposeScreenShareStreamView.bind(this);
        this.disposeRemoteVideoStreamView.bind(this);
        this.disposeLocalVideoStreamView.bind(this);
        this.on.bind(this);
        this.off.bind(this);
        this.processNewCall.bind(this);
        this.sendDtmfTone.bind(this);
        /* @conditional-compile-remove(close-captions) */
        {
            this.startCaptions.bind(this);
            this.stopCaptions.bind(this);
            this.setSpokenLanguage.bind(this);
            this.setCaptionLanguage.bind(this);
        }
        /* @conditional-compile-remove(video-background-effects) */
        this.startVideoBackgroundEffect.bind(this);
        /* @conditional-compile-remove(video-background-effects) */
        this.stopVideoBackgroundEffects.bind(this);
        /* @conditional-compile-remove(video-background-effects) */
        this.updateBackgroundPickerImages.bind(this);
    }
    dispose() {
        this.resetDiagnosticsForwarder();
        this.callClient.offStateChange(this.onClientStateChange);
        this.callAgent.dispose();
    }
    queryCameras() {
        return __awaiter$5(this, void 0, void 0, function* () {
            const startTime = new Date().getTime();
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                const cameras = yield this.deviceManager.getCameras();
                const endTime = new Date().getTime();
                compositeLogger.info('time to query cameras', endTime - startTime, 'ms');
                return cameras;
            }));
        });
    }
    queryMicrophones() {
        return __awaiter$5(this, void 0, void 0, function* () {
            const startTime = new Date().getTime();
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                const microphones = yield this.deviceManager.getMicrophones();
                const endTime = new Date().getTime();
                compositeLogger.info('time to query microphones', endTime - startTime, 'ms');
                return microphones;
            }));
        });
    }
    querySpeakers() {
        return __awaiter$5(this, void 0, void 0, function* () {
            const startTime = new Date().getTime();
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                const speakers = (yield this.deviceManager.isSpeakerSelectionAvailable) ? this.deviceManager.getSpeakers() : [];
                const endTime = new Date().getTime();
                compositeLogger.info('time to query speakers', endTime - startTime, 'ms');
                return speakers;
            }));
        });
    }
    askDevicePermission(constrain) {
        return __awaiter$5(this, void 0, void 0, function* () {
            const startTime = new Date().getTime();
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.deviceManager.askDevicePermission(constrain);
                const endTime = new Date().getTime();
                compositeLogger.info('time to query askDevicePermissions', endTime - startTime, 'ms');
            }));
        });
    }
    joinCall(options) {
        var _a, _b;
        if (_isInCall((_b = (_a = this.getState().call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None')) {
            throw new Error('You are already in the call!');
        }
        else if (this.locator === undefined) {
            throw new Error('Locator is not defined!');
        }
        return this.teeErrorToEventEmitter(() => {
            // Default to keeping camera/mic on if no override argument specified
            let shouldCameraBeOnInCall = this.getState().cameraStatus === 'On';
            let shouldMicrophoneBeOnInCall = this.getState().isLocalPreviewMicrophoneEnabled;
            // Apply override arguments
            if (typeof options === 'boolean') {
                // Deprecated joinCall API (boolen)
                shouldMicrophoneBeOnInCall = options;
            }
            else if (typeof options === 'object') {
                // Options bag API
                if (options.microphoneOn && options.microphoneOn !== 'keep') {
                    shouldMicrophoneBeOnInCall = options.microphoneOn;
                }
                if (options.cameraOn && options.cameraOn !== 'keep') {
                    shouldCameraBeOnInCall = options.cameraOn;
                }
            }
            const audioOptions = {
                muted: !shouldMicrophoneBeOnInCall
            };
            const selectedCamera = getSelectedCameraFromAdapterState(this.getState());
            const videoOptions = selectedCamera && shouldCameraBeOnInCall ? {
                localVideoStreams: [new communicationCalling.LocalVideoStream(selectedCamera)]
            } : {};
            const call = this._joinCall(audioOptions, videoOptions);
            this.processNewCall(call);
            return call;
        });
    }
    _joinCall(audioOptions, videoOptions) {
        const isTeamsMeeting = this.locator ? 'meetingLink' in this.locator : false;
        /* @conditional-compile-remove(rooms) */
        const isRoomsCall = this.locator ? 'roomId' in this.locator : false;
        if (isTeamsMeeting) {
            return this.callAgent.join(this.locator, {
                audioOptions,
                videoOptions
            });
        }
        /* @conditional-compile-remove(rooms) */
        if (isRoomsCall) {
            return this.callAgent.join(this.locator, {
                audioOptions,
                videoOptions
            });
        }
        return this.callAgent.join(this.locator, {
            audioOptions,
            videoOptions
        });
    }
    createStreamView(remoteUserId, options) {
        return __awaiter$5(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                return yield this.handlers.onCreateLocalStreamView(options);
            }
            else {
                return yield this.handlers.onCreateRemoteStreamView(remoteUserId, options);
            }
        });
    }
    disposeStreamView(remoteUserId) {
        return __awaiter$5(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                yield this.handlers.onDisposeLocalStreamView();
            }
            else {
                yield this.handlers.onDisposeRemoteStreamView(remoteUserId);
            }
        });
    }
    disposeScreenShareStreamView(remoteUserId) {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield this.handlers.onDisposeRemoteScreenShareStreamView(remoteUserId);
        });
    }
    disposeRemoteVideoStreamView(remoteUserId) {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield this.handlers.onDisposeRemoteVideoStreamView(remoteUserId);
        });
    }
    disposeLocalVideoStreamView() {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield this.handlers.onDisposeLocalStreamView();
        });
    }
    leaveCall(forEveryone) {
        return __awaiter$5(this, void 0, void 0, function* () {
            if (this.getState().page === 'transferring') {
                const transferCall = this.callAgent.calls.filter(call => { var _a; return call.id === ((_a = this.getState().acceptedTransferCallState) === null || _a === void 0 ? void 0 : _a.id); })[0];
                transferCall === null || transferCall === void 0 ? void 0 : transferCall.hangUp();
            }
            yield this.handlers.onHangUp(forEveryone);
            this.unsubscribeCallEvents();
            this.handlers = createHandlers(this.callClient, this.callAgent, this.deviceManager, this.call, /* @conditional-compile-remove(video-background-effects) */ {
                onResolveVideoBackgroundEffectsDependency: this.onResolveVideoBackgroundEffectsDependency
            });
            // We set the adapter.call object to undefined immediately when a call is ended.
            // We do not set the context.callId to undefined because it is a part of the immutable data flow loop.
            this.call = undefined;
            this.stopCamera();
            this.mute();
        });
    }
    setCamera(device, options) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onSelectCamera(device, options);
            }));
        });
    }
    setMicrophone(device) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onSelectMicrophone(device);
            }));
        });
    }
    setSpeaker(device) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onSelectSpeaker(device);
            }));
        });
    }
    startCamera(options) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                if (!isCameraOn(this.getState())) {
                    // First kick off the effect on the local device before starting the camera in the call.
                    // This prevents the effect not being applied for a brief moment when the camera is started.
                    /* @conditional-compile-remove(video-background-effects) */
                    {
                        const selectedEffect = this.getState().selectedVideoBackgroundEffect;
                        const selectedCamera = getSelectedCameraFromAdapterState(this.getState());
                        if (selectedEffect && selectedCamera && this.onResolveVideoBackgroundEffectsDependency) {
                            const stream = new communicationCalling.LocalVideoStream(selectedCamera);
                            const effect = getBackgroundEffectFromSelectedEffect(selectedEffect, yield this.onResolveVideoBackgroundEffectsDependency());
                            if (effect) {
                                yield stream.feature(communicationCalling.Features.VideoEffects).startEffects(effect);
                            }
                            else {
                                yield stream.feature(communicationCalling.Features.VideoEffects).stopEffects();
                            }
                        }
                    }
                    yield this.handlers.onToggleCamera(options);
                }
            }));
        });
    }
    stopCamera() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                if (isCameraOn(this.getState())) {
                    yield this.handlers.onToggleCamera();
                }
            }));
        });
    }
    mute() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                var _a, _b;
                this.context.setIsLocalMicrophoneEnabled(false);
                if (_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) && !((_b = this.call) === null || _b === void 0 ? void 0 : _b.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    unmute() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                var _a, _b, _c;
                this.context.setIsLocalMicrophoneEnabled(true);
                if ((_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) || _isInLobbyOrConnecting((_b = this.call) === null || _b === void 0 ? void 0 : _b.state)) && ((_c = this.call) === null || _c === void 0 ? void 0 : _c.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    startScreenShare() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                var _a;
                if (!((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn)) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    stopScreenShare() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                var _a;
                if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    raiseHand() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onToggleRaiseHand();
            }));
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    lowerHand() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onToggleRaiseHand();
            }));
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    startVideoBackgroundEffect(videoBackgroundEffect) {
        return __awaiter$5(this, void 0, void 0, function* () {
            if (this.isBlurEffect(videoBackgroundEffect)) {
                const blurConfig = videoBackgroundEffect;
                yield this.handlers.onBlurVideoBackground(blurConfig);
            }
            else if (this.isReplacementEffect(videoBackgroundEffect)) {
                const replaceConfig = videoBackgroundEffect;
                yield this.handlers.onReplaceVideoBackground(replaceConfig);
            }
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    stopVideoBackgroundEffects() {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield this.handlers.onRemoveVideoBackgroundEffects();
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    updateBackgroundPickerImages(backgroundImages) {
        this.context.setBackroundPickerImages(backgroundImages);
    }
    /* @conditional-compile-remove(video-background-effects) */
    updateSelectedVideoBackgroundEffect(selectedVideoBackground) {
        this.context.setSelectedVideoBackgroundEffect(selectedVideoBackground);
    }
    startCall(participants, options) {
        var _a, _b;
        if (_isInCall((_b = (_a = this.getState().call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None')) {
            throw new Error('You are already in the call.');
        }
        const isCameraOn = this.getState().cameraStatus === 'On';
        const selectedCamera = getSelectedCameraFromAdapterState(this.getState());
        /* we only configure the video options here since the Calling SDK always unmutes the participant when starting a call */
        const startCallVideoOptions = selectedCamera ? {
            videoOptions: isCameraOn ? {
                localVideoStreams: [new communicationCalling.LocalVideoStream(selectedCamera)]
            } : undefined
        } : {};
        const combinedCallOptions = Object.assign(Object.assign({}, startCallVideoOptions), options);
        const idsToAdd = participants.map(participant => {
            const backendId = _toCommunicationIdentifier(participant);
            if ('phoneNumber' in backendId) {
                if ((options === null || options === void 0 ? void 0 : options.alternateCallerId) === undefined) {
                    throw new Error('Unable to start call, PSTN user present with no alternateCallerId.');
                }
            }
            return backendId;
        });
        /* @conditional-compile-remove(calling-sounds) */
        this.context.setTargetCallee(idsToAdd);
        const call = this.handlers.onStartCall(idsToAdd, combinedCallOptions);
        if (!call) {
            throw new Error('Unable to start call.');
        }
        this.processNewCall(call);
        return call;
    }
    processNewCall(call) {
        this.call = call;
        this.context.setCurrentCallId(call.id);
        // Resync state after callId is set
        this.context.updateClientState(this.callClient.getState());
        this.handlers = createHandlers(this.callClient, this.callAgent, this.deviceManager, this.call, /* @conditional-compile-remove(video-background-effects) */ {
            onResolveVideoBackgroundEffectsDependency: this.onResolveVideoBackgroundEffectsDependency
        });
        this.subscribeCallEvents();
    }
    /* @conditional-compile-remove(video-background-effects) */
    isBlurEffect(effect) {
        return effect.effectName === 'blur';
    }
    /* @conditional-compile-remove(video-background-effects) */
    isReplacementEffect(effect) {
        return effect.effectName === 'replacement';
    }
    removeParticipant(userId) {
        return __awaiter$5(this, void 0, void 0, function* () {
            let participant = userId;
            this.handlers.onRemoveParticipant(participant);
        });
    }
    sendDtmfTone(dtmfTone) {
        return __awaiter$5(this, void 0, void 0, function* () {
            this.handlers.onSendDtmfTone(dtmfTone);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    startCaptions(options) {
        return __awaiter$5(this, void 0, void 0, function* () {
            this.handlers.onStartCaptions(options);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    stopCaptions() {
        return __awaiter$5(this, void 0, void 0, function* () {
            this.handlers.onStopCaptions();
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setCaptionLanguage(language) {
        return __awaiter$5(this, void 0, void 0, function* () {
            this.handlers.onSetCaptionLanguage(language);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setSpokenLanguage(language) {
        return __awaiter$5(this, void 0, void 0, function* () {
            this.handlers.onSetSpokenLanguage(language);
        });
    }
    getState() {
        return this.context.getState();
    }
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    /* @conditional-compile-remove(close-captions) */
    subscribeToCaptionEvents() {
        var _a;
        if (this.call && this.call.state === 'Connected' && this.context.getState().isTeamsCall) {
            const captionsFeature = (_a = this.call) === null || _a === void 0 ? void 0 : _a.feature(communicationCalling.Features.Captions).captions;
            captionsFeature.on('CaptionsReceived', this.captionsReceived.bind(this));
            captionsFeature.on('CaptionsActiveChanged', this.isCaptionsActiveChanged.bind(this));
            captionsFeature.on('CaptionLanguageChanged', this.isCaptionLanguageChanged.bind(this));
            captionsFeature.on('SpokenLanguageChanged', this.isSpokenLanguageChanged.bind(this));
        }
    }
    /* @conditional-compile-remove(close-captions) */
    unsubscribeFromCaptionEvents() {
        var _a, _b;
        if (this.call && this.call.state === 'Connected' && this.context.getState().isTeamsCall) {
            const captionsFeature = (_a = this.call) === null || _a === void 0 ? void 0 : _a.feature(communicationCalling.Features.Captions).captions;
            captionsFeature.off('CaptionsReceived', this.captionsReceived.bind(this));
            captionsFeature.off('CaptionsActiveChanged', this.isCaptionsActiveChanged.bind(this));
            captionsFeature.off('CaptionLanguageChanged', this.isCaptionLanguageChanged.bind(this));
            captionsFeature.off('SpokenLanguageChanged', this.isSpokenLanguageChanged.bind(this));
            (_b = this.call) === null || _b === void 0 ? void 0 : _b.off('stateChanged', this.subscribeToCaptionEvents.bind(this));
        }
    }
    subscribeCallEvents() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        /* @conditional-compile-remove(calling-sounds) */
        if (this.call) {
            this.callingSoundSubscriber = new CallingSoundSubscriber(this.call, this.getState().targetCallees, this.getState().sounds);
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.on('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.on('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.on('idChanged', this.callIdChanged.bind(this));
        /* @conditional-compile-remove(close-captions) */
        (_e = this.call) === null || _e === void 0 ? void 0 : _e.on('stateChanged', this.subscribeToCaptionEvents.bind(this));
        /* @conditional-compile-remove(rooms) */
        (_f = this.call) === null || _f === void 0 ? void 0 : _f.on('roleChanged', this.roleChanged.bind(this));
        /* @conditional-compile-remove(call-transfer) */
        (_g = this.call) === null || _g === void 0 ? void 0 : _g.feature(communicationCalling.Features.Transfer).on('transferAccepted', this.transferAccepted.bind(this));
        /* @conditional-compile-remove(capabilities) */
        (_h = this.call) === null || _h === void 0 ? void 0 : _h.feature(communicationCalling.Features.Capabilities).on('capabilitiesChanged', this.capabilitiesChanged.bind(this));
    }
    unsubscribeCallEvents() {
        var _a, _b, _c, _d, _e;
        for (const subscriber of this.participantSubscribers.values()) {
            subscriber.unsubscribeAll();
        }
        this.participantSubscribers.clear();
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.off('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.off('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.off('idChanged', this.callIdChanged.bind(this));
        /* @conditional-compile-remove(rooms) */
        (_e = this.call) === null || _e === void 0 ? void 0 : _e.off('roleChanged', this.roleChanged.bind(this));
        /* @conditional-compile-remove(close-captions) */
        this.unsubscribeFromCaptionEvents();
        /* @conditional-compile-remove(calling-sounds) */
        if (this.callingSoundSubscriber) {
            this.callingSoundSubscriber.unsubscribeAll();
        }
    }
    onRemoteParticipantsUpdated({ added, removed }) {
        if (added && added.length > 0) {
            this.emitter.emit('participantsJoined', {
                joined: added
            });
        }
        if (removed && removed.length > 0) {
            this.emitter.emit('participantsLeft', {
                removed: removed
            });
        }
        added.forEach(participant => {
            this.participantSubscribers.set(toFlatCommunicationIdentifier(participant.identifier), new ParticipantSubscriber(participant, this.emitter));
        });
        removed.forEach(participant => {
            const subscriber = this.participantSubscribers.get(toFlatCommunicationIdentifier(participant.identifier));
            subscriber && subscriber.unsubscribeAll();
            this.participantSubscribers.delete(toFlatCommunicationIdentifier(participant.identifier));
        });
    }
    isScreenSharingOnChanged() {
        var _a;
        this.emitter.emit('isLocalScreenSharingActiveChanged', {
            isScreenSharingOn: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn
        });
    }
    /* @conditional-compile-remove(close-captions) */
    captionsReceived(captionsInfo) {
        this.emitter.emit('captionsReceived', {
            captionsInfo
        });
    }
    /* @conditional-compile-remove(close-captions) */
    isCaptionsActiveChanged() {
        var _a;
        const captionsFeature = (_a = this.call) === null || _a === void 0 ? void 0 : _a.feature(communicationCalling.Features.Captions).captions;
        this.emitter.emit('isCaptionsActiveChanged', {
            isActive: captionsFeature.isCaptionsFeatureActive
        });
    }
    /* @conditional-compile-remove(close-captions) */
    isSpokenLanguageChanged() {
        var _a;
        const captionsFeature = (_a = this.call) === null || _a === void 0 ? void 0 : _a.feature(communicationCalling.Features.Captions).captions;
        this.emitter.emit('isSpokenLanguageChanged', {
            activeSpokenLanguage: captionsFeature.activeSpokenLanguage
        });
    }
    /* @conditional-compile-remove(close-captions) */
    isCaptionLanguageChanged() {
        var _a;
        const captionsFeature = (_a = this.call) === null || _a === void 0 ? void 0 : _a.feature(communicationCalling.Features.Captions).captions;
        this.emitter.emit('isCaptionLanguageChanged', {
            activeCaptionLanguage: captionsFeature.activeCaptionLanguage
        });
    }
    /* @conditional-compile-remove(call-transfer) */
    transferAccepted(args) {
        this.emitter.emit('transferAccepted', args);
    }
    /* @conditional-compile-remove(capabilities) */
    capabilitiesChanged(data) {
        var _a, _b, _c, _d, _e;
        if (((_a = data.newValue.turnVideoOn) === null || _a === void 0 ? void 0 : _a.isPresent) === false) {
            // Only stop camera when the call state is not on hold. The Calling SDK does not allow us to stop camera when
            // the call state is on hold.
            if (((_b = this.call) === null || _b === void 0 ? void 0 : _b.state) !== 'LocalHold' && ((_c = this.call) === null || _c === void 0 ? void 0 : _c.state) !== 'RemoteHold') {
                this.stopCamera();
            }
            this.disposeLocalVideoStreamView();
        }
        if (((_d = data.newValue.unmuteMic) === null || _d === void 0 ? void 0 : _d.isPresent) === false) {
            this.mute();
        }
        if (((_e = data.newValue.shareScreen) === null || _e === void 0 ? void 0 : _e.isPresent) === false) {
            this.stopScreenShare();
        }
        this.emitter.emit('capabilitiesChanged', data);
    }
    /* @conditional-compile-remove(rooms) */
    roleChanged() {
        var _a, _b;
        if (((_a = this.call) === null || _a === void 0 ? void 0 : _a.role) === 'Consumer') {
            (_b = this.call) === null || _b === void 0 ? void 0 : _b.feature(communicationCalling.Features.RaiseHand).lowerHand();
        }
        this.emitter.emit('roleChanged');
    }
    callIdChanged() {
        var _a;
        ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id) && this.emitter.emit('callIdChanged', {
            callId: this.call.id
        });
    }
    resetDiagnosticsForwarder(newCall) {
        if (this.diagnosticsForwarder) {
            this.diagnosticsForwarder.unsubscribe();
        }
        if (newCall) {
            this.diagnosticsForwarder = new DiagnosticsForwarder(this.emitter, newCall);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    asyncTeeErrorToEventEmitter(f) {
        return __awaiter$5(this, void 0, void 0, function* () {
            try {
                return yield f();
            }
            catch (error) {
                if (isCallError(error)) {
                    this.emitter.emit('error', error);
                }
                throw error;
            }
        });
    }
    teeErrorToEventEmitter(f) {
        try {
            return f();
        }
        catch (error) {
            if (isCallError(error)) {
                this.emitter.emit('error', error);
            }
            throw error;
        }
    }
}
/**
 * @public
 */
/**
 * Create a {@link CallAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link CallAdapter} provided by this library.
 *
 * Note: `displayName` can be a maximum of 256 characters.
 *
 * @public
 */
function createAzureCommunicationCallAdapter(args) {
    return __awaiter$5(this, void 0, void 0, function* () {
        if (communicationCommon.isMicrosoftTeamsUserIdentifier(args.userId)) {
            throw new Error('Microsoft Teams user identifier is not supported by AzureCommunicationCallAdapter. Instead use TeamsCallAdapter.');
        }
        return _createAzureCommunicationCallAdapterInner({
            userId: args.userId,
            displayName: args.displayName,
            credential: args.credential,
            locator: args.locator,
            targetCallees: args.targetCallees,
            /* @conditional-compile-remove(video-background-effects) */
            options: args.options
        });
    });
}
/**
 * This inner function is used to allow injection of TelemetryImplementationHint without changing the public API.
 *
 * @internal
 */
const _createAzureCommunicationCallAdapterInner = ({ userId, displayName, credential, locator, targetCallees, 
/* @conditional-compile-remove(video-background-effects) */ options, telemetryImplementationHint = 'Call' }) => __awaiter$5(void 0, void 0, void 0, function* () {
    if (!_isValidIdentifier(userId)) {
        throw new Error('Invalid identifier. Please provide valid identifier object.');
    }
    const callClient = _createStatefulCallClientInner({
        userId
    }, undefined, telemetryImplementationHint);
    const callAgent = yield callClient.createCallAgent(credential, {
        displayName
    });
    let adapter;
    if (locator) {
        adapter = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, locator, /* @conditional-compile-remove(video-background-effects) */ options);
    }
    else {
        adapter = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, targetCallees, /* @conditional-compile-remove(video-background-effects) */ options);
    }
    return adapter;
});
/**
 * @private
 */
function useAzureCommunicationCallAdapterGeneric(args, adapterKind = 'AzureCommunication', afterCreate, beforeDispose) {
    const { credential, userId } = args;
    const locator = 'locator' in args ? args.locator : undefined;
    const targetCallees = 'targetCallees' in args ? args.targetCallees : undefined;
    const displayName = 'displayName' in args ? args.displayName : undefined;
    /* @conditional-compile-remove(video-background-effects) */
    const options = 'options' in args ? args.options : undefined;
    // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = React.useState(undefined);
    // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = React.useRef(undefined);
    const creatingAdapterRef = React.useRef(false);
    const afterCreateRef = React.useRef(undefined);
    const beforeDisposeRef = React.useRef(undefined);
    // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    React.useEffect(() => {
        if (!credential || !locator && !targetCallees || !userId) {
            return;
        }
        if (adapterKind === 'AzureCommunication' && !displayName) {
            return;
        }
        (() => __awaiter$5(this, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            let newAdapter = undefined;
            if (adapterKind === 'AzureCommunication') {
                // This is just the type check to ensure that displayName is defined.
                if (!displayName) {
                    throw new Error('Unreachable code, displayName already checked above.');
                }
                if (creatingAdapterRef.current) {
                    console.warn('Adapter is already being created, please see storybook for more information: https://azure.github.io/communication-ui-library/?path=/story/troubleshooting--page');
                    return;
                }
                creatingAdapterRef.current = true;
                if (locator) {
                    newAdapter = (yield createAzureCommunicationCallAdapter({
                        credential,
                        displayName: displayName,
                        locator,
                        userId: userId,
                        /* @conditional-compile-remove(video-background-effects) */ options
                    }));
                }
                else if (targetCallees) {
                    newAdapter = (yield createAzureCommunicationCallAdapter({
                        credential,
                        displayName: displayName,
                        targetCallees,
                        userId: userId,
                        /* @conditional-compile-remove(video-background-effects) */ options
                    }));
                }
            }
            else if (adapterKind === 'Teams') {
                if (creatingAdapterRef.current) {
                    console.warn('Adapter is already being created, skipping creation.');
                    return;
                }
                creatingAdapterRef.current = true;
            }
            else {
                throw new Error('Unreachable code, unknown adapterKind');
            }
            if (!newAdapter) {
                throw Error('Unreachable code! Get undefined adapter');
            }
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            creatingAdapterRef.current = false;
            setAdapter(newAdapter);
        }))();
    }, 
    // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, adapterKind, credential, locator, userId, displayName, options, targetCallees]);
    // Dispose any existing adapter when the component unmounts.
    React.useEffect(() => {
        return () => {
            (() => __awaiter$5(this, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
}
/**
 * A custom React hook to simplify the creation of {@link CallAdapter}.
 *
 * Similar to {@link createAzureCommunicationCallAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
const useAzureCommunicationCallAdapter = (args, afterCreate, beforeDispose) => {
    return useAzureCommunicationCallAdapterGeneric(args, 'AzureCommunication', afterCreate, beforeDispose);
};
/**
 * Create a {@link CallAdapter} using the provided {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallAdapter} for a simpler API.
 *
 * @public
 */
function createAzureCommunicationCallAdapterFromClient(callClient, callAgent, locatorOrtargetCallees, /* @conditional-compile-remove(video-background-effects) */ options) {
    return __awaiter$5(this, void 0, void 0, function* () {
        const deviceManager = yield callClient.getDeviceManager();
        yield Promise.all([deviceManager.getCameras(), deviceManager.getMicrophones()]);
        if (deviceManager.isSpeakerSelectionAvailable) {
            yield deviceManager.getSpeakers();
        }
        if (getLocatorOrTargetCallees(locatorOrtargetCallees)) {
            return new AzureCommunicationCallAdapter(callClient, locatorOrtargetCallees, callAgent, deviceManager, /* @conditional-compile-remove(video-background-effects) */ options);
        }
        else {
            return new AzureCommunicationCallAdapter(callClient, locatorOrtargetCallees, callAgent, deviceManager, /* @conditional-compile-remove(video-background-effects) */ options);
        }
    });
}
const isCallError = (e) => {
    return 'target' in e && 'innerError' in e;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const compositeOuterContainerStyles = {
    root: {
        width: '100%',
        // Create a new stacking context so that DrawerMenu can be positioned absolutely.
        position: 'relative'
    }
};
/** @private */
const callCompositeContainerStyles = (isMobile) => ({
    root: {
        // Start a new stacking context so that any `position:absolute` elements
        // inside the call composite do not compete with its siblings.
        position: 'relative',
        width: '100%',
        minWidth: isMobile ? 'unset' : `${compositeMinWidthRem}rem`
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$4 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/**
 * Facade around the CallWithChatAdapter to satisfy the call adapter interface.
 *
 * @private
 */
class CallWithChatBackedCallAdapter {
    constructor(callWithChatAdapter) {
        // For onStateChange we must convert CallWithChat state to chat state. This involves creating a new handler to be passed into the onStateChange.
        // In order to unsubscribe the handler when offStateChange is called we must have a mapping of the original handler to the newly created handler.
        this.eventStore = new Map();
        this.on = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.on('callError', listener);
                case 'participantsJoined':
                    return this.callWithChatAdapter.on('callParticipantsJoined', listener);
                case 'participantsLeft':
                    return this.callWithChatAdapter.on('callParticipantsLeft', listener);
                default:
                    return this.callWithChatAdapter.on(event, listener);
            }
        };
        this.off = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.off('callError', listener);
                case 'participantsJoined':
                    return this.callWithChatAdapter.off('callParticipantsJoined', listener);
                case 'participantsLeft':
                    return this.callWithChatAdapter.off('callParticipantsLeft', listener);
                default:
                    return this.callWithChatAdapter.off(event, listener);
            }
        };
        this.onStateChange = (handler) => {
            const convertedHandler = (state) => {
                handler(callAdapterStateFromCallWithChatAdapterState(state));
            };
            this.callWithChatAdapter.onStateChange(convertedHandler);
            this.eventStore.set(handler, convertedHandler);
        };
        this.offStateChange = (handler) => {
            const convertedHandler = this.eventStore.get(handler);
            convertedHandler && this.callWithChatAdapter.offStateChange(convertedHandler);
        };
        this.getState = () => callAdapterStateFromCallWithChatAdapterState(this.callWithChatAdapter.getState());
        this.dispose = () => this.callWithChatAdapter.dispose();
        this.joinCall = (options) => {
            if (typeof options === 'boolean') {
                return this.callWithChatAdapter.joinCall(options);
            }
            else {
                return this.callWithChatAdapter.joinCall(options);
            }
        };
        this.leaveCall = (forEveryone) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.leaveCall(forEveryone); });
        this.startCall = (participants, options) => {
            if (participants.every((participant) => typeof participant === 'string')) {
                return this.callWithChatAdapter.startCall(participants, options);
            }
            else {
                return this.callWithChatAdapter.startCall(participants, options);
            }
        };
        this.setCamera = (sourceId, options) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.setCamera(sourceId, options); });
        this.setMicrophone = (sourceId) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.setMicrophone(sourceId); });
        this.setSpeaker = (sourceId) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.setSpeaker(sourceId); });
        this.askDevicePermission = (constraints) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.askDevicePermission(constraints); });
        this.queryCameras = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.queryCameras(); });
        this.queryMicrophones = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.queryMicrophones(); });
        this.querySpeakers = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.querySpeakers(); });
        this.startCamera = (options) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.startCamera(options); });
        this.stopCamera = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.stopCamera(); });
        this.mute = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.mute(); });
        this.unmute = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.unmute(); });
        this.startScreenShare = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.startScreenShare(); });
        this.stopScreenShare = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.stopScreenShare(); });
        /* @conditional-compile-remove(raise-hand) */
        this.raiseHand = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.raiseHand(); });
        /* @conditional-compile-remove(raise-hand) */
        this.lowerHand = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.lowerHand(); });
        this.removeParticipant = (userId) => __awaiter$4(this, void 0, void 0, function* () {
            let participant = userId;
            yield this.callWithChatAdapter.removeParticipant(participant);
        });
        this.createStreamView = (remoteUserId, options) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.createStreamView(remoteUserId, options); });
        this.disposeStreamView = (remoteUserId, options) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.disposeStreamView(remoteUserId, options); });
        this.sendDtmfTone = (dtmfTone) => __awaiter$4(this, void 0, void 0, function* () {
            yield this.callWithChatAdapter.sendDtmfTone(dtmfTone);
        });
        this.callWithChatAdapter = callWithChatAdapter;
    }
    disposeScreenShareStreamView(remoteUserId) {
        return this.callWithChatAdapter.disposeScreenShareStreamView(remoteUserId);
    }
    disposeRemoteVideoStreamView(remoteUserId) {
        return this.callWithChatAdapter.disposeRemoteVideoStreamView(remoteUserId);
    }
    disposeLocalVideoStreamView() {
        return this.callWithChatAdapter.disposeLocalVideoStreamView();
    }
    /* @conditional-compile-remove(close-captions) */
    startCaptions(options) {
        return __awaiter$4(this, void 0, void 0, function* () {
            this.callWithChatAdapter.startCaptions(options);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    stopCaptions() {
        return __awaiter$4(this, void 0, void 0, function* () {
            this.callWithChatAdapter.stopCaptions();
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setCaptionLanguage(language) {
        return __awaiter$4(this, void 0, void 0, function* () {
            this.callWithChatAdapter.setCaptionLanguage(language);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setSpokenLanguage(language) {
        return __awaiter$4(this, void 0, void 0, function* () {
            this.callWithChatAdapter.setSpokenLanguage(language);
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    startVideoBackgroundEffect(videoBackgroundEffect) {
        return __awaiter$4(this, void 0, void 0, function* () {
            yield this.callWithChatAdapter.startVideoBackgroundEffect(videoBackgroundEffect);
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    stopVideoBackgroundEffects() {
        return __awaiter$4(this, void 0, void 0, function* () {
            yield this.callWithChatAdapter.stopVideoBackgroundEffects();
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    updateBackgroundPickerImages(backgroundImages) {
        return this.callWithChatAdapter.updateBackgroundPickerImages(backgroundImages);
    }
    /* @conditional-compile-remove(video-background-effects) */
    updateSelectedVideoBackgroundEffect(selectedVideoBackground) {
        return this.callWithChatAdapter.updateSelectedVideoBackgroundEffect(selectedVideoBackground);
    }
}
function callAdapterStateFromCallWithChatAdapterState(callWithChatAdapterState) {
    return {
        isLocalPreviewMicrophoneEnabled: callWithChatAdapterState.isLocalPreviewMicrophoneEnabled,
        page: callWithChatAdapterState.page,
        userId: callWithChatAdapterState.userId,
        displayName: callWithChatAdapterState.displayName,
        call: callWithChatAdapterState.call,
        devices: callWithChatAdapterState.devices,
        isTeamsCall: callWithChatAdapterState.isTeamsCall,
        /* @conditional-compile-remove(rooms) */
        isRoomsCall: false,
        latestErrors: callWithChatAdapterState.latestCallErrors,
        /* @conditional-compile-remove(video-background-effects) */
        videoBackgroundImages: callWithChatAdapterState.videoBackgroundImages,
        /* @conditional-compile-remove(video-background-effects) */
        onResolveVideoEffectDependency: callWithChatAdapterState.onResolveVideoEffectDependency,
        /* @conditional-compile-remove(video-background-effects) */
        selectedVideoBackgroundEffect: callWithChatAdapterState.selectedVideoBackgroundEffect
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$3 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Facade around the CallWithChatAdapter to satisfy the chat adapter interface.
 *
 * @private
 */
class CallWithChatBackedChatAdapter {
    constructor(callWithChatAdapter) {
        // For onStateChange we must convert CallWithChat state to chat state. This involves creating a new handler to be passed into the onStateChange.
        // In order to unsubscribe the handler when offStateChange is called we must have a mapping of the original handler to the newly created handler.
        this.eventStore = new Map();
        this.fetchInitialData = () => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.fetchInitialData(); });
        this.sendMessage = (content) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.sendMessage(content); });
        this.sendReadReceipt = (chatMessageId) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.sendReadReceipt(chatMessageId); });
        this.sendTypingIndicator = () => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.sendTypingIndicator(); });
        this.removeParticipant = (userId) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.removeParticipant(userId); });
        this.loadPreviousChatMessages = (messagesToLoad) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.loadPreviousChatMessages(messagesToLoad); });
        this.dispose = () => this.callWithChatAdapter.dispose();
        this.onStateChange = (handler) => {
            const convertedHandler = (state) => {
                handler(chatAdapterStateFromCallWithChatAdapterState(state));
            };
            this.callWithChatAdapter.onStateChange(convertedHandler);
            this.eventStore.set(handler, convertedHandler);
        };
        this.offStateChange = (handler) => {
            const convertedHandler = this.eventStore.get(handler);
            convertedHandler && this.callWithChatAdapter.offStateChange(convertedHandler);
        };
        this.getState = () => chatAdapterStateFromCallWithChatAdapterState(this.callWithChatAdapter.getState());
        /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
        this.on = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.on('chatError', listener);
                case 'participantsAdded':
                    return this.callWithChatAdapter.on('chatParticipantsAdded', listener);
                case 'participantsRemoved':
                    return this.callWithChatAdapter.on('chatParticipantsRemoved', listener);
                default:
                    return this.callWithChatAdapter.on(event, listener);
            }
        };
        this.off = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.off('chatError', listener);
                case 'participantsAdded':
                    return this.callWithChatAdapter.off('chatParticipantsAdded', listener);
                case 'participantsRemoved':
                    return this.callWithChatAdapter.off('chatParticipantsRemoved', listener);
                default:
                    return this.callWithChatAdapter.off(event, listener);
            }
        };
        this.updateMessage = (messageId, content, metadata) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.updateMessage(messageId, content, metadata); });
        this.deleteMessage = (messageId) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.deleteMessage(messageId); });
        this.clearErrors = (errorTypes) => {
            throw new Error(`Method not supported in CallWithChatComposite.`);
        };
        this.setTopic = (topicName) => __awaiter$3(this, void 0, void 0, function* () {
            throw new Error(`Chat Topics are not supported in CallWithChatComposite.`);
        });
        this.callWithChatAdapter = callWithChatAdapter;
    }
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    downloadResourceToCache(resourceDetails) {
        return __awaiter$3(this, void 0, void 0, function* () {
            this.callWithChatAdapter.downloadResourceToCache(resourceDetails);
        });
    }
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    removeResourceFromCache(resourceDetails) {
        this.callWithChatAdapter.removeResourceFromCache(resourceDetails);
    }
}
function chatAdapterStateFromCallWithChatAdapterState(callWithChatAdapterState) {
    if (!callWithChatAdapterState.chat) {
        throw new Error('Chat thread state id undefined.');
    }
    return {
        userId: callWithChatAdapterState.userId,
        displayName: callWithChatAdapterState.displayName || '',
        thread: callWithChatAdapterState.chat,
        latestErrors: callWithChatAdapterState.latestChatErrors
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const ChatButton = (props) => {
    const strings = Object.assign({ label: props.label }, props.strings);
    const theme = useTheme();
    const styles = React.useMemo(() => {
        var _a;
        return react.concatStyleSets({
            rootChecked: {
                background: theme.palette.neutralLight
            }
        }, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    }, [props.styles, theme.palette.neutralLight]);
    return React.createElement(ControlBarButton, Object.assign({}, props, { labelKey: 'chatButtonLabelKey', strings: strings, onClick: props.onClick, styles: styles }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
const NotificationIcon = (props) => {
    const { chatMessagesCount, label } = props;
    const theme = react.useTheme();
    const renderNumber = (numberOfMessages) => {
        if (numberOfMessages < 1) {
            return React.createElement(React.Fragment, null);
        }
        else {
            const textNumberOfMessages = numberOfMessages < 9 ? numberOfMessages : '9+';
            return React.createElement(react.Text, { role: 'status', "aria-label": textNumberOfMessages + (label !== null && label !== void 0 ? label : ''), styles: notificationTextStyles(theme) }, textNumberOfMessages);
        }
    };
    return React.createElement(react.Stack, { "data-ui-id": "call-with-chat-composite-chat-button-unread-icon", horizontalAlign: "center", verticalAlign: "center", styles: notificationIconContainerStyles(theme) },
        React.createElement(react.Stack, null, renderNumber(chatMessagesCount)));
};
const notificationIconPaddingREM = 0.225;
const notificationSizeREM = 1;
const notificationIconContainerStyles = react.memoizeFunction((theme) => ({
    root: {
        borderRadius: `${notificationSizeREM}rem`,
        // Create a css circle. This should match the height.
        height: `${notificationSizeREM}rem`,
        minWidth: `${notificationSizeREM}rem`,
        // use min-width over width as we want to extend the width of the notification icon when contents is more than one character (e.g. 9+)
        background: theme.palette.themePrimary,
        border: `0.0625rem solid white`,
        // border should always be white
        padding: `${notificationIconPaddingREM}rem`,
        // positioning to place the badge within the button appropriately.
        position: 'absolute',
        top: `-${0.5 - notificationIconPaddingREM / 2}rem`,
        left: `${0.5 + notificationIconPaddingREM / 2}rem`
    }
}));
const notificationTextStyles = react.memoizeFunction((theme) => ({
    root: {
        color: 'white',
        fontSize: theme.fonts.xSmall.fontSize
    }
}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const filledIcon = React.createElement(CallWithChatCompositeIcon, { iconName: 'ControlBarChatButtonActive' });
const regularIcon = React.createElement(CallWithChatCompositeIcon, { iconName: 'ControlBarChatButtonInactive' });
/**
 * @private
 */
const ChatButtonWithUnreadMessagesBadge = (props) => {
    var _a, _b, _c, _d;
    const { newMessageLabel, unreadChatMessagesCount, hideUnreadChatMessagesBadge } = props;
    const baseIcon = props.showLabel ? regularIcon : filledIcon;
    const callWithChatStrings = useCallWithChatCompositeStrings();
    const numberOfMsgToolTip = ((_a = props.strings) === null || _a === void 0 ? void 0 : _a.tooltipOffContent) && unreadChatMessagesCount > 0 ? _formatString(callWithChatStrings.chatButtonTooltipClosedWithMessageCount, {
        unreadMessagesCount: `${unreadChatMessagesCount}`
    }) : undefined;
    const chatStrings = React.useMemo(() => {
        var _a, _b, _c;
        return ({
            label: (_a = props.strings) === null || _a === void 0 ? void 0 : _a.label,
            tooltipOffContent: numberOfMsgToolTip ? numberOfMsgToolTip : (_b = props.strings) === null || _b === void 0 ? void 0 : _b.tooltipOffContent,
            tooltipOnContent: (_c = props.strings) === null || _c === void 0 ? void 0 : _c.tooltipOnContent
        });
    }, [numberOfMsgToolTip, (_b = props.strings) === null || _b === void 0 ? void 0 : _b.label, (_c = props.strings) === null || _c === void 0 ? void 0 : _c.tooltipOffContent, (_d = props.strings) === null || _d === void 0 ? void 0 : _d.tooltipOnContent]);
    const onRenderOnIcon = React.useCallback(() => baseIcon, [baseIcon]);
    const notificationOnIcon = React.useCallback(() => {
        return React.createElement(react.Stack, { styles: chatNotificationContainerStyles },
            unreadChatMessagesCount > 0 && !hideUnreadChatMessagesBadge && React.createElement(NotificationIcon, { chatMessagesCount: unreadChatMessagesCount, label: newMessageLabel }),
            baseIcon);
    }, [unreadChatMessagesCount, newMessageLabel, baseIcon, hideUnreadChatMessagesBadge]);
    return React.createElement(ChatButton, Object.assign({}, props, { "data-ui-id": "call-with-chat-composite-chat-button", onRenderOffIcon: notificationOnIcon, onRenderOnIcon: onRenderOnIcon, strings: chatStrings }));
};
const chatNotificationContainerStyles = {
    root: {
        display: 'inline',
        position: 'relative'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Used by the CallWithChatComposite to track unread messages for showing as a badge on the Chat Button.
 * @private
 */
const useUnreadMessagesTracker = (chatAdapter, isChatPaneVisible) => {
    // Store messageIds of unread messages
    const [unreadChatMessages, setUnreadChatMessages] = React.useState(new Set());
    React.useEffect(() => {
        // Clear unread messages when chat pane is opened
        if (isChatPaneVisible) {
            setUnreadChatMessages(new Set());
            return;
        }
        // Increment unread messages when a new message is received and the chat pane is closed
        const incrementUnreadChatMessagesCount = (event) => {
            if (!isChatPaneVisible && validNewChatMessage(event.message)) {
                setUnreadChatMessages(prevUnreadChatMessages => {
                    const newUnreadChatMessages = new Set(prevUnreadChatMessages);
                    newUnreadChatMessages.add(event.message.id);
                    return newUnreadChatMessages;
                });
            }
        };
        // Decrement unread messages when a message is deleted and the chat pane is closed
        const decrementUnreadChatMessagesCount = (event) => {
            if (!isChatPaneVisible) {
                setUnreadChatMessages(prevUnreadChatMessages => {
                    const newUnreadChatMessages = new Set(prevUnreadChatMessages);
                    newUnreadChatMessages.delete(event.message.id);
                    return newUnreadChatMessages;
                });
            }
        };
        chatAdapter.on('messageReceived', incrementUnreadChatMessagesCount);
        chatAdapter.on('messageDeleted', decrementUnreadChatMessagesCount);
        return () => {
            chatAdapter.off('messageReceived', incrementUnreadChatMessagesCount);
            chatAdapter.off('messageDeleted', decrementUnreadChatMessagesCount);
        };
    }, [chatAdapter, setUnreadChatMessages, isChatPaneVisible]);
    return unreadChatMessages.size;
};
/**
 * Helper function to determine if the message in the event is a valid one from a user.
 * Display name is used since system messages will not have one.
 */
const validNewChatMessage = (message) => !!message.senderDisplayName && (message.type === 'text' || message.type === 'html');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const CallWithChatScreen = (props) => {
    const { callWithChatAdapter, fluentTheme, formFactor = 'desktop' } = props;
    const mobileView = formFactor === 'mobile';
    if (!callWithChatAdapter) {
        throw new Error('CallWithChatAdapter is undefined');
    }
    const callAdapter = React.useMemo(() => new CallWithChatBackedCallAdapter(callWithChatAdapter), [callWithChatAdapter]);
    const [currentCallState, setCurrentCallState] = React.useState();
    const [currentPage, setCurrentPage] = React.useState();
    const [isChatOpen, setIsChatOpen] = React.useState(false);
    const containerRef = React.useRef(null);
    React.useEffect(() => {
        const updateCallWithChatPage = (newState) => {
            var _a;
            setCurrentPage(newState.page);
            setCurrentCallState((_a = newState.call) === null || _a === void 0 ? void 0 : _a.state);
        };
        updateCallWithChatPage(callWithChatAdapter.getState());
        callWithChatAdapter.onStateChange(updateCallWithChatPage);
        return () => {
            callWithChatAdapter.offStateChange(updateCallWithChatPage);
        };
    }, [callWithChatAdapter]);
    const chatAdapter = React.useMemo(() => {
        return new CallWithChatBackedChatAdapter(callWithChatAdapter);
    }, [callWithChatAdapter]);
    /** Constant setting of id for the parent stack of the composite */
    const compositeParentDivId = reactHooks.useId('callWithChatCompositeParentDiv-internal');
    const closeChat = React.useCallback(() => {
        setIsChatOpen(false);
    }, []);
    const openChat = React.useCallback(() => {
        setIsChatOpen(true);
        // timeout is required to give the window time to render the sendbox so we have something to send focus to.
        // TODO: Selecting elements in the DOM via attributes is not stable. We should expose an API from ChatComposite to be able to focus on the sendbox.
        const chatFocusTimeout = setInterval(() => {
            const callWithChatCompositeRootDiv = document.querySelector(`[id="${compositeParentDivId}"]`);
            const sendbox = callWithChatCompositeRootDiv === null || callWithChatCompositeRootDiv === void 0 ? void 0 : callWithChatCompositeRootDiv.querySelector(`[id="sendbox"]`);
            if (sendbox !== null) {
                sendbox.focus();
                clearInterval(chatFocusTimeout);
            }
        }, 3);
        setTimeout(() => {
            clearInterval(chatFocusTimeout);
        }, 300);
    }, [compositeParentDivId]);
    const isOnHold = isOnHoldTrampoline();
    React.useEffect(() => {
    }, [closeChat, isOnHold]);
    const hasJoinedCall = !!(currentPage && hasJoinedCallFn(currentPage, currentCallState !== null && currentCallState !== void 0 ? currentCallState : 'None'));
    const toggleChat = React.useCallback(() => {
        isChatOpen || !hasJoinedCall ? closeChat() : openChat();
    }, [closeChat, hasJoinedCall, isChatOpen, openChat]);
    const callWithChatStrings = useCallWithChatCompositeStrings();
    const chatButtonStrings = React.useMemo(() => ({
        label: callWithChatStrings.chatButtonLabel,
        tooltipOffContent: callWithChatStrings.chatButtonTooltipOpen,
        tooltipOnContent: callWithChatStrings.chatButtonTooltipClose
    }), [callWithChatStrings]);
    const theme = useTheme();
    const commonButtonStyles = React.useMemo(() => !mobileView ? getDesktopCommonButtonStyles(theme) : undefined, [mobileView, theme]);
    const showChatButton = checkShowChatButton(props.callControls);
    const chatButtonDisabled = showChatButton && (checkChatButtonIsDisabled(props.callControls) || !hasJoinedCall || isOnHold);
    const chatTabHeaderProps = React.useMemo(() => mobileView && showChatButton ? {
        onClick: toggleChat,
        disabled: chatButtonDisabled
    } : undefined, [chatButtonDisabled, mobileView, toggleChat, showChatButton]);
    const unreadChatMessagesCount = useUnreadMessagesTracker(chatAdapter, isChatOpen);
    const customChatButton = React.useCallback((args) => ({
        placement: mobileView ? 'primary' : 'secondary',
        onRenderButton: () => React.createElement(ChatButtonWithUnreadMessagesBadge, { checked: isChatOpen, showLabel: args.displayType !== 'compact', onClick: toggleChat, disabled: chatButtonDisabled, strings: chatButtonStrings, styles: commonButtonStyles, newMessageLabel: callWithChatStrings.chatButtonNewMessageNotificationLabel, unreadChatMessagesCount: unreadChatMessagesCount, 
            // As chat is disabled when on hold, we don't want to show the unread badge when on hold
            hideUnreadChatMessagesBadge: isOnHold, disableTooltip: mobileView })
    }), [callWithChatStrings.chatButtonNewMessageNotificationLabel, chatButtonStrings, commonButtonStyles, isChatOpen, chatButtonDisabled, mobileView, toggleChat, unreadChatMessagesCount, isOnHold]);
    const callControlOptionsFromProps = React.useMemo(() => (Object.assign({}, (typeof props.callControls === 'object' ? props.callControls : {}))), [props.callControls]);
    const injectedCustomButtonsFromProps = React.useMemo(() => {
        var _a;
        /* @conditional-compile-remove(control-bar-button-injection) */
        return [...((_a = callControlOptionsFromProps.onFetchCustomButtonProps) !== null && _a !== void 0 ? _a : [])];
    }, [callControlOptionsFromProps]);
    const callCompositeOptions = React.useMemo(() => ({
        callControls: props.callControls === false ? false : Object.assign(Object.assign({}, callControlOptionsFromProps), { onFetchCustomButtonProps: [...(showChatButton ? [customChatButton] : []), /* @conditional-compile-remove(control-bar-button-injection) */
                ...injectedCustomButtonsFromProps], legacyControlBarExperience: false }),
        remoteVideoTileMenuOptions: props.remoteVideoTileMenuOptions,
        galleryOptions: props.galleryOptions,
        /* @conditional-compile-remove(click-to-call) */
        localVideoTile: props.localVideoTile,
        /* @conditional-compile-remove(custom-branding) */
        branding: {
            logo: props.logo,
            backgroundImage: props.backgroundImage
        }
    }), [props.callControls, callControlOptionsFromProps, showChatButton, customChatButton, injectedCustomButtonsFromProps, props.galleryOptions, /* @conditional-compile-remove(click-to-call) */
        props.localVideoTile, props.remoteVideoTileMenuOptions, /* @conditional-compile-remove(custom-branding) */
        props.logo, /* @conditional-compile-remove(custom-branding) */
        props.backgroundImage]);
    const onRenderChatContent = React.useCallback(() => React.createElement(ChatComposite, { adapter: chatAdapter, fluentTheme: theme, options: {
            topic: false
        }, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData }), [chatAdapter, props.onFetchAvatarPersonaData, theme]);
    const sidePaneHeaderRenderer = React.useCallback(() => { var _a; return React.createElement(SidePaneHeader, { headingText: callWithChatStrings.chatPaneTitle, onClose: closeChat, dismissSidePaneButtonAriaLabel: (_a = callWithChatStrings.dismissSidePaneButtonLabel) !== null && _a !== void 0 ? _a : '', mobileView: mobileView }); }, [callWithChatStrings.chatPaneTitle, callWithChatStrings.dismissSidePaneButtonLabel, closeChat, mobileView]);
    const sidePaneContentRenderer = React.useMemo(() => hasJoinedCall ? onRenderChatContent : undefined, [hasJoinedCall, onRenderChatContent]);
    const sidePaneRenderer = React.useMemo(() => ({
        contentRenderer: sidePaneContentRenderer,
        headerRenderer: sidePaneHeaderRenderer,
        id: 'chat'
    }), [sidePaneContentRenderer, sidePaneHeaderRenderer]);
    const overrideSidePaneProps = React.useMemo(() => ({
        renderer: sidePaneRenderer,
        isActive: isChatOpen,
        persistRenderingWhenClosed: true
    }), [isChatOpen, sidePaneRenderer]);
    const onSidePaneIdChange = React.useCallback((sidePaneId) => {
        // If the pane is switched to something other than chat, removing rendering chat.
        if (sidePaneId && sidePaneId !== 'chat') {
            closeChat();
        }
    }, [closeChat]);
    // When the call ends ensure the side pane is set to closed to prevent the side pane being open if the call is re-joined.
    React.useEffect(() => {
        callAdapter.on('callEnded', closeChat);
        return () => {
            callAdapter.off('callEnded', closeChat);
        };
    }, [callAdapter, closeChat]);
    return React.createElement("div", { ref: containerRef, className: react.mergeStyles(containerDivStyles) },
        React.createElement(react.Stack, { verticalFill: true, grow: true, styles: compositeOuterContainerStyles, id: compositeParentDivId },
            React.createElement(react.Stack, { horizontal: true, grow: true },
                React.createElement(react.Stack.Item, { grow: true, styles: callCompositeContainerStyles(mobileView) },
                    React.createElement(CallCompositeInner, Object.assign({}, props, { formFactor: formFactor, options: callCompositeOptions, adapter: callAdapter, fluentTheme: fluentTheme, callInvitationUrl: props.joinInvitationURL, overrideSidePane: overrideSidePaneProps, onSidePaneIdChange: onSidePaneIdChange, mobileChatTabHeader: chatTabHeaderProps, onCloseChatPane: closeChat }))))));
};
/**
 * CallWithChatComposite brings together key components to provide a full call with chat experience out of the box.
 *
 * @public
 */
const CallWithChatComposite = (props) => {
    var _a, _b;
    const { adapter, fluentTheme, rtl, formFactor, joinInvitationURL, options } = props;
    return React.createElement(BaseProvider, { fluentTheme: fluentTheme, rtl: rtl, locale: props.locale, icons: props.icons },
        React.createElement(CallWithChatScreen, Object.assign({}, props, { callWithChatAdapter: adapter, formFactor: formFactor, callControls: options === null || options === void 0 ? void 0 : options.callControls, joinInvitationURL: joinInvitationURL, fluentTheme: fluentTheme, remoteVideoTileMenuOptions: options === null || options === void 0 ? void 0 : options.remoteVideoTileMenuOptions, localVideoTile: options === null || options === void 0 ? void 0 : options.localVideoTile, galleryOptions: options === null || options === void 0 ? void 0 : options.galleryOptions, 
            /* @conditional-compile-remove(custom-branding) */ logo: (_a = options === null || options === void 0 ? void 0 : options.branding) === null || _a === void 0 ? void 0 : _a.logo, 
            /* @conditional-compile-remove(custom-branding) */ backgroundImage: (_b = options === null || options === void 0 ? void 0 : options.branding) === null || _b === void 0 ? void 0 : _b.backgroundImage })));
};
const hasJoinedCallFn = (page, callStatus) => {
    return page === 'call' && (callStatus === 'Connected' || callStatus === 'Disconnecting');
};
const checkShowChatButton = (callControls) => {
    if (callControls === undefined || callControls === true) {
        return true;
    }
    if (callControls === false) {
        return false;
    }
    return callControls.chatButton !== false;
};
const checkChatButtonIsDisabled = (callControls) => {
    return typeof callControls === 'object' && isDisabled$3(callControls === null || callControls === void 0 ? void 0 : callControls.chatButton);
};
const isOnHoldTrampoline = (page) => {
    return false;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @private
 */
function callWithChatAdapterStateFromBackingStates(callAdapter, chatAdapter) {
    const callAdapterState = callAdapter.getState();
    const chatAdapterState = chatAdapter.getState();
    return {
        call: callAdapterState.call,
        chat: chatAdapterState.thread,
        userId: callAdapterState.userId,
        page: callAdapterState.page,
        displayName: callAdapterState.displayName,
        devices: callAdapterState.devices,
        isLocalPreviewMicrophoneEnabled: callAdapterState.isLocalPreviewMicrophoneEnabled,
        isTeamsCall: callAdapterState.isTeamsCall,
        latestCallErrors: callAdapterState.latestErrors,
        latestChatErrors: chatAdapterState.latestErrors,
        /* @conditional-compile-remove(video-background-effects) */
        videoBackgroundImages: callAdapterState.videoBackgroundImages,
        /* @conditional-compile-remove(video-background-effects) */
        onResolveVideoEffectDependency: callAdapterState.onResolveVideoEffectDependency,
        /* @conditional-compile-remove(video-background-effects) */
        selectedVideoBackgroundEffect: callAdapterState.selectedVideoBackgroundEffect
    };
}
/**
 * @private
 */
function mergeChatAdapterStateIntoCallWithChatAdapterState(existingCallWithChatAdapterState, chatAdapterState) {
    return Object.assign(Object.assign({}, existingCallWithChatAdapterState), { chat: chatAdapterState.thread, latestChatErrors: chatAdapterState.latestErrors });
}
/**
 * @private
 */
function mergeCallAdapterStateIntoCallWithChatAdapterState(existingCallWithChatAdapterState, callAdapterState) {
    return Object.assign(Object.assign({}, existingCallWithChatAdapterState), { userId: callAdapterState.userId, page: callAdapterState.page, displayName: callAdapterState.displayName, devices: callAdapterState.devices, call: callAdapterState.call, isLocalPreviewMicrophoneEnabled: callAdapterState.isLocalPreviewMicrophoneEnabled, isTeamsCall: callAdapterState.isTeamsCall, latestCallErrors: callAdapterState.latestErrors, 
        /* @conditional-compile-remove(video-background-effects) */
        videoBackgroundImages: callAdapterState.videoBackgroundImages, 
        /* @conditional-compile-remove(video-background-effects) */
        onResolveVideoEffectDependency: callAdapterState.onResolveVideoEffectDependency, 
        /* @conditional-compile-remove(video-background-effects) */
        selectedVideoBackgroundEffect: callAdapterState.selectedVideoBackgroundEffect });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Get chat thread from a teams url.
 * As per documented on the Chat SDK: https://docs.microsoft.com/en-us/azure/communication-services/quickstarts/chat/meeting-interop?pivots=platform-web#get-a-teams-meeting-chat-thread-for-a-communication-services-user
 *
 * @private
 */
const getChatThreadFromTeamsLink = (teamsMeetingLink) => {
    // Get the threadId from the url - this also contains the call locator ID that will be removed in the threadId.split
    let threadId = teamsMeetingLink.replace('https://teams.microsoft.com/l/meetup-join/', '');
    // Unescape characters that applications like Outlook encode when creating joinable links
    threadId = decodeURIComponent(threadId);
    // Extract just the chat guid from the link, stripping away the call locator ID
    threadId = threadId.split(/^(.*?@thread\.v2)/gm)[1];
    if (!threadId || threadId.length === 0) {
        if (UNSUPPORTED_CHAT_THREAD_TYPE.some(t => teamsMeetingLink.includes(t))) {
            throw new Error(`Teams Channel Meetings are not currently supported, read more ${TEAMS_LIMITATION_LEARN_MORE}`);
        }
        throw new Error('Could not get chat thread from teams link');
    }
    return threadId;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$2 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/** Context of Call with Chat, which is a centralized context for all state updates */
class CallWithChatContext {
    constructor(clientState, maxListeners = 50) {
        this.emitter = new EventEmitter.EventEmitter();
        this.state = clientState;
        this.emitter.setMaxListeners(maxListeners);
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    updateClientState(clientState) {
        this.setState(clientState);
    }
    updateClientStateWithChatState(chatAdapterState) {
        this.updateClientState(mergeChatAdapterStateIntoCallWithChatAdapterState(this.state, chatAdapterState));
    }
    updateClientStateWithCallState(callAdapterState) {
        this.updateClientState(mergeCallAdapterStateIntoCallWithChatAdapterState(this.state, callAdapterState));
    }
}
/**
 * CallWithChat adapter backed by Azure Communication Services.
 * Created for easy use with the {@link CallWithChatComposite}.
 */
class AzureCommunicationCallWithChatAdapter {
    constructor(callAdapter, chatAdapter) {
        this.bindPublicMethods();
        this.callAdapter = callAdapter;
        this.chatAdapter = chatAdapter;
        this.context = new CallWithChatContext(callWithChatAdapterStateFromBackingStates(callAdapter, chatAdapter));
        const onChatStateChange = (newChatAdapterState) => {
            this.context.updateClientStateWithChatState(newChatAdapterState);
        };
        this.chatAdapter.onStateChange(onChatStateChange);
        this.onChatStateChange = onChatStateChange;
        const onCallStateChange = (newCallAdapterState) => {
            this.context.updateClientStateWithCallState(newCallAdapterState);
        };
        this.callAdapter.onStateChange(onCallStateChange);
        this.onCallStateChange = onCallStateChange;
    }
    bindPublicMethods() {
        this.joinCall.bind(this);
        this.leaveCall.bind(this);
        this.startCall.bind(this);
        this.onStateChange.bind(this);
        this.offStateChange.bind(this);
        this.getState.bind(this);
        this.dispose.bind(this);
        this.setCamera.bind(this);
        this.setMicrophone.bind(this);
        this.setSpeaker.bind(this);
        this.askDevicePermission.bind(this);
        this.queryCameras.bind(this);
        this.queryMicrophones.bind(this);
        this.querySpeakers.bind(this);
        this.startCamera.bind(this);
        this.stopCamera.bind(this);
        this.mute.bind(this);
        this.unmute.bind(this);
        this.startScreenShare.bind(this);
        this.stopScreenShare.bind(this);
        /* @conditional-compile-remove(raise-hand) */
        this.raiseHand.bind(this);
        /* @conditional-compile-remove(raise-hand) */
        this.lowerHand.bind(this);
        this.removeParticipant.bind(this);
        this.createStreamView.bind(this);
        this.disposeStreamView.bind(this);
        this.disposeScreenShareStreamView.bind(this);
        this.fetchInitialData.bind(this);
        this.sendMessage.bind(this);
        this.sendReadReceipt.bind(this);
        this.sendTypingIndicator.bind(this);
        this.loadPreviousChatMessages.bind(this);
        this.updateMessage.bind(this);
        this.deleteMessage.bind(this);
        this.on.bind(this);
        this.off.bind(this);
        /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
        this.downloadResourceToCache = this.downloadResourceToCache.bind(this);
        /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
        this.removeResourceFromCache = this.removeResourceFromCache.bind(this);
        this.sendDtmfTone.bind(this);
        /* @conditional-compile-remove(close-captions) */ {
            this.startCaptions.bind(this);
            this.stopCaptions.bind(this);
            this.setSpokenLanguage.bind(this);
            this.setCaptionLanguage.bind(this);
        }
        /* @conditional-compile-remove(video-background-effects) */
        this.startVideoBackgroundEffect.bind(this);
        /* @conditional-compile-remove(video-background-effects) */
        this.stopVideoBackgroundEffects.bind(this);
        /* @conditional-compile-remove(video-background-effects) */
        this.updateBackgroundPickerImages.bind(this);
    }
    /** Join existing Call. */
    joinCall(options) {
        if (typeof options === 'boolean') {
            return this.callAdapter.joinCall(options);
        }
        else {
            return this.callAdapter.joinCall(options);
        }
    }
    /** Leave current Call. */
    leaveCall(forEveryone) {
        return __awaiter$2(this, void 0, void 0, function* () {
            // Only remove self from the GroupCall. Contoso must manage access to Chat.
            yield this.callAdapter.leaveCall(forEveryone);
        });
    }
    /** Start a new Call. */
    startCall(participants, options) {
        if (participants.length === 0) {
            throw new Error('At least one participant is required to start a call');
        }
        if (typeof participants[0] === 'string') {
            return this.callAdapter.startCall(participants, options);
        }
        else {
            return this.callAdapter.startCall(participants, options);
        }
    }
    /**
     * Subscribe to state change events.
     * @param handler - handler to be called when the state changes. This is passed the new state.
     */
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    /**
     * Unsubscribe to state change events.
     * @param handler - handler to be no longer called when state changes.
     */
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    /** Get current Call and Chat state. */
    getState() {
        return this.context.getState();
    }
    /** Dispose of the current CallWithChatAdapter. */
    dispose() {
        this.chatAdapter.offStateChange(this.onChatStateChange);
        this.callAdapter.offStateChange(this.onCallStateChange);
        this.chatAdapter.dispose();
        this.callAdapter.dispose();
    }
    /** Remove a participant from the Call only. */
    removeParticipant(userId) {
        return __awaiter$2(this, void 0, void 0, function* () {
            let participant = userId;
            yield this.callAdapter.removeParticipant(participant);
        });
    }
    setCamera(device, options) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.setCamera(device, options);
        });
    }
    /** Set the microphone to be used in the Call. */
    setMicrophone(device) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.setMicrophone(device);
        });
    }
    /** Set the speaker to be used in the Call. */
    setSpeaker(device) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.setSpeaker(device);
        });
    }
    askDevicePermission(constraints) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.askDevicePermission(constraints);
        });
    }
    /** Query for available cameras. */
    queryCameras() {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield this.callAdapter.queryCameras();
        });
    }
    /** Query for available microphones. */
    queryMicrophones() {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield this.callAdapter.queryMicrophones();
        });
    }
    /** Query for available speakers. */
    querySpeakers() {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield this.callAdapter.querySpeakers();
        });
    }
    /** Start the camera for the user in the Call. */
    startCamera(options) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.startCamera(options);
        });
    }
    /** Stop the camera for the user in the Call. */
    stopCamera() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.stopCamera();
        });
    }
    /** Mute the user in the Call. */
    mute() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.mute();
        });
    }
    /** Unmute the user in the Call. */
    unmute() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.unmute();
        });
    }
    /** Trigger the user to start screen share. */
    startScreenShare() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.startScreenShare();
        });
    }
    /** Stop the current active screen share. */
    stopScreenShare() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.stopScreenShare();
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    /** Raise hand for local user. */
    raiseHand() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.raiseHand();
        });
    }
    /* @conditional-compile-remove(raise-hand) */
    /** Lower hand for local user. */
    lowerHand() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.lowerHand();
        });
    }
    /** Create a stream view for a remote participants video feed. */
    createStreamView(remoteUserId, options) {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield this.callAdapter.createStreamView(remoteUserId, options);
        });
    }
    /** Dispose of a created stream view of a remote participants video feed. */
    disposeStreamView(remoteUserId, options) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.disposeStreamView(remoteUserId, options);
        });
    }
    /** Dispose of a remote screen share */
    disposeScreenShareStreamView(remoteUserId) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.disposeScreenShareStreamView(remoteUserId);
        });
    }
    /** Dispose of a remote video stream */
    disposeRemoteVideoStreamView(remoteUserId) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.disposeRemoteVideoStreamView(remoteUserId);
        });
    }
    /** Dispose of the local video stream */
    disposeLocalVideoStreamView() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.disposeLocalVideoStreamView();
        });
    }
    /** Fetch initial Call and Chat data such as chat messages. */
    fetchInitialData() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.chatAdapter.fetchInitialData();
        });
    }
    /** Send a chat message. */
    sendMessage(content) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendMessage(content);
        });
    }
    /** Send a chat read receipt. */
    sendReadReceipt(chatMessageId) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendReadReceipt(chatMessageId);
        });
    }
    /** Send an isTyping indicator. */
    sendTypingIndicator() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendTypingIndicator();
        });
    }
    /** Load previous Chat messages. */
    loadPreviousChatMessages(messagesToLoad) {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield this.chatAdapter.loadPreviousChatMessages(messagesToLoad);
        });
    }
    /** Update an existing message. */
    updateMessage(messageId, content, metadata, options) {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield this.chatAdapter.updateMessage(messageId, content, metadata);
        });
    }
    /** Delete an existing message. */
    deleteMessage(messageId) {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield this.chatAdapter.deleteMessage(messageId);
        });
    }
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    downloadResourceToCache(resourceDetails) {
        return __awaiter$2(this, void 0, void 0, function* () {
            this.chatAdapter.downloadResourceToCache(resourceDetails);
        });
    }
    /* @conditional-compile-remove(teams-inline-images-and-file-sharing) */
    removeResourceFromCache(resourceDetails) {
        this.chatAdapter.removeResourceFromCache(resourceDetails);
    }
    sendDtmfTone(dtmfTone) {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield this.callAdapter.sendDtmfTone(dtmfTone);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    startCaptions(options) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.startCaptions(options);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    stopCaptions() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.stopCaptions();
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setCaptionLanguage(language) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.setCaptionLanguage(language);
        });
    }
    /* @conditional-compile-remove(close-captions) */
    setSpokenLanguage(language) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.setSpokenLanguage(language);
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    startVideoBackgroundEffect(videoBackgroundEffect) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.callAdapter.startVideoBackgroundEffect(videoBackgroundEffect);
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    stopVideoBackgroundEffects() {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield this.callAdapter.stopVideoBackgroundEffects();
        });
    }
    /* @conditional-compile-remove(video-background-effects) */
    updateBackgroundPickerImages(backgroundImages) {
        return this.callAdapter.updateBackgroundPickerImages(backgroundImages);
    }
    /* @conditional-compile-remove(video-background-effects) */
    updateSelectedVideoBackgroundEffect(selectedVideoBackground) {
        return this.callAdapter.updateSelectedVideoBackgroundEffect(selectedVideoBackground);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        switch (event) {
            case 'callParticipantsJoined':
                this.callAdapter.on('participantsJoined', listener);
                break;
            case 'callParticipantsLeft':
                this.callAdapter.on('participantsLeft', listener);
                break;
            case 'callEnded':
                this.callAdapter.on('callEnded', listener);
                break;
            case 'isMutedChanged':
                this.callAdapter.on('isMutedChanged', listener);
                break;
            case 'callIdChanged':
                this.callAdapter.on('callIdChanged', listener);
                break;
            case 'isLocalScreenSharingActiveChanged':
                this.callAdapter.on('isLocalScreenSharingActiveChanged', listener);
                break;
            case 'displayNameChanged':
                this.callAdapter.on('displayNameChanged', listener);
                break;
            case 'isSpeakingChanged':
                this.callAdapter.on('isSpeakingChanged', listener);
                break;
            case 'selectedMicrophoneChanged':
                this.callAdapter.on('selectedMicrophoneChanged', listener);
                break;
            case 'selectedSpeakerChanged':
                this.callAdapter.on('selectedSpeakerChanged', listener);
                break;
            /* @conditional-compile-remove(close-captions) */
            case 'captionsReceived':
                this.callAdapter.on('captionsReceived', listener);
                break;
            /* @conditional-compile-remove(close-captions) */
            case 'isCaptionsActiveChanged':
                this.callAdapter.on('isCaptionsActiveChanged', listener);
                break;
            /* @conditional-compile-remove(close-captions) */
            case 'isCaptionLanguageChanged':
                this.callAdapter.on('isCaptionLanguageChanged', listener);
                break;
            /* @conditional-compile-remove(close-captions) */
            case 'isSpokenLanguageChanged':
                this.callAdapter.on('isSpokenLanguageChanged', listener);
                break;
            case 'messageReceived':
                this.chatAdapter.on('messageReceived', listener);
                break;
            case 'messageEdited':
                this.chatAdapter.on('messageEdited', listener);
                break;
            case 'messageDeleted':
                this.chatAdapter.on('messageDeleted', listener);
                break;
            case 'messageSent':
                this.chatAdapter.on('messageSent', listener);
                break;
            case 'messageRead':
                this.chatAdapter.on('messageRead', listener);
                break;
            case 'chatParticipantsAdded':
                this.chatAdapter.on('participantsAdded', listener);
                break;
            case 'chatParticipantsRemoved':
                this.chatAdapter.on('participantsRemoved', listener);
                break;
            case 'callError':
                this.callAdapter.on('error', listener);
                break;
            case 'chatError':
                this.chatAdapter.on('error', listener);
                break;
            default:
                throw `Unknown AzureCommunicationCallWithChatAdapter Event: ${event}`;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        switch (event) {
            case 'callParticipantsJoined':
                this.callAdapter.off('participantsJoined', listener);
                break;
            case 'callParticipantsLeft':
                this.callAdapter.off('participantsLeft', listener);
                break;
            case 'callEnded':
                this.callAdapter.off('callEnded', listener);
                break;
            case 'isMutedChanged':
                this.callAdapter.off('isMutedChanged', listener);
                break;
            case 'callIdChanged':
                this.callAdapter.off('callIdChanged', listener);
                break;
            case 'isLocalScreenSharingActiveChanged':
                this.callAdapter.off('isLocalScreenSharingActiveChanged', listener);
                break;
            case 'displayNameChanged':
                this.callAdapter.off('displayNameChanged', listener);
                break;
            case 'isSpeakingChanged':
                this.callAdapter.off('isSpeakingChanged', listener);
                break;
            case 'selectedMicrophoneChanged':
                this.callAdapter.off('selectedMicrophoneChanged', listener);
                break;
            case 'selectedSpeakerChanged':
                this.callAdapter.off('selectedSpeakerChanged', listener);
                break;
            /* @conditional-compile-remove(close-captions) */
            case 'captionsReceived':
                this.callAdapter.off('captionsReceived', listener);
                break;
            /* @conditional-compile-remove(close-captions) */
            case 'isCaptionsActiveChanged':
                this.callAdapter.off('isCaptionsActiveChanged', listener);
                break;
            /* @conditional-compile-remove(close-captions) */
            case 'isCaptionLanguageChanged':
                this.callAdapter.off('isCaptionLanguageChanged', listener);
                break;
            /* @conditional-compile-remove(close-captions) */
            case 'isSpokenLanguageChanged':
                this.callAdapter.off('isSpokenLanguageChanged', listener);
                break;
            case 'messageReceived':
                this.chatAdapter.off('messageReceived', listener);
                break;
            case 'messageEdited':
                this.chatAdapter.off('messageEdited', listener);
                break;
            case 'messageDeleted':
                this.chatAdapter.off('messageDeleted', listener);
                break;
            case 'messageSent':
                this.chatAdapter.off('messageSent', listener);
                break;
            case 'messageRead':
                this.chatAdapter.off('messageRead', listener);
                break;
            case 'chatParticipantsAdded':
                this.chatAdapter.off('participantsAdded', listener);
                break;
            case 'chatParticipantsRemoved':
                this.chatAdapter.off('participantsRemoved', listener);
                break;
            case 'callError':
                this.callAdapter.off('error', listener);
                break;
            case 'chatError':
                this.chatAdapter.off('error', listener);
                break;
            default:
                throw `Unknown AzureCommunicationCallWithChatAdapter Event: ${event}`;
        }
    }
}
/**
 * Create a CallWithChatAdapter backed by Azure Communication services
 * to plug into the {@link CallWithChatComposite}.
 *
 * @public
 */
const createAzureCommunicationCallWithChatAdapter = ({ userId, displayName, credential, endpoint, locator, 
/* @conditional-compile-remove(video-background-effects) */ callAdapterOptions }) => __awaiter$2(void 0, void 0, void 0, function* () {
    const callAdapterLocator = isTeamsMeetingLinkLocator(locator) ? locator : locator.callLocator;
    const createCallAdapterPromise = _createAzureCommunicationCallAdapterInner({
        userId,
        displayName,
        credential,
        locator: callAdapterLocator,
        /* @conditional-compile-remove(video-background-effects) */ options: callAdapterOptions,
        telemetryImplementationHint: 'CallWithChat'
    });
    const threadId = isTeamsMeetingLinkLocator(locator) ? getChatThreadFromTeamsLink(locator.meetingLink) : locator.chatThreadId;
    const createChatAdapterPromise = _createAzureCommunicationChatAdapterInner(endpoint, userId, displayName, credential, threadId, 'CallWithChat');
    const [callAdapter, chatAdapter] = yield Promise.all([createCallAdapterPromise, createChatAdapterPromise]);
    return new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);
});
/**
 * A custom React hook to simplify the creation of {@link CallWithChatAdapter}.
 *
 * Similar to {@link createAzureCommunicationCallWithChatAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
const useAzureCommunicationCallWithChatAdapter = (args, afterCreate, beforeDispose) => {
    const { credential, displayName, endpoint, locator, userId, 
    /* @conditional-compile-remove(video-background-effects) */ callAdapterOptions } = args;
    // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = React.useState(undefined);
    // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = React.useRef(undefined);
    const creatingAdapterRef = React.useRef(false);
    const afterCreateRef = React.useRef(undefined);
    const beforeDisposeRef = React.useRef(undefined);
    // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    React.useEffect(() => {
        if (!credential || !displayName || !endpoint || !locator || !userId) {
            return;
        }
        (() => __awaiter$2(void 0, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            if (creatingAdapterRef.current) {
                console.warn('Adapter is already being created, please see storybook for more information: https://azure.github.io/communication-ui-library/?path=/story/troubleshooting--page');
                return;
            }
            creatingAdapterRef.current = true;
            let newAdapter = yield createAzureCommunicationCallWithChatAdapter({
                credential,
                displayName,
                endpoint,
                locator,
                userId,
                /* @conditional-compile-remove(video-background-effects) */ callAdapterOptions
            });
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            setAdapter(newAdapter);
        }))();
    }, 
    // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, credential, displayName, endpoint, locator, userId, /* @conditional-compile-remove(video-background-effects) */ callAdapterOptions]);
    // Dispose any existing adapter when the component unmounts.
    React.useEffect(() => {
        return () => {
            (() => __awaiter$2(void 0, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
};
/**
 * Create a {@link CallWithChatAdapter} using the provided {@link StatefulChatClient} and {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient} and {@link StatefulCallClient}.
 * Please note that chatThreadClient has to be created by StatefulChatClient via chatClient.getChatThreadClient(chatThreadId) API.
 * Consider using {@link createAzureCommunicationCallWithChatAdapter} for a simpler API.
 *
 * @public
 */
const createAzureCommunicationCallWithChatAdapterFromClients = ({ callClient, callAgent, callLocator, chatClient, chatThreadClient, 
/* @conditional-compile-remove(video-background-effects) */
callAdapterOptions }) => __awaiter$2(void 0, void 0, void 0, function* () {
    const createCallAdapterPromise = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, callLocator, /* @conditional-compile-remove(video-background-effects) */ callAdapterOptions);
    const createChatAdapterPromise = createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient);
    const [callAdapter, chatAdapter] = yield Promise.all([createCallAdapterPromise, createChatAdapterPromise]);
    return new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);
});
const isTeamsMeetingLinkLocator = (locator) => {
    return 'meetingLink' in locator;
};

var call$j={cameraLabel:"Camera",noCamerasLabel:"No cameras found",cameraPermissionDenied:"Your browser is blocking access to your camera",cameraTurnedOff:"Your camera is turned off",chatButtonLabel:"Chat",close:"Close",complianceBannerNowOnlyRecording:"You are now only recording this meeting.",complianceBannerNowOnlyTranscription:"You are now only transcribing this meeting.",complianceBannerRecordingAndTranscriptionSaved:"Recording and transcription are being saved.",complianceBannerRecordingAndTranscriptionStarted:"Recording and transcription have started.",complianceBannerRecordingAndTranscriptionStopped:"Recording and transcription have stopped.",complianceBannerRecordingSaving:"Recording is being saved.",complianceBannerRecordingStarted:"Recording has started.",complianceBannerRecordingStopped:"Recording has stopped.",complianceBannerTranscriptionStarted:"Transcription has started.",complianceBannerTranscriptionConsent:"By joining, you are giving consent for this meeting to be transcribed.",complianceBannerTranscriptionSaving:"Transcription is being saved.",complianceBannerTranscriptionStopped:"Transcription has stopped.",configurationPageTitle:"Start a call",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",defaultPlaceHolder:"Select an option",dismissSidePaneButtonLabel:"Close",videoEffectsPaneTitle:"Effects",videoEffectsPaneBackgroundSelectionTitle:"Background",configurationPageVideoEffectsButtonLabel:"Effects",unableToStartVideoEffect:"Unable to apply video effect.",blurBackgroundEffectButtonLabel:"Blur",blurBackgroundTooltip:"Blur Background",removeBackgroundEffectButtonLabel:"None",removeBackgroundTooltip:"Remove Background",cameraOffBackgroundEffectWarningText:"Your camera is off. Turn on camera to see video effect.",failedToJoinCallDueToNoNetworkMoreDetails:"Call was disconnected due to a network issue. Check your connection and join again.",failedToJoinCallDueToNoNetworkTitle:"Call disconnected",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"You were not granted entry in the call. If this was a mistake, re-join the call.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Dismissed from lobby",learnMore:"Learn more",leavingCallTitle:"Leaving...",leftCallMoreDetails:"If this was a mistake, re-join the call.",leftCallTitle:"You left the call",lobbyScreenConnectingToCallTitle:"Joining call",lobbyScreenWaitingToBeAdmittedTitle:"Waiting to be admitted",microphonePermissionDenied:"Your browser is blocking access to your microphone",microphoneToggleInLobbyNotAllowed:"Cannot mute or unmute while in lobby.",mutedMessage:"You're muted",networkReconnectMoreDetails:"Looks like something went wrong. We're trying to get back into the call.",networkReconnectTitle:"Hold on",notInvitedToRoomDetails:"You are not able to join this room because you do not have an invite.",notInvitedToRoomTitle:"Not invited to room",peopleButtonLabel:"People",selectedPeopleButtonLabel:"People Button Selected",peoplePaneTitle:"People",peoplePaneMoreButtonAriaLabel:"More",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call {numberOfPeople}",privacyPolicy:"Privacy policy",rejoinCallButtonLabel:"Re-join call",removedFromCallMoreDetails:"Another participant removed you from the call.",removedFromCallTitle:"You were removed",removeMenuLabel:"Remove",startSpotlightParticipantListMenuLabel:"Spotlight for everyone",addSpotlightParticipantListMenuLabel:"Add spotlight",stopSpotlightParticipantListMenuLabel:"Stop spotlighting",stopSpotlightOnSelfParticipantListMenuLabel:"Exit spotlight",spotlightLimitReachedParticipantListMenuTitle:"Spotlight limit reached",stopAllSpotlightMenuLabel:"Stop all spotlights",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",roomNotFoundDetails:"The room ID provided could not be found.",roomNotFoundTitle:"Room not found",roomNotValidDetails:"This room is not valid at this current time.",roomNotValidTitle:"Room not valid",inviteToRoomRemovedDetails:"Your invite to join this room was removed.",inviteToRoomRemovedTitle:"Invite to room removed",soundLabel:"Sound",noMicrophonesLabel:"No microphones found",noSpeakersLabel:"No speakers found",startCallButtonLabel:"Start call",openDialpadButtonLabel:"Dial phone number",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",moreButtonCallingLabel:"More",resumeCallButtonLabel:"Resume",resumingCallButtonLabel:"Resuming...",resumeCallButtonAriaLabel:"Resume call",resumingCallButtonAriaLabel:"Resume call",holdScreenLabel:"You're on hold",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number",outboundCallingNoticeString:"Calling...",participantJoinedNoticeString:"{displayName} joined",twoParticipantJoinedNoticeString:"{displayName1} and {displayName2} have joined",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} and {displayName3} have joined",participantLeftNoticeString:"{displayName} left",twoParticipantLeftNoticeString:"{displayName1} and {displayName2} have left",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} and {displayName3} have left",unnamedParticipantString:"unnamed participant",manyUnnamedParticipantsJoined:"unnamed participant and {numOfParticipants} other participants joined",manyUnnamedParticipantsLeft:"unnamed participant and {numOfParticipants} other participants left",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} and {numOfParticipants} other participants joined",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} and {numOfParticipants} other participants left",liveCaptionsLabel:"Live captions",captionsSettingsLabel:"Caption settings",startCaptionsButtonOnLabel:"Turn on captions",startCaptionsButtonOffLabel:"Turn off captions",startCaptionsButtonTooltipOnContent:"Turn off captions",startCaptionsButtonTooltipOffContent:"Turn on captions",captionsSettingsModalTitle:"Captions Settings",captionsSettingsSpokenLanguageDropdownLabel:"Spoken language",captionsSettingsCaptionLanguageDropdownLabel:"Captions language",captionsSettingsSpokenLanguageDropdownInfoText:"Language that everyone on this call is speaking.",captionsSettingsCaptionLanguageDropdownInfoText:"Captions will appear in this langugage.",captionsSettingsConfirmButtonLabel:"Confirm",captionsSettingsCancelButtonLabel:"Cancel",captionsSettingsModalAriaLabel:"Captions Setting Modal",captionsSettingsCloseModalButtonAriaLabel:"Close Captions Setting",captionsBannerMoreButtonCallingLabel:"More",captionsBannerMoreButtonTooltip:"More options",dismissModalAriaLabel:"Local and remote picture and picture, press enter to return to call",callRejectedTitle:"The call could not be completed",callRejectedMoreDetails:"The person you are trying to reach is unavailable. Please try again later.",callTimeoutTitle:"The call could not be completed",callTimeoutDetails:"The person you are trying to reach is unavailable. Please try again later.",callTimeoutBotTitle:"The call could not be completed",callTimeoutBotDetails:"The service that you are trying to reach is unavailable. Please try again later.",dtmfDialerButtonLabel:"Dialpad",dtmfDialerButtonTooltipOn:"Show dialpad",dtmfDialerButtonTooltipOff:"Hide dialpad",dtmfDialerMoreButtonLabelOn:"Show dialpad",dtmfDialerMoreButtonLabelOff:"Hide dialpad",spokenLanguageStrings:{"ar-ae":"Arabic - U.A.E.","ar-sa":"Arabic - Saudi Arabia","da-dk":"Danish","de-de":"German - Germany","en-au":"English - Australia","en-ca":"English - Canada","en-gb":"English - United Kingdom","en-in":"English - India","en-nz":"English - New Zealand","en-us":"English - United States","es-es":"Spanish - Spain (Modern Sort)","es-mx":"Spanish - Mexico","fi-fi":"Finnish","fr-ca":"French - Canada","fr-fr":"French - France","hi-in":"Hindi","it-it":"Italian - Italy","ja-jp":"Japanese","ko-kr":"Korean","nb-no":"Norwegian (Bokml)","nl-be":"Dutch - Belgium","nl-nl":"Dutch - Netherlands","pl-pl":"Polish","pt-br":"Portuguese - Brazil","ru-ru":"Russian","sv-se":"Swedish","zh-cn":"Chinese - People's Republic of China","zh-hk":"Chinese - Hong Kong SAR","cs-cz":"Czech","pt-pt":"Portuguese - Portugal","tr-tr":"Turkish","vi-vn":"Vietnamese","th-th":"Thai","he-il":"Hebrew","cy-gb":"Welsh","uk-ua":"Ukrainian","el-gr":"Greek","hu-hu":"Hungarian","ro-ro":"Romanian","sk-sk":"Slovak","zh-tw":"Chinese - Taiwan"},captionLanguageStrings:{ar:"Arabic",da:"Danish",de:"German",en:"English",es:"Spanish",fi:"Finnish","fr-ca":"French - Canada",fr:"French - France",hi:"Hindi",it:"Italian",ja:"Japanese",ko:"Korean",nb:"Norwegian (Bokml)",nl:"Dutch",pl:"Polish",pt:"Portuguese - Brazil",ru:"Russian",sv:"Swedish","zh-Hans":"Chinese (Simplified)","zh-Hant":"Chinese (Traditional)",cs:"Czech","pt-pt":"Portuguese - Portugal",tr:"Turkish",vi:"Vietnamese",th:"Thai",he:"Hebrew",cy:"Welsh",uk:"Ukrainian",el:"Greek",hu:"Hungarian",ro:"Romanian",sk:"Slovak"},captionsBannerSpinnerText:"Starting captions...",transferPageTransferorText:"Transferring...",transferPageTransferTargetText:"Connecting...",transferPageUnknownTransferorDisplayName:"Unknown",transferPageUnknownTransferTargetDisplayName:"Unknown",transferPageNoticeString:"You are being transferred",participantCouldNotBeReachedTitle:"Target participant is currently not available",participantCouldNotBeReachedMoreDetails:"Please contact participant when they are available",permissionToReachTargetParticipantNotAllowedTitle:"Permission to reach target participant is not allowed",permissionToReachTargetParticipantNotAllowedMoreDetails:"Please check that the target participant is in the same tenant",unableToResolveTenantTitle:"Unable to resolve tenant id for the target participant",unableToResolveTenantMoreDetails:"Please check the participant id is entered correctly",participantIdIsMalformedTitle:"Participant id is not in the correct format",participantIdIsMalformedMoreDetails:"Please check that the participant id is in the correct format",moreButtonGalleryControlLabel:"View",moreButtonGalleryPositionToggleLabel:"Move gallery to top",moreButtonGallerySpeakerLayoutLabel:"Speaker",moreButtonGalleryFloatingLocalLayoutLabel:"Dynamic",moreButtonGalleryDefaultLayoutLabel:"Gallery view",moreButtonGalleryFocusedContentLayoutLabel:"Focus on content",moreButtonLargeGalleryDefaultLayoutLabel:"Large Gallery",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Your camera has been disabled. You can no longer share video.",grantedDueToMeetingOption:"Your camera has been enabled. Turn it on if you'd like to share video."},unmuteMic:{lostDueToMeetingOption:"Your mic has been disabled. You can no longer unmute.",grantedDueToMeetingOption:"Your mic has been enabled. Unmute if you'd like to speak."},shareScreen:{lostDueToRoleChangeToAttendee:"Your role has been changed. Some actions, like sharing content, won't be available to you.",grantedDueToRoleChangeToPresenter:"You're a presenter. You can share content and facilitate the meeting."}},surveyTitle:"Help us improve",starSurveyHelperText:"How was the quality of the call?",starSurveyOneStarText:"The quality was bad.",starSurveyTwoStarText:"The quality was poor.",starSurveyThreeStarText:"The quality was good.",starSurveyFourStarText:"The quality was great.",starSurveyFiveStarText:"The quality was excellent.",surveyConfirmButtonLabel:"Send Feedback",starRatingAriaLabel:"Select {0} of {1} stars",surveySkipButtonLabel:"Skip",tagsSurveyQuestion:"What could have been better?",tagsSurveyTextFieldDefaultText:"Other, please specify",tagsSurveyHelperText:"Check any issues you experienced",surveyTextboxDefaultText:"Other, please specify",endOfSurveyText:"Thank you for your feedback!",surveyIssues:{overallRating:{callCannotJoin:"I could not join call",callCannotInvite:"I could not invite others into the call",hadToRejoin:"I had to rejoin the call",callEndedUnexpectedly:"Call ended for me unexpectedly",otherIssues:"I was having other issues with the call"},audioRating:{noLocalAudio:"The other side could not hear any sound",noRemoteAudio:"I could not hear any sound",echo:"I heard echos on the call",audioNoise:"I heard noise on the call",lowVolume:"Volume was low",audioStoppedUnexpectedly:"Audio stopped unexpectedly",distortedSpeech:"Audio was distorted",audioInterruption:"Audio was interrupted",otherIssues:"I was having other audio issues in this call"},videoRating:{noVideoReceived:"I could not see any video",noVideoSent:"Others could not see me",lowQuality:"Video quality was low",freezes:"Video frozen",stoppedUnexpectedly:"Video stopped unexpectedly",darkVideoReceived:"I can only see dark screens when others turn on their camera",audioVideoOutOfSync:"Audio and Video was out of sync",otherIssues:"I was having other video issues in this call"},screenshareRating:{noContentLocal:"Other people could not see my screenshare",noContentRemote:"I could not see other people's screenshare",cannotPresent:"I could not present my screen",lowQuality:"Screen share quality was low",freezes:"Screen share frozen",stoppedUnexpectedly:"Screen share stopped unexpectedly",largeDelay:"Screen share has a large delay",otherIssues:"I was having other screen share issues in this call"}},SurveyIssuesHeadingStrings:{overallRating:"Overall",audioRating:"Audio",videoRating:"Video",screenshareRating:"Presenting"},spotlightPrompt:{startSpotlightHeading:"Spotlight for everyone?",startSpotlightText:"You'll highlight this video for everyone in the meeting.",startSpotlightOnSelfText:"You'll highlight your video for everyone in the meeting.",startSpotlightConfirmButtonLabel:"Spotlight for everyone",startSpotlightCancelButtonLabel:"Cancel",stopSpotlightHeading:"Stop spotlighting this video?",stopSpotlightOnSelfHeading:"Exit spotlight?",stopSpotlightText:"This video will no longer be highlighted for everyone in the meeting.",stopSpotlightOnSelfText:"Your video will no longer be highlighted for everyone in the meeting.",stopSpotlightConfirmButtonLabel:"Stop spotlighting",stopSpotlightOnSelfConfirmButtonLabel:"Exit spotlight",stopSpotlightCancelButtonLabel:"Cancel"},exitSpotlightButtonLabel:"Exit spotlight",exitSpotlightButtonTooltip:"Exit spotlight"};var chat$j={chatListHeader:"In this chat",uploadFile:"Upload File"};var callWithChat$j={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"New Message",chatButtonTooltipClosedWithMessageCount:"Show chat ({unreadMessagesCount} unread)",chatButtonTooltipClose:"Hide chat",chatButtonTooltipOpen:"Show chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",dismissSidePaneButtonLabel:"Close",moreDrawerAudioDeviceMenuTitle:"Audio Device",moreDrawerButtonLabel:"More options",moreDrawerButtonTooltip:"More options",moreDrawerMicrophoneMenuTitle:"Microphone",moreDrawerSpeakerMenuTitle:"Speaker",moreDrawerCaptionsMenuTitle:"Live captions",moreDrawerSpokenLanguageMenuTitle:"Spoken language",moreDrawerCaptionLanguageMenuTitle:"Caption language",moreDrawerGalleryOptionsMenuTitle:"Gallery options",peopleButtonLabel:"People",selectedPeopleButtonLabel:"People Button Selected",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call",peoplePaneTitle:"People",pictureInPictureTileAriaLabel:"Video Feeds. Click to return to call screen.",removeMenuLabel:"Remove",openDialpadButtonLabel:"Dial phone number",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number"};var en_GB = {call:call$j,chat:chat$j,callWithChat:callWithChat$j};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 *
 * @private
 */
const createCompositeStrings = (localizedStrings) => {
    const strings = Object.assign({}, en_US);
    _getKeys(localizedStrings).forEach(key => {
        // mark the value as unknown because the type changes based on the key.
        // this is unsafe at runtime as we could assign the wrong type based on the key here.
        // but typescript isn't smart enough to know that the key used across each access will result in the same type
        strings[key] = Object.assign(Object.assign({}, strings[key]), localizedStrings[key]);
    });
    return strings;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for English (British)
 *
 * @public
 */
const COMPOSITE_LOCALE_EN_GB = {
    component: COMPONENT_LOCALE_EN_GB,
    strings: createCompositeStrings(en_GB)
};

var call$i={cameraLabel:"",noCamerasLabel:"   ",cameraPermissionDenied:"     ",cameraTurnedOff:"   ",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"     .",complianceBannerNowOnlyTranscription:"       .",complianceBannerRecordingAndTranscriptionSaved:"    .",complianceBannerRecordingAndTranscriptionStarted:"  . ",complianceBannerRecordingAndTranscriptionStopped:"   .",complianceBannerRecordingSaving:"  .",complianceBannerRecordingStarted:"  .",complianceBannerRecordingStopped:"  .",complianceBannerTranscriptionStarted:"  .",complianceBannerTranscriptionConsent:"        .",complianceBannerTranscriptionSaving:"   .",complianceBannerTranscriptionStopped:"  .",configurationPageTitle:" ",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"   ",defaultPlaceHolder:" ",dismissSidePaneButtonLabel:"",videoEffectsPaneTitle:"",videoEffectsPaneBackgroundSelectionTitle:"",configurationPageVideoEffectsButtonLabel:"",unableToStartVideoEffect:"   .",blurBackgroundEffectButtonLabel:"",blurBackgroundTooltip:" ",removeBackgroundEffectButtonLabel:" ",removeBackgroundTooltip:" ",cameraOffBackgroundEffectWarningText:"  .      .",failedToJoinCallDueToNoNetworkMoreDetails:"      .      .",failedToJoinCallDueToNoNetworkTitle:"   ",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"     .        .",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"    ",learnMore:"  ",leavingCallTitle:"  ...",leftCallMoreDetails:"       .",leftCallTitle:"  ",lobbyScreenConnectingToCallTitle:"   ",lobbyScreenWaitingToBeAdmittedTitle:"  ",microphonePermissionDenied:"     ",microphoneToggleInLobbyNotAllowed:"           .",mutedMessage:"  ",networkReconnectMoreDetails:"     .   .",networkReconnectTitle:"",notInvitedToRoomDetails:"         .",notInvitedToRoomTitle:"   ",peopleButtonLabel:"",selectedPeopleButtonLabel:"   ",peoplePaneTitle:"",peoplePaneMoreButtonAriaLabel:"",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:"   {numberOfPeople}",privacyPolicy:" ",rejoinCallButtonLabel:"  ",removedFromCallMoreDetails:"     .",removedFromCallTitle:" ",removeMenuLabel:"",startSpotlightParticipantListMenuLabel:"   ",addSpotlightParticipantListMenuLabel:"  ",stopSpotlightParticipantListMenuLabel:"   ",stopSpotlightOnSelfParticipantListMenuLabel:"    ",spotlightLimitReachedParticipantListMenuTitle:"      ",stopAllSpotlightMenuLabel:"    ",returnToCallButtonAriaDescription:"  ",returnToCallButtonAriaLabel:"",roomNotFoundDetails:"       .",roomNotFoundTitle:"    ",roomNotValidDetails:"      .",roomNotValidTitle:"  ",inviteToRoomRemovedDetails:"      .",inviteToRoomRemovedTitle:"    ",soundLabel:"",noMicrophonesLabel:"    ",noSpeakersLabel:"    ",startCallButtonLabel:" ",openDialpadButtonLabel:"  ",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"  ",dialpadModalAriaLabel:" ",dialpadCloseModalButtonAriaLabel:"  ",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"  ...",resumeCallButtonAriaLabel:" ",resumingCallButtonAriaLabel:" ",holdScreenLabel:"  ",openDtmfDialpadLabel:"  ",dtmfDialpadPlaceholderText:" ",outboundCallingNoticeString:"  ...",participantJoinedNoticeString:" {displayName}",twoParticipantJoinedNoticeString:" {displayName1} {displayName2}",threeParticipantJoinedNoticeString:" {displayName1} {displayName2} {displayName3}",participantLeftNoticeString:" {displayName}",twoParticipantLeftNoticeString:" {displayName1} {displayName2}",threeParticipantLeftNoticeString:" {displayName1} {displayName2} {displayName3}",unnamedParticipantString:"  ",manyUnnamedParticipantsJoined:"    {numOfParticipants}   ",manyUnnamedParticipantsLeft:"    {numOfParticipants}   ",manyParticipantsJoined:" {displayName1} {displayName2} {displayName3} {numOfParticipants}  ",manyParticipantsLeft:" {displayName1} {displayName2} {displayName3}   {numOfParticipants}",liveCaptionsLabel:"  ",captionsSettingsLabel:"  ",startCaptionsButtonOnLabel:"  ",startCaptionsButtonOffLabel:"  ",startCaptionsButtonTooltipOnContent:"  ",startCaptionsButtonTooltipOffContent:"  ",captionsSettingsModalTitle:"  ",captionsSettingsSpokenLanguageDropdownLabel:" ",captionsSettingsCaptionLanguageDropdownLabel:"  ",captionsSettingsSpokenLanguageDropdownInfoText:"        .",captionsSettingsCaptionLanguageDropdownInfoText:"    .",captionsSettingsConfirmButtonLabel:"",captionsSettingsCancelButtonLabel:"",captionsSettingsModalAriaLabel:"     ",captionsSettingsCloseModalButtonAriaLabel:"   ",captionsBannerMoreButtonCallingLabel:"",captionsBannerMoreButtonTooltip:" ",dismissModalAriaLabel:"          ",callRejectedTitle:"   ",callRejectedMoreDetails:"      .     .",callTimeoutTitle:"   ",callTimeoutDetails:"      .     .",callTimeoutBotTitle:"   ",callTimeoutBotDetails:"      .     .",dtmfDialerButtonLabel:" ",dtmfDialerButtonTooltipOn:"  ",dtmfDialerButtonTooltipOff:"  ",dtmfDialerMoreButtonLabelOn:"  ",dtmfDialerMoreButtonLabelOff:"  ",spokenLanguageStrings:{"ar-ae":" -   ","ar-sa":" - ","da-dk":"","de-de":" - ","en-au":" - ","en-ca":" - ","en-gb":" -  ","en-in":" - ","en-nz":" - ","en-us":" -  ","es-es":" -  ( )","es-mx":" - ","fi-fi":"","fr-ca":" - ","fr-fr":" - ","hi-in":"","it-it":" - ","ja-jp":"","ko-kr":"","nb-no":" ()","nl-be":" - ","nl-nl":" - ","pl-pl":"","pt-br":" - ","ru-ru":"","sv-se":"","zh-cn":" -   ","zh-hk":" -     ","cs-cz":"","pt-pt":" - ","tr-tr":"","vi-vn":"","th-th":"","he-il":"","cy-gb":"","uk-ua":"","el-gr":"","hu-hu":"","ro-ro":"","sk-sk":"","zh-tw":" - "},captionLanguageStrings:{ar:"",da:"",de:"",en:"",es:"",fi:"","fr-ca":" - ",fr:" - ",hi:"",it:"",ja:"",ko:"",nb:" ()",nl:"",pl:"",pt:" - ",ru:"",sv:"","zh-Hans":" ()","zh-Hant":" ()",cs:"","pt-pt":" - ",tr:"",vi:"",th:"",he:"",cy:"",uk:"",el:"",hu:"",ro:"",sk:""},captionsBannerSpinnerText:"    ...",transferPageTransferorText:"  ...",transferPageTransferTargetText:" ...",transferPageUnknownTransferorDisplayName:" ",transferPageUnknownTransferTargetDisplayName:" ",transferPageNoticeString:" ",participantCouldNotBeReachedTitle:"    ",participantCouldNotBeReachedMoreDetails:"     ",permissionToReachTargetParticipantNotAllowedTitle:"      ",permissionToReachTargetParticipantNotAllowedMoreDetails:"         ",unableToResolveTenantTitle:"     ",unableToResolveTenantMoreDetails:"       ",participantIdIsMalformedTitle:"    ",participantIdIsMalformedMoreDetails:"       ",moreButtonGalleryControlLabel:"",moreButtonGalleryPositionToggleLabel:"   ",moreButtonGallerySpeakerLayoutLabel:" ",moreButtonGalleryFloatingLocalLayoutLabel:"",moreButtonGalleryDefaultLayoutLabel:"  ",moreButtonGalleryFocusedContentLayoutLabel:"  ",moreButtonLargeGalleryDefaultLayoutLabel:" ",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"    .     .",grantedDueToMeetingOption:"    .        ."},unmuteMic:{lostDueToMeetingOption:"     .      .",grantedDueToMeetingOption:"   .         ."},shareScreen:{lostDueToRoleChangeToAttendee:"  .        .",grantedDueToRoleChangeToPresenter:"  .     ."}},surveyTitle:"   ",starSurveyHelperText:"   ",starSurveyOneStarText:"  .",starSurveyTwoStarText:"  .",starSurveyThreeStarText:"  .",starSurveyFourStarText:"  .",starSurveyFiveStarText:"  .",surveyConfirmButtonLabel:" ",starRatingAriaLabel:" {0}  {1} ",surveySkipButtonLabel:"",tagsSurveyQuestion:"      ",tagsSurveyTextFieldDefaultText:"  ",tagsSurveyHelperText:"    ",surveyTextboxDefaultText:"  ",endOfSurveyText:"    !",surveyIssues:{overallRating:{callCannotJoin:"    ",callCannotInvite:"      ",hadToRejoin:"     ",callEndedUnexpectedly:"     ",otherIssues:"     "},audioRating:{noLocalAudio:"     ",noRemoteAudio:"   ",echo:"   ",audioNoise:"   ",lowVolume:"   ",audioStoppedUnexpectedly:"     ",distortedSpeech:"  ",audioInterruption:"  ",otherIssues:"       "},videoRating:{noVideoReceived:"     ",noVideoSent:"    ",lowQuality:"  ",freezes:" ",stoppedUnexpectedly:"    ",darkVideoReceived:"          ",audioVideoOutOfSync:"    ",otherIssues:"       "},screenshareRating:{noContentLocal:"      ",noContentRemote:"        ",cannotPresent:"   ",lowQuality:"    ",freezes:"   ",stoppedUnexpectedly:"     ",largeDelay:"    ",otherIssues:"         "}},SurveyIssuesHeadingStrings:{overallRating:" ",audioRating:"",videoRating:"",screenshareRating:""},spotlightPrompt:{startSpotlightHeading:"    ",startSpotlightText:"        .",startSpotlightOnSelfText:"        .",startSpotlightConfirmButtonLabel:"  ",startSpotlightCancelButtonLabel:"",stopSpotlightHeading:"        ",stopSpotlightOnSelfHeading:"    ",stopSpotlightText:"           .",stopSpotlightOnSelfText:"           .",stopSpotlightConfirmButtonLabel:"   ",stopSpotlightOnSelfConfirmButtonLabel:"    ",stopSpotlightCancelButtonLabel:""},exitSpotlightButtonLabel:"    ",exitSpotlightButtonTooltip:"    "};var chat$i={chatListHeader:"  ",uploadFile:" "};var callWithChat$i={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:" ",chatButtonTooltipClosedWithMessageCount:"  ({unreadMessagesCount}  )",chatButtonTooltipClose:" ",chatButtonTooltipOpen:" ",chatPaneTitle:"",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"   ",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:" ",moreDrawerButtonLabel:"  ",moreDrawerButtonTooltip:"  ",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:" ",moreDrawerCaptionsMenuTitle:"  ",moreDrawerSpokenLanguageMenuTitle:" ",moreDrawerCaptionLanguageMenuTitle:"  ",moreDrawerGalleryOptionsMenuTitle:" ",peopleButtonLabel:"",selectedPeopleButtonLabel:"   ",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:"  ",peoplePaneTitle:"",pictureInPictureTileAriaLabel:" .     .",removeMenuLabel:"",openDialpadButtonLabel:"  ",returnToCallButtonAriaDescription:"  ",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"  ",dialpadModalAriaLabel:" ",dialpadCloseModalButtonAriaLabel:"  ",openDtmfDialpadLabel:"  ",dtmfDialpadPlaceholderText:" "};var ar_SA = {call:call$i,chat:chat$i,callWithChat:callWithChat$i};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Arabic (Saudi Arabia)
 *
 * @public
 */
const COMPOSITE_LOCALE_AR_SA = {
    component: COMPONENT_LOCALE_AR_SA,
    strings: createCompositeStrings(ar_SA)
};

var call$h={cameraLabel:"Kamera",noCamerasLabel:"Nebyly nalezeny dn kamery",cameraPermissionDenied:"V prohle blokuje pstup ke kamee.",cameraTurnedOff:"Mte vypnutou kameru.",chatButtonLabel:"Chat",close:"Zavt",complianceBannerNowOnlyRecording:"Nyn tuto schzku pouze nahrvte.",complianceBannerNowOnlyTranscription:"Nyn tuto schzku pouze pepisujete.",complianceBannerRecordingAndTranscriptionSaved:"Zznam a pepis se ukldaj.",complianceBannerRecordingAndTranscriptionStarted:"Spustilo se nahrvn a pepis.",complianceBannerRecordingAndTranscriptionStopped:"Nahrvn a pepis se zastavily.",complianceBannerRecordingSaving:"Probh ukldn zznamu.",complianceBannerRecordingStarted:"Nahrvn se spustilo.",complianceBannerRecordingStopped:"Nahrvn se zastavilo.",complianceBannerTranscriptionStarted:"Pepis se spustil.",complianceBannerTranscriptionConsent:"Pipojenm vyjadujete souhlas s pepisem tto schzky.",complianceBannerTranscriptionSaving:"Pepis se ukld.",complianceBannerTranscriptionStopped:"Pepis se zastavil.",configurationPageTitle:"Zat hovor",copyInviteLinkButtonLabel:"Koprovat odkaz pro pozvn",copyInviteLinkActionedAriaLabel:"Odkaz pozvnky se zkoproval",defaultPlaceHolder:"Vyberte jednu monost",dismissSidePaneButtonLabel:"Zavt",videoEffectsPaneTitle:"Efekty",videoEffectsPaneBackgroundSelectionTitle:"Pozad",configurationPageVideoEffectsButtonLabel:"Efekty",unableToStartVideoEffect:"Nelze pout efekt videa.",blurBackgroundEffectButtonLabel:"Rozosten",blurBackgroundTooltip:"Rozostit pozad",removeBackgroundEffectButtonLabel:"dn",removeBackgroundTooltip:"Odebrat pozad",cameraOffBackgroundEffectWarningText:"Vae kamera je vypnut. Pokud chcete vidt efekt videa, zapnte kameru.",failedToJoinCallDueToNoNetworkMoreDetails:"Hovor byl odpojen z dvodu problmu se st. Zkontrolujte pipojen a pipojte se znovu.",failedToJoinCallDueToNoNetworkTitle:"Hovor odpojen",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Vstup do hovoru vm nebyl povolen. Pokud se jednalo o chybu, znovu se do hovoru pihlaste.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Odchod z pedsl",learnMore:"Dal informace",leavingCallTitle:"Opoutte hovor...",leftCallMoreDetails:"Pokud se jedn o chybu, pipojte se k hovoru znovu.",leftCallTitle:"Opustili jste hovor",lobbyScreenConnectingToCallTitle:"Pipojovn k hovoru",lobbyScreenWaitingToBeAdmittedTitle:"ek se na pijet",microphonePermissionDenied:"V prohle blokuje pstup k mikrofonu.",microphoneToggleInLobbyNotAllowed:"V pedsl nejde ztlumit ani zruit ztlumen.",mutedMessage:"Jste ztlumen",networkReconnectMoreDetails:"Vypad to, e se nco nepovedlo. Pokoume se znovu pipojit k hovoru.",networkReconnectTitle:"Vydrte",notInvitedToRoomDetails:"K tto mstnosti se nemete pipojit, protoe nemte pozvnku.",notInvitedToRoomTitle:"Nepozvn(a) do mstnosti",peopleButtonLabel:"Lid",selectedPeopleButtonLabel:"Vybrno tlatko Lid",peoplePaneTitle:"Lid",peoplePaneMoreButtonAriaLabel:"Vce",peopleButtonTooltipOpen:"Zobrazit astnky",peopleButtonTooltipClose:"Skrt astnky",peoplePaneSubTitle:"V tomto hovoru {numberOfPeople}",privacyPolicy:"Zsady ochrany osobnch daj",rejoinCallButtonLabel:"Znovu se pipojit k hovoru",removedFromCallMoreDetails:"Jin astnk vs odebral z hovoru.",removedFromCallTitle:"Byli jste odebrni",removeMenuLabel:"Odebrat",startSpotlightParticipantListMenuLabel:"Pidat do hlavnho vbru vem",addSpotlightParticipantListMenuLabel:"Pidat do hlavnho vbru",stopSpotlightParticipantListMenuLabel:"Zastavit pidvn do hlavnho vbru",stopSpotlightOnSelfParticipantListMenuLabel:"Ukonit hlavn vbr",spotlightLimitReachedParticipantListMenuTitle:"Doshlo se limitu hlavnho vbru",stopAllSpotlightMenuLabel:"Zastavit vechny vbry",returnToCallButtonAriaDescription:"Pokraovat v hovoru",returnToCallButtonAriaLabel:"Zpt",roomNotFoundDetails:"Zadan ID mstnosti se nepovedlo najt.",roomNotFoundTitle:"Mstnost nebyla nalezena",roomNotValidDetails:"Tato mstnost nen v tuto chvli platn.",roomNotValidTitle:"Neplatn mstnost",inviteToRoomRemovedDetails:"Vae pozvnka k pipojen k tto mstnosti se odebrala.",inviteToRoomRemovedTitle:"Pozvnka do mstnosti se odebrala",soundLabel:"Zvuk",noMicrophonesLabel:"Nenaly se dn mikrofony",noSpeakersLabel:"Nenaly se dn reproduktory",startCallButtonLabel:"Zahjit hovor",openDialpadButtonLabel:"Vytoit telefonn slo",peoplePaneAddPeopleButtonLabel:"Pidat lidi",dialpadStartCallButtonLabel:"Volat",dialpadModalTitle:"Vytoit telefonn slo",dialpadModalAriaLabel:"selnk",dialpadCloseModalButtonAriaLabel:"Zavt selnk",moreButtonCallingLabel:"Dal",resumeCallButtonLabel:"Pokraovat",resumingCallButtonLabel:"Obnovovn",resumeCallButtonAriaLabel:"Pokraovat v hovoru",resumingCallButtonAriaLabel:"Pokraovat v hovoru",holdScreenLabel:"V hovor je pidren",openDtmfDialpadLabel:"Zobrazit selnk",dtmfDialpadPlaceholderText:"Zadejte slo",outboundCallingNoticeString:"Voln",participantJoinedNoticeString:"{displayName} se pipojil(a)",twoParticipantJoinedNoticeString:"{displayName1} a {displayName2} se pipojili",threeParticipantJoinedNoticeString:"Uivatel {displayName1}, {displayName2} a {displayName3} se pipojili",participantLeftNoticeString:"{displayName} se odpojil(a)",twoParticipantLeftNoticeString:"{displayName1} a {displayName2} se odpojili",threeParticipantLeftNoticeString:"Uivatel {displayName1}, {displayName2} a {displayName3} se odpojili",unnamedParticipantString:"nepojmenovan astnk",manyUnnamedParticipantsJoined:"nepojmenovan astnk a {numOfParticipants} dal astnci se pipojili",manyUnnamedParticipantsLeft:"nepojmenovan astnk a {numOfParticipants} dal astnci se odpojili",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} a {numOfParticipants} se pipojili dal astnci",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} a {numOfParticipants} dal astnci",liveCaptionsLabel:"iv titulky",captionsSettingsLabel:"Nastaven titulk",startCaptionsButtonOnLabel:"Zapnout titulky",startCaptionsButtonOffLabel:"Vypnout titulky",startCaptionsButtonTooltipOnContent:"Vypnout titulky",startCaptionsButtonTooltipOffContent:"Zapnout titulky",captionsSettingsModalTitle:"Nastaven titulk",captionsSettingsSpokenLanguageDropdownLabel:"Mluven jazyk",captionsSettingsCaptionLanguageDropdownLabel:"Jazyk titulk",captionsSettingsSpokenLanguageDropdownInfoText:"Jazyk, kterm mluv vichni astnci tohoto hovoru.",captionsSettingsCaptionLanguageDropdownInfoText:"Titulky se zobraz v tomto jazyce. ",captionsSettingsConfirmButtonLabel:"Potvrdit",captionsSettingsCancelButtonLabel:"Zruit",captionsSettingsModalAriaLabel:"Modln nastaven titulk",captionsSettingsCloseModalButtonAriaLabel:"Nastaven titulk",captionsBannerMoreButtonCallingLabel:"Dal",captionsBannerMoreButtonTooltip:"Dal monosti",dismissModalAriaLabel:"Mstn a vzdlen obrzek a obrzek, stisknutm klvesy Enter se vrtte k hovoru",callRejectedTitle:"Hovor nelo spojit.",callRejectedMoreDetails:"Osoba, se kterou se pokoute spojit, nen k dispozici. Zkuste to prosm znovu pozdji.",callTimeoutTitle:"Hovor nelo spojit.",callTimeoutDetails:"Osoba, se kterou se pokoute spojit, nen k dispozici. Zkuste to prosm znovu pozdji.",callTimeoutBotTitle:"Hovor nelo spojit.",callTimeoutBotDetails:"Sluba, ke kter se pokoute zskat pstup, nen k dispozici. Zkuste to prosm znovu pozdji.",dtmfDialerButtonLabel:"selnk",dtmfDialerButtonTooltipOn:"Zobrazit selnk",dtmfDialerButtonTooltipOff:"Skrt selnk",dtmfDialerMoreButtonLabelOn:"Zobrazit selnk",dtmfDialerMoreButtonLabelOff:"Skrt selnk",spokenLanguageStrings:{"ar-ae":"Arabtina - Spojen arabsk emirty","ar-sa":"Arabtina - Sadsk Arbie","da-dk":"Dntina","de-de":"Nmina - Nmecko","en-au":"Anglitina - Austrlie","en-ca":"Anglitina - Kanada","en-gb":"Anglitina - Spojen krlovstv","en-in":"Anglitina - Indie","en-nz":"Anglitina - Nov Zland","en-us":"Anglitina - Spojen stty americk","es-es":"panltina - panlsko (Modern Sort)","es-mx":"panltina - Mexiko","fi-fi":"Fintina","fr-ca":"Francouztina - Kanada","fr-fr":"Francouztina - Francie","hi-in":"Hindtina","it-it":"Italtina - Itlie","ja-jp":"Japontina","ko-kr":"Korejtina","nb-no":"Nortina (Bokml)","nl-be":"Holandtina  Belgie","nl-nl":"Holandtina - Nizozemsko","pl-pl":"Poltina","pt-br":"Portugaltina  Brazlie","ru-ru":"Rutina","sv-se":"vdtina","zh-cn":"ntina  nsk lidov republika","zh-hk":"ntina  Hong Kong SAR","cs-cz":"etina","pt-pt":"Portugaltina  Portugalsko","tr-tr":"Turetina","vi-vn":"Vietnamtina","th-th":"Thajtina","he-il":"Hebrejtina","cy-gb":"Veltina","uk-ua":"Ukrajintina","el-gr":"etina","hu-hu":"Maartina","ro-ro":"Rumuntina","sk-sk":"Sloventina","zh-tw":"ntina  Tchaj-wan"},captionLanguageStrings:{ar:"Arabtina",da:"Dntina",de:"Nmina",en:"Anglitina",es:"panltina",fi:"Fintina","fr-ca":"Francouztina - Kanada",fr:"Francouztina - Francie",hi:"Hindtina",it:"Italtina",ja:"Japontina",ko:"Korejtina",nb:"Nortina (Bokml)",nl:"Nizozemtina",pl:"Poltina",pt:"Portugaltina  Brazlie",ru:"Rutina",sv:"vdtina","zh-Hans":"ntina (zjednoduen)","zh-Hant":"ntina (tradin)",cs:"etina","pt-pt":"Portugaltina  Portugalsko",tr:"Turetina",vi:"Vietnamtina",th:"Thajtina",he:"Hebrejtina",cy:"Veltina",uk:"Ukrajintina",el:"etina",hu:"Maartina",ro:"Rumuntina",sk:"Sloventina"},captionsBannerSpinnerText:"Spout se titulky...",transferPageTransferorText:"Probh penos...",transferPageTransferTargetText:"Pipojovn...",transferPageUnknownTransferorDisplayName:"Neznm",transferPageUnknownTransferTargetDisplayName:"Neznm",transferPageNoticeString:"Pepojujeme vs",participantCouldNotBeReachedTitle:"Clov astnk nen v tuto chvli k dispozici",participantCouldNotBeReachedMoreDetails:"Obrate se prosm na astnka, a bude k dispozici",permissionToReachTargetParticipantNotAllowedTitle:"Oprvnn k dosaen clovho astnka nen povolen",permissionToReachTargetParticipantNotAllowedMoreDetails:"Zkontrolujte prosm, jestli je clov astnk ve stejnm tenantovi.",unableToResolveTenantTitle:"Nepovedlo se peloit ID tenanta pro clovho astnka",unableToResolveTenantMoreDetails:"Zkontrolujte prosm, jestli je sprvn zadan ID astnka.",participantIdIsMalformedTitle:"ID astnka nem sprvn formt.",participantIdIsMalformedMoreDetails:"Zkontrolujte prosm, jestli je ID astnka ve sprvnm formtu.",moreButtonGalleryControlLabel:"Zobrazit",moreButtonGalleryPositionToggleLabel:"Pesunout galerii na zatek",moreButtonGallerySpeakerLayoutLabel:"Reproduktor",moreButtonGalleryFloatingLocalLayoutLabel:"Dynamick",moreButtonGalleryDefaultLayoutLabel:"Zobrazen galerie",moreButtonGalleryFocusedContentLayoutLabel:"Penst hlavn pozornost na obsah",moreButtonLargeGalleryDefaultLayoutLabel:"Velk galerie",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Vae kamera byla zakzna. U nemete sdlet video.",grantedDueToMeetingOption:"Vae kamera je povolen. Pokud chcete sdlet video, zapnte ji."},unmuteMic:{lostDueToMeetingOption:"V mikrofon byl zakzn. U nemete zruit ztlumen.",grantedDueToMeetingOption:"V mikrofon je povolen. Zrute ztlumen, pokud chcete mluvit."},shareScreen:{lostDueToRoleChangeToAttendee:"Vae role se zmnila. Nkter akce, jako je sdlen obsahu, pro vs nebudou k dispozici.",grantedDueToRoleChangeToPresenter:"Jste prezentujc. Mete sdlet obsah a moderovat schzku."}},surveyTitle:"Pomozte nm se zlepovat",starSurveyHelperText:"Jak byla kvalita hovoru?",starSurveyOneStarText:"Kvalita byla patn.",starSurveyTwoStarText:"Kvalita byla slab.",starSurveyThreeStarText:"Kvalita byla dobr.",starSurveyFourStarText:"Kvalita byla skvl.",starSurveyFiveStarText:"Kvalita byla vynikajc.",surveyConfirmButtonLabel:"Poslat zptnou vazbu",starRatingAriaLabel:"Vybrat {0} z(e) {1} hvzdiek",surveySkipButtonLabel:"Peskoit",tagsSurveyQuestion:"Co by mohlo bt lep?",tagsSurveyTextFieldDefaultText:"Jin, upesnte prosm",tagsSurveyHelperText:"Zkontrolujte vechny problmy, se kter jste zaznamenali.",surveyTextboxDefaultText:"Jin, upesnte prosm",endOfSurveyText:"Dkujeme za v nzor!",surveyIssues:{overallRating:{callCannotJoin:"Nepovedlo se mi pipojit se k hovoru",callCannotInvite:"Nepovedlo se mi pozvat ostatn do hovoru.",hadToRejoin:"Musel(a) jsem se znovu pipojit k hovoru",callEndedUnexpectedly:"Hovor pro m neoekvan skonil",otherIssues:"Ml(a) jsem s hovorem jin problmy"},audioRating:{noLocalAudio:"Druh strana neslyela dn zvuk",noRemoteAudio:"Vbec jsem neslyel(a) zvuk",echo:"Pi hovoru jsem slyel(a) ozvny",audioNoise:"Pi hovoru jsem slyel(a) um",lowVolume:"Hlasitost byla nzk",audioStoppedUnexpectedly:"Zvuk se neoekvan zastavil",distortedSpeech:"Zvuk byl zkreslen",audioInterruption:"Dolo k peruen zvuku",otherIssues:"Bhem tohoto hovoru dolo k jinm problmm se zvukem"},videoRating:{noVideoReceived:"Vbec se mi nezobrazovalo video",noVideoSent:"Ostatn m nevidli",lowQuality:"Kvalita videa byla nzk.",freezes:"Video se zablokuje",stoppedUnexpectedly:"Video se neoekvan zastavilo",darkVideoReceived:"Kdy ostatn zapnou kameru, vidm jenom tmav obrazovky",audioVideoOutOfSync:"Zvuk a video se nesynchronizovaly",otherIssues:"V tomto hovoru dolo k jinm problmm s videem"},screenshareRating:{noContentLocal:"Ostatn uivatel nevidli moje sdlen obrazovky",noContentRemote:"Nepovedlo se mi zobrazit sdlen obrazovky jinch lid",cannotPresent:"Nepovedlo se mi ukzat obrazovku",lowQuality:"Kvalita sdlen obrazovky byla nzk",freezes:"Zablokovan sdlen obrazovky",stoppedUnexpectedly:"Sdlen obrazovky se neoekvan zastavilo",largeDelay:"Sdlen obrazovky m velk zpodn",otherIssues:"Ml(a) jsem jin problmy se sdlenm obrazovky v tomto hovoru"}},SurveyIssuesHeadingStrings:{overallRating:"Celkem",audioRating:"Zvuk",videoRating:"Video",screenshareRating:"Prezentovn"},spotlightPrompt:{startSpotlightHeading:"Pidat do hlavnho vbru vem?",startSpotlightText:"Toto video se zvrazn vem astnkm schzky.",startSpotlightOnSelfText:"Vae video se zvrazn vem astnkm schzky.",startSpotlightConfirmButtonLabel:"Pidat do hlavnho vbru vem",startSpotlightCancelButtonLabel:"Zruit",stopSpotlightHeading:"Chcete pestat zobrazovat toto video v hlavnm vbru?",stopSpotlightOnSelfHeading:"Ukonit hlavn vbr?",stopSpotlightText:"astnkm se u toto video nebude zvrazovat.",stopSpotlightOnSelfText:"astnkm se u vae video nebude zvrazovat.",stopSpotlightConfirmButtonLabel:"Zastavit pidvn do hlavnho vbru",stopSpotlightOnSelfConfirmButtonLabel:"Ukonit hlavn vbr",stopSpotlightCancelButtonLabel:"Zruit"},exitSpotlightButtonLabel:"Ukonit hlavn vbr",exitSpotlightButtonTooltip:"Ukonit hlavn vbr"};var chat$h={chatListHeader:"V tomto chatu",uploadFile:"Nahrt soubor"};var callWithChat$h={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Nov zprva",chatButtonTooltipClosedWithMessageCount:"Zobrazit chat (poet nepetench zprv: {unreadMessagesCount})",chatButtonTooltipClose:"Skrt chat",chatButtonTooltipOpen:"Zobrazit chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Koprovat odkaz pro pozvn",copyInviteLinkActionedAriaLabel:"Odkaz pozvnky se zkoproval",dismissSidePaneButtonLabel:"Zavt",moreDrawerAudioDeviceMenuTitle:"Zvukov zazen",moreDrawerButtonLabel:"Dal monosti",moreDrawerButtonTooltip:"Dal monosti",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Mluv",moreDrawerCaptionsMenuTitle:"iv titulky",moreDrawerSpokenLanguageMenuTitle:"Mluven jazyk",moreDrawerCaptionLanguageMenuTitle:"Jazyk titulk",moreDrawerGalleryOptionsMenuTitle:"Monosti galerie",peopleButtonLabel:"Lid",selectedPeopleButtonLabel:"Vybrno tlatko Lid",peopleButtonTooltipOpen:"Zobrazit astnky",peopleButtonTooltipClose:"Skrt astnky",peoplePaneSubTitle:"V tomto hovoru",peoplePaneTitle:"Lid",pictureInPictureTileAriaLabel:"Informan kanly videa. Kliknutm se vrtte na obrazovku hovoru.",removeMenuLabel:"Odebrat",openDialpadButtonLabel:"Vytoit telefonn slo",returnToCallButtonAriaDescription:"Pokraovat v hovoru",returnToCallButtonAriaLabel:"Zpt",peoplePaneAddPeopleButtonLabel:"Pidat lidi",dialpadStartCallButtonLabel:"Volat",dialpadModalTitle:"Vytoit telefonn slo",dialpadModalAriaLabel:"selnk",dialpadCloseModalButtonAriaLabel:"Zavt selnk",openDtmfDialpadLabel:"Zobrazit selnk",dtmfDialpadPlaceholderText:"Zadejte slo"};var cs_CZ = {call:call$h,chat:chat$h,callWithChat:callWithChat$h};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Czech (Czech Republic)
 *
 * @public
 */
const COMPOSITE_LOCALE_CS_CZ = {
    component: COMPONENT_LOCALE_CS_CZ,
    strings: createCompositeStrings(cs_CZ)
};

var call$g={cameraLabel:"Kamera",noCamerasLabel:"Keine Kameras gefunden",cameraPermissionDenied:"Ihr Browser blockiert den Zugriff auf Ihre Kamera.",cameraTurnedOff:"Ihre Kamera ist deaktiviert.",chatButtonLabel:"Chat",close:"Schlieen",complianceBannerNowOnlyRecording:"Sie zeichnen nun nur diese Besprechung auf.",complianceBannerNowOnlyTranscription:"Sie transkribieren diese Besprechung jetzt nur noch.",complianceBannerRecordingAndTranscriptionSaved:"Aufzeichnung und Transkription werden gespeichert.",complianceBannerRecordingAndTranscriptionStarted:"Die Aufzeichnung und Transkription haben begonnen.",complianceBannerRecordingAndTranscriptionStopped:"Die Aufzeichnung und Transkription wurden beendet.",complianceBannerRecordingSaving:"Aufzeichnung wird gespeichert.",complianceBannerRecordingStarted:"Die Aufzeichnung wurde gestartet.",complianceBannerRecordingStopped:"Aufzeichnung wurde beendet.",complianceBannerTranscriptionStarted:"Die Transkription hat begonnen.",complianceBannerTranscriptionConsent:"Durch Ihre Teilnahme stimmen Sie zu, dass diese Besprechung transkribiert wird.",complianceBannerTranscriptionSaving:"Die Transkription wird gespeichert.",complianceBannerTranscriptionStopped:"Die Transkription wurde beendet.",configurationPageTitle:"Einen Anruf beginnen",copyInviteLinkButtonLabel:"Einladungslink kopieren",copyInviteLinkActionedAriaLabel:"Gruppeneinladungslink kopiert",defaultPlaceHolder:"Option auswhlen",dismissSidePaneButtonLabel:"Schlieen",videoEffectsPaneTitle:"Effekte",videoEffectsPaneBackgroundSelectionTitle:"Hintergrund",configurationPageVideoEffectsButtonLabel:"Effekte",unableToStartVideoEffect:"Videoeffekt kann nicht angewendet werden.",blurBackgroundEffectButtonLabel:"Unscharf machen",blurBackgroundTooltip:"Hintergrund unscharf machen",removeBackgroundEffectButtonLabel:"Keine",removeBackgroundTooltip:"Hintergrund entfernen",cameraOffBackgroundEffectWarningText:"Ihre Kamera ist ausgeschaltet. Aktivieren Sie die Kamera, um den Videoeffekt anzuzeigen.",failedToJoinCallDueToNoNetworkMoreDetails:"Der Anruf wurde aufgrund eines Netzwerkproblems getrennt. berprfen Sie Ihre Verbindung, und treten Sie erneut bei.",failedToJoinCallDueToNoNetworkTitle:"Anruf unterbrochen",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Ihnen wurde keine Teilnahme am Anruf gewhrt. Wenn dies ein Fehler war, treten Sie dem Anruf erneut bei.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Aus Wartebereich entlassen",learnMore:"Weitere Informationen",leavingCallTitle:"Verlsst Besprechung...",leftCallMoreDetails:"Wenn dies ein Fehler war, nehmen Sie erneut am Anruf teil.",leftCallTitle:"Sie haben den Anruf verlassen",lobbyScreenConnectingToCallTitle:"Teilnehmen am Anruf",lobbyScreenWaitingToBeAdmittedTitle:"Warten auf die Zulassung",microphonePermissionDenied:"Ihr Browser blockiert den Zugriff auf Ihr Mikrofon.",microphoneToggleInLobbyNotAllowed:"Stummschalten oder Aufheben der Stummschaltung im Wartebereich nicht zulssig.",mutedMessage:"Sie sind stummgeschaltet.",networkReconnectMoreDetails:"Offensichtlich ist etwas schief gegangen. Wir versuchen, Sie wieder mit dem Anruf zu verbinden.",networkReconnectTitle:"Einen Augenblick bitte",notInvitedToRoomDetails:"Sie knnen diesem Raum ohne Einladung nicht beitreten.",notInvitedToRoomTitle:"Nicht zum Raum eingeladen",peopleButtonLabel:"Kontakte",selectedPeopleButtonLabel:"Schaltflche \"Personen\" ausgewhlt",peoplePaneTitle:"Kontakte",peoplePaneMoreButtonAriaLabel:"Mehr",peopleButtonTooltipOpen:"Teilnehmende anzeigen",peopleButtonTooltipClose:"Teilnehmende ausblenden",peoplePaneSubTitle:"In diesem Anruf {numberOfPeople}",privacyPolicy:"Datenschutzrichtlinie",rejoinCallButtonLabel:"Am Anruf erneut teilnehmen",removedFromCallMoreDetails:"Ein anderer Teilnehmer hat Sie aus dem Anruf entfernt.",removedFromCallTitle:"Sie wurden entfernt",removeMenuLabel:"Entfernen",startSpotlightParticipantListMenuLabel:"Spotlight fr alle",addSpotlightParticipantListMenuLabel:"Spotlight hinzufgen",stopSpotlightParticipantListMenuLabel:"Spotlight beenden",stopSpotlightOnSelfParticipantListMenuLabel:"Spotlight beenden",spotlightLimitReachedParticipantListMenuTitle:"Spotlight-Limit erreicht",stopAllSpotlightMenuLabel:"Alle Spotlights beenden",returnToCallButtonAriaDescription:"Zurck zum Anruf",returnToCallButtonAriaLabel:"Zurck",roomNotFoundDetails:"Die angegebene Raum-ID wurde nicht gefunden.",roomNotFoundTitle:"Raum nicht gefunden",roomNotValidDetails:"Dieser Raum ist zurzeit nicht gltig.",roomNotValidTitle:"Raum ungltig",inviteToRoomRemovedDetails:"Ihre Einladung, diesem Raum beizutreten, wurde entfernt.",inviteToRoomRemovedTitle:"Einladung zum Raum entfernt",soundLabel:"Sound",noMicrophonesLabel:"Keine Mikrofone gefunden",noSpeakersLabel:"Keine Lautsprecher gefunden",startCallButtonLabel:"Anruf beginnen",openDialpadButtonLabel:"Telefonnummer whlen",peoplePaneAddPeopleButtonLabel:"Personen hinzufgen",dialpadStartCallButtonLabel:"Anrufen",dialpadModalTitle:"Telefonnummer whlen",dialpadModalAriaLabel:"Whltastatur",dialpadCloseModalButtonAriaLabel:"Whltastatur schlieen",moreButtonCallingLabel:"Mehr",resumeCallButtonLabel:"Fortsetzen",resumingCallButtonLabel:"Wird fortgesetzt",resumeCallButtonAriaLabel:"Anruf fortsetzen",resumingCallButtonAriaLabel:"Anruf fortsetzen",holdScreenLabel:"Sie sind in der Warteschleife.",openDtmfDialpadLabel:"Whltastatur anzeigen",dtmfDialpadPlaceholderText:"Nummer eingeben",outboundCallingNoticeString:"Anrufen...",participantJoinedNoticeString:"{displayName} ist beigetreten.",twoParticipantJoinedNoticeString:"{displayName1} und {displayName2} sind beigetreten.",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} und {displayName3} sind beigetreten.",participantLeftNoticeString:"{displayName} ist gegangen.",twoParticipantLeftNoticeString:"{displayName1} und {displayName2} sind gegangen.",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} und {displayName3} sind gegangen.",unnamedParticipantString:"unbenannter Teilnehmer",manyUnnamedParticipantsJoined:"unbenannter Teilnehmer und {numOfParticipants} weitere Teilnehmer sind beigetreten.",manyUnnamedParticipantsLeft:"unbenannter Teilnehmer und {numOfParticipants} weitere Teilnehmer sind gegangen.",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} und {numOfParticipants} anderen Teilnehmern sind beigetreten.",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} und {numOfParticipants} anderen Teilnehmer verlassen",liveCaptionsLabel:"Liveuntertitel",captionsSettingsLabel:"Untertiteleinstellungen",startCaptionsButtonOnLabel:"Beschriftungen aktivieren",startCaptionsButtonOffLabel:"Untertitel deaktivieren",startCaptionsButtonTooltipOnContent:"Untertitel deaktivieren",startCaptionsButtonTooltipOffContent:"Beschriftungen aktivieren",captionsSettingsModalTitle:"Einstellungen fr Untertitel",captionsSettingsSpokenLanguageDropdownLabel:"Gesprochene Sprache",captionsSettingsCaptionLanguageDropdownLabel:"Sprache der Untertitel",captionsSettingsSpokenLanguageDropdownInfoText:"Sprache, die jeder in diesem Anruf spricht.",captionsSettingsCaptionLanguageDropdownInfoText:"Untertitel werden in dieser Sprache angezeigt.",captionsSettingsConfirmButtonLabel:"Besttigen",captionsSettingsCancelButtonLabel:"Abbrechen",captionsSettingsModalAriaLabel:"Untertiteleinstellung modal",captionsSettingsCloseModalButtonAriaLabel:"Einstellung Untertitel schlieen",captionsBannerMoreButtonCallingLabel:"Mehr",captionsBannerMoreButtonTooltip:"Weitere Optionen",dismissModalAriaLabel:"Lokales Bild und Remotebild. Drcken Sie die EINGABETASTE, um zum Anruf zurckzukehren.",callRejectedTitle:"Der Anruf konnte nicht ausgefhrt werden.",callRejectedMoreDetails:"Die Person, die Sie erreichen mchten, ist nicht verfgbar. Versuchen Sie es spter noch mal.",callTimeoutTitle:"Der Anruf konnte nicht ausgefhrt werden.",callTimeoutDetails:"Die Person, die Sie erreichen mchten, ist nicht verfgbar. Versuchen Sie es spter noch mal.",callTimeoutBotTitle:"Der Anruf konnte nicht ausgefhrt werden.",callTimeoutBotDetails:"Der Dienst, den Sie erreichen mchten, ist nicht verfgbar. Versuchen Sie es spter noch mal.",dtmfDialerButtonLabel:"Whltastatur",dtmfDialerButtonTooltipOn:"Whltastatur anzeigen",dtmfDialerButtonTooltipOff:"Whltastatur ausblenden",dtmfDialerMoreButtonLabelOn:"Whltastatur anzeigen",dtmfDialerMoreButtonLabelOff:"Whltastatur ausblenden",spokenLanguageStrings:{"ar-ae":"Arabisch  Vereinigte Arabische Emirate","ar-sa":"Arabisch  Saudi-Arabien","da-dk":"Dnisch","de-de":"Deutsch  Deutschland","en-au":"Englisch  Australien","en-ca":"Englisch  Kanada","en-gb":"Englisch - Vereinigtes Knigreich","en-in":"Englisch  Indien","en-nz":"Englisch  Neuseeland","en-us":"Englisch  USA","es-es":"Spanisch  Spanien (Moderne Sortierung)","es-mx":"Spanisch  Mexiko","fi-fi":"Finnisch","fr-ca":"Franzsisch (Kanada)","fr-fr":"Franzsisch (Frankreich)","hi-in":"Hindi","it-it":"Italienisch  Italien","ja-jp":"Japanisch","ko-kr":"Koreanisch","nb-no":"Norwegisch (Bokml)","nl-be":"Niederlndisch  Belgien","nl-nl":"Niederlndisch  Niederlande","pl-pl":"Polnisch","pt-br":"Portugiesisch (Brasilien)","ru-ru":"Russisch","sv-se":"Schwedisch","zh-cn":"Chinesisch  Volksrepublik China","zh-hk":"Chinesisch  Hongkong (SAR)","cs-cz":"Tschechisch","pt-pt":"Portugiesisch (Portugal)","tr-tr":"Trkisch","vi-vn":"Vietnamesisch","th-th":"Thailndisch","he-il":"Hebrisch","cy-gb":"Walisisch","uk-ua":"Ukrainisch","el-gr":"Griechisch","hu-hu":"Ungarisch","ro-ro":"Rumnisch","sk-sk":"Slowakisch","zh-tw":"Chinesisch  Taiwan"},captionLanguageStrings:{ar:"Arabisch",da:"Dnisch",de:"Deutsch",en:"Englisch",es:"Spanisch",fi:"Finnisch","fr-ca":"Franzsisch  Kanada",fr:"Franzsisch  Frankreich",hi:"Hindi",it:"Italienisch",ja:"Japanisch",ko:"Koreanisch",nb:"Norwegisch (Bokml)",nl:"Niederlndisch",pl:"Polnisch",pt:"Portugiesisch  Brasilien",ru:"Russisch",sv:"Schwedisch","zh-Hans":"Chinesisch (vereinfacht)","zh-Hant":"Chinesisch (traditionell)",cs:"Tschechisch","pt-pt":"Portugiesisch  Portugal",tr:"Trkisch",vi:"Vietnamesisch",th:"Thailndisch",he:"Hebrisch",cy:"Walisisch",uk:"Ukrainisch",el:"Griechisch",hu:"Ungarisch",ro:"Rumnisch",sk:"Slowakisch"},captionsBannerSpinnerText:"Untertitel werden gestartet...",transferPageTransferorText:"bertragung...",transferPageTransferTargetText:"Verbindung wird hergestellt...",transferPageUnknownTransferorDisplayName:"Unbekannt",transferPageUnknownTransferTargetDisplayName:"Unbekannt",transferPageNoticeString:"Sie werden versetzt",participantCouldNotBeReachedTitle:"Der Zielteilnehmer ist zurzeit nicht verfgbar",participantCouldNotBeReachedMoreDetails:"Wenden Sie sich an den Teilnehmer, wenn er verfgbar ist",permissionToReachTargetParticipantNotAllowedTitle:"Die Berechtigung zum Erreichen des Zielteilnehmers ist nicht zulssig",permissionToReachTargetParticipantNotAllowedMoreDetails:"berprfen Sie, ob sich der Zielteilnehmer im selben Mandanten befindet",unableToResolveTenantTitle:"Die Mandanten-ID fr den Zielteilnehmer kann nicht aufgelst werden",unableToResolveTenantMoreDetails:"berprfen Sie, ob die Teilnehmer-ID richtig eingegeben wurde.",participantIdIsMalformedTitle:"Die Teilnehmer-ID weist nicht das richtige Format auf",participantIdIsMalformedMoreDetails:"berprfen Sie, ob die Teilnehmer-ID das richtige Format aufweist.",moreButtonGalleryControlLabel:"Anzeigen",moreButtonGalleryPositionToggleLabel:"Katalog nach oben verschieben",moreButtonGallerySpeakerLayoutLabel:"Lautsprecher",moreButtonGalleryFloatingLocalLayoutLabel:"Dynamisch",moreButtonGalleryDefaultLayoutLabel:"Profilfotoansicht",moreButtonGalleryFocusedContentLayoutLabel:"Fokus auf Inhalte",moreButtonLargeGalleryDefaultLayoutLabel:"Groe Galerie",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Ihre Kamera wurde deaktiviert. Sie knnen kein Video mehr freigeben.",grantedDueToMeetingOption:"Ihre Kamera wurde aktiviert. Aktivieren Sie diese Option, wenn Sie Video freigeben mchten."},unmuteMic:{lostDueToMeetingOption:"Ihr Mikro wurde deaktiviert. Sie knnen die Stummschaltung nicht mehr aufheben.",grantedDueToMeetingOption:"Ihr Mikro wurde aktiviert. Heben Sie die Stummschaltung auf, wenn Sie sprechen mchten."},shareScreen:{lostDueToRoleChangeToAttendee:"Ihre Rolle wurde gendert. Einige Aktionen, z. B. das Teilen von Inhalten, stehen Ihnen nicht zur Verfgung.",grantedDueToRoleChangeToPresenter:"Sie sind Referent. Sie knnen Inhalte teilen und die Besprechung untersttzen."}},surveyTitle:"Helfen Sie uns, besser zu werden.",starSurveyHelperText:"Wie war die Qualitt des Anrufs?",starSurveyOneStarText:"Die Qualitt war schlecht.",starSurveyTwoStarText:"Die Qualitt war schlecht.",starSurveyThreeStarText:"Die Qualitt war gut.",starSurveyFourStarText:"Die Qualitt war toll.",starSurveyFiveStarText:"Die Qualitt war ausgezeichnet.",surveyConfirmButtonLabel:"Feedback senden",starRatingAriaLabel:"{0} von {1} Sternen auswhlen",surveySkipButtonLabel:"berspringen",tagsSurveyQuestion:"Was htte besser sein knnen?",tagsSurveyTextFieldDefaultText:"Sonstiges, bitte angeben",tagsSurveyHelperText:"berprfen Sie alle aufgetretenen Probleme",surveyTextboxDefaultText:"Sonstiges, bitte angeben",endOfSurveyText:"Vielen Dank fr Ihr Feedback!",surveyIssues:{overallRating:{callCannotJoin:"Ich konnte dem Anruf nicht beitreten",callCannotInvite:"Ich konnte andere nicht zum Anruf einladen",hadToRejoin:"Ich musste dem Anruf erneut beitreten",callEndedUnexpectedly:"Anruf fr mich unerwartet beendet",otherIssues:"Ich hatte andere Probleme mit dem Anruf"},audioRating:{noLocalAudio:"Die andere Seite konnte keinen Ton hren",noRemoteAudio:"Ich konnte keinen Ton hren",echo:"Ich habe Echos beim Anruf gehrt",audioNoise:"Ich habe Rauschen beim Anruf gehrt",lowVolume:"Die Lautstrke war niedrig",audioStoppedUnexpectedly:"Audio wurde unerwartet beendet",distortedSpeech:"Audio war verzerrt",audioInterruption:"Audio wurde unterbrochen",otherIssues:"In diesem Anruf gab es andere Audioprobleme"},videoRating:{noVideoReceived:"Ich konnte kein Video sehen.",noVideoSent:"Andere konnten mich nicht sehen",lowQuality:"Die Videoqualitt war niedrig",freezes:"Video gefroren",stoppedUnexpectedly:"Video unerwartet beendet",darkVideoReceived:"Ich kann nur dunkle Bildschirme sehen, wenn andere ihre Kamera einschalten",audioVideoOutOfSync:"Audio und Video waren nicht synchronisiert",otherIssues:"In diesem Anruf gab es andere Videoprobleme"},screenshareRating:{noContentLocal:"Andere Personen konnten meine Bildschirmfreigabe nicht sehen",noContentRemote:"Ich konnte die Bildschirmfreigabe anderer Personen nicht sehen",cannotPresent:"Ich konnte meinen Bildschirm nicht prsentieren",lowQuality:"Qualitt der Bildschirmfreigabe war niedrig",freezes:"Bildschirmfreigabe gefroren",stoppedUnexpectedly:"Bildschirmfreigabe unerwartet beendet",largeDelay:"Die Bildschirmfreigabe hat eine groe Verzgerung",otherIssues:"Ich hatte andere Probleme mit der Bildschirmfreigabe in diesem Anruf."}},SurveyIssuesHeadingStrings:{overallRating:"Insgesamt",audioRating:"Audio",videoRating:"Video",screenshareRating:"Hlt Prsentation"},spotlightPrompt:{startSpotlightHeading:"Spotlight fr alle?",startSpotlightText:"Sie heben dieses Video fr alle Teilnehmer der Besprechung hervor.",startSpotlightOnSelfText:"Sie setzen Ihr Video fr alle Teilnehmer der Besprechung ins Spotlight.",startSpotlightConfirmButtonLabel:"Spotlight fr alle",startSpotlightCancelButtonLabel:"Abbrechen",stopSpotlightHeading:"Dieses Video aus dem Spotlight nehmen?",stopSpotlightOnSelfHeading:"Spotlight verlassen?",stopSpotlightText:"Dieses Video wird nicht mehr fr alle Teilnehmer der Besprechung hervorgehoben.",stopSpotlightOnSelfText:"Ihr Video wird nicht mehr fr alle Teilnehmer der Besprechung hervor gehoben.",stopSpotlightConfirmButtonLabel:"Spotlight beenden",stopSpotlightOnSelfConfirmButtonLabel:"Spotlight beenden",stopSpotlightCancelButtonLabel:"Abbrechen"},exitSpotlightButtonLabel:"Spotlight beenden",exitSpotlightButtonTooltip:"Spotlight beenden"};var chat$g={chatListHeader:"In diesem Chat",uploadFile:"Datei hochladen"};var callWithChat$g={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Neue Nachricht",chatButtonTooltipClosedWithMessageCount:"Chat anzeigen ({unreadMessagesCount} ungelesen)",chatButtonTooltipClose:"Chat ausblenden",chatButtonTooltipOpen:"Chat anzeigen",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Einladungslink kopieren",copyInviteLinkActionedAriaLabel:"Gruppeneinladungslink kopiert",dismissSidePaneButtonLabel:"Schlieen",moreDrawerAudioDeviceMenuTitle:"Audiogert",moreDrawerButtonLabel:"Weitere Optionen",moreDrawerButtonTooltip:"Weitere Optionen",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Lautsprecher",moreDrawerCaptionsMenuTitle:"Liveuntertitel",moreDrawerSpokenLanguageMenuTitle:"Gesprochene Sprache",moreDrawerCaptionLanguageMenuTitle:"Sprache fr Untertitel",moreDrawerGalleryOptionsMenuTitle:"Katalogoptionen",peopleButtonLabel:"Personen",selectedPeopleButtonLabel:"Schaltflche \"Personen\" ausgewhlt",peopleButtonTooltipOpen:"Teilnehmende anzeigen",peopleButtonTooltipClose:"Teilnehmende ausblenden",peoplePaneSubTitle:"In diesem Anruf",peoplePaneTitle:"Personen",pictureInPictureTileAriaLabel:"Videofeeds. Klicken Sie hier, um zum Anrufbildschirm zurckzukehren.",removeMenuLabel:"Entfernen",openDialpadButtonLabel:"Telefonnummer whlen",returnToCallButtonAriaDescription:"Zurck zum Anruf",returnToCallButtonAriaLabel:"Zurck",peoplePaneAddPeopleButtonLabel:"Personen hinzufgen",dialpadStartCallButtonLabel:"Anrufen",dialpadModalTitle:"Telefonnummer whlen",dialpadModalAriaLabel:"Whltastatur",dialpadCloseModalButtonAriaLabel:"Whltastatur schlieen",openDtmfDialpadLabel:"Whltastatur anzeigen",dtmfDialpadPlaceholderText:"Nummer eingeben"};var de_DE = {call:call$g,chat:chat$g,callWithChat:callWithChat$g};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for German (Germany)
 *
 * @public
 */
const COMPOSITE_LOCALE_DE_DE = {
    component: COMPONENT_LOCALE_DE_DE,
    strings: createCompositeStrings(de_DE)
};

var call$f={cameraLabel:"Cmara",noCamerasLabel:"No se han encontrado cmaras",cameraPermissionDenied:"El explorador est bloqueando el acceso a la cmara",cameraTurnedOff:"La cmara est apagada",chatButtonLabel:"Chat",close:"Cerrar",complianceBannerNowOnlyRecording:"Solo est grabando esta reunin.",complianceBannerNowOnlyTranscription:"Solo est transcribiendo esta reunin.",complianceBannerRecordingAndTranscriptionSaved:"Se estn guardando la grabacin y la transcripcin.",complianceBannerRecordingAndTranscriptionStarted:"Se han iniciado la grabacin y la transcripcin.",complianceBannerRecordingAndTranscriptionStopped:"Se han detenido la grabacin y la transcripcin.",complianceBannerRecordingSaving:"La grabacin se est guardando.",complianceBannerRecordingStarted:"Se ha iniciado la grabacin.",complianceBannerRecordingStopped:"La grabacin se ha detenido.",complianceBannerTranscriptionStarted:"La transcripcin se ha iniciado.",complianceBannerTranscriptionConsent:"Al unirse, da su consentimiento para que se transcriba esta reunin.",complianceBannerTranscriptionSaving:"Se est guardando la transcripcin.",complianceBannerTranscriptionStopped:"La transcripcin se ha detenido.",configurationPageTitle:"Iniciar una llamada",copyInviteLinkButtonLabel:"Copiar vnculo de invitacin",copyInviteLinkActionedAriaLabel:"Vnculo de invitacin copiado",defaultPlaceHolder:"Seleccionar una opcin",dismissSidePaneButtonLabel:"Cerrar",videoEffectsPaneTitle:"Efectos",videoEffectsPaneBackgroundSelectionTitle:"Fondo",configurationPageVideoEffectsButtonLabel:"Efectos",unableToStartVideoEffect:"No se puede aplicar el efecto de vdeo.",blurBackgroundEffectButtonLabel:"Desenfoque",blurBackgroundTooltip:"Desenfocar fondo",removeBackgroundEffectButtonLabel:"Ninguno",removeBackgroundTooltip:"Quitar fondo",cameraOffBackgroundEffectWarningText:"La cmara est apagada. Enciende la cmara para ver el efecto de vdeo.",failedToJoinCallDueToNoNetworkMoreDetails:"Se desconect la llamada debido a un problema de red. Compruebe la conexin y nase de nuevo.",failedToJoinCallDueToNoNetworkTitle:"Llamada desconectada",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"No se te concedi la entrada a la llamada. Si se trata de un error, vuelve a unirte.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Rechazado de la sala de espera",learnMore:"Ms informacin",leavingCallTitle:"Saliendo...",leftCallMoreDetails:"Si se trata de un error, vuelve a unirte a la llamada.",leftCallTitle:"Has abandonado la llamada",lobbyScreenConnectingToCallTitle:"Unindose a la llamada",lobbyScreenWaitingToBeAdmittedTitle:"Esperando a ser admitido",microphonePermissionDenied:"El explorador est bloqueando el acceso al micrfono",microphoneToggleInLobbyNotAllowed:"No se puede silenciar ni reactivar el audio mientras se est en la sala de espera.",mutedMessage:"Ests silenciado",networkReconnectMoreDetails:"Parece que hubo un problema. Estamos intentando reconectar la llamada.",networkReconnectTitle:"Espere",notInvitedToRoomDetails:"No puede unirse a esta sala porque no tiene una invitacin.",notInvitedToRoomTitle:"No invitado a la sala",peopleButtonLabel:"Contactos",selectedPeopleButtonLabel:"Se seleccion el botn Contactos",peoplePaneTitle:"Contactos",peoplePaneMoreButtonAriaLabel:"Ms",peopleButtonTooltipOpen:"Mostrar participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"En esta llamada {numberOfPeople}",privacyPolicy:"Directiva de privacidad",rejoinCallButtonLabel:"Volver a unirse a la llamada",removedFromCallMoreDetails:"Otro participante te ha eliminado de la llamada.",removedFromCallTitle:"Fuiste eliminado",removeMenuLabel:"Quitar",startSpotlightParticipantListMenuLabel:"Poner en primer plano para todos",addSpotlightParticipantListMenuLabel:"Agregar primer plano",stopSpotlightParticipantListMenuLabel:"Dejar de poner en primer plano",stopSpotlightOnSelfParticipantListMenuLabel:"Primer plano",spotlightLimitReachedParticipantListMenuTitle:"Se alcanz el lmite de primer plano",stopAllSpotlightMenuLabel:"Detener todos los primeros planos",returnToCallButtonAriaDescription:"Volver a llamada",returnToCallButtonAriaLabel:"Volver",roomNotFoundDetails:"No se encontr el Id. de sala proporcionado.",roomNotFoundTitle:"No se ha encontrado la sala",roomNotValidDetails:"Esta sala no es vlida en este momento.",roomNotValidTitle:"Sala no vlida",inviteToRoomRemovedDetails:"Se ha quitado la invitacin para unirse a esta sala.",inviteToRoomRemovedTitle:"Invitacin a sala quitada",soundLabel:"Sonido",noMicrophonesLabel:"No se han encontrado micrfonos",noSpeakersLabel:"No se han encontrado altavoces",startCallButtonLabel:"Iniciar llamada",openDialpadButtonLabel:"Marcar nmero de telfono",peoplePaneAddPeopleButtonLabel:"Agregar contactos",dialpadStartCallButtonLabel:"Llamar",dialpadModalTitle:"Marcar nmero de telfono",dialpadModalAriaLabel:"Teclado de marcado",dialpadCloseModalButtonAriaLabel:"Cerrar teclado de marcado",moreButtonCallingLabel:"Ms",resumeCallButtonLabel:"Reanudar",resumingCallButtonLabel:"Reanudando",resumeCallButtonAriaLabel:"Reanudar llamada",resumingCallButtonAriaLabel:"Reanudar llamada",holdScreenLabel:"Est en espera",openDtmfDialpadLabel:"Mostrar teclado de marcado",dtmfDialpadPlaceholderText:"Introducir nmero",outboundCallingNoticeString:"Llamando...",participantJoinedNoticeString:"{displayName} unido",twoParticipantJoinedNoticeString:"{displayName1} y {displayName2} se han unido",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} y {displayName3} se han unido",participantLeftNoticeString:"{displayName} se ha retirado",twoParticipantLeftNoticeString:"{displayName1} y {displayName2} se han retirado",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} y {displayName3} se han retirado",unnamedParticipantString:"participante sin nombre",manyUnnamedParticipantsJoined:"participante sin nombre y {numOfParticipants} participantes ms se han unido",manyUnnamedParticipantsLeft:"participante sin nombre y {numOfParticipants} participantes ms se han retirado",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} y {numOfParticipants} se han unido otros participantes",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} y {numOfParticipants} restantes",liveCaptionsLabel:"Subttulos en directo",captionsSettingsLabel:"Configuracin de subttulos",startCaptionsButtonOnLabel:"Activar subttulos",startCaptionsButtonOffLabel:"Desactivar subttulos",startCaptionsButtonTooltipOnContent:"Desactivar subttulos",startCaptionsButtonTooltipOffContent:"Activar subttulos",captionsSettingsModalTitle:"Configuracin de subttulos",captionsSettingsSpokenLanguageDropdownLabel:"Idioma hablado",captionsSettingsCaptionLanguageDropdownLabel:"Idioma de subttulos",captionsSettingsSpokenLanguageDropdownInfoText:"Idioma en el que estn hablando todos los usuarios de esta llamada.",captionsSettingsCaptionLanguageDropdownInfoText:"Los subttulos aparecern en este idioma.",captionsSettingsConfirmButtonLabel:"Confirmar",captionsSettingsCancelButtonLabel:"Cancelar",captionsSettingsModalAriaLabel:"Configuracin modal de subttulos",captionsSettingsCloseModalButtonAriaLabel:"Cerrar configuracin de subttulos",captionsBannerMoreButtonCallingLabel:"Ms",captionsBannerMoreButtonTooltip:"Ms opciones",dismissModalAriaLabel:"Imagen e imagen local y remota, presiona Entrar para volver a la llamada",callRejectedTitle:"No se pudo completar la llamada",callRejectedMoreDetails:"La persona con la que quieres contactarte no est disponible. Intntalo de nuevo ms tarde.",callTimeoutTitle:"No se pudo completar la llamada",callTimeoutDetails:"La persona con la que quieres contactarte no est disponible. Intntalo de nuevo ms tarde.",callTimeoutBotTitle:"No se pudo completar la llamada",callTimeoutBotDetails:"El servicio al que intenta conectarse no est disponible. Vuelva a intentarlo ms tarde.",dtmfDialerButtonLabel:"Teclado de marcado",dtmfDialerButtonTooltipOn:"Mostrar teclado de marcado",dtmfDialerButtonTooltipOff:"Ocultar teclado de marcado",dtmfDialerMoreButtonLabelOn:"Mostrar teclado de marcado",dtmfDialerMoreButtonLabelOff:"Ocultar teclado de marcado",spokenLanguageStrings:{"ar-ae":"rabe - Emiratos rabes Unidos","ar-sa":"rabe - Arabia Saud","da-dk":"Dans","de-de":"Alemn - Alemania","en-au":"Ingls - Australia","en-ca":"Ingls (Canad)","en-gb":"Ingls - Reino Unido","en-in":"Ingls (India)","en-nz":"Ingls (Nueva Zelanda)","en-us":"Ingls - Estados Unidos","es-es":"Espaol - Espaa (alfabetizacin internacional)","es-mx":"Espaol (Mxico)","fi-fi":"Fins","fr-ca":"Francs (Canad)","fr-fr":"Francs - Francia","hi-in":"Hindi","it-it":"Italiano (Italia)","ja-jp":"Japons","ko-kr":"Coreano","nb-no":"Noruego (Bokml)","nl-be":"Neerlands - Blgica","nl-nl":"Neerlands (Pases Bajos)","pl-pl":"Polaco","pt-br":"Portugus (Brasil)","ru-ru":"Ruso","sv-se":"Sueco","zh-cn":"Chino - Repblica Popular China","zh-hk":"Chino - Hong Kong (RAE)","cs-cz":"Checo","pt-pt":"Portugus de Portugal","tr-tr":"Turco","vi-vn":"Vietnamita","th-th":"Tailands","he-il":"Hebreo","cy-gb":"Gals","uk-ua":"Ucraniano","el-gr":"Griego","hu-hu":"Hngaro","ro-ro":"Rumano","sk-sk":"Eslovaco","zh-tw":"Chino - Taiwn"},captionLanguageStrings:{ar:"rabe",da:"Dans",de:"Alemn",en:"Ingls",es:"Espaol",fi:"Fins","fr-ca":"Francs (Canad)",fr:"Francs - Francia",hi:"Hindi",it:"Italiano",ja:"Japons",ko:"Coreano",nb:"Noruego (Bokml)",nl:"Neerlands",pl:"Polaco",pt:"Portugus (Brasil)",ru:"Ruso",sv:"Sueco","zh-Hans":"Chino (simplificado)","zh-Hant":"Chino (tradicional)",cs:"Checo","pt-pt":"Portugus de Portugal",tr:"Turco",vi:"Vietnamita",th:"Tailands",he:"Hebreo",cy:"Gals",uk:"Ucraniano",el:"Griego",hu:"Hngaro",ro:"Rumano",sk:"Eslovaco"},captionsBannerSpinnerText:"Iniciando subttulos...",transferPageTransferorText:"Transfiriendo...",transferPageTransferTargetText:"Conectando...",transferPageUnknownTransferorDisplayName:"Desconocido",transferPageUnknownTransferTargetDisplayName:"Desconocido",transferPageNoticeString:"Est siendo transferido",participantCouldNotBeReachedTitle:"El participante de destino no est disponible actualmente",participantCouldNotBeReachedMoreDetails:"Pngase en contacto con el participante cuando est disponible",permissionToReachTargetParticipantNotAllowedTitle:"No se permite el permiso para llegar al participante objetivo",permissionToReachTargetParticipantNotAllowedMoreDetails:"Compruebe que el participante de destino est en el mismo inquilino.",unableToResolveTenantTitle:"No se puede resolver el id. de inquilino para el participante de destino",unableToResolveTenantMoreDetails:"Compruebe que el id. de participante se ha escrito correctamente.",participantIdIsMalformedTitle:"El id. de participante no tiene el formato correcto",participantIdIsMalformedMoreDetails:"Compruebe que el id. de participante tiene el formato correcto",moreButtonGalleryControlLabel:"Ver",moreButtonGalleryPositionToggleLabel:"Mover galera a la parte superior",moreButtonGallerySpeakerLayoutLabel:"Orador",moreButtonGalleryFloatingLocalLayoutLabel:"Dinmico",moreButtonGalleryDefaultLayoutLabel:"Vista galera",moreButtonGalleryFocusedContentLayoutLabel:"Centrarse en el contenido",moreButtonLargeGalleryDefaultLayoutLabel:"Galera de gran tamao",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"La cmara se ha deshabilitado. Ya no puedes compartir vdeo.",grantedDueToMeetingOption:"Tu cmara ha sido habilitada. Actvala si quiere compartir un vdeo."},unmuteMic:{lostDueToMeetingOption:"El micrfono se ha deshabilitado. Ya no se puede reactivar el audio.",grantedDueToMeetingOption:"Se ha habilitado el micro. Reactive el audio si quiere hablar."},shareScreen:{lostDueToRoleChangeToAttendee:"Tu rol ha sido cambiado. Algunas acciones, como compartir contenido, no estarn disponibles para usted.",grantedDueToRoleChangeToPresenter:"Es moderador. Puede compartir contenido y facilitar la reunin."}},surveyTitle:"Aydenos a mejorar",starSurveyHelperText:"Qu tal era la calidad de la llamada?",starSurveyOneStarText:"La calidad era mala.",starSurveyTwoStarText:"La calidad era deficiente.",starSurveyThreeStarText:"La calidad era buena.",starSurveyFourStarText:"La calidad era estupenda.",starSurveyFiveStarText:"La calidad era excelente.",surveyConfirmButtonLabel:"Enviar comentarios",starRatingAriaLabel:"Seleccione {0} de {1} estrellas",surveySkipButtonLabel:"Omitir",tagsSurveyQuestion:"Qu podra haber sido mejor?",tagsSurveyTextFieldDefaultText:"Otro, especifique",tagsSurveyHelperText:"Marque los problemas que haya experimentado",surveyTextboxDefaultText:"Otro, especifique",endOfSurveyText:"Gracias por sus comentarios.",surveyIssues:{overallRating:{callCannotJoin:"No pude unirme a la llamada",callCannotInvite:"No poda invitar a nadie a la llamada",hadToRejoin:"He tenido que volver a unirme a la llamada",callEndedUnexpectedly:"La llamada finaliz inesperadamente",otherIssues:"Estaba teniendo otros problemas con la llamada"},audioRating:{noLocalAudio:"Los otros participantes no podan or nada",noRemoteAudio:"No pude or nada",echo:"He odo ecos en la llamada",audioNoise:"Se oa ruido en la llamada",lowVolume:"El volumen era bajo",audioStoppedUnexpectedly:"El audio se detuvo inesperadamente",distortedSpeech:"El audio se distorsionaba",audioInterruption:"Se interrumpi el audio",otherIssues:"Estaba teniendo otros problemas de audio en esta llamada"},videoRating:{noVideoReceived:"No pude ver ningn vdeo",noVideoSent:"Los dems usuarios no me vean",lowQuality:"La calidad de vdeo era baja",freezes:"Vdeo congelado",stoppedUnexpectedly:"El vdeo se detuvo inesperadamente",darkVideoReceived:"Solo puedo ver pantallas oscuras cuando otros usuarios activan su cmara",audioVideoOutOfSync:"Audio y vdeo no sincronizados",otherIssues:"Estaba teniendo otros problemas de vdeo en esta llamada"},screenshareRating:{noContentLocal:"Otras personas no pudieron ver mi pantalla compartida",noContentRemote:"No pude ver el la pantalla compartida de otras personas",cannotPresent:"No pude presentar mi pantalla",lowQuality:"La calidad de la pantalla compartida era baja",freezes:"Pantalla compartida congelada",stoppedUnexpectedly:"El la pantalla compartida se detuvo inesperadamente",largeDelay:"La pantalla compartida tiene mucho retraso",otherIssues:"Estaba teniendo otros problemas de pantalla compartida en esta llamada"}},SurveyIssuesHeadingStrings:{overallRating:"General",audioRating:"Audio",videoRating:"Vdeo",screenshareRating:"Presentacin"},spotlightPrompt:{startSpotlightHeading:"Poner en primer plano para todos?",startSpotlightText:"Este vdeo lo resaltar para todos en la reunin.",startSpotlightOnSelfText:"Resaltar el vdeo para todos los participantes de la reunin.",startSpotlightConfirmButtonLabel:"Poner en primer plano para todos",startSpotlightCancelButtonLabel:"Cancelar",stopSpotlightHeading:"Dejar de poner este vdeo en primer plano?",stopSpotlightOnSelfHeading:"Salir del primer plano?",stopSpotlightText:"Este vdeo dejar de estar resaltado para todos los asistentes a la reunin.",stopSpotlightOnSelfText:"Su vdeo ya no resaltar para todos en la reunin.",stopSpotlightConfirmButtonLabel:"Dejar de poner en primer plano",stopSpotlightOnSelfConfirmButtonLabel:"Salir del primer plano",stopSpotlightCancelButtonLabel:"Cancelar"},exitSpotlightButtonLabel:"Salir del primer plano",exitSpotlightButtonTooltip:"Salir del primer plano"};var chat$f={chatListHeader:"En este chat",uploadFile:"Subir archivo"};var callWithChat$f={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Nuevo mensaje",chatButtonTooltipClosedWithMessageCount:"Mostrar chat ({unreadMessagesCount} no ledos)",chatButtonTooltipClose:"Ocultar chat",chatButtonTooltipOpen:"Mostrar chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copiar vnculo de invitacin",copyInviteLinkActionedAriaLabel:"Vnculo de invitacin copiado",dismissSidePaneButtonLabel:"Cerrar",moreDrawerAudioDeviceMenuTitle:"Dispositivo de audio",moreDrawerButtonLabel:"Ms opciones",moreDrawerButtonTooltip:"Ms opciones",moreDrawerMicrophoneMenuTitle:"Micrfono",moreDrawerSpeakerMenuTitle:"Altavoz",moreDrawerCaptionsMenuTitle:"Subttulos en directo",moreDrawerSpokenLanguageMenuTitle:"Idioma hablado",moreDrawerCaptionLanguageMenuTitle:"Idioma de subttulos",moreDrawerGalleryOptionsMenuTitle:"Opciones de la Galera",peopleButtonLabel:"Contactos",selectedPeopleButtonLabel:"Se seleccion el botn Contactos",peopleButtonTooltipOpen:"Mostrar participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"En esta llamada",peoplePaneTitle:"Contactos",pictureInPictureTileAriaLabel:"Fuentes de vdeo. Hacer clic para volver a la pantalla de la llamada.",removeMenuLabel:"Quitar",openDialpadButtonLabel:"Marcar nmero de telfono",returnToCallButtonAriaDescription:"Volver a llamada",returnToCallButtonAriaLabel:"Volver",peoplePaneAddPeopleButtonLabel:"Agregar contactos",dialpadStartCallButtonLabel:"Llamar",dialpadModalTitle:"Marcar nmero de telfono",dialpadModalAriaLabel:"Teclado de marcado",dialpadCloseModalButtonAriaLabel:"Cerrar teclado de marcado",openDtmfDialpadLabel:"Mostrar teclado de marcado",dtmfDialpadPlaceholderText:"Introducir nmero"};var es_ES = {call:call$f,chat:chat$f,callWithChat:callWithChat$f};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Spanish (Spain)
 *
 * @public
 */
const COMPOSITE_LOCALE_ES_ES = {
    component: COMPONENT_LOCALE_ES_ES,
    strings: createCompositeStrings(es_ES)
};

var call$e={cameraLabel:"Kamera",noCamerasLabel:"Kameroita ei lytynyt",cameraPermissionDenied:"Selaimesi est kameran kytn",cameraTurnedOff:"Kamerasi on pois kytst",chatButtonLabel:"Keskustelu",close:"Sulje",complianceBannerNowOnlyRecording:"Tallennetta ollaan luomassa vain tst kokouksesta.",complianceBannerNowOnlyTranscription:"Transkriptiota ollaan luomassa vain tst kokouksesta.",complianceBannerRecordingAndTranscriptionSaved:"Tallennusta ja transkriptiota tallennetaan.",complianceBannerRecordingAndTranscriptionStarted:"Tallentaminen ja litterointi on aloitettu.",complianceBannerRecordingAndTranscriptionStopped:"Tallentaminen ja litterointi on pysytetty.",complianceBannerRecordingSaving:"Tallennetta tallennetaan.",complianceBannerRecordingStarted:"Tallentaminen on aloitettu.",complianceBannerRecordingStopped:"Tallentaminen on pysytetty.",complianceBannerTranscriptionStarted:"Transkriptio on aloitettu.",complianceBannerTranscriptionConsent:"Liittymll annat suostumuksesi kokouksen litteroimiseen.",complianceBannerTranscriptionSaving:"Transkriptiota tallennetaan.",complianceBannerTranscriptionStopped:"Transkriptio on pysytetty.",configurationPageTitle:"Aloita puhelu",copyInviteLinkButtonLabel:"Kopioi kutsulinkki",copyInviteLinkActionedAriaLabel:"Kutsulinkki kopioitu",defaultPlaceHolder:"Valitse vaihtoehto",dismissSidePaneButtonLabel:"Sulje",videoEffectsPaneTitle:"Tehosteet",videoEffectsPaneBackgroundSelectionTitle:"Tausta",configurationPageVideoEffectsButtonLabel:"Tehosteet",unableToStartVideoEffect:"Videotehosteen kyttminen ei onnistu.",blurBackgroundEffectButtonLabel:"Sumenna",blurBackgroundTooltip:"Sumenna tausta",removeBackgroundEffectButtonLabel:"Ei mitn",removeBackgroundTooltip:"Poista tausta",cameraOffBackgroundEffectWarningText:"Kamera ei ole kytss. Ota kamera kyttn nhdksesi videotehosteen.",failedToJoinCallDueToNoNetworkMoreDetails:"Puhelu katkaistiin verkko-ongelman vuoksi. Tarkista yhteys ja liity uudelleen.",failedToJoinCallDueToNoNetworkTitle:"Puhelu on katkennut",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Sinulle ei mynnetty puheluun merkint. Jos tm oli virhe, liity puheluun uudelleen.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Poistettu odotustilasta",learnMore:"Listietoja",leavingCallTitle:"Poistumassa...",leftCallMoreDetails:"Jos tm oli virhe, liity puheluun uudelleen.",leftCallTitle:"Poistuit puhelusta",lobbyScreenConnectingToCallTitle:"Liitytn puheluun",lobbyScreenWaitingToBeAdmittedTitle:"Odotetaan hyvksymist mukaan kokoukseen",microphonePermissionDenied:"Selaimesi est mikrofonin kytn",microphoneToggleInLobbyNotAllowed:"Mykistmistoimintoa ei voi kytt odotustilassa.",mutedMessage:"Mikrofonisi on mykistetty",networkReconnectMoreDetails:"Vaikuttaa silt, ett tapahtui virhe. Sinua yritetn saada takaisin mukaan puheluun.",networkReconnectTitle:"Odota",notInvitedToRoomDetails:"Et voi liitty thn huoneeseen, koska sinulla ei ole kutsua.",notInvitedToRoomTitle:"Ei kutsuttu huoneeseen",peopleButtonLabel:"Ihmiset",selectedPeopleButtonLabel:"Henkilt-painike valittu",peoplePaneTitle:"Ihmiset",peoplePaneMoreButtonAriaLabel:"Lis",peopleButtonTooltipOpen:"Nyt osallistujat",peopleButtonTooltipClose:"Piilota osallistujat",peoplePaneSubTitle:"Tss puhelussa {numberOfPeople}",privacyPolicy:"Tietosuojakytnnt",rejoinCallButtonLabel:"Liity uudelleen puheluun",removedFromCallMoreDetails:"Toinen osallistuja poisti sinut puhelusta.",removedFromCallTitle:"Sinut on poistettu",removeMenuLabel:"Poista",startSpotlightParticipantListMenuLabel:"Lis valokeilaan kaikille",addSpotlightParticipantListMenuLabel:"Lis valokeilaan",stopSpotlightParticipantListMenuLabel:"Poista valokeilasta",stopSpotlightOnSelfParticipantListMenuLabel:"Valokeila",spotlightLimitReachedParticipantListMenuTitle:"Spotlight-raja saavutettu",stopAllSpotlightMenuLabel:"Poista kaikki valokeilat",returnToCallButtonAriaDescription:"Palaa puheluun",returnToCallButtonAriaLabel:"Takaisin",roomNotFoundDetails:"Annettua huonetunnusta ei lydy.",roomNotFoundTitle:"Tilaa ei lytynyt",roomNotValidDetails:"Tm huone ei ole kelvollinen tll hetkell.",roomNotValidTitle:"Huone ei ole kelvollinen",inviteToRoomRemovedDetails:"Kutsusi liitty thn huoneeseen poistettiin.",inviteToRoomRemovedTitle:"Kutsu huoneeseen poistettu",soundLabel:"ni",noMicrophonesLabel:"Mikrofoneja ei lytynyt",noSpeakersLabel:"Kaiuttimia ei lytynyt",startCallButtonLabel:"Aloita puhelu",openDialpadButtonLabel:"Valitse puhelinnumero",peoplePaneAddPeopleButtonLabel:"Lis ihmisi",dialpadStartCallButtonLabel:"Soita",dialpadModalTitle:"Valitse puhelinnumero",dialpadModalAriaLabel:"Valintapaneeli",dialpadCloseModalButtonAriaLabel:"Sulje valintapaneeli",moreButtonCallingLabel:"Lis",resumeCallButtonLabel:"Jatka",resumingCallButtonLabel:"Jatketaan...",resumeCallButtonAriaLabel:"Jatka puhelua",resumingCallButtonAriaLabel:"Jatka puhelua",holdScreenLabel:"Olet pidossa",openDtmfDialpadLabel:"Nyt valintapaneeli",dtmfDialpadPlaceholderText:"Syt numero",outboundCallingNoticeString:"Soitetaan...",participantJoinedNoticeString:"{displayName} liittyi",twoParticipantJoinedNoticeString:"{displayName1} ja {displayName2} ovat liittyneet",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} ja {displayName3} ovat liittyneet",participantLeftNoticeString:"{displayName} poistui",twoParticipantLeftNoticeString:"{displayName1} ja {displayName2} ovat poistuneet",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} ja {displayName3} ovat poistuneet",unnamedParticipantString:"nimetn osallistuja",manyUnnamedParticipantsJoined:"nimetn osallistuja ja {numOfParticipants} muuta osallistujaa liittyi",manyUnnamedParticipantsLeft:"nimetn osallistuja ja {numOfParticipants} muuta osallistujaa poistuivat",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} ja {numOfParticipants} muuta osallistujaa liittyivt",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} ja {numOfParticipants} muuta osallistujaa poistuivat",liveCaptionsLabel:"Live-tekstitykset",captionsSettingsLabel:"Tekstitysasetukset",startCaptionsButtonOnLabel:"Ota tekstitykset kyttn",startCaptionsButtonOffLabel:"Poista tekstitykset kytst",startCaptionsButtonTooltipOnContent:"Poista tekstitykset kytst",startCaptionsButtonTooltipOffContent:"Ota tekstitykset kyttn",captionsSettingsModalTitle:"Tekstitysasetukset",captionsSettingsSpokenLanguageDropdownLabel:"Puhuttu kieli",captionsSettingsCaptionLanguageDropdownLabel:"Tekstitysten kieli",captionsSettingsSpokenLanguageDropdownInfoText:"Kieli, jota kaikki thn puheluun osallistuvat puhuvat.",captionsSettingsCaptionLanguageDropdownInfoText:"Tekstitys nkyy tll kielell.",captionsSettingsConfirmButtonLabel:"Vahvista",captionsSettingsCancelButtonLabel:"Peruuta",captionsSettingsModalAriaLabel:"Tekstitysasetus, modaalinen valintaikkuna",captionsSettingsCloseModalButtonAriaLabel:"Sulje tekstitysasetus",captionsBannerMoreButtonCallingLabel:"Lis",captionsBannerMoreButtonTooltip:"Lis vaihtoehtoja",dismissModalAriaLabel:"Paikallinen kuva ja etkuva, palaa puheluun painamalla Enter-nppint",callRejectedTitle:"Puhelua ei voitu soittaa",callRejectedMoreDetails:"Henkil, jota yritt tavoittaa, ei ole tavoitettavissa. Yrit myhemmin uudelleen.",callTimeoutTitle:"Puhelua ei voitu soittaa",callTimeoutDetails:"Henkil, jota yritt tavoittaa, ei ole tavoitettavissa. Yrit myhemmin uudelleen.",callTimeoutBotTitle:"Puhelua ei voitu soittaa",callTimeoutBotDetails:"Palvelu, jota yritt tavoittaa, ei ole kytettviss. Yrit myhemmin uudelleen.",dtmfDialerButtonLabel:"Valintapaneeli",dtmfDialerButtonTooltipOn:"Nyt valintapaneeli",dtmfDialerButtonTooltipOff:"Piilota valintapaneeli",dtmfDialerMoreButtonLabelOn:"Nyt valintapaneeli",dtmfDialerMoreButtonLabelOff:"Piilota valintapaneeli",spokenLanguageStrings:{"ar-ae":"arabia  Arabiemiirikunnat","ar-sa":"arabia  Saudi-Arabia","da-dk":"tanska","de-de":"saksa  Saksa","en-au":"englanti  Australia","en-ca":"englanti  Kanada","en-gb":"englanti  Yhdistynyt kuningaskunta","en-in":"englanti  Intia","en-nz":"englanti  Uusi-Seelanti","en-us":"englanti  Yhdysvallat","es-es":"espanja  Espanja (nykykieli)","es-mx":"espanja  Meksiko","fi-fi":"suomi","fr-ca":"ranska  Kanada","fr-fr":"ranska  Ranska","hi-in":"hindi","it-it":"italia  Italia","ja-jp":"japani","ko-kr":"korea","nb-no":"norja (bokml)","nl-be":"hollanti  Belgia","nl-nl":"hollanti  Alankomaat","pl-pl":"puola","pt-br":"portugali  Brasilia","ru-ru":"venj","sv-se":"ruotsi","zh-cn":"kiina  Kiinan kansantasavalta","zh-hk":"kiina  Hongkong, erityishallintoalue","cs-cz":"tekki","pt-pt":"portugali  Portugali","tr-tr":"turkki","vi-vn":"vietnam","th-th":"thai","he-il":"heprea","cy-gb":"kymri","uk-ua":"ukraina","el-gr":"kreikka","hu-hu":"unkari","ro-ro":"romania","sk-sk":"slovakki","zh-tw":"kiina  Taiwan"},captionLanguageStrings:{ar:"arabia",da:"tanska",de:"saksa",en:"englanti",es:"espanja",fi:"suomi","fr-ca":"ranska  Kanada",fr:"ranska  Ranska",hi:"hindi",it:"italia",ja:"japani",ko:"korea",nb:"norja (bokml)",nl:"hollanti",pl:"puola",pt:"portugali  Brasilia",ru:"venj",sv:"ruotsi","zh-Hans":"kiina (yksinkertaistettu)","zh-Hant":"kiinalainen (perinteinen)",cs:"tekki","pt-pt":"portugali  Portugali",tr:"turkki",vi:"vietnam",th:"thai",he:"heprea",cy:"kymri",uk:"ukraina",el:"kreikka",hu:"unkari",ro:"romania",sk:"slovakki"},captionsBannerSpinnerText:"Aloitetaan tekstityst...",transferPageTransferorText:"Siirretn...",transferPageTransferTargetText:"Yhdistetn...",transferPageUnknownTransferorDisplayName:"Tuntematon",transferPageUnknownTransferTargetDisplayName:"Tuntematon",transferPageNoticeString:"Sinut siirretn",participantCouldNotBeReachedTitle:"Kohdeosallistuja ei ole tll hetkell tavoitettavissa",participantCouldNotBeReachedMoreDetails:"Ota yhteytt osallistujaan, kun hn on tavoitettavissa",permissionToReachTargetParticipantNotAllowedTitle:"Kohdeosallistujan tavoittamisoikeutta ei sallita",permissionToReachTargetParticipantNotAllowedMoreDetails:"Tarkista, ett kohdeosallistuja on samassa vuokraajassa",unableToResolveTenantTitle:"Kohdeosallistujan vuokraajan tunnusta ei voi selvitt",unableToResolveTenantMoreDetails:"Tarkista, ett osallistujan tunnus on kirjoitettu oikein",participantIdIsMalformedTitle:"Osallistujan tunnus ei ole oikeassa muodossa",participantIdIsMalformedMoreDetails:"Tarkista, ett osallistujan tunnus on oikeassa muodossa",moreButtonGalleryControlLabel:"Nkym",moreButtonGalleryPositionToggleLabel:"Siirr valikoima ylimmiseksi",moreButtonGallerySpeakerLayoutLabel:"Kaiutin",moreButtonGalleryFloatingLocalLayoutLabel:"Dynaaminen",moreButtonGalleryDefaultLayoutLabel:"Valikoimankym",moreButtonGalleryFocusedContentLayoutLabel:"Huomio sisltn",moreButtonLargeGalleryDefaultLayoutLabel:"Suuri galleria",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Kamerasi on poistettu kytst. Et voi en jakaa videota.",grantedDueToMeetingOption:"Kamera on otettu kyttn. Ota se kyttn, jos haluat jakaa videota."},unmuteMic:{lostDueToMeetingOption:"Mikrofonisi on poistettu kytst. Et voi en poistaa mykistyst.",grantedDueToMeetingOption:"Mikrofoni on otettu kyttn. Poista mykistys, jos haluat puhua."},shareScreen:{lostDueToRoleChangeToAttendee:"Roolisi on muuttunut. Jotkin toiminnot, kuten sislln jakaminen, eivt ole kytettvisssi.",grantedDueToRoleChangeToPresenter:"Olet esittj. Voit jakaa sislt ja johtaa kokousta."}},surveyTitle:"Auta kehittmn tuotetta",starSurveyHelperText:"Millainen oli puhelun nenlaatu?",starSurveyOneStarText:"Laatu oli huono.",starSurveyTwoStarText:"Laatu oli erittin huono.",starSurveyThreeStarText:"Laatu oli hyv.",starSurveyFourStarText:"Laatu oli erinomainen.",starSurveyFiveStarText:"Laatu oli erinomainen.",surveyConfirmButtonLabel:"Lhet palautetta",starRatingAriaLabel:"Valitse {0}/{1} thte",surveySkipButtonLabel:"Ohita",tagsSurveyQuestion:"Mik olisi voinut olla paremmin?",tagsSurveyTextFieldDefaultText:"Muu, anna kuvaus",tagsSurveyHelperText:"Tarkista havaitsematsi ongelmat",surveyTextboxDefaultText:"Muu, anna kuvaus",endOfSurveyText:"Kiitos palautteestasi!",surveyIssues:{overallRating:{callCannotJoin:"En pystynyt liittymn puheluun",callCannotInvite:"En pystynyt kutsumaan muita mukaan puheluun",hadToRejoin:"Minun oli pakko liitty puheluun uudelleen",callEndedUnexpectedly:"Puhelu pttyi odottamatta",otherIssues:"Minulla oli muita ongelmia puhelun kanssa"},audioRating:{noLocalAudio:"Toinen osapuoli ei kuullut mitn",noRemoteAudio:"En kuullut mitn",echo:"Kuulin kaikua puhelun aikana",audioNoise:"Kuulin taustamelua puhelun aikana",lowVolume:"nenvoimakkuus oli matala",audioStoppedUnexpectedly:"ni lakkasi odottamatta kuulumasta",distortedSpeech:"ness esiintyi vristymi",audioInterruption:"ni keskeytyi",otherIssues:"Minulla oli puhelun aikana muita neen liittyvi ongelmia"},videoRating:{noVideoReceived:"En nhnyt videokuvaa",noVideoSent:"Muut eivt pystyneet nkemn minua",lowQuality:"Videokuva oli laadultaan heikkoa",freezes:"Video jumitti",stoppedUnexpectedly:"Videokuva pyshtyi odottamatta",darkVideoReceived:"Nen ainoastaan tummia nyttj, kun toiset ottavat kameransa kyttn",audioVideoOutOfSync:"ni ja kuva olivat eptahdissa",otherIssues:"Minulla oli puhelun aikana muita videokuvaan liittyvi ongelmia"},screenshareRating:{noContentLocal:"Muut henkilt eivt nhneet jakamaani nytt",noContentRemote:"En nhnyt muiden jakamaa nytt",cannotPresent:"En voinut esitt nyttni sislt",lowQuality:"Nytn jakaminen oli laadultaan heikkoa",freezes:"Nytn jakaminen jumitti",stoppedUnexpectedly:"Nytn jakaminen keskeytyi odottamatta",largeDelay:"Nytn jakamisessa ilmenee suurta viivett",otherIssues:"Minulla oli puhelun aikana muita nytn jakamiseen liittyvi ongelmia"}},SurveyIssuesHeadingStrings:{overallRating:"Yleinen",audioRating:"net",videoRating:"Video",screenshareRating:"Esitys kynniss"},spotlightPrompt:{startSpotlightHeading:"Listnk valokeilaan kaikille?",startSpotlightText:"Korostat videon kaikille kokouksen osallistujille.",startSpotlightOnSelfText:"Korostat videosi kaikille kokouksen osallistujille.",startSpotlightConfirmButtonLabel:"Lis valokeilaan kaikille",startSpotlightCancelButtonLabel:"Peruuta",stopSpotlightHeading:"Haluatko poistaa videon valokeilasta?",stopSpotlightOnSelfHeading:"Haluatko poistua valokeilasta?",stopSpotlightText:"Videota ei en korosteta kaikille kokouksen osallistujille.",stopSpotlightOnSelfText:"Videota ei en korosteta kaikille kokouksen osallistujille.",stopSpotlightConfirmButtonLabel:"Poista valokeilasta",stopSpotlightOnSelfConfirmButtonLabel:"Valokeila",stopSpotlightCancelButtonLabel:"Peruuta"},exitSpotlightButtonLabel:"Poistu valokeilasta",exitSpotlightButtonTooltip:"Poistu valokeilasta"};var chat$e={chatListHeader:"Tss keskustelussa",uploadFile:"Lataa tiedosto palvelimeen"};var callWithChat$e={chatButtonLabel:"Keskustelu",chatButtonNewMessageNotificationLabel:"Uusi viesti",chatButtonTooltipClosedWithMessageCount:"Nyt keskustelu ({unreadMessagesCount} lukematonta viesti)",chatButtonTooltipClose:"Piilota keskustelu",chatButtonTooltipOpen:"Nyt keskustelu",chatPaneTitle:"Keskustelu",copyInviteLinkButtonLabel:"Kopioi kutsulinkki",copyInviteLinkActionedAriaLabel:"Kutsulinkki kopioitu",dismissSidePaneButtonLabel:"Sulje",moreDrawerAudioDeviceMenuTitle:"nilaite",moreDrawerButtonLabel:"Lis vaihtoehtoja",moreDrawerButtonTooltip:"Lis vaihtoehtoja",moreDrawerMicrophoneMenuTitle:"Mikrofoni",moreDrawerSpeakerMenuTitle:"Kaiutin",moreDrawerCaptionsMenuTitle:"Live-tekstitykset",moreDrawerSpokenLanguageMenuTitle:"Puhuttu kieli",moreDrawerCaptionLanguageMenuTitle:"Tekstityksen kieli",moreDrawerGalleryOptionsMenuTitle:"Valikoiman asetukset",peopleButtonLabel:"Ihmiset",selectedPeopleButtonLabel:"Henkilt-painike valittu",peopleButtonTooltipOpen:"Nyt osallistujat",peopleButtonTooltipClose:"Piilota osallistujat",peoplePaneSubTitle:"Tss puhelussa",peoplePaneTitle:"Ihmiset",pictureInPictureTileAriaLabel:"Videosytteet. Palaa puhelunyttn napsauttamalla.",removeMenuLabel:"Poista",openDialpadButtonLabel:"Valitse puhelinnumero",returnToCallButtonAriaDescription:"Palaa puheluun",returnToCallButtonAriaLabel:"Takaisin",peoplePaneAddPeopleButtonLabel:"Lis ihmisi",dialpadStartCallButtonLabel:"Soita",dialpadModalTitle:"Valitse puhelinnumero",dialpadModalAriaLabel:"Valintapaneeli",dialpadCloseModalButtonAriaLabel:"Sulje valintapaneeli",openDtmfDialpadLabel:"Nyt valintapaneeli",dtmfDialpadPlaceholderText:"Syt numero"};var fi_FI = {call:call$e,chat:chat$e,callWithChat:callWithChat$e};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Finnish (Finland)
 *
 * @public
 */
const COMPOSITE_LOCALE_FI_FI = {
    component: COMPONENT_LOCALE_FI_FI,
    strings: createCompositeStrings(fi_FI)
};

var call$d={cameraLabel:"Appareil photo",noCamerasLabel:"Aucune camra trouve",cameraPermissionDenied:"Votre navigateur bloque laccs  votre camra",cameraTurnedOff:"Votre camra est dsactive",chatButtonLabel:"Conversation",close:"Fermer",complianceBannerNowOnlyRecording:"Vous nenregistrez dsormais que cette runion.",complianceBannerNowOnlyTranscription:" prsent, vous ne transcrivez que cette runion.",complianceBannerRecordingAndTranscriptionSaved:"Sauvegarde en cours de lenregistrement et de la transcription.",complianceBannerRecordingAndTranscriptionStarted:"Dmarrage de lenregistrement et de la transcription.",complianceBannerRecordingAndTranscriptionStopped:"Lenregistrement et la transcription ont pris fin.",complianceBannerRecordingSaving:"Sauvegarde en cours de l'enregistrement.",complianceBannerRecordingStarted:"Lenregistrement a dmarr.",complianceBannerRecordingStopped:"Lenregistrement a pris fin.",complianceBannerTranscriptionStarted:"Dmarrage de la transcription.",complianceBannerTranscriptionConsent:"En participant, vous autorisez la transcription de cette runion.",complianceBannerTranscriptionSaving:"Sauvegarde en cours de la transcription.",complianceBannerTranscriptionStopped:"La transcription a pris fin.",configurationPageTitle:"Lancer un appel",copyInviteLinkButtonLabel:"Copier le lien d'invitation",copyInviteLinkActionedAriaLabel:"Le lien dinvitation a t copi.",defaultPlaceHolder:"Slectionnez une option",dismissSidePaneButtonLabel:"Fermer",videoEffectsPaneTitle:"Effets",videoEffectsPaneBackgroundSelectionTitle:"Arrire-plan",configurationPageVideoEffectsButtonLabel:"Effets",unableToStartVideoEffect:"Impossible dappliquer leffet vido.",blurBackgroundEffectButtonLabel:"Flouter",blurBackgroundTooltip:"Flouter l'arrire-plan",removeBackgroundEffectButtonLabel:"Aucun",removeBackgroundTooltip:"Supprimer larrire-plan",cameraOffBackgroundEffectWarningText:"Votre camra est dsactive. Activez la camra pour voir leffet vido.",failedToJoinCallDueToNoNetworkMoreDetails:"Lappel a t dconnect en raison dun problme rseau. Vrifiez votre connexion et rejoignez-la  nouveau.",failedToJoinCallDueToNoNetworkTitle:"Appel dconnect",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Vous navez pas reu dentre dans lappel. Sil sagissait dune erreur, rejoignez  nouveau lappel.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Rejet de la salle dattente",learnMore:"En savoir plus",leavingCallTitle:"Quitter...",leftCallMoreDetails:"Sil sagissait dune erreur, rejoignez  nouveau lappel.",leftCallTitle:"Vous avez quitt lappel.",lobbyScreenConnectingToCallTitle:"Connexion  l'appel",lobbyScreenWaitingToBeAdmittedTitle:"En attente dadmission",microphonePermissionDenied:"Votre navigateur bloque laccs  votre micro",microphoneToggleInLobbyNotAllowed:"Impossible de dsactiver ou dactiver le son dans la salle dattente.",mutedMessage:"Le son de votre micro est dsactiv.",networkReconnectMoreDetails:"On dirait qu'une erreur est survenue. Nous tentons de vous reconnecter  lappel.",networkReconnectTitle:"Patience",notInvitedToRoomDetails:"Vous ne pouvez pas rejoindre cette salle, car vous navez pas dinvitation.",notInvitedToRoomTitle:"Na pas t invit  la salle",peopleButtonLabel:"Personnes",selectedPeopleButtonLabel:"Bouton Contacts slectionn",peoplePaneTitle:"Personnes",peoplePaneMoreButtonAriaLabel:"Autres",peopleButtonTooltipOpen:"Afficher les participants",peopleButtonTooltipClose:"Masquer les participants",peoplePaneSubTitle:"Dans cet appel {numberOfPeople}",privacyPolicy:"Politique de confidentialit",rejoinCallButtonLabel:"Rejoindre lappel  nouveau.",removedFromCallMoreDetails:"Un autre participant vous a supprim de lappel.",removedFromCallTitle:"Vous avez t supprim.",removeMenuLabel:"Supprimer",startSpotlightParticipantListMenuLabel:"Mettre en vidence pour tout le monde",addSpotlightParticipantListMenuLabel:"Ajouter la mise en vidence",stopSpotlightParticipantListMenuLabel:"Arrter la mise en vidence",stopSpotlightOnSelfParticipantListMenuLabel:"Quitter la mise en vidence",spotlightLimitReachedParticipantListMenuTitle:"Limite Spotlight atteinte",stopAllSpotlightMenuLabel:"Arrtez tous les projecteurs",returnToCallButtonAriaDescription:"Revenir  lappel",returnToCallButtonAriaLabel:"Prcdent",roomNotFoundDetails:"LID de la salle fourni est introuvable.",roomNotFoundTitle:"Salle introuvable",roomNotValidDetails:"Cette salle nest pas valide pour linstant.",roomNotValidTitle:"Salle non valide",inviteToRoomRemovedDetails:"Votre invitation  rejoindre cette salle a t supprime.",inviteToRoomRemovedTitle:"Invitation  la salle supprime",soundLabel:"Son",noMicrophonesLabel:"Aucun microphone trouv",noSpeakersLabel:"Aucun haut-parleur trouv",startCallButtonLabel:"Lancer l'appel",openDialpadButtonLabel:"Composer le numro de tlphone",peoplePaneAddPeopleButtonLabel:"Ajouter des personnes",dialpadStartCallButtonLabel:"Appeler",dialpadModalTitle:"Composer le numro de tlphone",dialpadModalAriaLabel:"Pav numrique",dialpadCloseModalButtonAriaLabel:"Fermer le pav numrique",moreButtonCallingLabel:"Plus",resumeCallButtonLabel:"Reprendre",resumingCallButtonLabel:"Reprise...",resumeCallButtonAriaLabel:"Reprendre lappel",resumingCallButtonAriaLabel:"Reprendre lappel",holdScreenLabel:"Vous avez t mis(e) en attente.",openDtmfDialpadLabel:"Afficher le pav numrique",dtmfDialpadPlaceholderText:"Saisir un numro",outboundCallingNoticeString:"Appel en cours...",participantJoinedNoticeString:"{displayName} a rejoint",twoParticipantJoinedNoticeString:"{displayName1} et {displayName2} ont rejoint",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} et {displayName3} ont rejoint",participantLeftNoticeString:"{displayName} a quitt",twoParticipantLeftNoticeString:"{displayName1} et {displayName2} sont partis",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} et {displayName3} ont quitt",unnamedParticipantString:"participant sans nom",manyUnnamedParticipantsJoined:"participant sans nom et {numOfParticipants} autres participants ont rejoint",manyUnnamedParticipantsLeft:"participant sans nom et {numOfParticipants} autres participants ont quitt",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} et {numOfParticipants} autres participants ont rejoint",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} et {numOfParticipants} autres participants restants",liveCaptionsLabel:"Sous-titres en direct",captionsSettingsLabel:"Paramtres de sous-titres",startCaptionsButtonOnLabel:"Activer les sous-titres",startCaptionsButtonOffLabel:"Dsactiver les sous-titres",startCaptionsButtonTooltipOnContent:"Dsactiver les sous-titres",startCaptionsButtonTooltipOffContent:"Activer les sous-titres",captionsSettingsModalTitle:"Paramtres des sous-titres",captionsSettingsSpokenLanguageDropdownLabel:"Langue parle",captionsSettingsCaptionLanguageDropdownLabel:"Langue des sous-titres",captionsSettingsSpokenLanguageDropdownInfoText:"Langue parle par tous les participants  cet appel.",captionsSettingsCaptionLanguageDropdownInfoText:"Les sous-titres apparatront dans cette langue.",captionsSettingsConfirmButtonLabel:"Confirmer",captionsSettingsCancelButtonLabel:"Annuler",captionsSettingsModalAriaLabel:"Paramtrage des lgendes Modal",captionsSettingsCloseModalButtonAriaLabel:"Paramtres de fermeture des sous-titres",captionsBannerMoreButtonCallingLabel:"Plus",captionsBannerMoreButtonTooltip:"Autres options",dismissModalAriaLabel:"Image et image locales et distantes, appuyez sur entre pour revenir  l'appel",callRejectedTitle:"Nous navons pas pu effectuer lappel",callRejectedMoreDetails:"La personne que vous essayez de rejoindre nest pas disponible. Veuillez ressayer plus tard.",callTimeoutTitle:"Nous navons pas pu effectuer lappel",callTimeoutDetails:"La personne que vous essayez de rejoindre nest pas disponible. Veuillez ressayer plus tard.",callTimeoutBotTitle:"Nous navons pas pu effectuer lappel",callTimeoutBotDetails:"Le service que vous essayez datteindre nest pas disponible. Veuillez ressayer plus tard.",dtmfDialerButtonLabel:"Clavier",dtmfDialerButtonTooltipOn:"Afficher le pav numrique",dtmfDialerButtonTooltipOff:"Masquez le pav de numrotation",dtmfDialerMoreButtonLabelOn:"Afficher le pav numrique",dtmfDialerMoreButtonLabelOff:"Masquez le pav de numrotation",spokenLanguageStrings:{"ar-ae":"Arabe  E.A.U.","ar-sa":"Arabe  Arabie saoudite","da-dk":"Danois","de-de":"Allemand  Allemagne","en-au":"Anglais  Australie","en-ca":"Anglais  Canada","en-gb":"Anglais  Royaume-Uni","en-in":"Anglais  Inde","en-nz":"Anglais  Nouvelle-Zlande","en-us":"Anglais  tats-Unis","es-es":"Espagnol  Espagne (tri moderne)","es-mx":"Espagnol  Mexique","fi-fi":"Finnois","fr-ca":"Franais  Canada","fr-fr":"Franais  France","hi-in":"Hindi","it-it":"Italien  Italie","ja-jp":"Japonais","ko-kr":"Coren","nb-no":"Norvgien (Bokml)","nl-be":"Nerlandais  Belgique","nl-nl":"Nerlandais  Pays-Bas","pl-pl":"Polonais","pt-br":"Portugais  Brsil","ru-ru":"Russe","sv-se":"Sudois","zh-cn":"Chinois  Rpublique populaire de Chine","zh-hk":"Chinois  Hong Kong SAR","cs-cz":"Tchque","pt-pt":"Portugais  Portugal","tr-tr":"Turc","vi-vn":"Vietnamien","th-th":"Tha","he-il":"Hbreu","cy-gb":"Gallois","uk-ua":"Ukrainien","el-gr":"Grec","hu-hu":"Hongrois","ro-ro":"Roumain","sk-sk":"Slovaque","zh-tw":"Chinois  Taiwan"},captionLanguageStrings:{ar:"Arabe",da:"Danois",de:"Allemand",en:"Anglais",es:"Espagnol",fi:"Finnois","fr-ca":"Franais  Canada",fr:"Franais  France",hi:"Hindi",it:"Italien",ja:"Japonais",ko:"Coren",nb:"Norvgien (Bokml)",nl:"Nerlandais",pl:"Polonais",pt:"Portugais  Brsil",ru:"Russe",sv:"Sudois","zh-Hans":"Chinois (simplifi)","zh-Hant":"Chinois (traditionnel)",cs:"Tchque","pt-pt":"Portugais  Portugal",tr:"Turc",vi:"Vietnamien",th:"Tha",he:"Hbreu",cy:"Gallois",uk:"Ukrainien",el:"Grec",hu:"Hongrois",ro:"Roumain",sk:"Slovaque"},captionsBannerSpinnerText:"Dmarrage des sous-titres...",transferPageTransferorText:"Transfert en cours...",transferPageTransferTargetText:"Connexion en cours...",transferPageUnknownTransferorDisplayName:"Inconnu",transferPageUnknownTransferTargetDisplayName:"Inconnu",transferPageNoticeString:"Vous tes en cours de transfert",participantCouldNotBeReachedTitle:"Le participant cible nest pas disponible actuellement",participantCouldNotBeReachedMoreDetails:"Contactez le participant lorsquil est disponible",permissionToReachTargetParticipantNotAllowedTitle:"Lautorisation datteindre le participant cible nest pas autorise",permissionToReachTargetParticipantNotAllowedMoreDetails:"Veuillez case active que le participant cible se trouve dans le mme client",unableToResolveTenantTitle:"Impossible de rsoudre lID de locataire pour le participant cible",unableToResolveTenantMoreDetails:"Veuillez case active lID de participant est entr correctement",participantIdIsMalformedTitle:"Le format de lID de participant nest pas correct",participantIdIsMalformedMoreDetails:"Veuillez case active que le format de lID de participant est correct",moreButtonGalleryControlLabel:"Afficher",moreButtonGalleryPositionToggleLabel:"Dplacer la galerie vers le haut",moreButtonGallerySpeakerLayoutLabel:"Haut-parleur",moreButtonGalleryFloatingLocalLayoutLabel:"Dynamique",moreButtonGalleryDefaultLayoutLabel:"Vue Galerie",moreButtonGalleryFocusedContentLayoutLabel:"Focalisation sur le contenu",moreButtonLargeGalleryDefaultLayoutLabel:"Grande galerie",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Votre camra a t dsactive. Vous ne pouvez plus partager de vido.",grantedDueToMeetingOption:"Votre camra a t active. Activez-la si vous souhaitez partager la vido."},unmuteMic:{lostDueToMeetingOption:"Votre micro a t dsactiv. Vous ne pouvez plus activer le son.",grantedDueToMeetingOption:"Votre microphone a t activ. Activez le microphone pour parler."},shareScreen:{lostDueToRoleChangeToAttendee:"Votre rle a t modifi. Certaines actions, telles que le partage de contenu, ne seront pas disponibles pour vous.",grantedDueToRoleChangeToPresenter:"Vous tes prsentateur. Vous pouvez partager du contenu et organiser la runion."}},surveyTitle:"Aidez-nous  nous amliorer",starSurveyHelperText:"Quelle a t la qualit globale de cet appel ?",starSurveyOneStarText:"La qualit tait mauvaise.",starSurveyTwoStarText:"La qualit tait mauvaise.",starSurveyThreeStarText:"La qualit tait bonne.",starSurveyFourStarText:"La qualit tait excellente.",starSurveyFiveStarText:"La qualit tait excellente.",surveyConfirmButtonLabel:"Envoyer des commentaires",starRatingAriaLabel:"Slectionner {0} toiles sur {1}",surveySkipButtonLabel:"Ignorer",tagsSurveyQuestion:"Que pouvons-nous amliorer?",tagsSurveyTextFieldDefaultText:"Autre, veuillez prciser",tagsSurveyHelperText:"Cochez les problmes que vous avez rencontrs",surveyTextboxDefaultText:"Autre, veuillez prciser",endOfSurveyText:"Merci pour vos commentaires!",surveyIssues:{overallRating:{callCannotJoin:"Je nai pas pu rejoindre lappel",callCannotInvite:"Je nai pas pu inviter dautres personnes  participer  lappel",hadToRejoin:"Jai d rejoindre lappel",callEndedUnexpectedly:"Lappel sest termin pour moi de manire inattendue",otherIssues:"Javais dautres problmes avec lappel"},audioRating:{noLocalAudio:"Mon interlocuteur n'entendait aucun son",noRemoteAudio:"Je n'entendais aucun son",echo:"Jai entendu des chos lors de lappel",audioNoise:"Il y avait des bruits parasites",lowVolume:"Le volume tait faible",audioStoppedUnexpectedly:"Laudio sest arrt de manire inattendue",distortedSpeech:"Laudio a t altr",audioInterruption:"Laudio a t interrompu",otherIssues:"Jai rencontr dautres problmes audio pendant cet appel"},videoRating:{noVideoReceived:"La vido ne s'affichait pas sur mon cran",noVideoSent:"Les autres personnes nont pas pu me voir",lowQuality:"La qualit de la vido tait faible",freezes:"Vido fige",stoppedUnexpectedly:"La vido s'est arrte de manire inattendue",darkVideoReceived:"Je ne vois que des crans sombres lorsque d'autres personnes allument leur camra",audioVideoOutOfSync:"Laudio et la vido ntaient pas synchroniss",otherIssues:"Jai rencontr dautres problmes vido pendant cet appel"},screenshareRating:{noContentLocal:"Les autres personnes nont pas pu voir mon partage dcran",noContentRemote:"Je nai pas pu voir le partage dcran dautres personnes",cannotPresent:"Je nai pas pu prsenter mon cran",lowQuality:"La qualit du partage dcran tait faible",freezes:"Partage dcran fig",stoppedUnexpectedly:"Le partage dcran sest arrt de manire inattendue",largeDelay:"Le partage dcran a un retard important",otherIssues:"Je rencontre dautres problmes de partage dcran dans cet appel"}},SurveyIssuesHeadingStrings:{overallRating:"Globale",audioRating:"Audio",videoRating:"Vido",screenshareRating:"En prsentation"},spotlightPrompt:{startSpotlightHeading:"Mettre en vidence pour tout le monde ?",startSpotlightText:"Votre vido ne sera plus mise en surbrillance pour tous les participants  la runion.",startSpotlightOnSelfText:"Vous mettez en surbrillance votre vido pour tous les participants  la runion.",startSpotlightConfirmButtonLabel:"Mettre en vidence pour tout le monde",startSpotlightCancelButtonLabel:"Annuler",stopSpotlightHeading:"Arrter la mise en vidence de cette vido?",stopSpotlightOnSelfHeading:"Quitter la mise en vidence ?",stopSpotlightText:"Cette vido ne sera plus mise en vidence pour tous les participants  la runion.",stopSpotlightOnSelfText:"Votre vido ne sera plus mise en surbrillance pour tous les participants  la runion.",stopSpotlightConfirmButtonLabel:"Arrter la mise en vidence",stopSpotlightOnSelfConfirmButtonLabel:"Quitter la mise en vidence",stopSpotlightCancelButtonLabel:"Annuler"},exitSpotlightButtonLabel:"Quitter la mise en vidence",exitSpotlightButtonTooltip:"Quitter la mise en vidence"};var chat$d={chatListHeader:"Dans cette conversation",uploadFile:"Charger un fichier"};var callWithChat$d={chatButtonLabel:"Clavardage",chatButtonNewMessageNotificationLabel:"Nouveau message",chatButtonTooltipClosedWithMessageCount:"Afficher la conversation ({unreadMessagesCount} non lu)",chatButtonTooltipClose:"Masquer la conversation",chatButtonTooltipOpen:"Afficher la conversation",chatPaneTitle:"Clavardage",copyInviteLinkButtonLabel:"Copier le lien d'invitation",copyInviteLinkActionedAriaLabel:"Le lien dinvitation a t copi.",dismissSidePaneButtonLabel:"Fermer",moreDrawerAudioDeviceMenuTitle:"Priphrique audio",moreDrawerButtonLabel:"Autres options",moreDrawerButtonTooltip:"Autres options",moreDrawerMicrophoneMenuTitle:"Microphone",moreDrawerSpeakerMenuTitle:"Haut-parleur",moreDrawerCaptionsMenuTitle:"Sous-titres en direct",moreDrawerSpokenLanguageMenuTitle:"Langue parle",moreDrawerCaptionLanguageMenuTitle:"Langue des sous-titres",moreDrawerGalleryOptionsMenuTitle:"Options de galerie",peopleButtonLabel:"Personnes",selectedPeopleButtonLabel:"Bouton Contacts slectionn",peopleButtonTooltipOpen:"Afficher les participants",peopleButtonTooltipClose:"Masquer les participants",peoplePaneSubTitle:"Pendant cet appel",peoplePaneTitle:"Personnes",pictureInPictureTileAriaLabel:"Flux vido. Cliquez pour revenir  lcran dappel.",removeMenuLabel:"Supprimer",openDialpadButtonLabel:"Composer le numro de tlphone",returnToCallButtonAriaDescription:"Revenir  lappel",returnToCallButtonAriaLabel:"Prcdent",peoplePaneAddPeopleButtonLabel:"Ajouter des personnes",dialpadStartCallButtonLabel:"Appeler",dialpadModalTitle:"Composer le numro de tlphone",dialpadModalAriaLabel:"Pav numrique",dialpadCloseModalButtonAriaLabel:"Fermer le pav numrique",openDtmfDialpadLabel:"Afficher le pav numrique",dtmfDialpadPlaceholderText:"Saisir un numro"};var fr_FR = {call:call$d,chat:chat$d,callWithChat:callWithChat$d};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for French (France)
 *
 * @public
 */
const COMPOSITE_LOCALE_FR_FR = {
    component: COMPONENT_LOCALE_FR_FR,
    strings: createCompositeStrings(fr_FR)
};

var call$c={cameraLabel:"",noCamerasLabel:"  ",cameraPermissionDenied:"      ",cameraTurnedOff:"  ",chatButtonLabel:"'",close:"",complianceBannerNowOnlyRecording:"     .",complianceBannerNowOnlyTranscription:"     .",complianceBannerRecordingAndTranscriptionSaved:"   .",complianceBannerRecordingAndTranscriptionStarted:"  .",complianceBannerRecordingAndTranscriptionStopped:"  .",complianceBannerRecordingSaving:" .",complianceBannerRecordingStarted:" .",complianceBannerRecordingStopped:" .",complianceBannerTranscriptionStarted:" .",complianceBannerTranscriptionConsent:"- ,      .",complianceBannerTranscriptionSaving:"    .",complianceBannerTranscriptionStopped:" .",configurationPageTitle:" ",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"  ",defaultPlaceHolder:" ",dismissSidePaneButtonLabel:"",videoEffectsPaneTitle:"",videoEffectsPaneBackgroundSelectionTitle:"",configurationPageVideoEffectsButtonLabel:"",unableToStartVideoEffect:"    .",blurBackgroundEffectButtonLabel:"",blurBackgroundTooltip:" ",removeBackgroundEffectButtonLabel:"",removeBackgroundTooltip:" ",cameraOffBackgroundEffectWarningText:"  .       .",failedToJoinCallDueToNoNetworkMoreDetails:"    .      .",failedToJoinCallDueToNoNetworkTitle:" ",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"    .    ,   .",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"  ",learnMore:" ",leavingCallTitle:"...",leftCallMoreDetails:"   ,   .",leftCallTitle:"  '",lobbyScreenConnectingToCallTitle:" ",lobbyScreenWaitingToBeAdmittedTitle:"  ",microphonePermissionDenied:"      ",microphoneToggleInLobbyNotAllowed:"       .",mutedMessage:" ",networkReconnectMoreDetails:"  .     .",networkReconnectTitle:"",notInvitedToRoomDetails:"         .",notInvitedToRoomTitle:"  ",peopleButtonLabel:"",selectedPeopleButtonLabel:" '' ",peoplePaneTitle:"",peoplePaneMoreButtonAriaLabel:"",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:"  {numberOfPeople}",privacyPolicy:" ",rejoinCallButtonLabel:"  ",removedFromCallMoreDetails:"    .",removedFromCallTitle:"",removeMenuLabel:"",startSpotlightParticipantListMenuLabel:"   ",addSpotlightParticipantListMenuLabel:" ",stopSpotlightParticipantListMenuLabel:"  ",stopSpotlightOnSelfParticipantListMenuLabel:" ",spotlightLimitReachedParticipantListMenuTitle:"  ",stopAllSpotlightMenuLabel:"    ",returnToCallButtonAriaDescription:" ",returnToCallButtonAriaLabel:"",roomNotFoundDetails:"    .",roomNotFoundTitle:"  ",roomNotValidDetails:"    .",roomNotValidTitle:"  ",inviteToRoomRemovedDetails:"     .",inviteToRoomRemovedTitle:"  ",soundLabel:"",noMicrophonesLabel:"  ",noSpeakersLabel:"  ",startCallButtonLabel:" ",openDialpadButtonLabel:"  ",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"  ",dialpadModalAriaLabel:" ",dialpadCloseModalButtonAriaLabel:"  ",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"...",resumeCallButtonAriaLabel:" ",resumingCallButtonAriaLabel:" ",holdScreenLabel:" ",openDtmfDialpadLabel:"  ",dtmfDialpadPlaceholderText:" ",outboundCallingNoticeString:"...",participantJoinedNoticeString:"{displayName} /",twoParticipantJoinedNoticeString:"{displayName1} {displayName2} ",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} {displayName3} ",participantLeftNoticeString:"{displayName} /",twoParticipantLeftNoticeString:"{displayName1} {displayName2} ",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} {displayName3} ",unnamedParticipantString:"/  ",manyUnnamedParticipantsJoined:"/   {numOfParticipants}   ",manyUnnamedParticipantsLeft:"/   {numOfParticipants}  ",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} {numOfParticipants}   ",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} {numOfParticipants}   ",liveCaptionsLabel:" ",captionsSettingsLabel:" ",startCaptionsButtonOnLabel:" ",startCaptionsButtonOffLabel:" ",startCaptionsButtonTooltipOnContent:" ",startCaptionsButtonTooltipOffContent:" ",captionsSettingsModalTitle:" ",captionsSettingsSpokenLanguageDropdownLabel:" ",captionsSettingsCaptionLanguageDropdownLabel:" ",captionsSettingsSpokenLanguageDropdownInfoText:"    .",captionsSettingsCaptionLanguageDropdownInfoText:"   .",captionsSettingsConfirmButtonLabel:"",captionsSettingsCancelButtonLabel:"",captionsSettingsModalAriaLabel:"  ",captionsSettingsCloseModalButtonAriaLabel:"  ",captionsBannerMoreButtonCallingLabel:"",captionsBannerMoreButtonTooltip:" ",dismissModalAriaLabel:"   ,   Enter   .",callRejectedTitle:"     .",callRejectedMoreDetails:"      .    .",callTimeoutTitle:"     .",callTimeoutDetails:"      .    .",callTimeoutBotTitle:"     .",callTimeoutBotDetails:"      .    .",dtmfDialerButtonLabel:" ",dtmfDialerButtonTooltipOn:"  ",dtmfDialerButtonTooltipOff:"  ",dtmfDialerMoreButtonLabelOn:"  ",dtmfDialerMoreButtonLabelOff:"  ",spokenLanguageStrings:{"ar-ae":" -  ","ar-sa":" -  ","da-dk":"","de-de":" - ","en-au":" - ","en-ca":" - ","en-gb":" - ","en-in":" - ","en-nz":" -  ","en-us":" -  ","es-es":" -  ( )","es-mx":" - ","fi-fi":"","fr-ca":" - ","fr-fr":" - ","hi-in":"","it-it":" - ","ja-jp":"","ko-kr":"","nb-no":" ()","nl-be":" - ","nl-nl":" - ","pl-pl":"","pt-br":" - ","ru-ru":"","sv-se":"","zh-cn":" -    ","zh-hk":" -  ","cs-cz":"","pt-pt":" - ","tr-tr":"","vi-vn":"","th-th":"","he-il":"","cy-gb":"","uk-ua":"","el-gr":"","hu-hu":"","ro-ro":"","sk-sk":"","zh-tw":" - "},captionLanguageStrings:{ar:"",da:"",de:"",en:"",es:"",fi:"","fr-ca":" - ",fr:" - ",hi:"",it:"",ja:"",ko:"",nb:" ()",nl:"",pl:"",pt:" - ",ru:"",sv:"","zh-Hans":" ()","zh-Hant":" ()",cs:"","pt-pt":" - ",tr:"",vi:"",th:"",he:"",cy:"",uk:"",el:"",hu:"",ro:"",sk:""},captionsBannerSpinnerText:" ...",transferPageTransferorText:"...",transferPageTransferTargetText:"...",transferPageUnknownTransferorDisplayName:" ",transferPageUnknownTransferTargetDisplayName:" ",transferPageNoticeString:"  ",participantCouldNotBeReachedTitle:"    ",participantCouldNotBeReachedMoreDetails:"    ",permissionToReachTargetParticipantNotAllowedTitle:"    ",permissionToReachTargetParticipantNotAllowedMoreDetails:"     ",unableToResolveTenantTitle:"       ",unableToResolveTenantMoreDetails:"    ",participantIdIsMalformedTitle:"    ",participantIdIsMalformedMoreDetails:"     ",moreButtonGalleryControlLabel:"",moreButtonGalleryPositionToggleLabel:"    ",moreButtonGallerySpeakerLayoutLabel:"",moreButtonGalleryFloatingLocalLayoutLabel:"",moreButtonGalleryDefaultLayoutLabel:" ",moreButtonGalleryFocusedContentLayoutLabel:" ",moreButtonLargeGalleryDefaultLayoutLabel:" ",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"    .     .",grantedDueToMeetingOption:"   .      ."},unmuteMic:{lostDueToMeetingOption:"    .     .",grantedDueToMeetingOption:"   .      ."},shareScreen:{lostDueToRoleChangeToAttendee:"  .  ,   ,    .",grantedDueToRoleChangeToPresenter:" .     ."}},surveyTitle:"  ",starSurveyHelperText:"     ?",starSurveyOneStarText:"  .",starSurveyTwoStarText:"  .",starSurveyThreeStarText:"  .",starSurveyFourStarText:"  .",starSurveyFiveStarText:"  .",surveyConfirmButtonLabel:" ",starRatingAriaLabel:" {0}  {1} ",surveySkipButtonLabel:"",tagsSurveyQuestion:"     ?",tagsSurveyTextFieldDefaultText:",  ",tagsSurveyHelperText:"     ",surveyTextboxDefaultText:",  ",endOfSurveyText:"  !",surveyIssues:{overallRating:{callCannotJoin:"   ",callCannotInvite:"    ",hadToRejoin:"    ",callEndedUnexpectedly:"     ",otherIssues:"   "},audioRating:{noLocalAudio:"       ",noRemoteAudio:"    ",echo:"   ",audioNoise:"  ",lowVolume:"   ",audioStoppedUnexpectedly:"    ",distortedSpeech:"  ",audioInterruption:" ",otherIssues:"     "},videoRating:{noVideoReceived:"    ",noVideoSent:"     ",lowQuality:"   ",freezes:" ",stoppedUnexpectedly:"    ",darkVideoReceived:"           ",audioVideoOutOfSync:"    ",otherIssues:"     "},screenshareRating:{noContentLocal:"        ",noContentRemote:"        ",cannotPresent:"     ",lowQuality:"    ",freezes:"  ",stoppedUnexpectedly:"     ",largeDelay:"    ",otherIssues:"      "}},SurveyIssuesHeadingStrings:{overallRating:" ",audioRating:"  ",videoRating:"",screenshareRating:""},spotlightPrompt:{startSpotlightHeading:"   ?",startSpotlightText:"       .",startSpotlightOnSelfText:"        .",startSpotlightConfirmButtonLabel:"   ",startSpotlightCancelButtonLabel:"",stopSpotlightHeading:"    ?",stopSpotlightOnSelfHeading:" ?",stopSpotlightText:"        .",stopSpotlightOnSelfText:"         .",stopSpotlightConfirmButtonLabel:"  ",stopSpotlightOnSelfConfirmButtonLabel:" ",stopSpotlightCancelButtonLabel:""},exitSpotlightButtonLabel:" ",exitSpotlightButtonTooltip:" "};var chat$c={chatListHeader:"' ",uploadFile:" "};var callWithChat$c={chatButtonLabel:"'",chatButtonNewMessageNotificationLabel:" ",chatButtonTooltipClosedWithMessageCount:" ' ({unreadMessagesCount}  )",chatButtonTooltipClose:" ",chatButtonTooltipOpen:" '",chatPaneTitle:"'",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"  ",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:" ",moreDrawerButtonLabel:" ",moreDrawerButtonTooltip:" ",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",moreDrawerCaptionsMenuTitle:" ",moreDrawerSpokenLanguageMenuTitle:" ",moreDrawerCaptionLanguageMenuTitle:" ",moreDrawerGalleryOptionsMenuTitle:" ",peopleButtonLabel:"",selectedPeopleButtonLabel:" '' ",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:" ",peoplePaneTitle:"",pictureInPictureTileAriaLabel:" .     .",removeMenuLabel:"",openDialpadButtonLabel:"  ",returnToCallButtonAriaDescription:" ",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"  ",dialpadModalAriaLabel:" ",dialpadCloseModalButtonAriaLabel:"  ",openDtmfDialpadLabel:"  ",dtmfDialpadPlaceholderText:" "};var he_IL = {call:call$c,chat:chat$c,callWithChat:callWithChat$c};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Hebrew (Israel)
 *
 * @public
 */
const COMPOSITE_LOCALE_HE_IL = {
    component: COMPONENT_LOCALE_HE_IL,
    strings: createCompositeStrings(he_IL)
};

var call$b={cameraLabel:"Fotocamera",noCamerasLabel:"Nessuna fotocamera trovata",cameraPermissionDenied:"Il browser blocca l'accesso alla fotocamera",cameraTurnedOff:"La videocamera  disabilitata",chatButtonLabel:"Chat",close:"Chiudi",complianceBannerNowOnlyRecording:" in corso la registrazione solo di questa riunione.",complianceBannerNowOnlyTranscription:" in corso la trascrizione solo di questa riunione.",complianceBannerRecordingAndTranscriptionSaved:" in corso il salvataggio della registrazione e della trascrizione.",complianceBannerRecordingAndTranscriptionStarted:"Registrazione e trascrizione avviate.",complianceBannerRecordingAndTranscriptionStopped:"Registrazione e trascrizione interrotte.",complianceBannerRecordingSaving:"Salvataggio della registrazione in corso.",complianceBannerRecordingStarted:"Registrazione avviata.",complianceBannerRecordingStopped:"Registrazione arrestata.",complianceBannerTranscriptionStarted:"Trascrizione avviata.",complianceBannerTranscriptionConsent:"Partecipando, fornisci il consenso per la trascrizione di questa riunione.",complianceBannerTranscriptionSaving:" in corso il salvataggio della trascrizione.",complianceBannerTranscriptionStopped:"Trascrizione interrotta.",configurationPageTitle:"Avvia una chiamata",copyInviteLinkButtonLabel:"Copia il collegamento dellinvito",copyInviteLinkActionedAriaLabel:"Collegamento di invito copiato",defaultPlaceHolder:"Seleziona un'opzione",dismissSidePaneButtonLabel:"Chiudi",videoEffectsPaneTitle:"Effetti",videoEffectsPaneBackgroundSelectionTitle:"In background",configurationPageVideoEffectsButtonLabel:"Effetti",unableToStartVideoEffect:"Non  possibile applicare l'effetto video.",blurBackgroundEffectButtonLabel:"Sfocatura",blurBackgroundTooltip:"Sfoca sfondo",removeBackgroundEffectButtonLabel:"Nessuno",removeBackgroundTooltip:"Rimuovi sfondo",cameraOffBackgroundEffectWarningText:"La fotocamera  disattivata. Attiva la fotocamera per vedere l'effetto video.",failedToJoinCallDueToNoNetworkMoreDetails:"La chiamata  stata disconnessa a causa di un problema di rete. Controlla la connessione e partecipa di nuovo.",failedToJoinCallDueToNoNetworkTitle:"Chiamata interrotta",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Non ti  stato concesso laccesso alla chiamata. Se si  trattato di un errore, partecipa di nuovo alla chiamata.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Ignorato dalla sala di attesa",learnMore:"Ulteriori informazioni",leavingCallTitle:"In uscita...",leftCallMoreDetails:"Se si  trattato di un errore, partecipa di nuovo alla chiamata.",leftCallTitle:"Hai abbandonato la chiamata",lobbyScreenConnectingToCallTitle:"Partecipazione alla chiamata",lobbyScreenWaitingToBeAdmittedTitle:"In attesa di essere ammessi",microphonePermissionDenied:"Il browser blocca l'accesso al microfono",microphoneToggleInLobbyNotAllowed:"Impossibile attivare o disattivare l'audio nella sala di attesa.",mutedMessage:"L'audio  disattivato.",networkReconnectMoreDetails:"Sembra si sia verificato un errore. Stiamo cercando di ristabilire la connessione alla chiamata.",networkReconnectTitle:"Attendi",notInvitedToRoomDetails:"Non puoi partecipare a questa chat room perch non hai un invito.",notInvitedToRoomTitle:"Non invitato alla stanza",peopleButtonLabel:"Persone",selectedPeopleButtonLabel:"Pulsante Persone selezionato",peoplePaneTitle:"Persone",peoplePaneMoreButtonAriaLabel:"Altro",peopleButtonTooltipOpen:"Mostra partecipanti",peopleButtonTooltipClose:"Nascondi partecipanti",peoplePaneSubTitle:"In questa chiamata {numberOfPeople}",privacyPolicy:"Informativa sulla privacy",rejoinCallButtonLabel:"Partecipa alla chiamata",removedFromCallMoreDetails:"Un altro partecipante ti ha rimosso dalla chiamata.",removedFromCallTitle:"Sei stato rimosso",removeMenuLabel:"Rimuovi",startSpotlightParticipantListMenuLabel:"Metti in evidenza per tutti",addSpotlightParticipantListMenuLabel:"Metti in evidenza",stopSpotlightParticipantListMenuLabel:"Interrompi la posizione in evidenza",stopSpotlightOnSelfParticipantListMenuLabel:"Chiudi visualizzazione in evidenza",spotlightLimitReachedParticipantListMenuTitle:" stato raggiunto il limite di contenuti in evidenza",stopAllSpotlightMenuLabel:"Smetti di mostrare in evidenza",returnToCallButtonAriaDescription:"Torna alla chiamata",returnToCallButtonAriaLabel:"Indietro",roomNotFoundDetails:"L'ID stanza specificato non  stato trovato.",roomNotFoundTitle:"La stanza non  stata trovata",roomNotValidDetails:"Questa stanza non  valida in questo momento.",roomNotValidTitle:"Stanza non valida",inviteToRoomRemovedDetails:"L'invito a partecipare a questa stanza  stato rimosso.",inviteToRoomRemovedTitle:"Linvito alla stanza  stato rimosso",soundLabel:"Suono",noMicrophonesLabel:"Nessun microfono trovato",noSpeakersLabel:"Nessun altoparlante trovato",startCallButtonLabel:"Avvia chiamata",openDialpadButtonLabel:"Componi il numero di telefono",peoplePaneAddPeopleButtonLabel:"Aggiungi persone",dialpadStartCallButtonLabel:"Chiamata",dialpadModalTitle:"Componi il numero di telefono",dialpadModalAriaLabel:"Tastiera",dialpadCloseModalButtonAriaLabel:"Chiudi tastiera",moreButtonCallingLabel:"Altro",resumeCallButtonLabel:"Riprendi",resumingCallButtonLabel:"Ripresa in corso...",resumeCallButtonAriaLabel:"Riprendi chiamata",resumingCallButtonAriaLabel:"Riprendi chiamata",holdScreenLabel:"In attesa.",openDtmfDialpadLabel:"Mostra tastiera",dtmfDialpadPlaceholderText:"Immetti il numero",outboundCallingNoticeString:"Chiamata in corso...",participantJoinedNoticeString:"{displayName} si  unito alla riunione",twoParticipantJoinedNoticeString:"{displayName1} e {displayName2} si sono uniti alla riunione",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} e {displayName3} si sono uniti alla riunione",participantLeftNoticeString:"{displayName}  uscito dalla riunione",twoParticipantLeftNoticeString:"{displayName1} e {displayName2} sono usciti dalla riunione",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} e {displayName3} sono usciti dalla riunione",unnamedParticipantString:"partecipante senza nome",manyUnnamedParticipantsJoined:"partecipante senza nome e {numOfParticipants} altri partecipanti si sono uniti alla riunione",manyUnnamedParticipantsLeft:"partecipante senza nome e {numOfParticipants} altri partecipanti sono usciti dalla riunione",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} e {numOfParticipants} altri partecipanti si sono uniti",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} e {numOfParticipants} altri partecipanti rimasti",liveCaptionsLabel:"Sottotitoli in tempo reale",captionsSettingsLabel:"Impostazioni sottotitoli",startCaptionsButtonOnLabel:"Attiva i sottotitoli",startCaptionsButtonOffLabel:"Disabilita sottotitoli",startCaptionsButtonTooltipOnContent:"Disabilita sottotitoli",startCaptionsButtonTooltipOffContent:"Attiva i sottotitoli",captionsSettingsModalTitle:"Impostazioni sottotitoli",captionsSettingsSpokenLanguageDropdownLabel:"Lingua parlata",captionsSettingsCaptionLanguageDropdownLabel:"Lingua dei sottotitoli",captionsSettingsSpokenLanguageDropdownInfoText:"La lingua che parlano tutti i partecipanti a questa chiamata.",captionsSettingsCaptionLanguageDropdownInfoText:"I sottotitoli verranno visualizzati in questa lingua.",captionsSettingsConfirmButtonLabel:"Conferma",captionsSettingsCancelButtonLabel:"Annulla",captionsSettingsModalAriaLabel:"Finestra modale impostazioni sottotitoli",captionsSettingsCloseModalButtonAriaLabel:"Chiudi impostazione sottotitoli",captionsBannerMoreButtonCallingLabel:"Altro",captionsBannerMoreButtonTooltip:"Altre opzioni",dismissModalAriaLabel:"Immagine e immagine locale e remota, premi INVIO per tornare alla chiamata",callRejectedTitle:"Non  stato possibile completare la chiamata",callRejectedMoreDetails:"La persona che stai tentando di raggiungere non  disponibile. Riprovare pi tardi.",callTimeoutTitle:"Non  stato possibile completare la chiamata",callTimeoutDetails:"La persona che stai tentando di raggiungere non  disponibile. Riprovare pi tardi.",callTimeoutBotTitle:"Non  stato possibile completare la chiamata",callTimeoutBotDetails:"Il servizio che si sta tentando di raggiungere non  disponibile. Riprovare pi tardi.",dtmfDialerButtonLabel:"Tastiera",dtmfDialerButtonTooltipOn:"Mostra tastiera",dtmfDialerButtonTooltipOff:"Nascondi tastierino",dtmfDialerMoreButtonLabelOn:"Mostra tastiera",dtmfDialerMoreButtonLabelOff:"Nascondi tastierino",spokenLanguageStrings:{"ar-ae":"Arabo - Emirati Arabi Uniti","ar-sa":"Arabo - Arabia Saudita","da-dk":"Danese","de-de":"Tedesco - Germania","en-au":"Inglese - Australia","en-ca":"Inglese - Canada","en-gb":"Inglese - Regno Unito","en-in":"Inglese - India","en-nz":"Inglese - Nuova Zelanda","en-us":"Inglese - Stati Uniti","es-es":"Spagnolo - Spagna (ordinamento moderno)","es-mx":"Spagnolo - Messico","fi-fi":"Finlandese","fr-ca":"Francese - Canada","fr-fr":"Francese - Francia","hi-in":"Hindi","it-it":"Italiano - Italia","ja-jp":"Giapponese","ko-kr":"Coreano","nb-no":"Norvegese (Bokml)","nl-be":"Olandese - Belgio","nl-nl":"Olandese - Paesi Bassi","pl-pl":"Polacco","pt-br":"Portoghese - Brasile","ru-ru":"Russo","sv-se":"Svedese","zh-cn":"Cinese - Repubblica popolare cinese","zh-hk":"Cinese - Hong Kong R.A.S.","cs-cz":"Ceco","pt-pt":"Portoghese - Portogallo","tr-tr":"Turco","vi-vn":"Vietnamita","th-th":"Thailandese","he-il":"Ebraico","cy-gb":"Gallese","uk-ua":"Ucraino","el-gr":"Greco","hu-hu":"Ungherese","ro-ro":"Rumeno","sk-sk":"Slovacco","zh-tw":"Cinese - Taiwan"},captionLanguageStrings:{ar:"Arabo",da:"Danese",de:"Tedesco",en:"Inglese",es:"Spagnolo",fi:"Finlandese","fr-ca":"Francese - Canada",fr:"Francese - Francia",hi:"Hindi",it:"Italiano",ja:"Giapponese",ko:"Coreano",nb:"Norvegese (Bokml)",nl:"Olandese",pl:"Polacco",pt:"Portoghese - Brasile",ru:"Russo",sv:"Svedese","zh-Hans":"Cinese (semplificato)","zh-Hant":"Cinese (tradizionale)",cs:"Ceco","pt-pt":"Portoghese - Portogallo",tr:"Turco",vi:"Vietnamita",th:"Thailandese",he:"Ebraico",cy:"Gallese",uk:"Ucraino",el:"Greco",hu:"Ungherese",ro:"Rumeno",sk:"Slovacco"},captionsBannerSpinnerText:"Avvio dei sottotitoli in corso...",transferPageTransferorText:"Trasferimento in corso...",transferPageTransferTargetText:"Connessione in corso...",transferPageUnknownTransferorDisplayName:"Sconosciuto",transferPageUnknownTransferTargetDisplayName:"Sconosciuto",transferPageNoticeString:"Stai per essere trasferito",participantCouldNotBeReachedTitle:"Il partecipante di riferimento non  attualmente disponibile",participantCouldNotBeReachedMoreDetails:"Contatta il partecipante quando  disponibile",permissionToReachTargetParticipantNotAllowedTitle:"L'autorizzazione per raggiungere il partecipante di riferimento non  consentita",permissionToReachTargetParticipantNotAllowedMoreDetails:"Verificare che il partecipante di riferimento si trovi nello stesso tenant",unableToResolveTenantTitle:"Non  possibile risolvere l'ID tenant per il partecipante di destinazione",unableToResolveTenantMoreDetails:"Verifica che l'ID partecipante sia stato immesso correttamente",participantIdIsMalformedTitle:"Il formato dell'ID partecipante non  corretto",participantIdIsMalformedMoreDetails:"Verifica che il formato dell'ID partecipante sia corretto",moreButtonGalleryControlLabel:"Visualizza",moreButtonGalleryPositionToggleLabel:"Sposta raccolta in alto",moreButtonGallerySpeakerLayoutLabel:"Altoparlante",moreButtonGalleryFloatingLocalLayoutLabel:"Dinamico",moreButtonGalleryDefaultLayoutLabel:"Visualizzazione raccolta",moreButtonGalleryFocusedContentLayoutLabel:"Focus sul contenuto",moreButtonLargeGalleryDefaultLayoutLabel:"Galleria estesa",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"La fotocamera  stata disattivata. Non  pi possibile condividere video.",grantedDueToMeetingOption:"La fotocamera  stata abilitata. Attivala se vuoi condividere il video."},unmuteMic:{lostDueToMeetingOption:"Il microfono  stato disabilitato. Non puoi pi riattivare l'audio.",grantedDueToMeetingOption:"Il microfono  stato abilitato. Riattiva l'audio se vuoi parlare."},shareScreen:{lostDueToRoleChangeToAttendee:"Il tuo ruolo  stato modificato. Alcune azioni, come la condivisione di contenuti, non saranno disponibili per te.",grantedDueToRoleChangeToPresenter:"Sei un relatore. Puoi condividere i contenuti e facilitare la riunione."}},surveyTitle:"Aiutaci a migliorare",starSurveyHelperText:"Come valuti la qualit della chiamata?",starSurveyOneStarText:"La qualit era pessima.",starSurveyTwoStarText:"La qualit era scadente.",starSurveyThreeStarText:"La qualit era buona.",starSurveyFourStarText:"La qualit era ottima.",starSurveyFiveStarText:"La qualit  stata eccellente.",surveyConfirmButtonLabel:"Invia feedback",starRatingAriaLabel:"Seleziona {0} di {1} stelle",surveySkipButtonLabel:"Salta",tagsSurveyQuestion:"Cosa avrebbe potuto essere migliore?",tagsSurveyTextFieldDefaultText:"Altro, specifica",tagsSurveyHelperText:"Controlla eventuali problemi riscontrati",surveyTextboxDefaultText:"Altro, specifica",endOfSurveyText:"Grazie per il feedback!",surveyIssues:{overallRating:{callCannotJoin:"Non sono riuscito a partecipare alla chiamata",callCannotInvite:"Non ho potuto invitare altri partecipanti alla chiamata",hadToRejoin:"Ho dovuto partecipare di nuovo alla chiamata",callEndedUnexpectedly:"La chiamata  terminata per me in modo imprevisto",otherIssues:"Ho avuto altri problemi con la chiamata"},audioRating:{noLocalAudio:"L'altro utente non mi sentiva",noRemoteAudio:"Non riuscivo a sentire niente",echo:"Ho sentito eco durante la chiamata",audioNoise:"Ho sentito rumore durante la chiamata",lowVolume:"Il volume era basso",audioStoppedUnexpectedly:"Laudio si  interrotto improvvisamente",distortedSpeech:"L'audio era distorto",audioInterruption:"L'audio  stato interrotto",otherIssues:"Ho avuto altri problemi audio in questa chiamata"},videoRating:{noVideoReceived:"Non vedevo nulla",noVideoSent:"Gli altri utenti non potevano vedermi",lowQuality:"La qualit del video era bassa",freezes:"Video bloccato",stoppedUnexpectedly:"Il video si  interrotto improvvisamente",darkVideoReceived:"Posso vedere gli schermi scuri solo quando altri utenti accendono la fotocamera",audioVideoOutOfSync:"Audio e immagini non erano sincronizzati",otherIssues:"Ho avuto altri problemi video in questa chiamata"},screenshareRating:{noContentLocal:"Altre persone non possono vedere la condivisione dello schermo",noContentRemote:"Non ho potuto visualizzare la condivisione dello schermo di altre persone",cannotPresent:"Non ho potuto presentare lo schermo",lowQuality:"La qualit della condivisione dello schermo  bassa",freezes:"Condivisione schermo bloccata",stoppedUnexpectedly:"Condivisione dello schermo interrotta in modo imprevisto",largeDelay:"La condivisione dello schermo presenta un ritardo elevato",otherIssues:"Ho avuto altri problemi di condivisione dello schermo in questa chiamata"}},SurveyIssuesHeadingStrings:{overallRating:"Generale",audioRating:"Audio",videoRating:"Video",screenshareRating:"Presentazione in corso"},spotlightPrompt:{startSpotlightHeading:"Mettere in evidenza per tutti?",startSpotlightText:"Questo video sar in evidenza per tutti i partecipanti alla riunione.",startSpotlightOnSelfText:"Il tuo video sar in evidenza per tutti i partecipanti alla riunione.",startSpotlightConfirmButtonLabel:"Metti in evidenza per tutti",startSpotlightCancelButtonLabel:"Annulla",stopSpotlightHeading:"Smettere di mostrare in evidenza questo video?",stopSpotlightOnSelfHeading:"Uscire dalla messa in evidenza?",stopSpotlightText:"Questo video non sar pi in evidenza per tutti i partecipanti alla riunione.",stopSpotlightOnSelfText:"Il tuo video non sar pi in evidenza per tutti i partecipanti alla riunione.",stopSpotlightConfirmButtonLabel:"Smetti di mettere in evidenza",stopSpotlightOnSelfConfirmButtonLabel:"Esci da visualizzazione in evidenza",stopSpotlightCancelButtonLabel:"Annulla"},exitSpotlightButtonLabel:"Esci da visualizzazione in evidenza",exitSpotlightButtonTooltip:"Esci da visualizzazione in evidenza"};var chat$b={chatListHeader:"In questa chat",uploadFile:"Carica file"};var callWithChat$b={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Nuovo messaggio",chatButtonTooltipClosedWithMessageCount:"Mostra chat ({unreadMessagesCount} non letto)",chatButtonTooltipClose:"Nascondi chat",chatButtonTooltipOpen:"Mostra chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copia il collegamento dellinvito",copyInviteLinkActionedAriaLabel:"Collegamento di invito copiato",dismissSidePaneButtonLabel:"Chiudi",moreDrawerAudioDeviceMenuTitle:"Dispositivo audio",moreDrawerButtonLabel:"Altre opzioni",moreDrawerButtonTooltip:"Altre opzioni",moreDrawerMicrophoneMenuTitle:"Microfono",moreDrawerSpeakerMenuTitle:"Altoparlante",moreDrawerCaptionsMenuTitle:"Sottotitoli in tempo reale",moreDrawerSpokenLanguageMenuTitle:"Lingua parlata",moreDrawerCaptionLanguageMenuTitle:"Lingua sottotitoli",moreDrawerGalleryOptionsMenuTitle:"Opzioni della raccolta",peopleButtonLabel:"Persone",selectedPeopleButtonLabel:"Pulsante Persone selezionato",peopleButtonTooltipOpen:"Mostra partecipanti",peopleButtonTooltipClose:"Nascondi partecipanti",peoplePaneSubTitle:"In questa chiamata",peoplePaneTitle:"Persone",pictureInPictureTileAriaLabel:"Feed video. Fare clic per tornare alla schermata della chiamata.",removeMenuLabel:"Rimuovi",openDialpadButtonLabel:"Componi il numero di telefono",returnToCallButtonAriaDescription:"Torna alla chiamata",returnToCallButtonAriaLabel:"Indietro",peoplePaneAddPeopleButtonLabel:"Aggiungi persone",dialpadStartCallButtonLabel:"Chiamata",dialpadModalTitle:"Componi il numero di telefono",dialpadModalAriaLabel:"Tastiera",dialpadCloseModalButtonAriaLabel:"Chiudi tastiera",openDtmfDialpadLabel:"Mostra tastiera",dtmfDialpadPlaceholderText:"Immetti il numero"};var it_IT = {call:call$b,chat:chat$b,callWithChat:callWithChat$b};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Italian (Italy)
 *
 * @public
 */
const COMPOSITE_LOCALE_IT_IT = {
    component: COMPONENT_LOCALE_IT_IT,
    strings: createCompositeStrings(it_IT)
};

var call$a={cameraLabel:"",noCamerasLabel:"",cameraPermissionDenied:"",cameraTurnedOff:"",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"",complianceBannerNowOnlyTranscription:"",complianceBannerRecordingAndTranscriptionSaved:"",complianceBannerRecordingAndTranscriptionStarted:"",complianceBannerRecordingAndTranscriptionStopped:"",complianceBannerRecordingSaving:"",complianceBannerRecordingStarted:"",complianceBannerRecordingStopped:"",complianceBannerTranscriptionStarted:"",complianceBannerTranscriptionConsent:"",complianceBannerTranscriptionSaving:"",complianceBannerTranscriptionStopped:"",configurationPageTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",defaultPlaceHolder:"",dismissSidePaneButtonLabel:"",videoEffectsPaneTitle:"",videoEffectsPaneBackgroundSelectionTitle:"",configurationPageVideoEffectsButtonLabel:"",unableToStartVideoEffect:"",blurBackgroundEffectButtonLabel:"",blurBackgroundTooltip:"",removeBackgroundEffectButtonLabel:"",removeBackgroundTooltip:"",cameraOffBackgroundEffectWarningText:"",failedToJoinCallDueToNoNetworkMoreDetails:"",failedToJoinCallDueToNoNetworkTitle:"",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"",learnMore:"",leavingCallTitle:"...",leftCallMoreDetails:"",leftCallTitle:"",lobbyScreenConnectingToCallTitle:"",lobbyScreenWaitingToBeAdmittedTitle:"",microphonePermissionDenied:"",microphoneToggleInLobbyNotAllowed:"",mutedMessage:"",networkReconnectMoreDetails:"",networkReconnectTitle:"",notInvitedToRoomDetails:"",notInvitedToRoomTitle:"",peopleButtonLabel:"",selectedPeopleButtonLabel:"[] ",peoplePaneTitle:"",peoplePaneMoreButtonAriaLabel:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:" {numberOfPeople} ",privacyPolicy:" ",rejoinCallButtonLabel:"",removedFromCallMoreDetails:"",removedFromCallTitle:"",removeMenuLabel:"",startSpotlightParticipantListMenuLabel:"",addSpotlightParticipantListMenuLabel:"",stopSpotlightParticipantListMenuLabel:"",stopSpotlightOnSelfParticipantListMenuLabel:"",spotlightLimitReachedParticipantListMenuTitle:"",stopAllSpotlightMenuLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",roomNotFoundDetails:" ID ",roomNotFoundTitle:"",roomNotValidDetails:"",roomNotValidTitle:"",inviteToRoomRemovedDetails:"",inviteToRoomRemovedTitle:"",soundLabel:"",noMicrophonesLabel:"",noSpeakersLabel:"",startCallButtonLabel:"",openDialpadButtonLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"...",resumeCallButtonAriaLabel:"",resumingCallButtonAriaLabel:"",holdScreenLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:"",outboundCallingNoticeString:"",participantJoinedNoticeString:"{displayName} ",twoParticipantJoinedNoticeString:"{displayName1}  {displayName2} ",threeParticipantJoinedNoticeString:"{displayName1} , {displayName2}  {displayName3} ",participantLeftNoticeString:"{displayName} ",twoParticipantLeftNoticeString:"{displayName1}  {displayName2} ",threeParticipantLeftNoticeString:"{displayName1} , {displayName2}  {displayName3} ",unnamedParticipantString:"",manyUnnamedParticipantsJoined:" {numOfParticipants} ",manyUnnamedParticipantsLeft:" {numOfParticipants} ",manyParticipantsJoined:"{displayName1}{displayName2}{displayName3}{numOfParticipants}",manyParticipantsLeft:"{displayName1}{displayName2}{displayName3}{numOfParticipants}",liveCaptionsLabel:" ",captionsSettingsLabel:"",startCaptionsButtonOnLabel:"",startCaptionsButtonOffLabel:"",startCaptionsButtonTooltipOnContent:"",startCaptionsButtonTooltipOffContent:"",captionsSettingsModalTitle:" ",captionsSettingsSpokenLanguageDropdownLabel:"",captionsSettingsCaptionLanguageDropdownLabel:" ",captionsSettingsSpokenLanguageDropdownInfoText:"",captionsSettingsCaptionLanguageDropdownInfoText:" ",captionsSettingsConfirmButtonLabel:"",captionsSettingsCancelButtonLabel:"",captionsSettingsModalAriaLabel:"",captionsSettingsCloseModalButtonAriaLabel:"",captionsBannerMoreButtonCallingLabel:"",captionsBannerMoreButtonTooltip:"",dismissModalAriaLabel:" Enter ",callRejectedTitle:"",callRejectedMoreDetails:"",callTimeoutTitle:"",callTimeoutDetails:"",callTimeoutBotTitle:"",callTimeoutBotDetails:"",dtmfDialerButtonLabel:"",dtmfDialerButtonTooltipOn:"",dtmfDialerButtonTooltipOff:" ",dtmfDialerMoreButtonLabelOn:"",dtmfDialerMoreButtonLabelOff:" ",spokenLanguageStrings:{"ar-ae":" - U.A.E.","ar-sa":" - ","da-dk":"","de-de":" - ","en-au":" - ","en-ca":" - ","en-gb":" - ","en-in":" - ","en-nz":" - ","en-us":" - ","es-es":" -  ()","es-mx":" - ","fi-fi":"","fr-ca":" - ","fr-fr":" - ","hi-in":"","it-it":" - ","ja-jp":"","ko-kr":"","nb-no":" ()","nl-be":" - ","nl-nl":" - ","pl-pl":"","pt-br":" - ","ru-ru":"","sv-se":"","zh-cn":" - ","zh-hk":" - ","cs-cz":"","pt-pt":" - ","tr-tr":"","vi-vn":"","th-th":"","he-il":"","cy-gb":"","uk-ua":"","el-gr":"","hu-hu":"","ro-ro":"","sk-sk":"","zh-tw":" - "},captionLanguageStrings:{ar:"",da:"",de:"",en:"",es:"",fi:"","fr-ca":" - ",fr:" - ",hi:"",it:"",ja:"",ko:"",nb:" ()",nl:"",pl:"",pt:" - ",ru:"",sv:"","zh-Hans":" ()","zh-Hant":" ()",cs:"","pt-pt":" - ",tr:"",vi:"",th:"",he:"",cy:"",uk:"",el:"",hu:"",ro:"",sk:""},captionsBannerSpinnerText:"...",transferPageTransferorText:"...",transferPageTransferTargetText:"...",transferPageUnknownTransferorDisplayName:"",transferPageUnknownTransferTargetDisplayName:"",transferPageNoticeString:"",participantCouldNotBeReachedTitle:"",participantCouldNotBeReachedMoreDetails:"",permissionToReachTargetParticipantNotAllowedTitle:"",permissionToReachTargetParticipantNotAllowedMoreDetails:"",unableToResolveTenantTitle:" ID ",unableToResolveTenantMoreDetails:" ID ",participantIdIsMalformedTitle:" ID ",participantIdIsMalformedMoreDetails:" ID ",moreButtonGalleryControlLabel:"",moreButtonGalleryPositionToggleLabel:"",moreButtonGallerySpeakerLayoutLabel:"",moreButtonGalleryFloatingLocalLayoutLabel:"",moreButtonGalleryDefaultLayoutLabel:" ",moreButtonGalleryFocusedContentLayoutLabel:"",moreButtonLargeGalleryDefaultLayoutLabel:" ",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"",grantedDueToMeetingOption:""},unmuteMic:{lostDueToMeetingOption:"",grantedDueToMeetingOption:""},shareScreen:{lostDueToRoleChangeToAttendee:"",grantedDueToRoleChangeToPresenter:""}},surveyTitle:"",starSurveyHelperText:"?",starSurveyOneStarText:"",starSurveyTwoStarText:"",starSurveyThreeStarText:"",starSurveyFourStarText:"",starSurveyFiveStarText:"",surveyConfirmButtonLabel:"",starRatingAriaLabel:"{1}  {0} ",surveySkipButtonLabel:"",tagsSurveyQuestion:"?",tagsSurveyTextFieldDefaultText:"",tagsSurveyHelperText:"",surveyTextboxDefaultText:" ()",endOfSurveyText:"",surveyIssues:{overallRating:{callCannotJoin:"",callCannotInvite:"",hadToRejoin:"",callEndedUnexpectedly:"",otherIssues:""},audioRating:{noLocalAudio:"",noRemoteAudio:"",echo:"",audioNoise:"",lowVolume:"",audioStoppedUnexpectedly:"",distortedSpeech:"",audioInterruption:"",otherIssues:""},videoRating:{noVideoReceived:"",noVideoSent:"",lowQuality:"",freezes:"",stoppedUnexpectedly:"",darkVideoReceived:"",audioVideoOutOfSync:"",otherIssues:""},screenshareRating:{noContentLocal:"",noContentRemote:"",cannotPresent:"",lowQuality:"",freezes:"",stoppedUnexpectedly:"",largeDelay:"",otherIssues:""}},SurveyIssuesHeadingStrings:{overallRating:"",audioRating:"",videoRating:"",screenshareRating:""},spotlightPrompt:{startSpotlightHeading:"?",startSpotlightText:"",startSpotlightOnSelfText:"",startSpotlightConfirmButtonLabel:"",startSpotlightCancelButtonLabel:"",stopSpotlightHeading:"?",stopSpotlightOnSelfHeading:"?",stopSpotlightText:"",stopSpotlightOnSelfText:"",stopSpotlightConfirmButtonLabel:"",stopSpotlightOnSelfConfirmButtonLabel:"",stopSpotlightCancelButtonLabel:""},exitSpotlightButtonLabel:"",exitSpotlightButtonTooltip:""};var chat$a={chatListHeader:"",uploadFile:""};var callWithChat$a={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:"",chatButtonTooltipClosedWithMessageCount:" ({unreadMessagesCount} )",chatButtonTooltipClose:"",chatButtonTooltipOpen:"",chatPaneTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:" ",moreDrawerButtonLabel:"",moreDrawerButtonTooltip:"",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",moreDrawerCaptionsMenuTitle:" ",moreDrawerSpokenLanguageMenuTitle:"",moreDrawerCaptionLanguageMenuTitle:"",moreDrawerGalleryOptionsMenuTitle:"",peopleButtonLabel:"",selectedPeopleButtonLabel:"[] ",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:"",peoplePaneTitle:"",pictureInPictureTileAriaLabel:"  ",removeMenuLabel:"",openDialpadButtonLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:""};var ja_JP = {call:call$a,chat:chat$a,callWithChat:callWithChat$a};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Japanese (Japan)
 *
 * @public
 */
const COMPOSITE_LOCALE_JA_JP = {
    component: COMPONENT_LOCALE_JA_JP,
    strings: createCompositeStrings(ja_JP)
};

var call$9={cameraLabel:"",noCamerasLabel:"   ",cameraPermissionDenied:"     .",cameraTurnedOff:"  ",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"   / .",complianceBannerNowOnlyTranscription:"    .",complianceBannerRecordingAndTranscriptionSaved:"/   .",complianceBannerRecordingAndTranscriptionStarted:"/  .",complianceBannerRecordingAndTranscriptionStopped:"/  .",complianceBannerRecordingSaving:"/  .",complianceBannerRecordingStarted:"/ .",complianceBannerRecordingStopped:"/ .",complianceBannerTranscriptionStarted:" .",complianceBannerTranscriptionConsent:"      .",complianceBannerTranscriptionSaving:"  .",complianceBannerTranscriptionStopped:" .",configurationPageTitle:" ",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"  ",defaultPlaceHolder:" ",dismissSidePaneButtonLabel:"",videoEffectsPaneTitle:"",videoEffectsPaneBackgroundSelectionTitle:"",configurationPageVideoEffectsButtonLabel:"",unableToStartVideoEffect:"    .",blurBackgroundEffectButtonLabel:"",blurBackgroundTooltip:" ",removeBackgroundEffectButtonLabel:"",removeBackgroundTooltip:" ",cameraOffBackgroundEffectWarningText:"  .     .",failedToJoinCallDueToNoNetworkMoreDetails:"     .    .",failedToJoinCallDueToNoNetworkTitle:"  ",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"     .    .",failedToJoinTeamsMeetingReasonAccessDeniedTitle:" .",learnMore:" ",leavingCallTitle:" ...",leftCallMoreDetails:"   .",leftCallTitle:" .",lobbyScreenConnectingToCallTitle:" ",lobbyScreenWaitingToBeAdmittedTitle:"  ",microphonePermissionDenied:"     .",microphoneToggleInLobbyNotAllowed:"       .",mutedMessage:" .",networkReconnectMoreDetails:"   .    .",networkReconnectTitle:"",notInvitedToRoomDetails:"      .",notInvitedToRoomTitle:"  ",peopleButtonLabel:"",selectedPeopleButtonLabel:"  ",peoplePaneTitle:"",peoplePaneMoreButtonAriaLabel:" ",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:"  {numberOfPeople}",privacyPolicy:"   ",rejoinCallButtonLabel:"  ",removedFromCallMoreDetails:"    .",removedFromCallTitle:" .",removeMenuLabel:"",startSpotlightParticipantListMenuLabel:"  ",addSpotlightParticipantListMenuLabel:" ",stopSpotlightParticipantListMenuLabel:" ",stopSpotlightOnSelfParticipantListMenuLabel:" ",spotlightLimitReachedParticipantListMenuTitle:"  ",stopAllSpotlightMenuLabel:"  ",returnToCallButtonAriaDescription:" ",returnToCallButtonAriaLabel:"",roomNotFoundDetails:"  ID   .",roomNotFoundTitle:"   ",roomNotValidDetails:"    .",roomNotValidTitle:"  ",inviteToRoomRemovedDetails:"     .",inviteToRoomRemovedTitle:"  ",soundLabel:"",noMicrophonesLabel:"   ",noSpeakersLabel:"   ",startCallButtonLabel:" ",openDialpadButtonLabel:"   ",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"   ",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:" ",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"  ...",resumeCallButtonAriaLabel:"  ",resumingCallButtonAriaLabel:" ",holdScreenLabel:" .",openDtmfDialpadLabel:" ",dtmfDialpadPlaceholderText:" ",outboundCallingNoticeString:"  ...",participantJoinedNoticeString:"{displayName}  ",twoParticipantJoinedNoticeString:"{displayName1}  {displayName2}  ",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2}  {displayName3}  ",participantLeftNoticeString:"{displayName}  ",twoParticipantLeftNoticeString:"{displayName1}  {displayName2}  ",threeParticipantLeftNoticeString:"{displayName1}, {displayName2}  {displayName3}  ",unnamedParticipantString:"  ",manyUnnamedParticipantsJoined:"    {numOfParticipants}   ",manyUnnamedParticipantsLeft:"    {numOfParticipants}   ",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3}  {numOfParticipants}   .",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3}    {numOfParticipants} ",liveCaptionsLabel:" ",captionsSettingsLabel:" ",startCaptionsButtonOnLabel:" ",startCaptionsButtonOffLabel:" ",startCaptionsButtonTooltipOnContent:" ",startCaptionsButtonTooltipOffContent:" ",captionsSettingsModalTitle:" ",captionsSettingsSpokenLanguageDropdownLabel:" ",captionsSettingsCaptionLanguageDropdownLabel:" ",captionsSettingsSpokenLanguageDropdownInfoText:"     .",captionsSettingsCaptionLanguageDropdownInfoText:"   .",captionsSettingsConfirmButtonLabel:"",captionsSettingsCancelButtonLabel:"",captionsSettingsModalAriaLabel:"  ",captionsSettingsCloseModalButtonAriaLabel:"  ",captionsBannerMoreButtonCallingLabel:"",captionsBannerMoreButtonTooltip:" ",dismissModalAriaLabel:"     , Enter    ",callRejectedTitle:"   .",callRejectedMoreDetails:"     .   .",callTimeoutTitle:"   .",callTimeoutDetails:"     .   .",callTimeoutBotTitle:"   .",callTimeoutBotDetails:"    .   .",dtmfDialerButtonLabel:"",dtmfDialerButtonTooltipOn:" ",dtmfDialerButtonTooltipOff:" ",dtmfDialerMoreButtonLabelOn:" ",dtmfDialerMoreButtonLabelOff:" ",spokenLanguageStrings:{"ar-ae":" - ","ar-sa":" -  ","da-dk":"","de-de":" - ","en-au":" - ","en-ca":" - ","en-gb":" - ","en-in":" - ","en-nz":" - ","en-us":" - ","es-es":" - ( )","es-mx":" - ","fi-fi":"","fr-ca":" - ","fr-fr":" - ","hi-in":"","it-it":" - ","ja-jp":"","ko-kr":"","nb-no":"()","nl-be":" - ","nl-nl":" - ","pl-pl":"","pt-br":" - ","ru-ru":"","sv-se":"","zh-cn":" - ","zh-hk":" -   ","cs-cz":"","pt-pt":" - ","tr-tr":"","vi-vn":"","th-th":"","he-il":"","cy-gb":"","uk-ua":"","el-gr":"","hu-hu":"","ro-ro":"","sk-sk":"","zh-tw":" - "},captionLanguageStrings:{ar:"",da:"",de:"",en:"",es:"",fi:"","fr-ca":" - ",fr:" - ",hi:"",it:"",ja:"",ko:"",nb:"()",nl:"",pl:"",pt:" - ",ru:"",sv:"","zh-Hans":"()","zh-Hant":"()",cs:"","pt-pt":" - ",tr:"",vi:"",th:"",he:"",cy:"",uk:"",el:"",hu:"",ro:"",sk:""},captionsBannerSpinnerText:"  ...",transferPageTransferorText:" ...",transferPageTransferTargetText:" ...",transferPageUnknownTransferorDisplayName:"  ",transferPageUnknownTransferTargetDisplayName:"  ",transferPageNoticeString:"  .",participantCouldNotBeReachedTitle:"     .",participantCouldNotBeReachedMoreDetails:"      .",permissionToReachTargetParticipantNotAllowedTitle:"       .",permissionToReachTargetParticipantNotAllowedMoreDetails:"     .",unableToResolveTenantTitle:"   ID resolve  .",unableToResolveTenantMoreDetails:" ID   .",participantIdIsMalformedTitle:" ID  .",participantIdIsMalformedMoreDetails:" ID   .",moreButtonGalleryControlLabel:"",moreButtonGalleryPositionToggleLabel:"   ",moreButtonGallerySpeakerLayoutLabel:"",moreButtonGalleryFloatingLocalLayoutLabel:"",moreButtonGalleryDefaultLayoutLabel:" ",moreButtonGalleryFocusedContentLayoutLabel:"  ",moreButtonLargeGalleryDefaultLayoutLabel:" ",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"   .      .",grantedDueToMeetingOption:"  .   ."},unmuteMic:{lostDueToMeetingOption:"   .      .",grantedDueToMeetingOption:"  .   ."},shareScreen:{lostDueToRoleChangeToAttendee:" .        .",grantedDueToRoleChangeToPresenter:" .      ."}},surveyTitle:"  ",starSurveyHelperText:"  ?",starSurveyOneStarText:"  .",starSurveyTwoStarText:" .",starSurveyThreeStarText:" .",starSurveyFourStarText:"  .",starSurveyFiveStarText:"  .",surveyConfirmButtonLabel:" ",starRatingAriaLabel:" {0}/{1} ",surveySkipButtonLabel:"",tagsSurveyQuestion:"  .",tagsSurveyTextFieldDefaultText:"()",tagsSurveyHelperText:"  .",surveyTextboxDefaultText:"()",endOfSurveyText:"  !",surveyIssues:{overallRating:{callCannotJoin:"   .",callCannotInvite:"     .",hadToRejoin:"   .",callEndedUnexpectedly:"   .",otherIssues:"   ."},audioRating:{noLocalAudio:"    ",noRemoteAudio:"   .",echo:"  .",audioNoise:"   .",lowVolume:" ",audioStoppedUnexpectedly:"   ",distortedSpeech:" .",audioInterruption:" .",otherIssues:"     ."},videoRating:{noVideoReceived:"  .",noVideoSent:"     .",lowQuality:"  ",freezes:" ",stoppedUnexpectedly:"  .",darkVideoReceived:"         .",audioVideoOutOfSync:"    .",otherIssues:"     ."},screenshareRating:{noContentLocal:"       .",noContentRemote:"      .",cannotPresent:"    .",lowQuality:"   ",freezes:"  .",stoppedUnexpectedly:"    ",largeDelay:"    ",otherIssues:"      ."}},SurveyIssuesHeadingStrings:{overallRating:"",audioRating:"",videoRating:"",screenshareRating:" "},spotlightPrompt:{startSpotlightHeading:"  ?",startSpotlightText:"       .",startSpotlightOnSelfText:"      .",startSpotlightConfirmButtonLabel:"  ",startSpotlightCancelButtonLabel:"",stopSpotlightHeading:"   ?",stopSpotlightOnSelfHeading:" ?",stopSpotlightText:"         .",stopSpotlightOnSelfText:"         .",stopSpotlightConfirmButtonLabel:" ",stopSpotlightOnSelfConfirmButtonLabel:" ",stopSpotlightCancelButtonLabel:""},exitSpotlightButtonLabel:" ",exitSpotlightButtonTooltip:" "};var chat$9={chatListHeader:" ",uploadFile:" "};var callWithChat$9={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:" ",chatButtonTooltipClosedWithMessageCount:" ({unreadMessagesCount}  )",chatButtonTooltipClose:" ",chatButtonTooltipOpen:" ",chatPaneTitle:"",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"  ",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:" ",moreDrawerButtonLabel:" ",moreDrawerButtonTooltip:" ",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",moreDrawerCaptionsMenuTitle:" ",moreDrawerSpokenLanguageMenuTitle:" ",moreDrawerCaptionLanguageMenuTitle:" ",moreDrawerGalleryOptionsMenuTitle:" ",peopleButtonLabel:"",selectedPeopleButtonLabel:"  ",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:" ",peoplePaneTitle:"",pictureInPictureTileAriaLabel:" .    .",removeMenuLabel:"",openDialpadButtonLabel:"   ",returnToCallButtonAriaDescription:" ",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"   ",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:" ",openDtmfDialpadLabel:" ",dtmfDialpadPlaceholderText:" "};var ko_KR = {call:call$9,chat:chat$9,callWithChat:callWithChat$9};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Korean (South Korea)
 *
 * @public
 */
const COMPOSITE_LOCALE_KO_KR = {
    component: COMPONENT_LOCALE_KO_KR,
    strings: createCompositeStrings(ko_KR)
};

var call$8={cameraLabel:"Kamera",noCamerasLabel:"Fant ingen kameraer",cameraPermissionDenied:"Nettleseren blokkerer tilgang til kameraet",cameraTurnedOff:"Kameraet er sltt av",chatButtonLabel:"Chat",close:"Lukk",complianceBannerNowOnlyRecording:"Du tar n bare opp dette mtet.",complianceBannerNowOnlyTranscription:"Du transkriberer n bare dette mtet.",complianceBannerRecordingAndTranscriptionSaved:"Opptak og transkripsjon lagres.",complianceBannerRecordingAndTranscriptionStarted:"Opptak og transkripsjon har startet.",complianceBannerRecordingAndTranscriptionStopped:"Innspilling og transkripsjon har stoppet.",complianceBannerRecordingSaving:"Opptaket blir lagret.",complianceBannerRecordingStarted:"Innspillingen er startet.",complianceBannerRecordingStopped:"Opptaket har stoppet.",complianceBannerTranscriptionStarted:"Transkripsjon har startet.",complianceBannerTranscriptionConsent:"Ved  bli med gir du samtykke til at dette mtet kan transkriberes.",complianceBannerTranscriptionSaving:"Transkripsjonen blir lagret.",complianceBannerTranscriptionStopped:"Transkripsjon er stoppet.",configurationPageTitle:"Start en samtale",copyInviteLinkButtonLabel:"Kopier invitasjonskobling",copyInviteLinkActionedAriaLabel:"Invitasjonskobling er kopiert",defaultPlaceHolder:"Velg et alternativ",dismissSidePaneButtonLabel:"Lukk",videoEffectsPaneTitle:"Effekter",videoEffectsPaneBackgroundSelectionTitle:"Bakgrunn",configurationPageVideoEffectsButtonLabel:"Effekter",unableToStartVideoEffect:"Kan ikke bruke videoeffekt.",blurBackgroundEffectButtonLabel:"Uskarp bakgrunn",blurBackgroundTooltip:"Gjr bakgrunnen uskarp",removeBackgroundEffectButtonLabel:"Ingen",removeBackgroundTooltip:"Fjern bakgrunnen",cameraOffBackgroundEffectWarningText:"Kameraet er av. Sl p kameraet for  se videoeffekten.",failedToJoinCallDueToNoNetworkMoreDetails:"Samtalen ble frakoblet p grunn av et nettverksproblem. Kontroller tilkoblingen og bli med p nytt.",failedToJoinCallDueToNoNetworkTitle:"Samtale frakoblet",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Du ble ikke gitt adgang i samtalen. Hvis dette var en feil, m du bli med i samtalen p nytt.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Avvist fra lobbyen",learnMore:"Mer informasjon",leavingCallTitle:"Forlater...",leftCallMoreDetails:"Hvis dette var en feil, m du bli med i samtalen p nytt.",leftCallTitle:"Du forlot samtalen",lobbyScreenConnectingToCallTitle:"Blir med i samtalen",lobbyScreenWaitingToBeAdmittedTitle:"Venter p  bli sluppet inn",microphonePermissionDenied:"Nettleseren blokkerer tilgang til mikrofonen",microphoneToggleInLobbyNotAllowed:"Kan ikke dempe eller oppheve demping i lobbyen.",mutedMessage:"Du er dempet.",networkReconnectMoreDetails:"Det ser ut til at noe gikk galt. Vi prver  g tilbake til samtalen.",networkReconnectTitle:"Vent litt",notInvitedToRoomDetails:"Du kan ikke bli med i dette rommet fordi du ikke har en invitasjon.",notInvitedToRoomTitle:"Ikke invitert til rommet",peopleButtonLabel:"Personer",selectedPeopleButtonLabel:"Personer-knappen er valgt",peoplePaneTitle:"Personer",peoplePaneMoreButtonAriaLabel:"Mer",peopleButtonTooltipOpen:"Vis deltakere",peopleButtonTooltipClose:"Skjul deltakere",peoplePaneSubTitle:"I denne samtalen {numberOfPeople}",privacyPolicy:"Personvernerklring",rejoinCallButtonLabel:"Bli med i samtale p nytt",removedFromCallMoreDetails:"En annen deltaker fjernet deg fra samtalen.",removedFromCallTitle:"Du ble fjernet",removeMenuLabel:"Fjern",startSpotlightParticipantListMenuLabel:"Sett i rampelyset for alle",addSpotlightParticipantListMenuLabel:"Legg til rampelys",stopSpotlightParticipantListMenuLabel:"Fjern fra rampelyset",stopSpotlightOnSelfParticipantListMenuLabel:"Rampelys av",spotlightLimitReachedParticipantListMenuTitle:"Rampelys-grensen er ndd",stopAllSpotlightMenuLabel:"Stopp rampelyset for alle",returnToCallButtonAriaDescription:"G tilbake til samtale",returnToCallButtonAriaLabel:"Tilbake",roomNotFoundDetails:"Finner ikke den angitte rom-IDen.",roomNotFoundTitle:"Finner ikke rommet",roomNotValidDetails:"Dette rommet er ikke gyldig for yeblikket.",roomNotValidTitle:"Ugyldig rom",inviteToRoomRemovedDetails:"Invitasjonen til  bli med i dette rommet ble fjernet.",inviteToRoomRemovedTitle:"Invitasjon til rommet er fjernet",soundLabel:"Lyd",noMicrophonesLabel:"Fant ingen mikrofoner",noSpeakersLabel:"Fant ingen hyttalere",startCallButtonLabel:"Start samtale",openDialpadButtonLabel:"Sl telefonnummeret",peoplePaneAddPeopleButtonLabel:"Legg til personer",dialpadStartCallButtonLabel:"Ringe",dialpadModalTitle:"Sl telefonnummeret",dialpadModalAriaLabel:"Numerisk tastatur",dialpadCloseModalButtonAriaLabel:"Lukk numerisk tastatur",moreButtonCallingLabel:"Mer",resumeCallButtonLabel:"Fortsett",resumingCallButtonLabel:"Gjenopptar ",resumeCallButtonAriaLabel:"Fortsett samtale",resumingCallButtonAriaLabel:"Fortsett samtale",holdScreenLabel:"Du er satt p vent",openDtmfDialpadLabel:"Vis numerisk tastatur",dtmfDialpadPlaceholderText:"Skriv inn nummer",outboundCallingNoticeString:"Ringer ",participantJoinedNoticeString:"{displayName} ble med",twoParticipantJoinedNoticeString:"{displayName1} og {displayName2} har blitt med",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} og {displayName3} har blitt med",participantLeftNoticeString:"{displayName} igjen",twoParticipantLeftNoticeString:"{displayName1} og {displayName2} har forlatt",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} og {displayName3} har forlatt",unnamedParticipantString:"deltaker uten navn",manyUnnamedParticipantsJoined:"deltaker uten navn og {numOfParticipants} andre deltakere ble med",manyUnnamedParticipantsLeft:"deltaker uten navn og {numOfParticipants} andre deltakere igjen",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} og {numOfParticipants} andre deltakere ble med",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} og {numOfParticipants} andre deltakere igjen",liveCaptionsLabel:"Undertekster",captionsSettingsLabel:"Innstillinger for undertekster",startCaptionsButtonOnLabel:"Sl p undertekster",startCaptionsButtonOffLabel:"Deaktiver undertekster",startCaptionsButtonTooltipOnContent:"Deaktiver undertekster",startCaptionsButtonTooltipOffContent:"Sl p undertekster",captionsSettingsModalTitle:"Tekstinnstillinger",captionsSettingsSpokenLanguageDropdownLabel:"Talesprk",captionsSettingsCaptionLanguageDropdownLabel:"Undertekstsprk",captionsSettingsSpokenLanguageDropdownInfoText:"Sprket som alle i denne samtalen snakker.",captionsSettingsCaptionLanguageDropdownInfoText:"Undertekster vises p dette sprket.",captionsSettingsConfirmButtonLabel:"Bekreft",captionsSettingsCancelButtonLabel:"Avbryt",captionsSettingsModalAriaLabel:"Sperre for innstillinger for undertekster",captionsSettingsCloseModalButtonAriaLabel:"Lukk innstilling for undertekster",captionsBannerMoreButtonCallingLabel:"Mer",captionsBannerMoreButtonTooltip:"Flere alternativer",dismissModalAriaLabel:"Lokalt og eksternt bilde og bilde, trykk p Enter for  g tilbake til samtalen",callRejectedTitle:"Kan ikke fullfre samtalen",callRejectedMoreDetails:"Personen du prver  n, er ikke tilgjengelig. Prv p nytt senere.",callTimeoutTitle:"Kan ikke fullfre samtalen",callTimeoutDetails:"Personen du prver  n, er ikke tilgjengelig. Prv p nytt senere.",callTimeoutBotTitle:"Kan ikke fullfre samtalen",callTimeoutBotDetails:"Tjenesten du prver  n, er ikke tilgjengelig. Prv p nytt senere.",dtmfDialerButtonLabel:"Numerisk tastatur",dtmfDialerButtonTooltipOn:"Vis numerisk tastatur",dtmfDialerButtonTooltipOff:"Skjul numerisk tastatur",dtmfDialerMoreButtonLabelOn:"Vis numerisk tastatur",dtmfDialerMoreButtonLabelOff:"Skjul numerisk tastatur",spokenLanguageStrings:{"ar-ae":"Arabisk  De forente arabiske emirater","ar-sa":"Arabisk  Saudi-Arabia","da-dk":"Dansk","de-de":"Tysk  Tyskland","en-au":"Engelsk  Australia","en-ca":"Engelsk  Canada","en-gb":"Engelsk  Storbritannia","en-in":"Engelsk  India","en-nz":"Engelsk  New Zealand","en-us":"Engelsk  USA","es-es":"Spansk  Spania (moderne)","es-mx":"Spansk  Mexico","fi-fi":"Finsk","fr-ca":"Fransk  Canada","fr-fr":"Fransk  Frankrike","hi-in":"Hindi","it-it":"Italiensk  Italia","ja-jp":"Japansk","ko-kr":"Koreansk","nb-no":"Norsk (bokml)","nl-be":"Nederlandsk  Belgia","nl-nl":"Nederlandsk  Nederland","pl-pl":"Polsk","pt-br":"Portugisisk  Brasil","ru-ru":"Russisk","sv-se":"Svensk","zh-cn":"Kinesisk  Folkerepublikken Kina","zh-hk":"Kinesisk  Hongkong SAR","cs-cz":"Tsjekkisk","pt-pt":"Portugisisk  Portugal","tr-tr":"Tyrkisk","vi-vn":"Vietnamesisk","th-th":"Thai","he-il":"Hebraisk","cy-gb":"Walisisk","uk-ua":"Ukrainsk","el-gr":"Gresk","hu-hu":"Ungarsk","ro-ro":"Rumensk","sk-sk":"Slovakisk","zh-tw":"Kinesisk  Taiwan"},captionLanguageStrings:{ar:"Arabisk",da:"Dansk",de:"Tysk",en:"Engelsk",es:"Spansk",fi:"Finsk","fr-ca":"Fransk  Canada",fr:"Fransk  Frankrike",hi:"Hindi",it:"Italiensk",ja:"Japansk",ko:"Koreansk",nb:"Norsk (bokml)",nl:"Nederlandsk",pl:"Polsk",pt:"Portugisisk  Brasil",ru:"Russisk",sv:"Svensk","zh-Hans":"Kinesisk (forenklet)","zh-Hant":"Kinesisk (tradisjonell)",cs:"Tsjekkisk","pt-pt":"Portugisisk  Portugal",tr:"Tyrkisk",vi:"Vietnamesisk",th:"Thai",he:"Hebraisk",cy:"Walisisk",uk:"Ukrainsk",el:"Gresk",hu:"Ungarsk",ro:"Rumensk",sk:"Slovakisk"},captionsBannerSpinnerText:"Starter teksting...",transferPageTransferorText:"Overfrer...",transferPageTransferTargetText:"Kobler til...",transferPageUnknownTransferorDisplayName:"Ukjent",transferPageUnknownTransferTargetDisplayName:"Ukjent",transferPageNoticeString:"Anropet blir overfrt",participantCouldNotBeReachedTitle:"Mldeltaker er for yeblikket ikke tilgjengelig",participantCouldNotBeReachedMoreDetails:"Kontakt deltakeren nr vedkommende er tilgjengelig",permissionToReachTargetParticipantNotAllowedTitle:"Tillatelse til  n mldeltaker er ikke tillatt",permissionToReachTargetParticipantNotAllowedMoreDetails:"Kontroller at mldeltakeren er i samme leier",unableToResolveTenantTitle:"Kan ikke lse leier-ID for mldeltakeren",unableToResolveTenantMoreDetails:"Kontroller at deltaker-ID-en er riktig angitt",participantIdIsMalformedTitle:"Deltaker-ID-en har ikke riktig format",participantIdIsMalformedMoreDetails:"Kontroller at deltaker-ID-en har riktig format",moreButtonGalleryControlLabel:"Vis",moreButtonGalleryPositionToggleLabel:"Flytt galleri verst",moreButtonGallerySpeakerLayoutLabel:"Hyttaler",moreButtonGalleryFloatingLocalLayoutLabel:"Dynamisk",moreButtonGalleryDefaultLayoutLabel:"Gallerivisning",moreButtonGalleryFocusedContentLayoutLabel:"Fokuser p innhold",moreButtonLargeGalleryDefaultLayoutLabel:"Stort galleri",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Kameraet er deaktivert. Du kan ikke lenger dele video.",grantedDueToMeetingOption:"Kameraet er aktivert. Sl den p hvis du vil dele video."},unmuteMic:{lostDueToMeetingOption:"Mikrofonen er deaktivert. Du kan ikke lenger oppheve dempingen.",grantedDueToMeetingOption:"Mikrofonen er aktivert. Opphev demping hvis du vil snakke."},shareScreen:{lostDueToRoleChangeToAttendee:"Rollen din er endret. Noen handlinger, for eksempel deling av innhold, vil ikke vre tilgjengelige for deg.",grantedDueToRoleChangeToPresenter:"Du er presentatr. Du kan dele innhold og tilrettelegge mtet."}},surveyTitle:"Hjelp oss med  bli bedre",starSurveyHelperText:"Hvordan var kvaliteten p samtalen?",starSurveyOneStarText:"Kvaliteten var drlig.",starSurveyTwoStarText:"Kvaliteten var drlig.",starSurveyThreeStarText:"Kvaliteten var bra.",starSurveyFourStarText:"Kvaliteten var meget bra.",starSurveyFiveStarText:"Kvaliteten var meget bra.",surveyConfirmButtonLabel:"Send tilbakemelding",starRatingAriaLabel:"Velg {0} av {1} stjerner",surveySkipButtonLabel:"Hopp over",tagsSurveyQuestion:"Hva kunne ha vrt bedre?",tagsSurveyTextFieldDefaultText:"Annet, spesifiser",tagsSurveyHelperText:"Merk eventuelle problemer du har opplevd.",surveyTextboxDefaultText:"Annet, spesifiser",endOfSurveyText:"Takk for tilbakemeldingen!",surveyIssues:{overallRating:{callCannotJoin:"Jeg kunne ikke bli i samtalen",callCannotInvite:"Jeg kunne ikke invitere noen til samtalen",hadToRejoin:"Jeg mtte bli med i samtalen p nytt",callEndedUnexpectedly:"Samtalen ble avbrutt",otherIssues:"Jeg hadde andre problemer med samtalen"},audioRating:{noLocalAudio:"Den andre parten hrte ikke noe lyd",noRemoteAudio:"Jeg hrte ikke lyd",echo:"Jeg hrte ekko i samtalen",audioNoise:"Jeg hrte sty i samtalen",lowVolume:"Volumet var lavt",audioStoppedUnexpectedly:"Lyd stoppet uventet",distortedSpeech:"Lyden var forvrengt",audioInterruption:"Lyden ble avbrutt",otherIssues:"Jeg hadde andre problemer med lyden i denne samtalen"},videoRating:{noVideoReceived:"Jeg kunne ikke se videoen",noVideoSent:"Andre kunne ikke se meg",lowQuality:"Videokvaliteten var drlig",freezes:"Videoen frs",stoppedUnexpectedly:"Video stoppet uventet",darkVideoReceived:"Jeg kan bare se mrke skjermer nr andre slr p kameraet",audioVideoOutOfSync:"Lyd og video er ikke synkronisert",otherIssues:"Jeg hadde andre problemer med videoen i denne samtalen"},screenshareRating:{noContentLocal:"Andre personer kunne ikke se skjermdelingen min",noContentRemote:"Jeg kunne ikke se skjermdelingen til andre personer",cannotPresent:"Jeg kunne ikke vise skjermen min",lowQuality:"Kvaliteten p skjermdelingen var drlig",freezes:"Skjermdeling frs",stoppedUnexpectedly:"Skjermdelingen ble avbrutt",largeDelay:"Skjermdelingen har en stor forsinkelse",otherIssues:"Jeg hadde andre problemer med skjermdeling i denne samtalen"}},SurveyIssuesHeadingStrings:{overallRating:"Samlet vurdering",audioRating:"Lyd",videoRating:"Video",screenshareRating:"Presentering"},spotlightPrompt:{startSpotlightHeading:"Sett i rampelyset for alle?",startSpotlightText:"Du merker denne videoen for alle i mtet.",startSpotlightOnSelfText:"Du merker videoen for alle i mtet.",startSpotlightConfirmButtonLabel:"Sett i rampelyset for alle",startSpotlightCancelButtonLabel:"Avbryt",stopSpotlightHeading:"Slutte  sette denne videoen i rampelyset?",stopSpotlightOnSelfHeading:"Fjern rampelyset?",stopSpotlightText:"Denne videoen vil ikke lenger vre uthevet for alle i mtet.",stopSpotlightOnSelfText:"Videoen vil ikke lenger vre uthevet for alle i mtet.",stopSpotlightConfirmButtonLabel:"Fjern fra rampelyset",stopSpotlightOnSelfConfirmButtonLabel:"Rampelys av",stopSpotlightCancelButtonLabel:"Avbryt"},exitSpotlightButtonLabel:"Rampelys av",exitSpotlightButtonTooltip:"Rampelys av"};var chat$8={chatListHeader:"I denne chatten",uploadFile:"Last opp fil"};var callWithChat$8={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Ny melding",chatButtonTooltipClosedWithMessageCount:"Vis chat ({unreadMessagesCount} ulest)",chatButtonTooltipClose:"Skjul chat",chatButtonTooltipOpen:"Vis chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Kopier invitasjonskobling",copyInviteLinkActionedAriaLabel:"Invitasjonskobling er kopiert",dismissSidePaneButtonLabel:"Lukk",moreDrawerAudioDeviceMenuTitle:"Lydenhet",moreDrawerButtonLabel:"Flere alternativer",moreDrawerButtonTooltip:"Flere alternativer",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Hyttaler",moreDrawerCaptionsMenuTitle:"Undertekster",moreDrawerSpokenLanguageMenuTitle:"Talesprk",moreDrawerCaptionLanguageMenuTitle:"Sprk for undertekst",moreDrawerGalleryOptionsMenuTitle:"Gallerialternativer",peopleButtonLabel:"Personer",selectedPeopleButtonLabel:"Personer-knappen er valgt",peopleButtonTooltipOpen:"Vis deltakere",peopleButtonTooltipClose:"Skjul deltakere",peoplePaneSubTitle:"I denne samtalen",peoplePaneTitle:"Personer",pictureInPictureTileAriaLabel:"Videofeeder. Klikk for  g tilbake til samtaleskjermen.",removeMenuLabel:"Fjern",openDialpadButtonLabel:"Sl telefonnummeret",returnToCallButtonAriaDescription:"G tilbake til samtale",returnToCallButtonAriaLabel:"Tilbake",peoplePaneAddPeopleButtonLabel:"Legg til personer",dialpadStartCallButtonLabel:"Ringe",dialpadModalTitle:"Sl telefonnummeret",dialpadModalAriaLabel:"Numerisk tastatur",dialpadCloseModalButtonAriaLabel:"Lukk numerisk tastatur",openDtmfDialpadLabel:"Vis numerisk tastatur",dtmfDialpadPlaceholderText:"Skriv inn nummer"};var nb_NO = {call:call$8,chat:chat$8,callWithChat:callWithChat$8};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Norwegian Bokml (Norway)
 *
 * @public
 */
const COMPOSITE_LOCALE_NB_NO = {
    component: COMPONENT_LOCALE_NB_NO,
    strings: createCompositeStrings(nb_NO)
};

var call$7={cameraLabel:"Camera",noCamerasLabel:"Geen camera's gevonden",cameraPermissionDenied:"Uw browser blokkeert de toegang tot uw camera",cameraTurnedOff:"Camera is uitgeschakeld",chatButtonLabel:"Chatten",close:"Sluiten",complianceBannerNowOnlyRecording:"U bent nu alleen deze vergadering aan het opnemen.",complianceBannerNowOnlyTranscription:"U bent nu alleen deze vergadering aan het transcriberen.",complianceBannerRecordingAndTranscriptionSaved:"Opname en transcriptie worden opgeslagen.",complianceBannerRecordingAndTranscriptionStarted:"Opname en transcriptie zijn gestart.",complianceBannerRecordingAndTranscriptionStopped:"Opname en transcriptie zijn gestopt.",complianceBannerRecordingSaving:"De opname wordt opgeslagen.",complianceBannerRecordingStarted:"De opname is gestart.",complianceBannerRecordingStopped:"De opname is gestopt.",complianceBannerTranscriptionStarted:"Transcriptie is gestart.",complianceBannerTranscriptionConsent:"Door deel te nemen, geeft u toestemming voor het transcriberen van deze vergadering.",complianceBannerTranscriptionSaving:"Transcriptie wordt opgeslagen.",complianceBannerTranscriptionStopped:"Transcriptie is gestopt.",configurationPageTitle:"Een oproep starten",copyInviteLinkButtonLabel:"Uitnodigingskoppeling kopiren",copyInviteLinkActionedAriaLabel:"Uitnodigingskoppeling gekopieerd",defaultPlaceHolder:"Een optie selecteren",dismissSidePaneButtonLabel:"Sluiten",videoEffectsPaneTitle:"Effecten",videoEffectsPaneBackgroundSelectionTitle:"Achtergrond",configurationPageVideoEffectsButtonLabel:"Effecten",unableToStartVideoEffect:"Kan video-effect niet toepassen.",blurBackgroundEffectButtonLabel:"Vervagen",blurBackgroundTooltip:"Achtergrond vervagen",removeBackgroundEffectButtonLabel:"Geen",removeBackgroundTooltip:"Achtergrond verwijderen",cameraOffBackgroundEffectWarningText:"Uw camera is uitgeschakeld. Schakel de camera in om het video-effect te zien.",failedToJoinCallDueToNoNetworkMoreDetails:"De verbinding is verbroken vanwege een netwerkprobleem. Controleer de verbinding en neem opnieuw deel.",failedToJoinCallDueToNoNetworkTitle:"Verbinding verbroken",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"U hebt geen toegang gekregen in het gesprek. Als dit een fout is, neemt u opnieuw deel aan het gesprek.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Verwijderd uit lobby",learnMore:"Meer informatie",leavingCallTitle:"Verlaten...",leftCallMoreDetails:"Als dit een vergissing was, neemt u opnieuw deel aan het gesprek.",leftCallTitle:"U hebt het gesprek verlaten",lobbyScreenConnectingToCallTitle:"Deelnemen aan oproep",lobbyScreenWaitingToBeAdmittedTitle:"Wachten om te worden toegelaten",microphonePermissionDenied:"Uw browser blokkeert de toegang tot uw microfoon",microphoneToggleInLobbyNotAllowed:"Kan niet dempen of dempen opheffen in de lobby.",mutedMessage:"Uw geluid is gedempt",networkReconnectMoreDetails:"Er is iets misgegaan. We proberen terug te gaan naar het gesprek.",networkReconnectTitle:"Wacht even",notInvitedToRoomDetails:"U kunt niet deelnemen aan deze ruimte omdat u geen uitnodiging hebt.",notInvitedToRoomTitle:"Niet uitgenodigd voor ruimte",peopleButtonLabel:"Personen",selectedPeopleButtonLabel:"Knop Personen geselecteerd",peoplePaneTitle:"Personen",peoplePaneMoreButtonAriaLabel:"Meer",peopleButtonTooltipOpen:"Deelnemers weergeven",peopleButtonTooltipClose:"Deelnemers verbergen",peoplePaneSubTitle:"In dit gesprek {numberOfPeople}",privacyPolicy:"Privacybeleid",rejoinCallButtonLabel:"Opnieuw deelnemen aan gesprek",removedFromCallMoreDetails:"Een andere deelnemer heeft u uit het gesprek verwijderd.",removedFromCallTitle:"U bent verwijderd",removeMenuLabel:"Verwijderen",startSpotlightParticipantListMenuLabel:"Spotlight voor iedereen",addSpotlightParticipantListMenuLabel:"Spotlight toevoegen",stopSpotlightParticipantListMenuLabel:"Spotlighten stoppen",stopSpotlightOnSelfParticipantListMenuLabel:"Spotlight afsluiten",spotlightLimitReachedParticipantListMenuTitle:"Spotlightlimiet bereikt",stopAllSpotlightMenuLabel:"Alle spotlights stoppen",returnToCallButtonAriaDescription:"Terug naar gesprek",returnToCallButtonAriaLabel:"Terug",roomNotFoundDetails:"Kan de opgegeven ruimte-id niet vinden.",roomNotFoundTitle:"Ruimte niet gevonden",roomNotValidDetails:"Deze ruimte is momenteel niet geldig.",roomNotValidTitle:"De ruimte is niet geldig",inviteToRoomRemovedDetails:"Uw uitnodiging om deel te nemen aan deze ruimte is verwijderd.",inviteToRoomRemovedTitle:"Uitnodiging voor ruimte verwijderd",soundLabel:"Geluid",noMicrophonesLabel:"Geen microfoons gevonden",noSpeakersLabel:"Geen luidsprekers gevonden",startCallButtonLabel:"Gesprek starten",openDialpadButtonLabel:"Telefoonnummer kiezen",peoplePaneAddPeopleButtonLabel:"Personen toevoegen",dialpadStartCallButtonLabel:"Bellen",dialpadModalTitle:"Telefoonnummer kiezen",dialpadModalAriaLabel:"Telefoonkiezer",dialpadCloseModalButtonAriaLabel:"Toetsenblok sluiten",moreButtonCallingLabel:"Meer",resumeCallButtonLabel:"Hervatten",resumingCallButtonLabel:"Hervatten...",resumeCallButtonAriaLabel:"Gesprek hervatten",resumingCallButtonAriaLabel:"Gesprek hervatten",holdScreenLabel:"U staat in de wacht",openDtmfDialpadLabel:"Toetsenblok weergeven",dtmfDialpadPlaceholderText:"Nummer invoeren",outboundCallingNoticeString:"Bellen...",participantJoinedNoticeString:"{displayName} neemt deel",twoParticipantJoinedNoticeString:"{displayName1} en {displayName2} nemen deel",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} en {displayName3} nemen deel",participantLeftNoticeString:"{displayName} is vertrokken",twoParticipantLeftNoticeString:"{displayName1} en {displayName2} zijn vertrokken",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} en {displayName3} zijn vertrokken",unnamedParticipantString:"naamloze deelnemer",manyUnnamedParticipantsJoined:"naamloze deelnemer en {numOfParticipants} andere deelnemers nemen deel",manyUnnamedParticipantsLeft:"naamloze deelnemer en {numOfParticipants} andere deelnemers zijn vertrokken",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} en {numOfParticipants} andere deelnemers",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} en {numOfParticipants} andere deelnemers resterend",liveCaptionsLabel:"Liveondertitels",captionsSettingsLabel:"Instellingen voor ondertiteling",startCaptionsButtonOnLabel:"Bijschriften inschakelen",startCaptionsButtonOffLabel:"Ondertitels uitschakelen",startCaptionsButtonTooltipOnContent:"Ondertitels uitschakelen",startCaptionsButtonTooltipOffContent:"Bijschriften inschakelen",captionsSettingsModalTitle:"Instellingen voor ondertitels",captionsSettingsSpokenLanguageDropdownLabel:"Gesproken taal",captionsSettingsCaptionLanguageDropdownLabel:"Taal van ondertitels",captionsSettingsSpokenLanguageDropdownInfoText:"Taal die iedereen in dit gesprek spreekt.",captionsSettingsCaptionLanguageDropdownInfoText:"Bijschriften worden weergegeven in deze taal.",captionsSettingsConfirmButtonLabel:"Bevestigen",captionsSettingsCancelButtonLabel:"Annuleren",captionsSettingsModalAriaLabel:"Bijschriften instellen modaal",captionsSettingsCloseModalButtonAriaLabel:"Instelling voor ondertiteling sluiten",captionsBannerMoreButtonCallingLabel:"Meer",captionsBannerMoreButtonTooltip:"Meer opties",dismissModalAriaLabel:"Lokale en externe afbeelding en afbeelding, druk op Enter om terug te keren naar het gesprek",callRejectedTitle:"De aanroep kan niet worden voltooid",callRejectedMoreDetails:"De persoon die u probeert te bereiken, is niet beschikbaar. Probeer het later opnieuw.",callTimeoutTitle:"De aanroep kan niet worden voltooid",callTimeoutDetails:"De persoon die u probeert te bereiken, is niet beschikbaar. Probeer het later opnieuw.",callTimeoutBotTitle:"De aanroep kan niet worden voltooid",callTimeoutBotDetails:"De service die u probeert te bereiken, is niet beschikbaar. Probeer het later opnieuw.",dtmfDialerButtonLabel:"Toetsenblok",dtmfDialerButtonTooltipOn:"Toetsenblok weergeven",dtmfDialerButtonTooltipOff:"Toetsenblok verbergen",dtmfDialerMoreButtonLabelOn:"Toetsenblok weergeven",dtmfDialerMoreButtonLabelOff:"Toetsenblok verbergen",spokenLanguageStrings:{"ar-ae":"Arabisch - Verenigde Arabische Emiraten","ar-sa":"Arabisch - Saudi-Arabi","da-dk":"Deens","de-de":"Duits - Duitsland","en-au":"Engels - Australi","en-ca":"Engels - Canada","en-gb":"Engels - Verenigd Koninkrijk","en-in":"Engels - India","en-nz":"Engels - Nieuw-Zeeland","en-us":"Engels - Verenigde Staten","es-es":"Spaans - Spanje (modern)","es-mx":"Spaans - Mexico","fi-fi":"Fins","fr-ca":"Frans - Canada","fr-fr":"Frans - Frankrijk","hi-in":"Hindi","it-it":"Italiaans - Itali","ja-jp":"Japans","ko-kr":"Koreaans","nb-no":"Noors (Bokml)","nl-be":"Nederlands - Belgi","nl-nl":"Nederlands - Nederland","pl-pl":"Pools","pt-br":"Portugees - Brazili","ru-ru":"Russisch","sv-se":"Zweeds","zh-cn":"Chinees (Volksrepubliek China)","zh-hk":"Chinees - Hongkong SAR","cs-cz":"Tsjechisch","pt-pt":"Portugees - Portugal","tr-tr":"Turks","vi-vn":"Vietnamees","th-th":"Thai","he-il":"Hebreeuws","cy-gb":"Welsh","uk-ua":"Oekraens","el-gr":"Grieks","hu-hu":"Hongaars","ro-ro":"Roemeens","sk-sk":"Slowaaks","zh-tw":"Chinees - Taiwan"},captionLanguageStrings:{ar:"Arabisch",da:"Deens",de:"Duits",en:"Engels",es:"Spaans",fi:"Fins","fr-ca":"Frans - Canada",fr:"Frans - Frankrijk",hi:"Hindi",it:"Italiaans",ja:"Japans",ko:"Koreaans",nb:"Noors (Bokml)",nl:"Nederlands",pl:"Pools",pt:"Portugees - Brazili",ru:"Russisch",sv:"Zweeds","zh-Hans":"Vereenvoudigd Chinees","zh-Hant":"Traditioneel Chinees",cs:"Tsjechisch","pt-pt":"Portugees - Portugal",tr:"Turks",vi:"Vietnamees",th:"Thai",he:"Hebreeuws",cy:"Welsh",uk:"Oekraens",el:"Grieks",hu:"Hongaars",ro:"Roemeens",sk:"Slowaaks"},captionsBannerSpinnerText:"Ondertitels starten...",transferPageTransferorText:"Doorverbinden...",transferPageTransferTargetText:"Verbinding maken...",transferPageUnknownTransferorDisplayName:"Onbekend",transferPageUnknownTransferTargetDisplayName:"Onbekend",transferPageNoticeString:"U wordt doorgeschakeld",participantCouldNotBeReachedTitle:"Doeldeelnemer is momenteel niet beschikbaar",participantCouldNotBeReachedMoreDetails:"Neem contact op met de deelnemer wanneer deze beschikbaar is",permissionToReachTargetParticipantNotAllowedTitle:"Machtiging om de doeldeelnemer te bereiken is niet toegestaan",permissionToReachTargetParticipantNotAllowedMoreDetails:"Controleer of de doeldeelnemer zich in dezelfde tenant bevindt",unableToResolveTenantTitle:"Kan de tenant-id voor de doeldeelnemer niet omzetten",unableToResolveTenantMoreDetails:"Controleer of de deelnemer-id juist is ingevoerd",participantIdIsMalformedTitle:"Deelnemer-id heeft niet de juiste indeling",participantIdIsMalformedMoreDetails:"Controleer of de deelnemer-id de juiste indeling heeft",moreButtonGalleryControlLabel:"Bekijken",moreButtonGalleryPositionToggleLabel:"Galerie naar boven verplaatsen",moreButtonGallerySpeakerLayoutLabel:"Luidspreker",moreButtonGalleryFloatingLocalLayoutLabel:"Dynamisch",moreButtonGalleryDefaultLayoutLabel:"Galerieweergave",moreButtonGalleryFocusedContentLayoutLabel:"Focus op inhoud",moreButtonLargeGalleryDefaultLayoutLabel:"Grote galerie",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Uw camera is uitgeschakeld. U kunt geen video meer delen.",grantedDueToMeetingOption:"Uw camera is ingeschakeld. Schakel deze optie in als u video wilt delen."},unmuteMic:{lostDueToMeetingOption:"Uw microfoon is uitgeschakeld. U kunt het dempen niet meer opheffen.",grantedDueToMeetingOption:"Uw microfoon is ingeschakeld. Hef het dempen op als u wilt spreken."},shareScreen:{lostDueToRoleChangeToAttendee:"Uw rol is gewijzigd. Sommige acties, zoals het delen van inhoud, zijn niet beschikbaar voor u.",grantedDueToRoleChangeToPresenter:"U bent een presentator. U kunt inhoud delen en de vergadering vergemakkelijken."}},surveyTitle:"Help mee met verbeteren",starSurveyHelperText:"Wat was de kwaliteit van het gesprek?",starSurveyOneStarText:"De kwaliteit was erg slecht.",starSurveyTwoStarText:"De kwaliteit was slecht.",starSurveyThreeStarText:"De kwaliteit was goed.",starSurveyFourStarText:"De kwaliteit was geweldig.",starSurveyFiveStarText:"De kwaliteit was uitstekend.",surveyConfirmButtonLabel:"Feedback verzenden",starRatingAriaLabel:"Selecteer {0} van {1} sterren",surveySkipButtonLabel:"Overslaan",tagsSurveyQuestion:"Wat had beter kunnen zijn?",tagsSurveyTextFieldDefaultText:"Overig, geef een toelichting",tagsSurveyHelperText:"Controleer eventuele problemen die u hebt ondervonden",surveyTextboxDefaultText:"Overige, geef een toelichting",endOfSurveyText:"Hartelijk dank voor uw feedback.",surveyIssues:{overallRating:{callCannotJoin:"Ik kan niet deelnemen aan de oproep",callCannotInvite:"Ik kan niet iemand uitnodigen voor de oproep",hadToRejoin:"Ik moest opnieuw deelnemen aan de oproep",callEndedUnexpectedly:"Oproep is onverwacht beindigd voor mij",otherIssues:"Ik had andere problemen met de oproep"},audioRating:{noLocalAudio:"De ander kon geen geluid horen",noRemoteAudio:"Ik kon geen geluid horen",echo:"Ik hoorde echo's tijdens de oproep",audioNoise:"Ik hoorde een ruis tijdens de oproep",lowVolume:"Het volume was laag",audioStoppedUnexpectedly:"Audio is onverwacht gestopt",distortedSpeech:"Audio is vervormd",audioInterruption:"Audio is onderbroken",otherIssues:"Ik had andere audioproblemen in deze oproep"},videoRating:{noVideoReceived:"Ik kon geen video zien",noVideoSent:"Anderen konden mij niet zien",lowQuality:"Videokwaliteit was laag",freezes:"Video bevroren",stoppedUnexpectedly:"De video stopte onverwacht",darkVideoReceived:"Ik zie alleen donkere schermen wanneer anderen hun camera inschakelen",audioVideoOutOfSync:"Audio en video niet gesynchroniseerd",otherIssues:"Ik had andere audioproblemen in deze oproep"},screenshareRating:{noContentLocal:"Anderen kunnen mijn gedeelde scherm niet zien",noContentRemote:"Ik kon het gedeelde scherm van anderen niet zien",cannotPresent:"Ik kon mijn scherm niet presenteren",lowQuality:"De kwaliteit van scherm delen was laag",freezes:"Scherm delen bevroren",stoppedUnexpectedly:"Scherm delen is onverwacht gestopt",largeDelay:"Scherm dele heeft een grote vertraging",otherIssues:"Ik had andere problemen met het delen van het scherm in dit gesprek"}},SurveyIssuesHeadingStrings:{overallRating:"Algemeen",audioRating:"Audio",videoRating:"Video",screenshareRating:"Presenteren"},spotlightPrompt:{startSpotlightHeading:"Spotlight voor iedereen?",startSpotlightText:"U markeert deze video voor iedereen in de vergadering.",startSpotlightOnSelfText:"U markeert deze video voor iedereen in de vergadering.",startSpotlightConfirmButtonLabel:"Spotlight voor iedereen",startSpotlightCancelButtonLabel:"Annuleren",stopSpotlightHeading:"Wilt u deze video niet meer spotlighten?",stopSpotlightOnSelfHeading:"Spotlight afsluiten?",stopSpotlightText:"Deze video wordt niet meer gemarkeerd voor iedereen in de vergadering.",stopSpotlightOnSelfText:"Uw video wordt niet meer gemarkeerd voor iedereen in de vergadering.",stopSpotlightConfirmButtonLabel:"Spotlighten stoppen",stopSpotlightOnSelfConfirmButtonLabel:"Spotlight afsluiten",stopSpotlightCancelButtonLabel:"Annuleren"},exitSpotlightButtonLabel:"Spotlight afsluiten",exitSpotlightButtonTooltip:"Spotlight afsluiten"};var chat$7={chatListHeader:"In deze chat",uploadFile:"Bestand uploaden"};var callWithChat$7={chatButtonLabel:"Chatten",chatButtonNewMessageNotificationLabel:"Nieuw bericht",chatButtonTooltipClosedWithMessageCount:"Chat weergeven ({unreadMessagesCount} ongelezen)",chatButtonTooltipClose:"Chat verbergen",chatButtonTooltipOpen:"Chat weergeven",chatPaneTitle:"Chatten",copyInviteLinkButtonLabel:"Uitnodigingskoppeling kopiren",copyInviteLinkActionedAriaLabel:"Uitnodigingskoppeling gekopieerd",dismissSidePaneButtonLabel:"Sluiten",moreDrawerAudioDeviceMenuTitle:"Audioapparaat",moreDrawerButtonLabel:"Meer opties",moreDrawerButtonTooltip:"Meer opties",moreDrawerMicrophoneMenuTitle:"Microfoon",moreDrawerSpeakerMenuTitle:"Luidspreker",moreDrawerCaptionsMenuTitle:"Liveondertitels",moreDrawerSpokenLanguageMenuTitle:"Gesproken taal",moreDrawerCaptionLanguageMenuTitle:"Taal van ondertiteling",moreDrawerGalleryOptionsMenuTitle:"Galerieopties",peopleButtonLabel:"Personen",selectedPeopleButtonLabel:"Knop Personen geselecteerd",peopleButtonTooltipOpen:"Deelnemers weergeven",peopleButtonTooltipClose:"Deelnemers verbergen",peoplePaneSubTitle:"In dit gesprek",peoplePaneTitle:"Personen",pictureInPictureTileAriaLabel:"Videofeeds. Klik om terug te keren naar het oproepscherm.",removeMenuLabel:"Verwijderen",openDialpadButtonLabel:"Telefoonnummer kiezen",returnToCallButtonAriaDescription:"Terug naar gesprek",returnToCallButtonAriaLabel:"Terug",peoplePaneAddPeopleButtonLabel:"Personen toevoegen",dialpadStartCallButtonLabel:"Bellen",dialpadModalTitle:"Telefoonnummer kiezen",dialpadModalAriaLabel:"Telefoonkiezer",dialpadCloseModalButtonAriaLabel:"Toetsenblok sluiten",openDtmfDialpadLabel:"Toetsenblok weergeven",dtmfDialpadPlaceholderText:"Nummer invoeren"};var nl_NL = {call:call$7,chat:chat$7,callWithChat:callWithChat$7};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Dutch (Netherlands)
 *
 * @public
 */
const COMPOSITE_LOCALE_NL_NL = {
    component: COMPONENT_LOCALE_NL_NL,
    strings: createCompositeStrings(nl_NL)
};

var call$6={cameraLabel:"Kamera",noCamerasLabel:"Nie znaleziono adnej kamery",cameraPermissionDenied:"Przegldarka blokuje dostp do kamery",cameraTurnedOff:"Twoja kamera jest wyczona",chatButtonLabel:"Czat",close:"Zamknij",complianceBannerNowOnlyRecording:"W tej chwili tylko Ty nagrywasz to spotkanie.",complianceBannerNowOnlyTranscription:"W tej chwili tylko Ty transkrybujesz to spotkanie.",complianceBannerRecordingAndTranscriptionSaved:"Trwa zapisywanie nagrania i transkrypcji.",complianceBannerRecordingAndTranscriptionStarted:"Rozpoczto nagrywanie i transkrypcj.",complianceBannerRecordingAndTranscriptionStopped:"Zatrzymano nagrywanie i transkrypcj.",complianceBannerRecordingSaving:"Trwa zapisywanie nagrania.",complianceBannerRecordingStarted:"Rozpoczto nagrywanie.",complianceBannerRecordingStopped:"Nagranie zostao zatrzymane.",complianceBannerTranscriptionStarted:"Rozpoczto transkrypcj.",complianceBannerTranscriptionConsent:"Doczajc, wyraasz zgod na transkrypcj tego spotkania.",complianceBannerTranscriptionSaving:"Trwa zapisywanie transkrypcji.",complianceBannerTranscriptionStopped:"Zakoczono transkrypcj.",configurationPageTitle:"Rozpocznij rozmow",copyInviteLinkButtonLabel:"Kopiuj link do zaproszenia",copyInviteLinkActionedAriaLabel:"Skopiowano link do zaproszenia",defaultPlaceHolder:"Wybierz opcj",dismissSidePaneButtonLabel:"Zamknij",videoEffectsPaneTitle:"Efekty",videoEffectsPaneBackgroundSelectionTitle:"To",configurationPageVideoEffectsButtonLabel:"Efekty",unableToStartVideoEffect:"Nie mona zastosowa efektu wideo.",blurBackgroundEffectButtonLabel:"Rozmycie",blurBackgroundTooltip:"Rozmyj to",removeBackgroundEffectButtonLabel:"Brak",removeBackgroundTooltip:"Usu to",cameraOffBackgroundEffectWarningText:"Kamera jest wyczona. Wcz kamer, aby zobaczy efekt wideo.",failedToJoinCallDueToNoNetworkMoreDetails:"Poczenie zostao rozczone z powodu problemu z sieci. Sprawd poczenie i docz ponownie.",failedToJoinCallDueToNoNetworkTitle:"Rozmowa zostaa rozczona",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Nie udzielono Ci dostpu do rozmowy. Jeli to pomyka, docz ponownie do rozmowy.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Odrzucono z poczekalni",learnMore:"Dowiedz si wicej",leavingCallTitle:"Opuszczanie",leftCallMoreDetails:"Jeli to pomyka, docz ponownie do rozmowy.",leftCallTitle:"Opuszczono rozmow",lobbyScreenConnectingToCallTitle:"Doczanie do rozmowy",lobbyScreenWaitingToBeAdmittedTitle:"Oczekiwanie na przyjcie",microphonePermissionDenied:"Twoja przegldarka blokuje dostp do mikrofonu",microphoneToggleInLobbyNotAllowed:"Nie mona wyciszy ani wyczy wyciszenia w poczekalni.",mutedMessage:"Wyciszenie jest wczone",networkReconnectMoreDetails:"Wyglda na to, e wystpi problem. Prbujemy wrci do rozmowy.",networkReconnectTitle:"Czekaj",notInvitedToRoomDetails:"Nie moesz doczy do tego pokoju, poniewa nie masz zaproszenia.",notInvitedToRoomTitle:"Nie zaproszono do pokoju",peopleButtonLabel:"Osoby",selectedPeopleButtonLabel:"Wybrano przycisk Kontakty",peoplePaneTitle:"Osoby",peoplePaneMoreButtonAriaLabel:"Wicej",peopleButtonTooltipOpen:"Poka uczestnikw",peopleButtonTooltipClose:"Ukryj uczestnikw",peoplePaneSubTitle:"W tej rozmowie {numberOfPeople}",privacyPolicy:"Zasady ochrony prywatnoci",rejoinCallButtonLabel:"Docz ponownie do rozmowy",removedFromCallMoreDetails:"Inny uczestnik usun Ci z rozmowy.",removedFromCallTitle:"Usunito Ci",removeMenuLabel:"Usu",startSpotlightParticipantListMenuLabel:"Wyrnij dla wszystkich",addSpotlightParticipantListMenuLabel:"Dodaj wyrnienie",stopSpotlightParticipantListMenuLabel:"Zatrzymaj wyrnianie",stopSpotlightOnSelfParticipantListMenuLabel:"Zakocz wyrnienie",spotlightLimitReachedParticipantListMenuTitle:"Osignito limit wyrnienia",stopAllSpotlightMenuLabel:"Zatrzymaj wszystkie wyrnienia",returnToCallButtonAriaDescription:"Wr do rozmowy",returnToCallButtonAriaLabel:"Wstecz",roomNotFoundDetails:"Nie mona odnale podanego identyfikatora pokoju.",roomNotFoundTitle:"Nie znaleziono pokoju",roomNotValidDetails:"Ten pokj jest obecnie nieprawidowy.",roomNotValidTitle:"Pokj jest nieprawidowy",inviteToRoomRemovedDetails:"Twoje zaproszenie do doczenia do tego pokoju zostao usunite.",inviteToRoomRemovedTitle:"Usunito zaproszenie do pokoju",soundLabel:"Dwik",noMicrophonesLabel:"Nie znaleziono mikrofonw",noSpeakersLabel:"Nie znaleziono gonikw",startCallButtonLabel:"Zadzwo",openDialpadButtonLabel:"Wybierz numer telefonu",peoplePaneAddPeopleButtonLabel:"Dodaj osoby",dialpadStartCallButtonLabel:"Zadzwo",dialpadModalTitle:"Wybieranie numeru telefonu",dialpadModalAriaLabel:"Klawiatura numeryczna",dialpadCloseModalButtonAriaLabel:"Zamknij klawiatur numeryczn",moreButtonCallingLabel:"Wicej",resumeCallButtonLabel:"Wznw",resumingCallButtonLabel:"Trwa wznawianie...",resumeCallButtonAriaLabel:"Wznw poczenie",resumingCallButtonAriaLabel:"Wznw poczenie",holdScreenLabel:"Poczenie zostao zawieszone.",openDtmfDialpadLabel:"Poka klawiatur numeryczn",dtmfDialpadPlaceholderText:"Wprowad numer",outboundCallingNoticeString:"Trwa czenie",participantJoinedNoticeString:"uytkownik {displayName} doczy",twoParticipantJoinedNoticeString:"uytkownicy {displayName1} i {displayName2} doczyli",threeParticipantJoinedNoticeString:"uytkownicy {displayName1}, {displayName2} i {displayName3} doczyli",participantLeftNoticeString:"uczestnik {displayName} opuci",twoParticipantLeftNoticeString:"uczestnicy {displayName1} i {displayName2} opucili",threeParticipantLeftNoticeString:"uczestnicy {displayName1}, {displayName2} i {displayName3} opucili",unnamedParticipantString:"uczestnik bez nazwy",manyUnnamedParticipantsJoined:"uczestnik bez nazwy i {numOfParticipants} innych uczestnikw doczyli",manyUnnamedParticipantsLeft:"uczestnik bez nazwy i {numOfParticipants} innych uczestnikw opucili",manyParticipantsJoined:"doczono {displayName1}, {displayName2}, {displayName3} i {numOfParticipants} innych uczestnikw",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} i {numOfParticipants} innych uczestnikw pozostao",liveCaptionsLabel:"Napisy na ywo",captionsSettingsLabel:"Ustawienia napisw",startCaptionsButtonOnLabel:"Wcz podpisy",startCaptionsButtonOffLabel:"Wycz podpisy",startCaptionsButtonTooltipOnContent:"Wycz podpisy",startCaptionsButtonTooltipOffContent:"Wcz podpisy",captionsSettingsModalTitle:"Ustawienia napisw",captionsSettingsSpokenLanguageDropdownLabel:"Jzyk mwiony",captionsSettingsCaptionLanguageDropdownLabel:"Jzyk napisw",captionsSettingsSpokenLanguageDropdownInfoText:"Jzyk, w ktrym mwi wszyscy uczestnicy tej rozmowy.",captionsSettingsCaptionLanguageDropdownInfoText:"Napisy bd wywietlane w tym jzyku.",captionsSettingsConfirmButtonLabel:"Potwierd",captionsSettingsCancelButtonLabel:"Anuluj",captionsSettingsModalAriaLabel:"Modalne ustawianie podpisw",captionsSettingsCloseModalButtonAriaLabel:"Ustawienie podpisw",captionsBannerMoreButtonCallingLabel:"Wicej",captionsBannerMoreButtonTooltip:"Wicej opcji",dismissModalAriaLabel:"Lokalny i zdalny obraz i obraz, nacinij klawisz Enter, aby powrci do rozmowy",callRejectedTitle:"Nie mona zakoczy rozmowy",callRejectedMoreDetails:"Osoba, z ktr prbujesz si skontaktowa, jest niedostpna. Sprbuj ponownie pniej.",callTimeoutTitle:"Nie mona zakoczy rozmowy",callTimeoutDetails:"Osoba, z ktr prbujesz si skontaktowa, jest niedostpna. Sprbuj ponownie pniej.",callTimeoutBotTitle:"Nie mona zakoczy rozmowy",callTimeoutBotDetails:"Usuga, z ktr prbujesz si skontaktowa, jest niedostpna. Sprbuj ponownie pniej.",dtmfDialerButtonLabel:"Klawiatura numeryczna",dtmfDialerButtonTooltipOn:"Poka klawiatur numeryczn",dtmfDialerButtonTooltipOff:"Ukryj klawiatur numeryczn",dtmfDialerMoreButtonLabelOn:"Poka klawiatur numeryczn",dtmfDialerMoreButtonLabelOff:"Ukryj klawiatur numeryczn",spokenLanguageStrings:{"ar-ae":"arabski  Zjednoczone Emiraty Arabskie","ar-sa":"arabski  Arabia Saudyjska","da-dk":"duski","de-de":"niemiecki  Niemcy","en-au":"angielski  Australia","en-ca":"angielski  Kanada","en-gb":"angielski  Zjednoczone Krlestwo","en-in":"angielski  Indie","en-nz":"angielski  Nowa Zelandia","en-us":"angielski  Stany Zjednoczone","es-es":"hiszpaski  Hiszpania (nowoczesny)","es-mx":"hiszpaski  Meksyk","fi-fi":"fiski","fr-ca":"francuski  Kanada","fr-fr":"francuski  Francja","hi-in":"hindi","it-it":"woski  Wochy","ja-jp":"japoski","ko-kr":"koreaski","nb-no":"norweski (Bokml)","nl-be":"niderlandzki  Belgia","nl-nl":"niderlandzki  Holandia","pl-pl":"polski","pt-br":"portugalski  Brazylia","ru-ru":"rosyjski","sv-se":"szwedzki","zh-cn":"chiski (Chiska Republika Ludowa)","zh-hk":"chiski  Hongkong SAR","cs-cz":"czeski","pt-pt":"portugalski  Portugalia","tr-tr":"turecki","vi-vn":"wietnamski","th-th":"tajski","he-il":"hebrajski","cy-gb":"walijski","uk-ua":"ukraiski","el-gr":"grecki","hu-hu":"wgierski","ro-ro":"rumuski","sk-sk":"sowacki","zh-tw":"chiski  Tajwan"},captionLanguageStrings:{ar:"arabski",da:"duski",de:"niemiecki",en:"Angielski",es:"hiszpaski",fi:"fiski","fr-ca":"francuski  Kanada",fr:"francuski  Francja",hi:"hindi",it:"woski",ja:"japoski",ko:"koreaski",nb:"norweski (Bokml)",nl:"niderlandzki",pl:"polski",pt:"portugalski (Brazylia)",ru:"rosyjski",sv:"szwedzki","zh-Hans":"Chiski (uproszczony)","zh-Hant":"Chiski (tradycyjny)",cs:"czeski","pt-pt":"portugalski (Portugalia)",tr:"turecki",vi:"wietnamski",th:"tajski",he:"hebrajski",cy:"walijski",uk:"ukraiski",el:"grecki",hu:"wgierski",ro:"rumuski",sk:"sowacki"},captionsBannerSpinnerText:"Trwa uruchamianie napisw...",transferPageTransferorText:"Trwa przeczanie...",transferPageTransferTargetText:"Trwa czenie...",transferPageUnknownTransferorDisplayName:"Nieznany",transferPageUnknownTransferTargetDisplayName:"Nieznany",transferPageNoticeString:"Jeste w trakcie przekierowania",participantCouldNotBeReachedTitle:"Uczestnik docelowy jest obecnie niedostpny",participantCouldNotBeReachedMoreDetails:"Skontaktuj si z uczestnikiem, gdy bdzie dostpny",permissionToReachTargetParticipantNotAllowedTitle:"Uprawnienie do dotarcia do uczestnika docelowego jest niedozwolone",permissionToReachTargetParticipantNotAllowedMoreDetails:"Sprawd, czy uczestnik docelowy znajduje si w tej samej dzierawie",unableToResolveTenantTitle:"Nie mona rozpozna identyfikatora dzierawy dla uczestnika docelowego",unableToResolveTenantMoreDetails:"Sprawd, czy identyfikator uczestnika zosta wprowadzony poprawnie",participantIdIsMalformedTitle:"Identyfikator uczestnika ma niepoprawny format",participantIdIsMalformedMoreDetails:"Sprawd, czy identyfikator uczestnika ma poprawny format",moreButtonGalleryControlLabel:"Zobacz",moreButtonGalleryPositionToggleLabel:"Przenie galeri na gr",moreButtonGallerySpeakerLayoutLabel:"Gonik",moreButtonGalleryFloatingLocalLayoutLabel:"Dynamiczny",moreButtonGalleryDefaultLayoutLabel:"Widok galerii",moreButtonGalleryFocusedContentLayoutLabel:"Skoncentruj si na zawartoci",moreButtonLargeGalleryDefaultLayoutLabel:"Dua galeria",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Kamera zostaa wyczona. Nie moesz ju udostpnia wideo.",grantedDueToMeetingOption:"Kamera zostaa wczona. Wcz j, jeli chcesz udostpni wideo."},unmuteMic:{lostDueToMeetingOption:"Mikrofon zosta wyczony. Nie mona ju wyczy wyciszenia.",grantedDueToMeetingOption:"Mikrofon zosta wczony. Wycz wyciszenie, jeli chcesz mwi."},shareScreen:{lostDueToRoleChangeToAttendee:"Rola zostaa zmieniona. Niektre akcje, takie jak udostpnianie zawartoci, nie bd dla Ciebie dostpne.",grantedDueToRoleChangeToPresenter:"Jeste osob prowadzc. Moesz udostpnia zawarto i prowadzi spotkanie."}},surveyTitle:"Pom nam w ulepszaniu",starSurveyHelperText:"Jaka bya jako poczenia?",starSurveyOneStarText:"Jako bya za.",starSurveyTwoStarText:"Jako bya niska.",starSurveyThreeStarText:"Jako bya dobra.",starSurveyFourStarText:"Jako bya doskonaa.",starSurveyFiveStarText:"Jako bya wietna.",surveyConfirmButtonLabel:"Przelij opini",starRatingAriaLabel:"Wybierz {0} z {1} gwiazdek",surveySkipButtonLabel:"Pomi",tagsSurveyQuestion:"Co mona byo zrobi lepiej?",tagsSurveyTextFieldDefaultText:"Inny  prosimy okreli",tagsSurveyHelperText:"Sprawd wszelkie napotkane problemy",surveyTextboxDefaultText:"Inna odpowied, podaj szczegy",endOfSurveyText:"Dzikujemy za opini!",surveyIssues:{overallRating:{callCannotJoin:"Nie mog doczy do rozmowy",callCannotInvite:"Nie mog zaprosi innych osb do rozmowy",hadToRejoin:"Konieczne byo ponowne doczenie do rozmowy",callEndedUnexpectedly:"Rozmowa zostaa nieoczekiwanie zakoczona",otherIssues:"Wystpiy inne problemy z poczeniem"},audioRating:{noLocalAudio:"Mj rozmwca nic nie sysza",noRemoteAudio:"Nie byo sycha adnego dwiku",echo:"Podczas rozmowy sycha byo echo",audioNoise:"Sysz szum podczas rozmowy",lowVolume:"Poziom gonoci by zbyt niski",audioStoppedUnexpectedly:"Dwik zosta nieoczekiwanie zatrzymany",distortedSpeech:"Dwik by znieksztacony",audioInterruption:"Dwik zosta przerwany",otherIssues:"Wystpoway inne problemy z dwikiem podczas tego poczenia"},videoRating:{noVideoReceived:"Nie byo nic wida",noVideoSent:"Inne osoby mnie nie widziay",lowQuality:"Jako wideo bya niska",freezes:"Wideo zablokowane",stoppedUnexpectedly:"Wideo zostao nieoczekiwanie zatrzymane",darkVideoReceived:"Widz ciemne ekrany tylko wtedy, gdy inni wczaj kamer",audioVideoOutOfSync:"Dwik i obraz nie byy zsynchronizowane",otherIssues:"Wystpoway inne problemy z wideo podczas tego poczenia"},screenshareRating:{noContentLocal:"Inne osoby nie widziay mojego udostpnionego ekranu",noContentRemote:"Nie widz zrzutw ekranu innych osb",cannotPresent:"Nie mog zaprezentowa ekranu",lowQuality:"Jako udostpniania ekranu bya niska",freezes:"Udostpnianie ekranu zablokowane",stoppedUnexpectedly:"Udostpnianie ekranu zostao nieoczekiwanie zatrzymane",largeDelay:"Udostpnianie ekranu ma due opnienie",otherIssues:"Wystpiy inne problemy z udostpnianiem ekranu podczas tej rozmowy"}},SurveyIssuesHeadingStrings:{overallRating:"Oglne",audioRating:"Dwik",videoRating:"Wideo",screenshareRating:"W trakcie prezentacji"},spotlightPrompt:{startSpotlightHeading:"Wyrni dla wszystkich?",startSpotlightText:"Wyrnisz ten klip wideo dla wszystkich uczestnikw spotkania.",startSpotlightOnSelfText:"Wyrnisz swj klip wideo dla wszystkich uczestnikw spotkania.",startSpotlightConfirmButtonLabel:"Wyrnij dla wszystkich",startSpotlightCancelButtonLabel:"Anuluj",stopSpotlightHeading:"Zatrzyma wyrnianie tego klipu wideo?",stopSpotlightOnSelfHeading:"Zakoczy wyrnianie?",stopSpotlightText:"Klip wideo nie bdzie ju wyrniany dla wszystkich osb na spotkaniu.",stopSpotlightOnSelfText:"Twj klip wideo nie bdzie ju wyrniany dla wszystkich osb na spotkaniu.",stopSpotlightConfirmButtonLabel:"Zatrzymaj wyrnianie",stopSpotlightOnSelfConfirmButtonLabel:"Zakocz wyrnienie",stopSpotlightCancelButtonLabel:"Anuluj"},exitSpotlightButtonLabel:"Wyjd z wanych informacji",exitSpotlightButtonTooltip:"Wyjd z wanych informacji"};var chat$6={chatListHeader:"W tym czacie",uploadFile:"Przekazywanie pliku"};var callWithChat$6={chatButtonLabel:"Czat",chatButtonNewMessageNotificationLabel:"Nowa wiadomo",chatButtonTooltipClosedWithMessageCount:"Poka czat (nieprzeczytane: {unreadMessagesCount})",chatButtonTooltipClose:"Ukryj czat",chatButtonTooltipOpen:"Poka czat",chatPaneTitle:"Czat",copyInviteLinkButtonLabel:"Kopiuj link do zaproszenia",copyInviteLinkActionedAriaLabel:"Skopiowano link do zaproszenia",dismissSidePaneButtonLabel:"Zamknij",moreDrawerAudioDeviceMenuTitle:"Urzdzenie audio",moreDrawerButtonLabel:"Wicej opcji",moreDrawerButtonTooltip:"Wicej opcji",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Gonik",moreDrawerCaptionsMenuTitle:"Napisy na ywo",moreDrawerSpokenLanguageMenuTitle:"Jzyk mwiony",moreDrawerCaptionLanguageMenuTitle:"Jzyk napisw",moreDrawerGalleryOptionsMenuTitle:"Opcje galerii",peopleButtonLabel:"Osoby",selectedPeopleButtonLabel:"Wybrano przycisk Kontakty",peopleButtonTooltipOpen:"Poka uczestnikw",peopleButtonTooltipClose:"Ukryj uczestnikw",peoplePaneSubTitle:"W tej rozmowie",peoplePaneTitle:"Osoby",pictureInPictureTileAriaLabel:"Kanay wideo. Kliknij, aby powrci do ekranu rozmowy.",removeMenuLabel:"Usu",openDialpadButtonLabel:"Wybierz numer telefonu",returnToCallButtonAriaDescription:"Wr do rozmowy",returnToCallButtonAriaLabel:"Wstecz",peoplePaneAddPeopleButtonLabel:"Dodaj osoby",dialpadStartCallButtonLabel:"Zadzwo",dialpadModalTitle:"Wybieranie numeru telefonu",dialpadModalAriaLabel:"Klawiatura numeryczna",dialpadCloseModalButtonAriaLabel:"Zamknij klawiatur numeryczn",openDtmfDialpadLabel:"Poka klawiatur numeryczn",dtmfDialpadPlaceholderText:"Wprowad numer"};var pl_PL = {call:call$6,chat:chat$6,callWithChat:callWithChat$6};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Polish (Poland)
 *
 * @public
 */
const COMPOSITE_LOCALE_PL_PL = {
    component: COMPONENT_LOCALE_PL_PL,
    strings: createCompositeStrings(pl_PL)
};

var call$5={cameraLabel:"Cmera",noCamerasLabel:"Nenhuma cmera encontrada",cameraPermissionDenied:"Seu navegador est bloqueando o acesso  cmera",cameraTurnedOff:"Sua cmera est desativada",chatButtonLabel:"Chat",close:"Fechar",complianceBannerNowOnlyRecording:"Voc agora est apenas gravando esta reunio.",complianceBannerNowOnlyTranscription:"Voc agora est apenas transcrevendo esta reunio.",complianceBannerRecordingAndTranscriptionSaved:"A gravao e a transcrio esto sendo salvas.",complianceBannerRecordingAndTranscriptionStarted:"A gravao e a transcrio foram iniciadas.",complianceBannerRecordingAndTranscriptionStopped:"A gravao e a transcrio foram interrompidas.",complianceBannerRecordingSaving:"A gravao est sendo salva.",complianceBannerRecordingStarted:"A gravao foi iniciada.",complianceBannerRecordingStopped:"A gravao foi interrompida.",complianceBannerTranscriptionStarted:"A transcrio foi iniciada.",complianceBannerTranscriptionConsent:"Ao ingressar, voc est dando consentimento para que esta reunio seja transcrita.",complianceBannerTranscriptionSaving:"A transcrio est sendo salva.",complianceBannerTranscriptionStopped:"A transcrio foi interrompida.",configurationPageTitle:"Iniciar uma chamada",copyInviteLinkButtonLabel:"Copiar o link de convite",copyInviteLinkActionedAriaLabel:"Link de convite copiado",defaultPlaceHolder:"Selecionar uma opo",dismissSidePaneButtonLabel:"Fechar",videoEffectsPaneTitle:"Efeitos",videoEffectsPaneBackgroundSelectionTitle:"Tela de fundo",configurationPageVideoEffectsButtonLabel:"Efeitos",unableToStartVideoEffect:"No  possvel aplicar o efeito de vdeo.",blurBackgroundEffectButtonLabel:"Desfoque",blurBackgroundTooltip:"Desfocar a Tela de fundo",removeBackgroundEffectButtonLabel:"Nenhum",removeBackgroundTooltip:"Remover Tela de fundo",cameraOffBackgroundEffectWarningText:"A cmera est desligada. Ligue a cmera para ver o efeito de vdeo.",failedToJoinCallDueToNoNetworkMoreDetails:"A chamada foi desconectada devido a um problema de rede. Verifique sua conexo e ingresse novamente.",failedToJoinCallDueToNoNetworkTitle:"Chamada desconectada",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Voc no recebeu entrada na chamada. Se isso foi um erro, ingresse novamente na chamada.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Ignorado do lobby",learnMore:"Saber mais",leavingCallTitle:"Saindo...",leftCallMoreDetails:"Se isso foi um erro, ingresse novamente na chamada.",leftCallTitle:"Voc saiu da chamada",lobbyScreenConnectingToCallTitle:"Ingressando na chamada",lobbyScreenWaitingToBeAdmittedTitle:"Esperando para ser admitido",microphonePermissionDenied:"Seu navegador est bloqueando o acesso ao microfone",microphoneToggleInLobbyNotAllowed:"No  possvel ativar ou desativar mudo enquanto estiver no lobby.",mutedMessage:"Voc est com o mudo ativado",networkReconnectMoreDetails:"Parece que algo deu errado. Estamos tentando retornar  chamada.",networkReconnectTitle:"Em espera",notInvitedToRoomDetails:"Voc no pode ingressar nesta sala porque no tem um convite.",notInvitedToRoomTitle:"No convidado para a sala",peopleButtonLabel:"Pessoas",selectedPeopleButtonLabel:"Boto Pessoas Selecionado",peoplePaneTitle:"Pessoas",peoplePaneMoreButtonAriaLabel:"Mais",peopleButtonTooltipOpen:"Mostrar participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"Nessa chamada {numberOfPeople}",privacyPolicy:"Poltica de privacidade",rejoinCallButtonLabel:"Reingressar na chamada",removedFromCallMoreDetails:"Outro participante removeu voc da chamada.",removedFromCallTitle:"Voc foi removido",removeMenuLabel:"Remover",startSpotlightParticipantListMenuLabel:"Destacar para todos",addSpotlightParticipantListMenuLabel:"Adicionar destaque",stopSpotlightParticipantListMenuLabel:"Parar de destacar",stopSpotlightOnSelfParticipantListMenuLabel:"Sair de destaque",spotlightLimitReachedParticipantListMenuTitle:"Limite de destaque atingido",stopAllSpotlightMenuLabel:"Parar todos os refletores",returnToCallButtonAriaDescription:"Retornar  Chamada",returnToCallButtonAriaLabel:"Voltar",roomNotFoundDetails:"No foi possvel encontrar a ID da sala fornecida.",roomNotFoundTitle:"Sala no encontrada",roomNotValidDetails:"No momento, esta sala no  vlida.",roomNotValidTitle:"Sala invlida",inviteToRoomRemovedDetails:"Seu convite para ingressar nesta sala foi removido.",inviteToRoomRemovedTitle:"O convite para a sala foi removido",soundLabel:"Som",noMicrophonesLabel:"Nenhum microfone encontrado",noSpeakersLabel:"Nenhum alto-falante encontrado",startCallButtonLabel:"Iniciar chamada",openDialpadButtonLabel:"Nmero de telefone de discagem",peoplePaneAddPeopleButtonLabel:"Adicionar Pessoas",dialpadStartCallButtonLabel:"Chamar",dialpadModalTitle:"Nmero de Telefone de Discagem",dialpadModalAriaLabel:"Teclado de discagem",dialpadCloseModalButtonAriaLabel:"Fechar teclado",moreButtonCallingLabel:"Mais",resumeCallButtonLabel:"Retomar",resumingCallButtonLabel:"Retomando",resumeCallButtonAriaLabel:"Retomar chamada",resumingCallButtonAriaLabel:"Retomar chamada",holdScreenLabel:"Voc est em espera",openDtmfDialpadLabel:"Mostrar teclado de discagem",dtmfDialpadPlaceholderText:"Digite o nmero",outboundCallingNoticeString:"Chamando...",participantJoinedNoticeString:"{displayName} ingressou",twoParticipantJoinedNoticeString:"{displayName1} e {displayName2} ingressaram",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} e {displayName3} ingressaram",participantLeftNoticeString:"{displayName} saiu",twoParticipantLeftNoticeString:"{displayName1} e {displayName2} saram",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} e {displayName3} saram",unnamedParticipantString:"participante sem nome",manyUnnamedParticipantsJoined:"participante sem nome e outros {numOfParticipants} participantes ingressaram",manyUnnamedParticipantsLeft:"participante sem nome e outros {numOfParticipants} participantes saram",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} e {numOfParticipants} outros participantes ingressaram",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} e {numOfParticipants} outros participantes saram",liveCaptionsLabel:"Legendas ao Vivo",captionsSettingsLabel:"Configuraes de legenda",startCaptionsButtonOnLabel:"Ativar legendas",startCaptionsButtonOffLabel:"Desativar legendas",startCaptionsButtonTooltipOnContent:"Desativar legendas",startCaptionsButtonTooltipOffContent:"Ativar legendas",captionsSettingsModalTitle:"Configuraes de Legendas",captionsSettingsSpokenLanguageDropdownLabel:"Idioma falado",captionsSettingsCaptionLanguageDropdownLabel:"Idioma das legendas",captionsSettingsSpokenLanguageDropdownInfoText:"Idioma que todos nesta chamada esto falando.",captionsSettingsCaptionLanguageDropdownInfoText:"As legendas sero exibidas neste idioma.",captionsSettingsConfirmButtonLabel:"Confirmar",captionsSettingsCancelButtonLabel:"Cancelar",captionsSettingsModalAriaLabel:"Configurao de Legendas Modal",captionsSettingsCloseModalButtonAriaLabel:"Fechar Configurao de Legendas",captionsBannerMoreButtonCallingLabel:"Mais",captionsBannerMoreButtonTooltip:"Mais opes",dismissModalAriaLabel:"Imagem e imagem local e remota, pressione Enter para retornar  chamada",callRejectedTitle:"No foi possvel concluir a chamada",callRejectedMoreDetails:"A pessoa que voc est tentando acessar no est disponvel. Tente novamente mais tarde.",callTimeoutTitle:"No foi possvel concluir a chamada",callTimeoutDetails:"A pessoa que voc est tentando acessar no est disponvel. Tente novamente mais tarde.",callTimeoutBotTitle:"No foi possvel concluir a chamada",callTimeoutBotDetails:"O servio que voc est tentando acessar no est disponvel. Tente novamente mais tarde.",dtmfDialerButtonLabel:"Teclado de discagem",dtmfDialerButtonTooltipOn:"Mostrar teclado de discagem",dtmfDialerButtonTooltipOff:"Ocultar teclado de discagem",dtmfDialerMoreButtonLabelOn:"Mostrar teclado de discagem",dtmfDialerMoreButtonLabelOff:"Ocultar teclado de discagem",spokenLanguageStrings:{"ar-ae":"rabe - Emirados rabes Unidos","ar-sa":"rabe - Arbia Saudita","da-dk":"Dinamarqus","de-de":"Alemo - Alemanha","en-au":"Ingls - Austrlia","en-ca":"Ingls - Canad","en-gb":"Ingls - Reino Unido","en-in":"Ingls - ndia","en-nz":"Ingls - Nova Zelndia","en-us":"Ingls - Estados Unidos","es-es":"Espanhol - Espanha (Moderno)","es-mx":"Espanhol - Mxico","fi-fi":"Finlands","fr-ca":"Francs - Canad","fr-fr":"Francs - Frana","hi-in":"Hndi","it-it":"Italiano - Itlia","ja-jp":"Japons","ko-kr":"Coreano","nb-no":"Noruegus (Bokml)","nl-be":"Holands - Blgica","nl-nl":"Holands - Pases Baixos","pl-pl":"Polons","pt-br":"Portugus - Brasil","ru-ru":"Russo","sv-se":"Sueco","zh-cn":"Chins - Repblica Popular da China","zh-hk":"Chins - RAE de Hong Kong","cs-cz":"Tcheco","pt-pt":"Portugus - Portugal","tr-tr":"Turco","vi-vn":"Vietnamita","th-th":"Tailands","he-il":"Hebraico","cy-gb":"Gals","uk-ua":"Ucraniano","el-gr":"Grego","hu-hu":"Hngaro","ro-ro":"Romeno","sk-sk":"Eslovaco","zh-tw":"Chins - Taiwan"},captionLanguageStrings:{ar:"rabe",da:"Dinamarqus",de:"Alemo",en:"Ingls",es:"Espanhol",fi:"Finlands","fr-ca":"Francs - Canad",fr:"Francs - Frana",hi:"Hndi",it:"Italiano",ja:"Japons",ko:"Coreano",nb:"Noruegus (Bokml)",nl:"Holands",pl:"Polons",pt:"Portugus - Brasil",ru:"Russo",sv:"Sueco","zh-Hans":"Chins (Simplificado)","zh-Hant":"Chins (Tradicional)",cs:"Tcheco","pt-pt":"Portugus - Portugal",tr:"Turco",vi:"Vietnamita",th:"Tailands",he:"Hebraico",cy:"Gals",uk:"Ucraniano",el:"Grego",hu:"Hngaro",ro:"Romeno",sk:"Eslovaco"},captionsBannerSpinnerText:"Iniciando legendas...",transferPageTransferorText:"Transferindo...",transferPageTransferTargetText:"Conectando...",transferPageUnknownTransferorDisplayName:"Desconhecido",transferPageUnknownTransferTargetDisplayName:"Desconhecido",transferPageNoticeString:"Voc est sendo transferido",participantCouldNotBeReachedTitle:"O participante de destino no est disponvel no momento",participantCouldNotBeReachedMoreDetails:"Entre em contato com o participante quando ele estiver disponvel",permissionToReachTargetParticipantNotAllowedTitle:"A permisso para alcanar o participante de destino no  permitida",permissionToReachTargetParticipantNotAllowedMoreDetails:"Verifique se o participante de destino est no mesmo locatrio",unableToResolveTenantTitle:"No  possvel resolve ID do locatrio para o participante de destino",unableToResolveTenantMoreDetails:"Verifique se a ID do participante foi inserida corretamente",participantIdIsMalformedTitle:"A ID do participante no est no formato correto",participantIdIsMalformedMoreDetails:"Verifique marcar a ID do participante est no formato correto",moreButtonGalleryControlLabel:"Exibir",moreButtonGalleryPositionToggleLabel:"Mover a galeria para o topo",moreButtonGallerySpeakerLayoutLabel:"Viva-voz",moreButtonGalleryFloatingLocalLayoutLabel:"Dinmica",moreButtonGalleryDefaultLayoutLabel:"Modo de exibio de galeria",moreButtonGalleryFocusedContentLayoutLabel:"Foco no contedo",moreButtonLargeGalleryDefaultLayoutLabel:"Galeria Grande",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Sua cmera foi desabilitada. Voc no pode mais compartilhar vdeo.",grantedDueToMeetingOption:"Sua cmera foi habilitada. Ative-o se quiser compartilhar vdeo."},unmuteMic:{lostDueToMeetingOption:"Seu microfone foi desabilitado. Voc no pode mais ativar o som.",grantedDueToMeetingOption:"O seu microfone foi habilitado. Desative o mudo se quiser falar."},shareScreen:{lostDueToRoleChangeToAttendee:"Sua funo foi alterada. Algumas aes, como o compartilhamento de contedo, no estaro disponveis para voc.",grantedDueToRoleChangeToPresenter:"Voc  um apresentador. Voc pode compartilhar contedo e facilitar a reunio."}},surveyTitle:"Ajude-nos a melhorar",starSurveyHelperText:"Como estava a qualidade da chamada?",starSurveyOneStarText:"A qualidadeera ruim.",starSurveyTwoStarText:"A qualidade eraruim.",starSurveyThreeStarText:"A qualidade era boa.",starSurveyFourStarText:"A qualidade eratima.",starSurveyFiveStarText:"A qualidade estava excelente.",surveyConfirmButtonLabel:"Enviar Comentrios",starRatingAriaLabel:"Selecione {0} de {1} estrelas",surveySkipButtonLabel:"Ignorar",tagsSurveyQuestion:"O que poderia tersido melhor?",tagsSurveyTextFieldDefaultText:"Outro; especifique",tagsSurveyHelperText:"Marque quaisquer problemas que voc tenha enfrentado.",surveyTextboxDefaultText:"Outro. Especifique",endOfSurveyText:"Agradecemos seus comentrios!",surveyIssues:{overallRating:{callCannotJoin:"No foi possvel ingressar na chamada",callCannotInvite:"No foi possvel convidar outras pessoas para a chamada",hadToRejoin:"Eu tive que reingressar na chamada",callEndedUnexpectedly:"A chamada foi encerrada inesperadamente para mim",otherIssues:"Eu tive outros problemas com a chamada"},audioRating:{noLocalAudio:"O outro lado no conseguiu ouvir nenhum som",noRemoteAudio:"No consegui ouvir o som",echo:"Ouvi ecos na chamada",audioNoise:"Ouvi rudo na chamada",lowVolume:"O volume estava baixo",audioStoppedUnexpectedly:"O udio foi interrompido inesperadamente",distortedSpeech:"O udio estava distorcido",audioInterruption:"O udio foi interrompido",otherIssues:"Eu tive outros problemas de udio nesta chamada"},videoRating:{noVideoReceived:"No consegui ver o vdeo",noVideoSent:"Outras pessoas no puderam me ver",lowQuality:"A qualidade do vdeo estava baixa",freezes:"O vdeo ficou congelado",stoppedUnexpectedly:"O vdeo foi interrompido inesperadamente",darkVideoReceived:"S consigo ver telas escuras quando outras pessoas ativam a cmera",audioVideoOutOfSync:"O udio e o Vdeo estavam fora de sincronia",otherIssues:"Eu tive outros problemas de vdeo nesta chamada"},screenshareRating:{noContentLocal:"Outras pessoas no puderam ver meu compartilhamento de tela",noContentRemote:"No foi possvel ver o compartilhamento de tela de outras pessoas",cannotPresent:"No foi possvel apresentar minha tela",lowQuality:"A qualidade do compartilhamento de tela estava baixa",freezes:"O compartilhamento de tela ficou congelado",stoppedUnexpectedly:"O compartilhamento de tela foi interrompido inesperadamente",largeDelay:"O compartilhamento de tela tem um grande atraso",otherIssues:"Eu estava tendo outros problemas de compartilhamento de tela nesta chamada"}},SurveyIssuesHeadingStrings:{overallRating:"De modo geral",audioRating:"udio",videoRating:"Vdeo",screenshareRating:"Apresentando"},spotlightPrompt:{startSpotlightHeading:"Destacar para todo mundo?",startSpotlightText:"Voc vai realar este vdeo para todos os participantes da reunio.",startSpotlightOnSelfText:"Voc realar seu vdeo para todos os participantes da reunio.",startSpotlightConfirmButtonLabel:"Destacar para todo mundo",startSpotlightCancelButtonLabel:"Cancelar",stopSpotlightHeading:"Parar de dar destaque a este vdeo?",stopSpotlightOnSelfHeading:"Sair do destaque?",stopSpotlightText:"Esse vdeo no ser mais realado para todos os participantes da reunio.",stopSpotlightOnSelfText:"Seu vdeo no ser mais realado para todos os participantes da reunio.",stopSpotlightConfirmButtonLabel:"Parar de destacar",stopSpotlightOnSelfConfirmButtonLabel:"Sair do destaque",stopSpotlightCancelButtonLabel:"Cancelar"},exitSpotlightButtonLabel:"Sair do destaque",exitSpotlightButtonTooltip:"Sair do destaque"};var chat$5={chatListHeader:"Neste chat",uploadFile:"Carregar Arquivo"};var callWithChat$5={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Nova mensagem",chatButtonTooltipClosedWithMessageCount:"Mostrar chat ({unreadMessagesCount} no lido)",chatButtonTooltipClose:"Ocultar chat",chatButtonTooltipOpen:"Mostrar chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copiar o link de convite",copyInviteLinkActionedAriaLabel:"Link de convite copiado",dismissSidePaneButtonLabel:"Fechar",moreDrawerAudioDeviceMenuTitle:"Dispositivo de udio",moreDrawerButtonLabel:"Mais opes",moreDrawerButtonTooltip:"Mais opes",moreDrawerMicrophoneMenuTitle:"Microfone",moreDrawerSpeakerMenuTitle:"Alto-falante",moreDrawerCaptionsMenuTitle:"Legendas ao Vivo",moreDrawerSpokenLanguageMenuTitle:"Idioma falado",moreDrawerCaptionLanguageMenuTitle:"Idioma da legenda",moreDrawerGalleryOptionsMenuTitle:"Opes da galeria",peopleButtonLabel:"Pessoas",selectedPeopleButtonLabel:"Boto Pessoas Selecionado",peopleButtonTooltipOpen:"Mostrar Participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"Nesta chamada",peoplePaneTitle:"Pessoas",pictureInPictureTileAriaLabel:"Feeds de vdeo. Clique para retornar  tela de chamada.",removeMenuLabel:"Remover",openDialpadButtonLabel:"Nmero de telefone de discagem",returnToCallButtonAriaDescription:"Retornar  Chamada",returnToCallButtonAriaLabel:"Voltar",peoplePaneAddPeopleButtonLabel:"Adicionar Pessoas",dialpadStartCallButtonLabel:"Chamar",dialpadModalTitle:"Nmero de Telefone de Discagem",dialpadModalAriaLabel:"Teclado de discagem",dialpadCloseModalButtonAriaLabel:"Fechar teclado",openDtmfDialpadLabel:"Mostrar teclado de discagem",dtmfDialpadPlaceholderText:"Digite o nmero"};var pt_BR = {call:call$5,chat:chat$5,callWithChat:callWithChat$5};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Portuguese (Brazil)
 *
 * @public
 */
const COMPOSITE_LOCALE_PT_BR = {
    component: COMPONENT_LOCALE_PT_BR,
    strings: createCompositeStrings(pt_BR)
};

var call$4={cameraLabel:"",noCamerasLabel:"  ",cameraPermissionDenied:"     ",cameraTurnedOff:" ",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"      .",complianceBannerNowOnlyTranscription:"      .",complianceBannerRecordingAndTranscriptionSaved:"   .",complianceBannerRecordingAndTranscriptionStarted:"   .",complianceBannerRecordingAndTranscriptionStopped:"   .",complianceBannerRecordingSaving:" .",complianceBannerRecordingStarted:" .",complianceBannerRecordingStopped:" .",complianceBannerTranscriptionStarted:" .",complianceBannerTranscriptionConsent:",       .",complianceBannerTranscriptionSaving:" .",complianceBannerTranscriptionStopped:" .",configurationPageTitle:"",copyInviteLinkButtonLabel:"   ",copyInviteLinkActionedAriaLabel:"     ",defaultPlaceHolder:"   ",dismissSidePaneButtonLabel:"",videoEffectsPaneTitle:"",videoEffectsPaneBackgroundSelectionTitle:"",configurationPageVideoEffectsButtonLabel:"",unableToStartVideoEffect:"    .",blurBackgroundEffectButtonLabel:"",blurBackgroundTooltip:" ",removeBackgroundEffectButtonLabel:"",removeBackgroundTooltip:" ",cameraOffBackgroundEffectWarningText:" .  ,   .",failedToJoinCallDueToNoNetworkMoreDetails:"   -   .      .",failedToJoinCallDueToNoNetworkTitle:" ",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"     .     ,    .",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"    \" \"",learnMore:"",leavingCallTitle:"...",leftCallMoreDetails:"    ,    .",leftCallTitle:"  ",lobbyScreenConnectingToCallTitle:"  ",lobbyScreenWaitingToBeAdmittedTitle:" ",microphonePermissionDenied:"     ",microphoneToggleInLobbyNotAllowed:"    ,   \" \".",mutedMessage:"  ",networkReconnectMoreDetails:", -   .     .",networkReconnectTitle:"",notInvitedToRoomDetails:"      ,      .",notInvitedToRoomTitle:"   ",peopleButtonLabel:"",selectedPeopleButtonLabel:"  \"\"",peoplePaneTitle:"",peoplePaneMoreButtonAriaLabel:"",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:"   {numberOfPeople}",privacyPolicy:" ",rejoinCallButtonLabel:"   ",removedFromCallMoreDetails:"     .",removedFromCallTitle:"  ",removeMenuLabel:"",startSpotlightParticipantListMenuLabel:"   ",addSpotlightParticipantListMenuLabel:" ",stopSpotlightParticipantListMenuLabel:" ",stopSpotlightOnSelfParticipantListMenuLabel:"",spotlightLimitReachedParticipantListMenuTitle:"   ",stopAllSpotlightMenuLabel:"  ",returnToCallButtonAriaDescription:"  ",returnToCallButtonAriaLabel:"",roomNotFoundDetails:"     .",roomNotFoundTitle:"  ",roomNotValidDetails:"     .",roomNotValidTitle:" ",inviteToRoomRemovedDetails:"       .",inviteToRoomRemovedTitle:"   ",soundLabel:"",noMicrophonesLabel:"  ",noSpeakersLabel:"  ",startCallButtonLabel:" ",openDialpadButtonLabel:"  ",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"  ",dialpadModalAriaLabel:"  ",dialpadCloseModalButtonAriaLabel:"   ",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"",resumeCallButtonAriaLabel:" ",resumingCallButtonAriaLabel:" ",holdScreenLabel:"   ",openDtmfDialpadLabel:"   ",dtmfDialpadPlaceholderText:" ",outboundCallingNoticeString:" ...",participantJoinedNoticeString:" {displayName} ",twoParticipantJoinedNoticeString:"{displayName1}  {displayName2} ",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2}  {displayName3} ",participantLeftNoticeString:" {displayName} ",twoParticipantLeftNoticeString:"{displayName1}  {displayName2} ",threeParticipantLeftNoticeString:"{displayName1}, {displayName2}  {displayName3} ",unnamedParticipantString:"  ",manyUnnamedParticipantsJoined:"     {numOfParticipants}  ",manyUnnamedParticipantsLeft:"     {numOfParticipants}  ",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3}  {numOfParticipants}  ",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3}  {numOfParticipants}  ",liveCaptionsLabel:" ",captionsSettingsLabel:" ",startCaptionsButtonOnLabel:"  ",startCaptionsButtonOffLabel:"  ",startCaptionsButtonTooltipOnContent:"  ",startCaptionsButtonTooltipOffContent:"  ",captionsSettingsModalTitle:" ",captionsSettingsSpokenLanguageDropdownLabel:" ",captionsSettingsCaptionLanguageDropdownLabel:" ",captionsSettingsSpokenLanguageDropdownInfoText:",      .",captionsSettingsCaptionLanguageDropdownInfoText:"     .",captionsSettingsConfirmButtonLabel:"",captionsSettingsCancelButtonLabel:"",captionsSettingsModalAriaLabel:"   ",captionsSettingsCloseModalButtonAriaLabel:"  ",captionsBannerMoreButtonCallingLabel:"",captionsBannerMoreButtonTooltip:" ",dismissModalAriaLabel:"   .   ,    .",callRejectedTitle:"   ",callRejectedMoreDetails:",     , .   .",callTimeoutTitle:"   ",callTimeoutDetails:",     , .   .",callTimeoutBotTitle:"   ",callTimeoutBotDetails:",     , .   .",dtmfDialerButtonLabel:"  ",dtmfDialerButtonTooltipOn:"   ",dtmfDialerButtonTooltipOff:"   ",dtmfDialerMoreButtonLabelOn:"   ",dtmfDialerMoreButtonLabelOff:"   ",spokenLanguageStrings:{"ar-ae":" ()","ar-sa":" ( )","da-dk":"","de-de":" ()","en-au":" ()","en-ca":" ()","en-gb":" ( )","en-in":" ()","en-nz":" ( )","en-us":" ()","es-es":" (),  ","es-mx":" ()","fi-fi":"","fr-ca":" ()","fr-fr":" ()","hi-in":"","it-it":" ()","ja-jp":"","ko-kr":"","nb-no":" ()","nl-be":" ()","nl-nl":" ","pl-pl":"","pt-br":" ()","ru-ru":"","sv-se":"","zh-cn":" (  )","zh-hk":" (, )","cs-cz":"","pt-pt":" ()","tr-tr":"","vi-vn":"","th-th":"","he-il":"","cy-gb":"","uk-ua":"","el-gr":"","hu-hu":"","ro-ro":"","sk-sk":"","zh-tw":" ()"},captionLanguageStrings:{ar:"",da:"",de:"",en:"",es:"",fi:"","fr-ca":" ()",fr:" ()",hi:"",it:"",ja:"",ko:"",nb:" ()",nl:"",pl:"",pt:" ()",ru:"",sv:"","zh-Hans":",  ","zh-Hant":" ( )",cs:"","pt-pt":" ()",tr:"",vi:"",th:"",he:"",cy:"",uk:"",el:"",hu:"",ro:"",sk:""},captionsBannerSpinnerText:" ...",transferPageTransferorText:" ...",transferPageTransferTargetText:"...",transferPageUnknownTransferorDisplayName:"",transferPageUnknownTransferTargetDisplayName:"",transferPageNoticeString:"   ",participantCouldNotBeReachedTitle:"   ",participantCouldNotBeReachedMoreDetails:"  ,    ",permissionToReachTargetParticipantNotAllowedTitle:"      ",permissionToReachTargetParticipantNotAllowedMoreDetails:",        ",unableToResolveTenantTitle:"       ",unableToResolveTenantMoreDetails:",     ",participantIdIsMalformedTitle:"   ",participantIdIsMalformedMoreDetails:",       ",moreButtonGalleryControlLabel:"",moreButtonGalleryPositionToggleLabel:"  ",moreButtonGallerySpeakerLayoutLabel:"",moreButtonGalleryFloatingLocalLayoutLabel:"",moreButtonGalleryDefaultLayoutLabel:" ",moreButtonGalleryFocusedContentLayoutLabel:"  ",moreButtonLargeGalleryDefaultLayoutLabel:" ",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:" .      .",grantedDueToMeetingOption:" .   ,    ."},unmuteMic:{lostDueToMeetingOption:"  .      .",grantedDueToMeetingOption:"  .  ,   ."},shareScreen:{lostDueToRoleChangeToAttendee:"  .  ,     ,   .",grantedDueToRoleChangeToPresenter:" .          ."}},surveyTitle:" ",starSurveyHelperText:"    ?",starSurveyOneStarText:"   .",starSurveyTwoStarText:"  .",starSurveyThreeStarText:"  .",starSurveyFourStarText:"  .",starSurveyFiveStarText:"  .",surveyConfirmButtonLabel:" ",starRatingAriaLabel:" {0}  {1} ",surveySkipButtonLabel:"",tagsSurveyQuestion:"   ?",tagsSurveyTextFieldDefaultText:", ",tagsSurveyHelperText:"  ,    ",surveyTextboxDefaultText:", ",endOfSurveyText:"  !",surveyIssues:{overallRating:{callCannotJoin:"    ",callCannotInvite:"      ",hadToRejoin:"     ",callEndedUnexpectedly:"  ",otherIssues:"      "},audioRating:{noLocalAudio:"     ",noRemoteAudio:"    .",echo:"     ",audioNoise:"     ",lowVolume:"  ",audioStoppedUnexpectedly:"  ",distortedSpeech:" ",audioInterruption:"  ",otherIssues:"          "},videoRating:{noVideoReceived:"    ",noVideoSent:"    ",lowQuality:"  ",freezes:" ",stoppedUnexpectedly:"  ",darkVideoReceived:"   ,    ",audioVideoOutOfSync:"    ",otherIssues:"          "},screenshareRating:{noContentLocal:"       ",noContentRemote:"      ",cannotPresent:"   ",lowQuality:"   ",freezes:"  ",stoppedUnexpectedly:"   ",largeDelay:"    ",otherIssues:"           "}},SurveyIssuesHeadingStrings:{overallRating:"",audioRating:"",videoRating:"",screenshareRating:""},spotlightPrompt:{startSpotlightHeading:"    ?",startSpotlightText:"       .",startSpotlightOnSelfText:"       .",startSpotlightConfirmButtonLabel:"     ",startSpotlightCancelButtonLabel:"",stopSpotlightHeading:"    ?",stopSpotlightOnSelfHeading:"    ?",stopSpotlightText:"           .",stopSpotlightOnSelfText:"         .",stopSpotlightConfirmButtonLabel:"   ",stopSpotlightOnSelfConfirmButtonLabel:"  ",stopSpotlightCancelButtonLabel:""},exitSpotlightButtonLabel:"  ",exitSpotlightButtonTooltip:"  "};var chat$4={chatListHeader:"  ",uploadFile:" "};var callWithChat$4={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:" ",chatButtonTooltipClosedWithMessageCount:"  (: {unreadMessagesCount})",chatButtonTooltipClose:" ",chatButtonTooltipOpen:" ",chatPaneTitle:"",copyInviteLinkButtonLabel:"   ",copyInviteLinkActionedAriaLabel:"     ",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:" ",moreDrawerButtonLabel:" ",moreDrawerButtonTooltip:" ",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",moreDrawerCaptionsMenuTitle:" ",moreDrawerSpokenLanguageMenuTitle:" ",moreDrawerCaptionLanguageMenuTitle:" ",moreDrawerGalleryOptionsMenuTitle:" ",peopleButtonLabel:"",selectedPeopleButtonLabel:"  \"\"",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:"  ",peoplePaneTitle:"",pictureInPictureTileAriaLabel:" . ,     .",removeMenuLabel:"",openDialpadButtonLabel:"  ",returnToCallButtonAriaDescription:"  ",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"  ",dialpadModalAriaLabel:"  ",dialpadCloseModalButtonAriaLabel:"   ",openDtmfDialpadLabel:"   ",dtmfDialpadPlaceholderText:" "};var ru_RU = {call:call$4,chat:chat$4,callWithChat:callWithChat$4};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Russian (Russia)
 *
 * @public
 */
const COMPOSITE_LOCALE_RU_RU = {
    component: COMPONENT_LOCALE_RU_RU,
    strings: createCompositeStrings(ru_RU)
};

var call$3={cameraLabel:"Kamera",noCamerasLabel:"Ingen kamera hittades",cameraPermissionDenied:"Din webblsare blockerar tkomsten till kameran",cameraTurnedOff:"Din kamera r avstngd",chatButtonLabel:"Chatt",close:"Stng",complianceBannerNowOnlyRecording:"Du spelar nu bara in det hr mtet.",complianceBannerNowOnlyTranscription:"Nu transkriberar du bara det hr mtet.",complianceBannerRecordingAndTranscriptionSaved:"Inspelning och transkription sparas.",complianceBannerRecordingAndTranscriptionStarted:"Inspelning och avskrift har startats.",complianceBannerRecordingAndTranscriptionStopped:"Inspelning och avskrift har avslutats.",complianceBannerRecordingSaving:"Inspelningen sparas.",complianceBannerRecordingStarted:"Inspelningen har startat.",complianceBannerRecordingStopped:"Inspelningen har stoppats.",complianceBannerTranscriptionStarted:"Transkriptionen har startat.",complianceBannerTranscriptionConsent:"Genom att ansluta ger du ditt medgivande fr att det hr mtet ska transkriberas.",complianceBannerTranscriptionSaving:"Transkriptionen sparas.",complianceBannerTranscriptionStopped:"Avskriften har avslutats.",configurationPageTitle:"Starta ett samtal",copyInviteLinkButtonLabel:"Kopiera inbjudningslnk",copyInviteLinkActionedAriaLabel:"Inbjudningslnken har kopierats",defaultPlaceHolder:"Vlj ett alternativ",dismissSidePaneButtonLabel:"Stng",videoEffectsPaneTitle:"Effekter",videoEffectsPaneBackgroundSelectionTitle:"Bakgrund",configurationPageVideoEffectsButtonLabel:"Effekter",unableToStartVideoEffect:"Det gr inte att tillmpa videoeffekten.",blurBackgroundEffectButtonLabel:"Oskrpa",blurBackgroundTooltip:"Gr bakgrunden oskarp",removeBackgroundEffectButtonLabel:"Ingen",removeBackgroundTooltip:"Ta bort bakgrund",cameraOffBackgroundEffectWarningText:"Kameran r avstngd. Aktivera kameran fr att se videoeffekten.",failedToJoinCallDueToNoNetworkMoreDetails:"Samtalet kopplades frn p grund av ett ntverksproblem. Kontrollera anslutningen och anslut igen.",failedToJoinCallDueToNoNetworkTitle:"Samtalet har kopplats frn",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Du har inte beviljats ngot bidrag i samtalet. Om det var ett misstag ansluter du till samtalet igen.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Avvisad frn lobbyn",learnMore:"Mer information",leavingCallTitle:"Lmnar",leftCallMoreDetails:"Anslut till samtalet igen om det var ett misstag.",leftCallTitle:"Du lmnade samtalet",lobbyScreenConnectingToCallTitle:"Ansluter till samtalet",lobbyScreenWaitingToBeAdmittedTitle:"Vntar p att bli inslst",microphonePermissionDenied:"Din webblsare blockerar tkomsten till mikrofonen",microphoneToggleInLobbyNotAllowed:"Det gr inte att stnga av ljudet eller sl p ljudet i lobbyn.",mutedMessage:"Din mikrofon har stngts av",networkReconnectMoreDetails:"Ngot verkar ha gtt fel. Vi frsker komma in i samtalet igen.",networkReconnectTitle:"Vnta",notInvitedToRoomDetails:"Du kan inte ansluta till det hr rummet eftersom du inte har ngon inbjudan.",notInvitedToRoomTitle:"Inte inbjuden till rummet",peopleButtonLabel:"Personer",selectedPeopleButtonLabel:"Knappen Kontakter har valts",peoplePaneTitle:"Personer",peoplePaneMoreButtonAriaLabel:"Mer",peopleButtonTooltipOpen:"Visa deltagare",peopleButtonTooltipClose:"Dlj deltagare",peoplePaneSubTitle:"I det hr samtalet {numberOfPeople}",privacyPolicy:"Sekretesspolicy",rejoinCallButtonLabel:"Anslut till samtal igen",removedFromCallMoreDetails:"En annan deltagare tog bort dig frn samtalet.",removedFromCallTitle:"Du har tagits bort",removeMenuLabel:"Ta bort",startSpotlightParticipantListMenuLabel:"Uppmrksamma fr alla",addSpotlightParticipantListMenuLabel:"Lgg till uppmrksammande",stopSpotlightParticipantListMenuLabel:"Sluta uppmrksamma",stopSpotlightOnSelfParticipantListMenuLabel:"Spotlight",spotlightLimitReachedParticipantListMenuTitle:"Spotlight-grnsen har ntts",stopAllSpotlightMenuLabel:"Avsluta alla uppmrksammanden",returnToCallButtonAriaDescription:"terg till samtal",returnToCallButtonAriaLabel:"Tillbaka",roomNotFoundDetails:"Det gick inte att hitta det angivna rums-ID:t.",roomNotFoundTitle:"Rummet hittades inte",roomNotValidDetails:"Det hr rummet r inte giltigt just nu.",roomNotValidTitle:"Rummet r inte giltigt",inviteToRoomRemovedDetails:"Din inbjudan att ansluta till det hr rummet har tagits bort.",inviteToRoomRemovedTitle:"Inbjudan till rummet har tagits bort",soundLabel:"Ljud",noMicrophonesLabel:"Inga mikrofoner hittades",noSpeakersLabel:"Inga hgtalare hittades",startCallButtonLabel:"Starta samtal",openDialpadButtonLabel:"Ring telefonnummer",peoplePaneAddPeopleButtonLabel:"Lgg till personer",dialpadStartCallButtonLabel:"Ringa upp",dialpadModalTitle:"Ring telefonnummer",dialpadModalAriaLabel:"Knappsats",dialpadCloseModalButtonAriaLabel:"Stng knappsats",moreButtonCallingLabel:"Mer",resumeCallButtonLabel:"teruppta",resumingCallButtonLabel:"terupptar",resumeCallButtonAriaLabel:"teruppta samtal",resumingCallButtonAriaLabel:"teruppta samtal",holdScreenLabel:"Du r parkerad",openDtmfDialpadLabel:"Visa knappsats",dtmfDialpadPlaceholderText:"Ange nummer",outboundCallingNoticeString:"Ringer...",participantJoinedNoticeString:"{displayName} har anslutits",twoParticipantJoinedNoticeString:"{displayName1} och {displayName2} har anslutit",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} och {displayName3} gick med",participantLeftNoticeString:"{displayName} kvar",twoParticipantLeftNoticeString:"{displayName1} och {displayName2} har lmnat",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} och {displayName3} har lmnat",unnamedParticipantString:"namnls deltagare",manyUnnamedParticipantsJoined:"namnls deltagare och {numOfParticipants} andra deltagare gick med",manyUnnamedParticipantsLeft:"namnls deltagare och {numOfParticipants} andra deltagare kvar",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} och {numOfParticipants} andra deltagare har anslutit",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} och {numOfParticipants} andra deltagare har lmnat",liveCaptionsLabel:"Liveundertexter",captionsSettingsLabel:"Instllningar fr undertexter",startCaptionsButtonOnLabel:"Aktivera undertexter",startCaptionsButtonOffLabel:"Stng av undertexter",startCaptionsButtonTooltipOnContent:"Stng av undertexter",startCaptionsButtonTooltipOffContent:"Aktivera undertexter",captionsSettingsModalTitle:"Instllningar fr undertexter",captionsSettingsSpokenLanguageDropdownLabel:"Talat sprk",captionsSettingsCaptionLanguageDropdownLabel:"Sprk fr undertexter",captionsSettingsSpokenLanguageDropdownInfoText:"Sprk som alla i det hr samtalet talar.",captionsSettingsCaptionLanguageDropdownInfoText:"Undertexter visas p det hr sprket.",captionsSettingsConfirmButtonLabel:"Bekrfta",captionsSettingsCancelButtonLabel:"Avbryt",captionsSettingsModalAriaLabel:"Modalt fnster fr instllning av undertexter",captionsSettingsCloseModalButtonAriaLabel:"Stng instllningar fr undertexter",captionsBannerMoreButtonCallingLabel:"Mer",captionsBannerMoreButtonTooltip:"Fler alternativ",dismissModalAriaLabel:"Lokal bild och fjrrbild och bild, tryck p Retur fr att terg till samtalet",callRejectedTitle:"Det gick inte att slutfra samtalet",callRejectedMoreDetails:"Personen du frsker n r inte tillgnglig. Frsk igen senare.",callTimeoutTitle:"Det gick inte att slutfra samtalet",callTimeoutDetails:"Personen du frsker n r inte tillgnglig. Frsk igen senare.",callTimeoutBotTitle:"Det gick inte att slutfra samtalet",callTimeoutBotDetails:"Tjnsten som du frsker n r inte tillgnglig. Frsk igen senare.",dtmfDialerButtonLabel:"Knappsats",dtmfDialerButtonTooltipOn:"Visa knappsats",dtmfDialerButtonTooltipOff:"Dlj knappsatsen",dtmfDialerMoreButtonLabelOn:"Visa knappsats",dtmfDialerMoreButtonLabelOff:"Dlj knappsatsen",spokenLanguageStrings:{"ar-ae":"Arabiska  Frenade Arabemiraten","ar-sa":"Arabiska  Saudiarabien","da-dk":"Danska","de-de":"Tyska  Tyskland","en-au":"Engelska  Australien","en-ca":"Engelska  Kanada","en-gb":"Engelska  Storbritannien","en-in":"Engelska  Indien","en-nz":"Engelska  Nya Zeeland","en-us":"Engelska  USA","es-es":"Spanska  Spanien (modern sortering)","es-mx":"Spanska  Mexiko","fi-fi":"Finska","fr-ca":"Franska  Kanada","fr-fr":"Franska  Frankrike","hi-in":"Hindi","it-it":"Italienska  Italien","ja-jp":"Japanska","ko-kr":"Koreanska","nb-no":"Norska (bokml)","nl-be":"Nederlndska  Belgien","nl-nl":"Nederlndska -Nederlnderna","pl-pl":"Polska","pt-br":"Portugisiska  Brasilien","ru-ru":"Ryska","sv-se":"Svenska","zh-cn":"Kinesiska (Kina),","zh-hk":"Kinesiska  Hongkong SAR","cs-cz":"Tjeckiska","pt-pt":"Portugisiska  Portugal","tr-tr":"Turkiska","vi-vn":"Vietnamesiska","th-th":"Thailndska","he-il":"Hebreiska","cy-gb":"Walesiska","uk-ua":"Ukrainska","el-gr":"Grekiska","hu-hu":"Ungerska","ro-ro":"Rumnska","sk-sk":"Slovakiska","zh-tw":"Kinesiska  Taiwan"},captionLanguageStrings:{ar:"Arabiska",da:"Danska",de:"Tyska",en:"Engelska",es:"Spanska",fi:"Finska","fr-ca":"Franska  Kanada",fr:"Franska  Frankrike",hi:"Hindi",it:"Italienska",ja:"Japanska",ko:"Koreanska",nb:"Norska (bokml)",nl:"Nederlndska",pl:"Polska",pt:"Portugisiska  Brasilien",ru:"Ryska",sv:"Svenska","zh-Hans":"Kinesiska (frenklad)","zh-Hant":"Kinesiska (traditionell)",cs:"Tjeckiska","pt-pt":"Portugisiska  Portugal",tr:"Turkiska",vi:"Vietnamesiska",th:"Thailndska",he:"Hebreiska",cy:"Walesiska",uk:"Ukrainska",el:"Grekiska",hu:"Ungerska",ro:"Rumnska",sk:"Slovakiska"},captionsBannerSpinnerText:"Startar undertexter ...",transferPageTransferorText:"verfr...",transferPageTransferTargetText:"Ansluter...",transferPageUnknownTransferorDisplayName:"Oknd",transferPageUnknownTransferTargetDisplayName:"Oknd",transferPageNoticeString:"Ditt samtal verfrs",participantCouldNotBeReachedTitle:"Mldeltagaren r fr nrvarande inte tillgnglig",participantCouldNotBeReachedMoreDetails:"Kontakta deltagaren nr de r tillgngliga",permissionToReachTargetParticipantNotAllowedTitle:"Behrighet att n mldeltagaren r inte tillten",permissionToReachTargetParticipantNotAllowedMoreDetails:"Kontrollera att mldeltagaren finns i samma klientorganisation",unableToResolveTenantTitle:"Det gick inte att matcha klientorganisations-ID fr mldeltagaren",unableToResolveTenantMoreDetails:"Kontrollera att deltagar-ID:t har angetts korrekt",participantIdIsMalformedTitle:"Deltagar-ID:t har inte rtt format",participantIdIsMalformedMoreDetails:"Kontrollera att deltagar-ID:t har rtt format",moreButtonGalleryControlLabel:"Visa",moreButtonGalleryPositionToggleLabel:"Flytta galleriet hgst upp",moreButtonGallerySpeakerLayoutLabel:"Hgtalare",moreButtonGalleryFloatingLocalLayoutLabel:"Dynamisk",moreButtonGalleryDefaultLayoutLabel:"Gallerivy",moreButtonGalleryFocusedContentLayoutLabel:"Fokusera p innehllet",moreButtonLargeGalleryDefaultLayoutLabel:"Stort galleri",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Kameran har inaktiverats. Du kan inte lngre dela video.",grantedDueToMeetingOption:"Kameran har aktiverats. Aktivera det om du vill dela video."},unmuteMic:{lostDueToMeetingOption:"Mikrofonen har inaktiverats. Du kan inte lngre sl p ljudet.",grantedDueToMeetingOption:"Din mikrofon har aktiverats. Sl p ljudet om du vill prata."},shareScreen:{lostDueToRoleChangeToAttendee:"Din roll har ndrats. Vissa tgrder, som att dela innehll, r inte tillgngliga fr dig.",grantedDueToRoleChangeToPresenter:"Du r presentatr. Du kan dela innehll och underltta mtet."}},surveyTitle:"Hjlp oss att frbttra",starSurveyHelperText:"Hur var kvaliteten p samtalet?",starSurveyOneStarText:"Kvaliteten var dlig.",starSurveyTwoStarText:"Kvaliteten var inte bra.",starSurveyThreeStarText:"Kvaliteten var bra.",starSurveyFourStarText:"Kvaliteten var utmrkt.",starSurveyFiveStarText:"Kvaliteten var mycket bra.",surveyConfirmButtonLabel:"Skicka feedback",starRatingAriaLabel:"Markera {0} av {1} stjrnor",surveySkipButtonLabel:"Hoppa ver",tagsSurveyQuestion:"Vad kan frbttras?",tagsSurveyTextFieldDefaultText:"Annat, specificera",tagsSurveyHelperText:"Kontrollera eventuella problem som du har upplevt",surveyTextboxDefaultText:"Annat, specificera",endOfSurveyText:"Tack fr din feedback!",surveyIssues:{overallRating:{callCannotJoin:"Jag kunde inte ansluta till samtalet",callCannotInvite:"Jag kunde inte bjuda in andra till samtalet",hadToRejoin:"Jag var tvungen att teransluta till samtalet",callEndedUnexpectedly:"Samtalet avslutades ovntat t mig",otherIssues:"Jag hade andra problem med samtalet"},audioRating:{noLocalAudio:"Den jag talade med kunde inte hra ngot alls",noRemoteAudio:"Jag kunde inte hra ngot alls",echo:"Jag hrde eko i samtalet",audioNoise:"Jag hrde strande ljud i samtalet",lowVolume:"Volymen var fr lg",audioStoppedUnexpectedly:"Ljudet avbrts pltsligt",distortedSpeech:"Ljudet frvrngdes",audioInterruption:"Ljudet avbrts",otherIssues:"Jag hade andra ljudproblem i det hr samtalet"},videoRating:{noVideoReceived:"Jag kunde inte se ngon video",noVideoSent:"De andra deltagarna kunde inte se mig",lowQuality:"Videokvaliteten var lg",freezes:"Videon r frusen",stoppedUnexpectedly:"Videon avbrts pltsligt",darkVideoReceived:"Jag kan bara se mrka skrmar nr andra aktiverar kameran",audioVideoOutOfSync:"Ljud och video var inte synkroniserade",otherIssues:"Jag hade andra videoproblem i det hr samtalet"},screenshareRating:{noContentLocal:"Andra personer kunde inte se min skrmdelning",noContentRemote:"Jag kunde inte se andra personers skrmdelning",cannotPresent:"Jag kunde inte presentera min skrm",lowQuality:"Skrmdelningskvaliteten var lg",freezes:"Skrmdelningen r frusen",stoppedUnexpectedly:"Skrmdelningen stoppades ovntat",largeDelay:"Skrmdelningen har en stor frdrjning",otherIssues:"Jag hade andra skrmdelningsproblem i det hr samtalet"}},SurveyIssuesHeadingStrings:{overallRating:"vergripande",audioRating:"Ljud",videoRating:"Video",screenshareRating:"Presenterar"},spotlightPrompt:{startSpotlightHeading:"Uppmrksamma fr alla?",startSpotlightText:"Du kommer markera den hr videon fr alla i mtet.",startSpotlightOnSelfText:"Du kommer att markera din video fr alla i mtet.",startSpotlightConfirmButtonLabel:"Uppmrksamma fr alla",startSpotlightCancelButtonLabel:"Avbryt",stopSpotlightHeading:"Sluta att uppmrksamma den hr videon?",stopSpotlightOnSelfHeading:"Avsluta uppmrksammande?",stopSpotlightText:"Den hr videon markeras inte lngre fr alla i mtet.",stopSpotlightOnSelfText:"Din video kommer inte lngre vara markerad fr alla i mtet.",stopSpotlightConfirmButtonLabel:"Sluta uppmrksamma",stopSpotlightOnSelfConfirmButtonLabel:"Spotlight",stopSpotlightCancelButtonLabel:"Avbryt"},exitSpotlightButtonLabel:"Spotlight",exitSpotlightButtonTooltip:"Spotlight"};var chat$3={chatListHeader:"I den hr chatten",uploadFile:"Ladda upp fil"};var callWithChat$3={chatButtonLabel:"Chatt",chatButtonNewMessageNotificationLabel:"Nytt meddelande",chatButtonTooltipClosedWithMessageCount:"Visa chatt ({unreadMessagesCount} olst)",chatButtonTooltipClose:"Dlj chatt",chatButtonTooltipOpen:"Visa chatt",chatPaneTitle:"Chatt",copyInviteLinkButtonLabel:"Kopiera inbjudningslnk",copyInviteLinkActionedAriaLabel:"Inbjudningslnken har kopierats",dismissSidePaneButtonLabel:"Stng",moreDrawerAudioDeviceMenuTitle:"Ljudenhet",moreDrawerButtonLabel:"Fler alternativ",moreDrawerButtonTooltip:"Fler alternativ",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Hgtalare",moreDrawerCaptionsMenuTitle:"Liveundertexter",moreDrawerSpokenLanguageMenuTitle:"Talat sprk",moreDrawerCaptionLanguageMenuTitle:"Sprk fr undertext",moreDrawerGalleryOptionsMenuTitle:"Gallerialternativ",peopleButtonLabel:"Personer",selectedPeopleButtonLabel:"Knappen Kontakter har valts",peopleButtonTooltipOpen:"Visa deltagare",peopleButtonTooltipClose:"Dlj deltagare",peoplePaneSubTitle:"I det hr samtalet",peoplePaneTitle:"Personer",pictureInPictureTileAriaLabel:"Videofeeds. Klicka fr att terg till samtalsskrmen.",removeMenuLabel:"Ta bort",openDialpadButtonLabel:"Ring telefonnummer",returnToCallButtonAriaDescription:"terg till samtal",returnToCallButtonAriaLabel:"Tillbaka",peoplePaneAddPeopleButtonLabel:"Lgg till personer",dialpadStartCallButtonLabel:"Ringa upp",dialpadModalTitle:"Ring telefonnummer",dialpadModalAriaLabel:"Knappsats",dialpadCloseModalButtonAriaLabel:"Stng knappsats",openDtmfDialpadLabel:"Visa knappsats",dtmfDialpadPlaceholderText:"Ange nummer"};var sv_SE = {call:call$3,chat:chat$3,callWithChat:callWithChat$3};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Swedish (Sweden)
 *
 * @public
 */
const COMPOSITE_LOCALE_SV_SE = {
    component: COMPONENT_LOCALE_SV_SE,
    strings: createCompositeStrings(sv_SE)
};

var call$2={cameraLabel:"Kamera",noCamerasLabel:"Kamera bulunamad",cameraPermissionDenied:"Taraycnz kameranza eriimi engelliyor",cameraTurnedOff:"Kameranz kapatld",chatButtonLabel:"Sohbet",close:"Kapat",complianceBannerNowOnlyRecording:"u anda yalnzca bu toplanty kaydediyorsunuz.",complianceBannerNowOnlyTranscription:"u anda yalnzca bu toplantnn dkmn oluturuyorsunuz.",complianceBannerRecordingAndTranscriptionSaved:"Kayt ve dkm kaydediliyor.",complianceBannerRecordingAndTranscriptionStarted:"Kayt ve dkm balatld.",complianceBannerRecordingAndTranscriptionStopped:"Kayt ve dkm durduruldu.",complianceBannerRecordingSaving:"Kayt kaydediliyor.",complianceBannerRecordingStarted:"Kayt balad.",complianceBannerRecordingStopped:"Kayt durduruldu.",complianceBannerTranscriptionStarted:"Dkm balatld.",complianceBannerTranscriptionConsent:"Katlarak bu toplantnn dkmnn karlmasna onay verirsiniz.",complianceBannerTranscriptionSaving:"Dkm kaydediliyor.",complianceBannerTranscriptionStopped:"Dkm durduruldu.",configurationPageTitle:"Arama balatn",copyInviteLinkButtonLabel:"Davet balantsn kopyala",copyInviteLinkActionedAriaLabel:"Davet balants kopyaland",defaultPlaceHolder:"Bir seenek belirleyin",dismissSidePaneButtonLabel:"Kapat",videoEffectsPaneTitle:"Efektler",videoEffectsPaneBackgroundSelectionTitle:"Arka plan",configurationPageVideoEffectsButtonLabel:"Efektler",unableToStartVideoEffect:"Video efekti uygulanamyor.",blurBackgroundEffectButtonLabel:"Bulanklatr",blurBackgroundTooltip:"Arka Plan Bulanklatr",removeBackgroundEffectButtonLabel:"Seilmedi",removeBackgroundTooltip:"Arka Plan Kaldr",cameraOffBackgroundEffectWarningText:"Kameranz kapal. Video efektini grmek iin kameray an.",failedToJoinCallDueToNoNetworkMoreDetails:"Bir a sorunu nedeniyle arama balants kesildi. Balantnz kontrol edin ve yeniden katln.",failedToJoinCallDueToNoNetworkTitle:"Arama kesildi",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Aramaya katlmanza izin verilmedi. Bu ilem yanllkla yapldysa aramaya yeniden katln.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Lobiden karld",learnMore:"Daha fazla bilgi edinin",leavingCallTitle:"Ayrlyor...",leftCallMoreDetails:"Bu bir hataysa aramaya yeniden katln.",leftCallTitle:"Aramadan ayrldnz",lobbyScreenConnectingToCallTitle:"Aramaya katlyorsunuz",lobbyScreenWaitingToBeAdmittedTitle:"Kabul edilmeyi bekliyor",microphonePermissionDenied:"Taraycnz mikrofonunuza eriimi engelliyor",microphoneToggleInLobbyNotAllowed:"Lobideyken sesi kapatlamaz veya alamaz.",mutedMessage:"Sesiniz kapatld",networkReconnectMoreDetails:"Bir sorun olutu gibi grnyor. arya geri alnmaya allyor.",networkReconnectTitle:"Bekleyin",notInvitedToRoomDetails:"Davetiniz olmad iin bu odaya katlamazsnz.",notInvitedToRoomTitle:"Odaya davet edilmedi",peopleButtonLabel:"Kiiler",selectedPeopleButtonLabel:"Kiiler Dmesi Seildi",peoplePaneTitle:"Kiiler",peoplePaneMoreButtonAriaLabel:"Daha fazla",peopleButtonTooltipOpen:"Katlmclar gster",peopleButtonTooltipClose:"Katlmclar gizle",peoplePaneSubTitle:"Bu aramada {numberOfPeople} var",privacyPolicy:"Gizlilik ilkesi",rejoinCallButtonLabel:"arya yeniden katl",removedFromCallMoreDetails:"Baka bir katlmc sizi aramadan kard.",removedFromCallTitle:"karldnz",removeMenuLabel:"Kaldr",startSpotlightParticipantListMenuLabel:"Herkes iin ne kar",addSpotlightParticipantListMenuLabel:"ne karma ekle",stopSpotlightParticipantListMenuLabel:"ne karmay durdur",stopSpotlightOnSelfParticipantListMenuLabel:"ne karmadan k",spotlightLimitReachedParticipantListMenuTitle:"ne karma snrna ulald",stopAllSpotlightMenuLabel:"Tm ne karmalar durdur",returnToCallButtonAriaDescription:"Aramaya Dn",returnToCallButtonAriaLabel:"Geri",roomNotFoundDetails:"Salanan oda kimlii bulunamad.",roomNotFoundTitle:"Oda bulunamad",roomNotValidDetails:"Bu oda u anda geerli deil.",roomNotValidTitle:"Oda geerli deil",inviteToRoomRemovedDetails:"Bu odaya katlma davetiniz kaldrld.",inviteToRoomRemovedTitle:"Odaya davet kaldrld",soundLabel:"Ses",noMicrophonesLabel:"Mikrofon bulunamad",noSpeakersLabel:"Hoparlr bulunamad",startCallButtonLabel:"Arama balat",openDialpadButtonLabel:"Telefon numarasn evir",peoplePaneAddPeopleButtonLabel:"Kii Ekle",dialpadStartCallButtonLabel:"Ara",dialpadModalTitle:"Telefon Numarasn evir",dialpadModalAriaLabel:"Tu takm",dialpadCloseModalButtonAriaLabel:"Tu takmn kapat",moreButtonCallingLabel:"Dier",resumeCallButtonLabel:"Devam edin",resumingCallButtonLabel:"Devam ediyor...",resumeCallButtonAriaLabel:"Grmeye devam edin",resumingCallButtonAriaLabel:"Grmeye devam edin",holdScreenLabel:"Beklemeye alndnz",openDtmfDialpadLabel:"Tu takmn gster",dtmfDialpadPlaceholderText:"Numara girin",outboundCallingNoticeString:"Aranyor...",participantJoinedNoticeString:"{displayName} katld",twoParticipantJoinedNoticeString:"{displayName1} ve {displayName2} katld",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} ve {displayName3} katld",participantLeftNoticeString:"{displayName} ayrld",twoParticipantLeftNoticeString:"{displayName1} ve {displayName2} ayrld",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} ve {displayName3} ayrld",unnamedParticipantString:"adsz katlmc",manyUnnamedParticipantsJoined:"adsz katlmc ve {numOfParticipants} katlmc katld",manyUnnamedParticipantsLeft:"adsz katlmc ve {numOfParticipants} katlmc ayrld",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} ve {numOfParticipants} katlmc katld",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} ve {numOfParticipants} katlmc kald",liveCaptionsLabel:"Aklamal canl alt yazlar",captionsSettingsLabel:"Aklamal alt yaz ayarlar",startCaptionsButtonOnLabel:"Aklamal alt yazlar ama",startCaptionsButtonOffLabel:"Aklamal alt yazlar kapat",startCaptionsButtonTooltipOnContent:"Aklamal alt yazlar kapat",startCaptionsButtonTooltipOffContent:"Aklamal alt yazlar ama",captionsSettingsModalTitle:"Aklamal Alt Yaz Ayarlar",captionsSettingsSpokenLanguageDropdownLabel:"Konuulan dil",captionsSettingsCaptionLanguageDropdownLabel:"Aklamal alt yaz dili",captionsSettingsSpokenLanguageDropdownInfoText:"Bu ardaki herkesin konuma dili.",captionsSettingsCaptionLanguageDropdownInfoText:"Aklamal alt yazlar bu dilde grnr.",captionsSettingsConfirmButtonLabel:"Onayla",captionsSettingsCancelButtonLabel:"ptal",captionsSettingsModalAriaLabel:"Aklamal Alt Yaz Ayar Kalc",captionsSettingsCloseModalButtonAriaLabel:"Aklamal Alt Yaz Ayarn Kapat",captionsBannerMoreButtonCallingLabel:"Dier",captionsBannerMoreButtonTooltip:"Dier seenekler",dismissModalAriaLabel:"Yerel ve uzak resim ve resim, aramaya geri dnmek iin Enter tuuna basn",callRejectedTitle:"Arama tamamlanamad",callRejectedMoreDetails:"Ulamaya altnz kii kullanlamyor. Ltfen daha sonra yeniden deneyin.",callTimeoutTitle:"Arama tamamlanamad",callTimeoutDetails:"Ulamaya altnz kii kullanlamyor. Ltfen daha sonra yeniden deneyin.",callTimeoutBotTitle:"Arama tamamlanamad",callTimeoutBotDetails:"Erimeye altnz hizmet kullanlamyor. Ltfen daha sonra yeniden deneyin.",dtmfDialerButtonLabel:"Tu takm",dtmfDialerButtonTooltipOn:"Tu takmn gster",dtmfDialerButtonTooltipOff:"Saysal tu takmn gizle",dtmfDialerMoreButtonLabelOn:"Tu takmn gster",dtmfDialerMoreButtonLabelOff:"Saysal tu takmn gizle",spokenLanguageStrings:{"ar-ae":"Arapa - BAE","ar-sa":"Arapa - Suudi Arabistan","da-dk":"Danca","de-de":"Almanca - Almanya","en-au":"ngilizce - Avustralya","en-ca":"ngilizce - Kanada","en-gb":"ngilizce - Birleik Krallk","en-in":"ngilizce - Hindistan","en-nz":"ngilizce - Yeni Zelanda","en-us":"ngilizce - ABD","es-es":"spanyolca - spanya (Modern)","es-mx":"spanyolca - Meksika","fi-fi":"Fince","fr-ca":"Franszca - Kanada","fr-fr":"Franszca - Fransa","hi-in":"Hinte","it-it":"talyanca - talya","ja-jp":"Japonca","ko-kr":"Korece","nb-no":"Norvee (Bokml)","nl-be":"Hollanda dili - Belika","nl-nl":"Felemenke - Hollanda","pl-pl":"Lehe","pt-br":"Portekizce - Brezilya","ru-ru":"Rusa","sv-se":"svee","zh-cn":"ince - in Halk Cumhuriyeti","zh-hk":"ince - Hong Kong B","cs-cz":"eke","pt-pt":"Portekizce - Portekiz","tr-tr":"Trke","vi-vn":"Vietnamca","th-th":"Tayca","he-il":"branice","cy-gb":"Galce","uk-ua":"Ukraynaca","el-gr":"Yunanca","hu-hu":"Macarca","ro-ro":"Rumence","sk-sk":"Slovaka","zh-tw":"ince - Tayvan"},captionLanguageStrings:{ar:"Arapa",da:"Danca",de:"Almanca",en:"ngilizce",es:"spanyolca",fi:"Fince","fr-ca":"Franszca - Kanada",fr:"Franszca - Fransa",hi:"Hinte",it:"talyanca",ja:"Japonca",ko:"Korece",nb:"Norvee (Bokml)",nl:"Felemenke",pl:"Lehe",pt:"Portekizce - Brezilya",ru:"Rusa",sv:"svee","zh-Hans":"ince (Basitletirilmi)","zh-Hant":"ince (Geleneksel)",cs:"eke","pt-pt":"Portekizce - Portekiz",tr:"Trke",vi:"Vietnamca",th:"Tayca",he:"branice",cy:"Galce",uk:"Ukraynaca",el:"Yunanca",hu:"Macarca",ro:"Rumence",sk:"Slovaka"},captionsBannerSpinnerText:"Alt yazlar balatlyor...",transferPageTransferorText:"Aktarlyor...",transferPageTransferTargetText:"Balanyor...",transferPageUnknownTransferorDisplayName:"Bilinmiyor",transferPageUnknownTransferTargetDisplayName:"Bilinmiyor",transferPageNoticeString:"ar aktarlyor",participantCouldNotBeReachedTitle:"Hedef katlmc u anda uygun deil",participantCouldNotBeReachedMoreDetails:"Uygun olduunda katlmcyla iletiim kurun",permissionToReachTargetParticipantNotAllowedTitle:"Hedef katlmcya eriim iznine izin verilmiyor",permissionToReachTargetParticipantNotAllowedMoreDetails:"Ltfen hedef katlmcnn ayn kiracda olup olmadn denetleyin",unableToResolveTenantTitle:"Hedef katlmcnn kirac kimlii zlemiyor",unableToResolveTenantMoreDetails:"Ltfen katlmc kimliinin doru giril olup olmadn denetleyin",participantIdIsMalformedTitle:"Katlmc kimlii doru biimde deil",participantIdIsMalformedMoreDetails:"Ltfen katlmc kimliinin doru biimde olduundan emin olun",moreButtonGalleryControlLabel:"Grnm",moreButtonGalleryPositionToggleLabel:"Galeriyi en ste ta",moreButtonGallerySpeakerLayoutLabel:"Konumac",moreButtonGalleryFloatingLocalLayoutLabel:"Dinamik",moreButtonGalleryDefaultLayoutLabel:"Galeri grnm",moreButtonGalleryFocusedContentLayoutLabel:"erie odakl",moreButtonLargeGalleryDefaultLayoutLabel:"Byk Galeri",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"Kameranz devre d brakld. Artk video paylaasnz.",grantedDueToMeetingOption:"Kameranz etkinletirildi. Video paylamak istiyorsanz an."},unmuteMic:{lostDueToMeetingOption:"Mikrofonunuz devre d brakld. Artk sesi aamaznz.",grantedDueToMeetingOption:"Mikrofonunuz etkinletirildi. Konumak istiyorsanz sesi an."},shareScreen:{lostDueToRoleChangeToAttendee:"Rolnz deitirildi. erik paylama gibi baz eylemler kullanlamaz.",grantedDueToRoleChangeToPresenter:"Sunucuyuz. erik paylaabilir ve toplantya yardmc olabilirsiniz."}},surveyTitle:"Gelitirmemize yardmc olun",starSurveyHelperText:"Arama kalitesi nasld?",starSurveyOneStarText:"Kalite ktyd.",starSurveyTwoStarText:"Kalite dkt.",starSurveyThreeStarText:"Kalite iyiydi.",starSurveyFourStarText:"Kalite harikayd.",starSurveyFiveStarText:"Kalite mkemmeldi.",surveyConfirmButtonLabel:"Geri Bildirim Gnder",starRatingAriaLabel:"{1} zerinden {0} yldz sein",surveySkipButtonLabel:"Atla",tagsSurveyQuestion:"Neleri iyiletirebiliriz?",tagsSurveyTextFieldDefaultText:"Dier, ltfen belirtin",tagsSurveyHelperText:"Karlatnz tm sorunlar iaretleyin",surveyTextboxDefaultText:"Dier, ltfen belirtin",endOfSurveyText:"Geri bildiriminiz iin teekkr ederiz!",surveyIssues:{overallRating:{callCannotJoin:"arya katlamadm",callCannotInvite:"Bakalarn arya davet edemedim",hadToRejoin:"arya yeniden katlmam gerekirdi",callEndedUnexpectedly:"Arama benim iin beklenmedik bir ekilde sona erdi",otherIssues:"Aramayla ilgili baka sorunlar yayorum"},audioRating:{noLocalAudio:"Kar taraf ses duyamad",noRemoteAudio:"Ses duyamadm",echo:"Aramada yanklar duydum",audioNoise:"Aramada parazit vard",lowVolume:"Ses dzeyi dkt",audioStoppedUnexpectedly:"Ses beklenmedik ekilde durduruldu",distortedSpeech:"Ses bozuktu",audioInterruption:"Ses kesildi",otherIssues:"Bu aramada baka ses sorunlaryla karlatm"},videoRating:{noVideoReceived:"Grnt yoktu",noVideoSent:"Dierleri beni gremedi",lowQuality:"Video kalitesi dkt",freezes:"Video dondu",stoppedUnexpectedly:"Grnt beklenmedik ekilde durdu",darkVideoReceived:"Bakalar kameralarn etkinletirildiinde sadece siyah ekranlar gryorum",audioVideoOutOfSync:"Ses ve Videoda senkron sorunu vard",otherIssues:"Bu aramada baka video sorunlaryla karlatm"},screenshareRating:{noContentLocal:"Dier kiiler ekran paylamm gremedi",noContentRemote:"Dier kiilerin ekran paylamn gremedim",cannotPresent:"Ekranm gsteremedim",lowQuality:"Ekran paylam kalitesi dkt",freezes:"Ekran paylam donduruldu",stoppedUnexpectedly:"Ekran paylam beklenmedik ekilde durdu",largeDelay:"Ekran paylamnda byk bir gecikme var",otherIssues:"Bu aramada baka ekran paylam sorunlaryla karlatm"}},SurveyIssuesHeadingStrings:{overallRating:"Genel",audioRating:"Ses",videoRating:"Video",screenshareRating:"Sunu"},spotlightPrompt:{startSpotlightHeading:"Herkes iin ne karlsn m?",startSpotlightText:"Bu videoyu toplantdaki herkes iin ne karacaksnz.",startSpotlightOnSelfText:"Videonuzu toplantdaki herkes iin ne karacaksnz.",startSpotlightConfirmButtonLabel:"Herkes iin ne kar",startSpotlightCancelButtonLabel:"ptal",stopSpotlightHeading:"Bu video iin ne karma durdurulsun mu?",stopSpotlightOnSelfHeading:"ne karmadan klsn m?",stopSpotlightText:"Bu video artk toplantdaki herkes iin ne karlmayacak.",stopSpotlightOnSelfText:"Videonuz toplantdaki herkes iin artk ne karlmayacak.",stopSpotlightConfirmButtonLabel:"ne karmay durdur",stopSpotlightOnSelfConfirmButtonLabel:"ne karmadan k",stopSpotlightCancelButtonLabel:"ptal"},exitSpotlightButtonLabel:"ne karmadan k",exitSpotlightButtonTooltip:"ne karmadan k"};var chat$2={chatListHeader:"Bu sohbette",uploadFile:"Dosyay Karya Ykle"};var callWithChat$2={chatButtonLabel:"Sohbet",chatButtonNewMessageNotificationLabel:"Yeni leti",chatButtonTooltipClosedWithMessageCount:"Sohbeti gster ({unreadMessagesCount} okunmam)",chatButtonTooltipClose:"Sohbeti gizle",chatButtonTooltipOpen:"Sohbeti gster",chatPaneTitle:"Sohbet",copyInviteLinkButtonLabel:"Davet balantsn kopyala",copyInviteLinkActionedAriaLabel:"Davet balants kopyaland",dismissSidePaneButtonLabel:"Kapat",moreDrawerAudioDeviceMenuTitle:"Ses Cihaz",moreDrawerButtonLabel:"Dier seenekler",moreDrawerButtonTooltip:"Dier seenekler",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Hoparlr",moreDrawerCaptionsMenuTitle:"Aklamal canl alt yazlar",moreDrawerSpokenLanguageMenuTitle:"Konuulan dil",moreDrawerCaptionLanguageMenuTitle:"Aklamal alt yaz dili",moreDrawerGalleryOptionsMenuTitle:"Galeri seenekleri",peopleButtonLabel:"Kiiler",selectedPeopleButtonLabel:"Kiiler Dmesi Seildi",peopleButtonTooltipOpen:"Katlmclar gster",peopleButtonTooltipClose:"Katlmclar gizle",peoplePaneSubTitle:"Bu aramada",peoplePaneTitle:"Kiiler",pictureInPictureTileAriaLabel:"Video Aklar. ar ekranna dnmek iin tklayn.",removeMenuLabel:"Kaldr",openDialpadButtonLabel:"Telefon numarasn evir",returnToCallButtonAriaDescription:"Aramaya Dn",returnToCallButtonAriaLabel:"Geri",peoplePaneAddPeopleButtonLabel:"Kii Ekle",dialpadStartCallButtonLabel:"Ara",dialpadModalTitle:"Telefon Numarasn evir",dialpadModalAriaLabel:"Tu takm",dialpadCloseModalButtonAriaLabel:"Tu takmn kapat",openDtmfDialpadLabel:"Tu takmn gster",dtmfDialpadPlaceholderText:"Numara girin"};var tr_TR = {call:call$2,chat:chat$2,callWithChat:callWithChat$2};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Turkish (Turkey)
 *
 * @public
 */
const COMPOSITE_LOCALE_TR_TR = {
    component: COMPONENT_LOCALE_TR_TR,
    strings: createCompositeStrings(tr_TR)
};

var call$1={cameraLabel:"",noCamerasLabel:"",cameraPermissionDenied:"",cameraTurnedOff:"",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"",complianceBannerNowOnlyTranscription:"",complianceBannerRecordingAndTranscriptionSaved:"",complianceBannerRecordingAndTranscriptionStarted:"",complianceBannerRecordingAndTranscriptionStopped:"",complianceBannerRecordingSaving:"",complianceBannerRecordingStarted:"",complianceBannerRecordingStopped:"",complianceBannerTranscriptionStarted:"",complianceBannerTranscriptionConsent:"",complianceBannerTranscriptionSaving:"",complianceBannerTranscriptionStopped:"",configurationPageTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",defaultPlaceHolder:"",dismissSidePaneButtonLabel:"",videoEffectsPaneTitle:"",videoEffectsPaneBackgroundSelectionTitle:"",configurationPageVideoEffectsButtonLabel:"",unableToStartVideoEffect:"",blurBackgroundEffectButtonLabel:"",blurBackgroundTooltip:"",removeBackgroundEffectButtonLabel:"",removeBackgroundTooltip:"",cameraOffBackgroundEffectWarningText:"",failedToJoinCallDueToNoNetworkMoreDetails:"",failedToJoinCallDueToNoNetworkTitle:"",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"",learnMore:"",leavingCallTitle:"...",leftCallMoreDetails:"",leftCallTitle:"",lobbyScreenConnectingToCallTitle:"",lobbyScreenWaitingToBeAdmittedTitle:"",microphonePermissionDenied:"",microphoneToggleInLobbyNotAllowed:"",mutedMessage:"",networkReconnectMoreDetails:"",networkReconnectTitle:"",notInvitedToRoomDetails:"",notInvitedToRoomTitle:"",peopleButtonLabel:"",selectedPeopleButtonLabel:"",peoplePaneTitle:"",peoplePaneMoreButtonAriaLabel:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:" {numberOfPeople}",privacyPolicy:"",rejoinCallButtonLabel:"",removedFromCallMoreDetails:"",removedFromCallTitle:"",removeMenuLabel:"",startSpotlightParticipantListMenuLabel:"",addSpotlightParticipantListMenuLabel:"",stopSpotlightParticipantListMenuLabel:"",stopSpotlightOnSelfParticipantListMenuLabel:"",spotlightLimitReachedParticipantListMenuTitle:"",stopAllSpotlightMenuLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",roomNotFoundDetails:" ID",roomNotFoundTitle:"",roomNotValidDetails:"",roomNotValidTitle:"",inviteToRoomRemovedDetails:"",inviteToRoomRemovedTitle:"",soundLabel:"",noMicrophonesLabel:"",noSpeakersLabel:"",startCallButtonLabel:"",openDialpadButtonLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"...",resumeCallButtonAriaLabel:"",resumingCallButtonAriaLabel:"",holdScreenLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:"",outboundCallingNoticeString:"...",participantJoinedNoticeString:"{displayName} ",twoParticipantJoinedNoticeString:"{displayName1}  {displayName2} ",threeParticipantJoinedNoticeString:"{displayName1}{displayName2}  {displayName3} ",participantLeftNoticeString:"{displayName} ",twoParticipantLeftNoticeString:"{displayName1}  {displayName2} ",threeParticipantLeftNoticeString:"{displayName1}{displayName2}  {displayName3} ",unnamedParticipantString:"",manyUnnamedParticipantsJoined:" {numOfParticipants} ",manyUnnamedParticipantsLeft:" {numOfParticipants} ",manyParticipantsJoined:"{displayName1}{displayName2}{displayName3}{numOfParticipants}",manyParticipantsLeft:"{displayName1}{displayName2}{displayName3}{numOfParticipants}",liveCaptionsLabel:"",captionsSettingsLabel:"",startCaptionsButtonOnLabel:"",startCaptionsButtonOffLabel:"",startCaptionsButtonTooltipOnContent:"",startCaptionsButtonTooltipOffContent:"",captionsSettingsModalTitle:"",captionsSettingsSpokenLanguageDropdownLabel:"",captionsSettingsCaptionLanguageDropdownLabel:"",captionsSettingsSpokenLanguageDropdownInfoText:"",captionsSettingsCaptionLanguageDropdownInfoText:"",captionsSettingsConfirmButtonLabel:"",captionsSettingsCancelButtonLabel:"",captionsSettingsModalAriaLabel:"",captionsSettingsCloseModalButtonAriaLabel:"",captionsBannerMoreButtonCallingLabel:"",captionsBannerMoreButtonTooltip:"",dismissModalAriaLabel:" Enter ",callRejectedTitle:"",callRejectedMoreDetails:"",callTimeoutTitle:"",callTimeoutDetails:"",callTimeoutBotTitle:"",callTimeoutBotDetails:"",dtmfDialerButtonLabel:"",dtmfDialerButtonTooltipOn:"",dtmfDialerButtonTooltipOff:"",dtmfDialerMoreButtonLabelOn:"",dtmfDialerMoreButtonLabelOff:"",spokenLanguageStrings:{"ar-ae":" - ","ar-sa":" - ","da-dk":"","de-de":" - ","en-au":" - ","en-ca":" - ","en-gb":" - ","en-in":" - ","en-nz":" - ","en-us":" - ","es-es":" - ()","es-mx":" - ","fi-fi":"","fr-ca":" - ","fr-fr":" - ","hi-in":"","it-it":"","ja-jp":"","ko-kr":"","nb-no":"()","nl-be":" - ","nl-nl":"  ","pl-pl":"","pt-br":" - ","ru-ru":"","sv-se":"","zh-cn":" - ","zh-hk":" - ","cs-cz":"","pt-pt":" - ","tr-tr":"","vi-vn":"","th-th":"","he-il":"","cy-gb":"","uk-ua":"","el-gr":"","hu-hu":"","ro-ro":"","sk-sk":"","zh-tw":"  "},captionLanguageStrings:{ar:"",da:"",de:"",en:"",es:"",fi:"","fr-ca":" - ",fr:" - ",hi:"",it:"",ja:"",ko:"",nb:"()",nl:"",pl:"",pt:" - ",ru:"",sv:"","zh-Hans":"()","zh-Hant":"()",cs:"","pt-pt":" - ",tr:"",vi:"",th:"",he:"",cy:"",uk:"",el:"",hu:"",ro:"",sk:""},captionsBannerSpinnerText:"...",transferPageTransferorText:"...",transferPageTransferTargetText:"...",transferPageUnknownTransferorDisplayName:"",transferPageUnknownTransferTargetDisplayName:"",transferPageNoticeString:"",participantCouldNotBeReachedTitle:"",participantCouldNotBeReachedMoreDetails:"",permissionToReachTargetParticipantNotAllowedTitle:"",permissionToReachTargetParticipantNotAllowedMoreDetails:"",unableToResolveTenantTitle:" ID",unableToResolveTenantMoreDetails:" ID",participantIdIsMalformedTitle:" ID ",participantIdIsMalformedMoreDetails:" ID ",moreButtonGalleryControlLabel:"",moreButtonGalleryPositionToggleLabel:"",moreButtonGallerySpeakerLayoutLabel:"",moreButtonGalleryFloatingLocalLayoutLabel:"",moreButtonGalleryDefaultLayoutLabel:"",moreButtonGalleryFocusedContentLayoutLabel:"",moreButtonLargeGalleryDefaultLayoutLabel:"",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"",grantedDueToMeetingOption:""},unmuteMic:{lostDueToMeetingOption:"",grantedDueToMeetingOption:""},shareScreen:{lostDueToRoleChangeToAttendee:"",grantedDueToRoleChangeToPresenter:""}},surveyTitle:"",starSurveyHelperText:"?",starSurveyOneStarText:"",starSurveyTwoStarText:"",starSurveyThreeStarText:"",starSurveyFourStarText:"",starSurveyFiveStarText:"",surveyConfirmButtonLabel:"",starRatingAriaLabel:" {0} ( {1} )",surveySkipButtonLabel:"",tagsSurveyQuestion:"?",tagsSurveyTextFieldDefaultText:"",tagsSurveyHelperText:"",surveyTextboxDefaultText:"",endOfSurveyText:"!",surveyIssues:{overallRating:{callCannotJoin:"",callCannotInvite:"",hadToRejoin:"",callEndedUnexpectedly:"",otherIssues:""},audioRating:{noLocalAudio:"",noRemoteAudio:"",echo:"",audioNoise:"",lowVolume:"",audioStoppedUnexpectedly:"",distortedSpeech:"",audioInterruption:"",otherIssues:""},videoRating:{noVideoReceived:"",noVideoSent:"",lowQuality:"",freezes:"",stoppedUnexpectedly:"",darkVideoReceived:"",audioVideoOutOfSync:"",otherIssues:""},screenshareRating:{noContentLocal:"",noContentRemote:"",cannotPresent:"",lowQuality:"",freezes:"",stoppedUnexpectedly:"",largeDelay:"",otherIssues:""}},SurveyIssuesHeadingStrings:{overallRating:"",audioRating:"",videoRating:"",screenshareRating:""},spotlightPrompt:{startSpotlightHeading:"?",startSpotlightText:"",startSpotlightOnSelfText:"",startSpotlightConfirmButtonLabel:"",startSpotlightCancelButtonLabel:"",stopSpotlightHeading:"?",stopSpotlightOnSelfHeading:"?",stopSpotlightText:"",stopSpotlightOnSelfText:"",stopSpotlightConfirmButtonLabel:"",stopSpotlightOnSelfConfirmButtonLabel:"",stopSpotlightCancelButtonLabel:""},exitSpotlightButtonLabel:"",exitSpotlightButtonTooltip:""};var chat$1={chatListHeader:"",uploadFile:""};var callWithChat$1={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:"",chatButtonTooltipClosedWithMessageCount:"({unreadMessagesCount} )",chatButtonTooltipClose:"",chatButtonTooltipOpen:"",chatPaneTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:"",moreDrawerButtonLabel:"",moreDrawerButtonTooltip:"",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",moreDrawerCaptionsMenuTitle:"",moreDrawerSpokenLanguageMenuTitle:"",moreDrawerCaptionLanguageMenuTitle:"",moreDrawerGalleryOptionsMenuTitle:"",peopleButtonLabel:"",selectedPeopleButtonLabel:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:"",peoplePaneTitle:"",pictureInPictureTileAriaLabel:"",removeMenuLabel:"",openDialpadButtonLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:""};var zh_CN = {call:call$1,chat:chat$1,callWithChat:callWithChat$1};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Chinese (Mainland China)
 *
 * @public
 */
const COMPOSITE_LOCALE_ZH_CN = {
    component: COMPONENT_LOCALE_ZH_CN,
    strings: createCompositeStrings(zh_CN)
};

var call={cameraLabel:"",noCamerasLabel:"",cameraPermissionDenied:"",cameraTurnedOff:"",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"",complianceBannerNowOnlyTranscription:"",complianceBannerRecordingAndTranscriptionSaved:"",complianceBannerRecordingAndTranscriptionStarted:"",complianceBannerRecordingAndTranscriptionStopped:"",complianceBannerRecordingSaving:"",complianceBannerRecordingStarted:"",complianceBannerRecordingStopped:"",complianceBannerTranscriptionStarted:"",complianceBannerTranscriptionConsent:"",complianceBannerTranscriptionSaving:"",complianceBannerTranscriptionStopped:"",configurationPageTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",defaultPlaceHolder:"",dismissSidePaneButtonLabel:"",videoEffectsPaneTitle:"",videoEffectsPaneBackgroundSelectionTitle:"",configurationPageVideoEffectsButtonLabel:"",unableToStartVideoEffect:"",blurBackgroundEffectButtonLabel:"",blurBackgroundTooltip:"",removeBackgroundEffectButtonLabel:"",removeBackgroundTooltip:"",cameraOffBackgroundEffectWarningText:"",failedToJoinCallDueToNoNetworkMoreDetails:"",failedToJoinCallDueToNoNetworkTitle:"",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"",learnMore:"",leavingCallTitle:"...",leftCallMoreDetails:"",leftCallTitle:"",lobbyScreenConnectingToCallTitle:"",lobbyScreenWaitingToBeAdmittedTitle:"",microphonePermissionDenied:"",microphoneToggleInLobbyNotAllowed:"",mutedMessage:"",networkReconnectMoreDetails:"",networkReconnectTitle:"",notInvitedToRoomDetails:"",notInvitedToRoomTitle:"",peopleButtonLabel:"",selectedPeopleButtonLabel:"",peoplePaneTitle:"",peoplePaneMoreButtonAriaLabel:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:" {numberOfPeople}",privacyPolicy:"",rejoinCallButtonLabel:"",removedFromCallMoreDetails:"",removedFromCallTitle:"",removeMenuLabel:"",startSpotlightParticipantListMenuLabel:"",addSpotlightParticipantListMenuLabel:"",stopSpotlightParticipantListMenuLabel:"",stopSpotlightOnSelfParticipantListMenuLabel:"",spotlightLimitReachedParticipantListMenuTitle:"",stopAllSpotlightMenuLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",roomNotFoundDetails:"",roomNotFoundTitle:"",roomNotValidDetails:"",roomNotValidTitle:"",inviteToRoomRemovedDetails:"",inviteToRoomRemovedTitle:"",soundLabel:"",noMicrophonesLabel:"",noSpeakersLabel:"",startCallButtonLabel:"",openDialpadButtonLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"...",resumeCallButtonAriaLabel:"",resumingCallButtonAriaLabel:"",holdScreenLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:"",outboundCallingNoticeString:"...",participantJoinedNoticeString:"{displayName} ",twoParticipantJoinedNoticeString:"{displayName1}  {displayName2} ",threeParticipantJoinedNoticeString:"{displayName1}{displayName2}  {displayName3} ",participantLeftNoticeString:"{displayName} ",twoParticipantLeftNoticeString:"{displayName1}  {displayName2} ",threeParticipantLeftNoticeString:"{displayName1}{displayName2}  {displayName3} ",unnamedParticipantString:"",manyUnnamedParticipantsJoined:" {numOfParticipants} ",manyUnnamedParticipantsLeft:" {numOfParticipants} ",manyParticipantsJoined:"{displayName1}{displayName2}{displayName3}{numOfParticipants}",manyParticipantsLeft:"{displayName1}{displayName2}{displayName3}{numOfParticipants}",liveCaptionsLabel:"",captionsSettingsLabel:"",startCaptionsButtonOnLabel:"",startCaptionsButtonOffLabel:"",startCaptionsButtonTooltipOnContent:"",startCaptionsButtonTooltipOffContent:"",captionsSettingsModalTitle:"",captionsSettingsSpokenLanguageDropdownLabel:"",captionsSettingsCaptionLanguageDropdownLabel:"",captionsSettingsSpokenLanguageDropdownInfoText:"",captionsSettingsCaptionLanguageDropdownInfoText:"",captionsSettingsConfirmButtonLabel:"",captionsSettingsCancelButtonLabel:"",captionsSettingsModalAriaLabel:"",captionsSettingsCloseModalButtonAriaLabel:"",captionsBannerMoreButtonCallingLabel:"",captionsBannerMoreButtonTooltip:"",dismissModalAriaLabel:" Enter ",callRejectedTitle:"",callRejectedMoreDetails:"",callTimeoutTitle:"",callTimeoutDetails:"",callTimeoutBotTitle:"",callTimeoutBotDetails:"",dtmfDialerButtonLabel:"",dtmfDialerButtonTooltipOn:"",dtmfDialerButtonTooltipOff:"",dtmfDialerMoreButtonLabelOn:"",dtmfDialerMoreButtonLabelOff:"",spokenLanguageStrings:{"ar-ae":" - ","ar-sa":" - ","da-dk":"","de-de":" - ","en-au":" - ","en-ca":" - ","en-gb":" - ","en-in":" - ","en-nz":" - ","en-us":" - ","es-es":" -  ()","es-mx":" - ","fi-fi":"","fr-ca":" - ","fr-fr":" - ","hi-in":"","it-it":" - ","ja-jp":"","ko-kr":"","nb-no":" ()","nl-be":" - ","nl-nl":" - ","pl-pl":"","pt-br":" - ","ru-ru":"","sv-se":"","zh-cn":" - ","zh-hk":" - ","cs-cz":"","pt-pt":" - ","tr-tr":"","vi-vn":"","th-th":"","he-il":"","cy-gb":"","uk-ua":"","el-gr":"","hu-hu":"","ro-ro":"","sk-sk":"","zh-tw":" - "},captionLanguageStrings:{ar:"",da:"",de:"",en:"",es:"",fi:"","fr-ca":" - ",fr:" - ",hi:"",it:"",ja:"",ko:"",nb:" ()",nl:"",pl:"",pt:" - ",ru:"",sv:"","zh-Hans":" ()","zh-Hant":" ()",cs:"","pt-pt":" - ",tr:"",vi:"",th:"",he:"",cy:"",uk:"",el:"",hu:"",ro:"",sk:""},captionsBannerSpinnerText:"...",transferPageTransferorText:"...",transferPageTransferTargetText:"...",transferPageUnknownTransferorDisplayName:"",transferPageUnknownTransferTargetDisplayName:"",transferPageNoticeString:"",participantCouldNotBeReachedTitle:"",participantCouldNotBeReachedMoreDetails:"",permissionToReachTargetParticipantNotAllowedTitle:"",permissionToReachTargetParticipantNotAllowedMoreDetails:"",unableToResolveTenantTitle:"",unableToResolveTenantMoreDetails:"",participantIdIsMalformedTitle:"",participantIdIsMalformedMoreDetails:"",moreButtonGalleryControlLabel:"",moreButtonGalleryPositionToggleLabel:"",moreButtonGallerySpeakerLayoutLabel:"",moreButtonGalleryFloatingLocalLayoutLabel:"",moreButtonGalleryDefaultLayoutLabel:"",moreButtonGalleryFocusedContentLayoutLabel:"",moreButtonLargeGalleryDefaultLayoutLabel:"",capabilityChangedNotification:{turnVideoOn:{lostDueToMeetingOption:"",grantedDueToMeetingOption:""},unmuteMic:{lostDueToMeetingOption:"",grantedDueToMeetingOption:""},shareScreen:{lostDueToRoleChangeToAttendee:"",grantedDueToRoleChangeToPresenter:""}},surveyTitle:"",starSurveyHelperText:"?",starSurveyOneStarText:"",starSurveyTwoStarText:"",starSurveyThreeStarText:"",starSurveyFourStarText:"",starSurveyFiveStarText:"",surveyConfirmButtonLabel:"",starRatingAriaLabel:" {0} / {1} ",surveySkipButtonLabel:"",tagsSurveyQuestion:"?",tagsSurveyTextFieldDefaultText:"",tagsSurveyHelperText:"",surveyTextboxDefaultText:"",endOfSurveyText:"!",surveyIssues:{overallRating:{callCannotJoin:"",callCannotInvite:"",hadToRejoin:"",callEndedUnexpectedly:"",otherIssues:""},audioRating:{noLocalAudio:"",noRemoteAudio:"",echo:"",audioNoise:"",lowVolume:"",audioStoppedUnexpectedly:"",distortedSpeech:"",audioInterruption:"",otherIssues:""},videoRating:{noVideoReceived:"",noVideoSent:"",lowQuality:"",freezes:"",stoppedUnexpectedly:"",darkVideoReceived:"",audioVideoOutOfSync:"",otherIssues:""},screenshareRating:{noContentLocal:"",noContentRemote:"",cannotPresent:"",lowQuality:"",freezes:"",stoppedUnexpectedly:"",largeDelay:"",otherIssues:""}},SurveyIssuesHeadingStrings:{overallRating:"",audioRating:"",videoRating:"",screenshareRating:""},spotlightPrompt:{startSpotlightHeading:"?",startSpotlightText:"",startSpotlightOnSelfText:"",startSpotlightConfirmButtonLabel:"",startSpotlightCancelButtonLabel:"",stopSpotlightHeading:"?",stopSpotlightOnSelfHeading:"?",stopSpotlightText:"",stopSpotlightOnSelfText:"",stopSpotlightConfirmButtonLabel:"",stopSpotlightOnSelfConfirmButtonLabel:"",stopSpotlightCancelButtonLabel:""},exitSpotlightButtonLabel:"",exitSpotlightButtonTooltip:""};var chat={chatListHeader:"",uploadFile:""};var callWithChat={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:"",chatButtonTooltipClosedWithMessageCount:" ({unreadMessagesCount} )",chatButtonTooltipClose:"",chatButtonTooltipOpen:"",chatPaneTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:"",moreDrawerButtonLabel:"",moreDrawerButtonTooltip:"",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",moreDrawerCaptionsMenuTitle:"",moreDrawerSpokenLanguageMenuTitle:"",moreDrawerCaptionLanguageMenuTitle:"",moreDrawerGalleryOptionsMenuTitle:"",peopleButtonLabel:"",selectedPeopleButtonLabel:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:"",peoplePaneTitle:"",pictureInPictureTileAriaLabel:"",removeMenuLabel:"",openDialpadButtonLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:""};var zh_TW = {call:call,chat:chat,callWithChat:callWithChat};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Locale for Chinese (Taiwan)
 *
 * @public
 */
const COMPOSITE_LOCALE_ZH_TW = {
    component: COMPONENT_LOCALE_ZH_TW,
    strings: createCompositeStrings(zh_TW)
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter$1 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* @conditional-compile-remove(video-background-effects) */
/**
 *
 * Dependency resolution for video background effects using lazy loading.
 * @public
 */
const onResolveVideoEffectDependencyLazy = () => __awaiter$1(void 0, void 0, void 0, function* () {
    const module = yield import('@azure/communication-calling-effects');
    const createBackgroundBlurEffect = (config) => {
        return new module.BackgroundBlurEffect(config);
    };
    const createBackgroundReplacementEffect = (config) => {
        return new module.BackgroundReplacementEffect(config);
    };
    const VideoBackgroundEffectsDependency = {
        createBackgroundBlurEffect,
        createBackgroundReplacementEffect
    };
    return VideoBackgroundEffectsDependency;
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* @conditional-compile-remove(video-background-effects) */
/**
 * Dependency resolution for video background effects.
 *
 * @public
 */
const onResolveVideoEffectDependency = () => __awaiter(void 0, void 0, void 0, function* () {
    const createBackgroundBlurEffect = (config) => {
        return new communicationCallingEffects.BackgroundBlurEffect(config);
    };
    const createBackgroundReplacementEffect = (config) => {
        return new communicationCallingEffects.BackgroundReplacementEffect(config);
    };
    const VideoBackgroundEffectsDependency = {
        createBackgroundBlurEffect,
        createBackgroundReplacementEffect
    };
    return VideoBackgroundEffectsDependency;
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector = (selector, selectorProps, type) => {
    // Because of react hooks rules, hooks can't be conditionally called
    // We call both call and chat hooks and detect current context
    // Return undefined and skip execution when not in that context
    const callingMode = !type || type === 'calling';
    const chatMode = !type || type === 'chat';
    const callProps = useSelector$3(callingMode ? selector : undefined, selectorProps);
    const chatProps = useSelector$2(chatMode ? selector : undefined, selectorProps);
    return callProps !== null && callProps !== void 0 ? callProps : chatProps;
};
/**
 * Primary hook to get all hooks necessary for a React Component from this library.
 *
 * To call this hook, the component requires to be wrapped under these providers:
 *
 * 1. For chat components: {@link ChatClientProvider} and {@link ChatThreadClientProvider}.
 *
 * 2. For calling components: {@link CallClientProvider}, {@link CallAgentProvider} and {@link CallAgentProvider}.
 *
 * Most straightforward usage of a components looks like:
 *
 * @example
 * ```
 *     import { ParticipantList, usePropsFor } from '@azure/communication-react';
 *
 *     const App = (): JSX.Element => {
 *         // ... code to setup Providers ...
 *
 *         return <ParticipantList {...usePropsFor(ParticipantList)}/>
 *     }
 * ```
 *
 * @public
 */
const usePropsFor = (component, type) => {
    const callingSelector = type === 'calling' || !type ? getSelector$1(component) : undefined;
    const chatSelector = type === 'chat' || !type ? getSelector(component) : undefined;
    const callProps = useSelector$3(callingSelector);
    const chatProps = useSelector$2(chatSelector);
    const callingHandlers = useHandlers$3();
    const chatHandlers = useHandlers$2();
    if (chatProps) {
        if (!chatHandlers) {
            throw 'Please initialize chatClient and chatThreadClient first!';
        }
        return Object.assign(Object.assign({}, chatProps), chatHandlers);
    }
    if (callProps) {
        if (!callingHandlers) {
            throw 'Please initialize callClient first!';
        }
        return Object.assign(Object.assign({}, callProps), callingHandlers);
    }
    if (!chatSelector && !callingSelector) {
        throw "Can't find corresponding selector for this component. Please check the supported components from Azure Communication UI Feature Component List.";
    }
    else {
        throw 'Could not find props for this component, ensure the component is wrapped by appropriate providers.';
    }
};

exports.COMPONENT_LOCALE_AR_SA = COMPONENT_LOCALE_AR_SA;
exports.COMPONENT_LOCALE_CS_CZ = COMPONENT_LOCALE_CS_CZ;
exports.COMPONENT_LOCALE_DE_DE = COMPONENT_LOCALE_DE_DE;
exports.COMPONENT_LOCALE_EN_GB = COMPONENT_LOCALE_EN_GB;
exports.COMPONENT_LOCALE_EN_US = COMPONENT_LOCALE_EN_US;
exports.COMPONENT_LOCALE_ES_ES = COMPONENT_LOCALE_ES_ES;
exports.COMPONENT_LOCALE_FI_FI = COMPONENT_LOCALE_FI_FI;
exports.COMPONENT_LOCALE_FR_FR = COMPONENT_LOCALE_FR_FR;
exports.COMPONENT_LOCALE_HE_IL = COMPONENT_LOCALE_HE_IL;
exports.COMPONENT_LOCALE_IT_IT = COMPONENT_LOCALE_IT_IT;
exports.COMPONENT_LOCALE_JA_JP = COMPONENT_LOCALE_JA_JP;
exports.COMPONENT_LOCALE_KO_KR = COMPONENT_LOCALE_KO_KR;
exports.COMPONENT_LOCALE_NB_NO = COMPONENT_LOCALE_NB_NO;
exports.COMPONENT_LOCALE_NL_NL = COMPONENT_LOCALE_NL_NL;
exports.COMPONENT_LOCALE_PL_PL = COMPONENT_LOCALE_PL_PL;
exports.COMPONENT_LOCALE_PT_BR = COMPONENT_LOCALE_PT_BR;
exports.COMPONENT_LOCALE_RU_RU = COMPONENT_LOCALE_RU_RU;
exports.COMPONENT_LOCALE_SV_SE = COMPONENT_LOCALE_SV_SE;
exports.COMPONENT_LOCALE_TR_TR = COMPONENT_LOCALE_TR_TR;
exports.COMPONENT_LOCALE_ZH_CN = COMPONENT_LOCALE_ZH_CN;
exports.COMPONENT_LOCALE_ZH_TW = COMPONENT_LOCALE_ZH_TW;
exports.COMPOSITE_LOCALE_AR_SA = COMPOSITE_LOCALE_AR_SA;
exports.COMPOSITE_LOCALE_CS_CZ = COMPOSITE_LOCALE_CS_CZ;
exports.COMPOSITE_LOCALE_DE_DE = COMPOSITE_LOCALE_DE_DE;
exports.COMPOSITE_LOCALE_EN_GB = COMPOSITE_LOCALE_EN_GB;
exports.COMPOSITE_LOCALE_EN_US = COMPOSITE_LOCALE_EN_US;
exports.COMPOSITE_LOCALE_ES_ES = COMPOSITE_LOCALE_ES_ES;
exports.COMPOSITE_LOCALE_FI_FI = COMPOSITE_LOCALE_FI_FI;
exports.COMPOSITE_LOCALE_FR_FR = COMPOSITE_LOCALE_FR_FR;
exports.COMPOSITE_LOCALE_HE_IL = COMPOSITE_LOCALE_HE_IL;
exports.COMPOSITE_LOCALE_IT_IT = COMPOSITE_LOCALE_IT_IT;
exports.COMPOSITE_LOCALE_JA_JP = COMPOSITE_LOCALE_JA_JP;
exports.COMPOSITE_LOCALE_KO_KR = COMPOSITE_LOCALE_KO_KR;
exports.COMPOSITE_LOCALE_NB_NO = COMPOSITE_LOCALE_NB_NO;
exports.COMPOSITE_LOCALE_NL_NL = COMPOSITE_LOCALE_NL_NL;
exports.COMPOSITE_LOCALE_PL_PL = COMPOSITE_LOCALE_PL_PL;
exports.COMPOSITE_LOCALE_PT_BR = COMPOSITE_LOCALE_PT_BR;
exports.COMPOSITE_LOCALE_RU_RU = COMPOSITE_LOCALE_RU_RU;
exports.COMPOSITE_LOCALE_SV_SE = COMPOSITE_LOCALE_SV_SE;
exports.COMPOSITE_LOCALE_TR_TR = COMPOSITE_LOCALE_TR_TR;
exports.COMPOSITE_LOCALE_ZH_CN = COMPOSITE_LOCALE_ZH_CN;
exports.COMPOSITE_LOCALE_ZH_TW = COMPOSITE_LOCALE_ZH_TW;
exports.COMPOSITE_ONLY_ICONS = COMPOSITE_ONLY_ICONS;
exports.CallAgentProvider = CallAgentProvider;
exports.CallClientProvider = CallClientProvider;
exports.CallComposite = CallComposite;
exports.CallProvider = CallProvider;
exports.CallWithChatComposite = CallWithChatComposite;
exports.CameraButton = CameraButton;
exports.ChatClientProvider = ChatClientProvider;
exports.ChatComposite = ChatComposite;
exports.ChatThreadClientProvider = ChatThreadClientProvider;
exports.ControlBar = ControlBar;
exports.ControlBarButton = ControlBarButton;
exports.DEFAULT_COMPONENT_ICONS = DEFAULT_COMPONENT_ICONS;
exports.DEFAULT_COMPOSITE_ICONS = DEFAULT_COMPOSITE_ICONS;
exports.DevicesButton = DevicesButton;
exports.Dialpad = Dialpad;
exports.EndCallButton = EndCallButton;
exports.ErrorBar = ErrorBar;
exports.FluentThemeProvider = FluentThemeProvider;
exports.GridLayout = GridLayout;
exports.ImageOverlay = ImageOverlay;
exports.LocalizationProvider = LocalizationProvider$1;
exports.MessageStatusIndicator = MessageStatusIndicator;
exports.MessageThread = MessageThread;
exports.MicrophoneButton = MicrophoneButton;
exports.ParticipantItem = ParticipantItem;
exports.ParticipantList = ParticipantList$k;
exports.ParticipantsButton = ParticipantsButton;
exports.RaiseHandButton = RaiseHandButton;
exports.ScreenShareButton = ScreenShareButton;
exports.SendBox = SendBox$1;
exports.StreamMedia = StreamMedia;
exports.TypingIndicator = TypingIndicator;
exports.VideoGallery = VideoGallery;
exports.VideoTile = VideoTile;
exports._IdentifierProvider = _IdentifierProvider;
exports.createAzureCommunicationCallAdapter = createAzureCommunicationCallAdapter;
exports.createAzureCommunicationCallAdapterFromClient = createAzureCommunicationCallAdapterFromClient;
exports.createAzureCommunicationCallWithChatAdapter = createAzureCommunicationCallWithChatAdapter;
exports.createAzureCommunicationCallWithChatAdapterFromClients = createAzureCommunicationCallWithChatAdapterFromClients;
exports.createAzureCommunicationChatAdapter = createAzureCommunicationChatAdapter;
exports.createAzureCommunicationChatAdapterFromClient = createAzureCommunicationChatAdapterFromClient;
exports.createDefaultCallingHandlers = createDefaultCallingHandlers;
exports.createDefaultChatHandlers = createDefaultChatHandlers;
exports.createStatefulCallClient = createStatefulCallClient;
exports.createStatefulChatClient = createStatefulChatClient;
exports.darkTheme = darkTheme;
exports.fromFlatCommunicationIdentifier = fromFlatCommunicationIdentifier;
exports.getCallingSelector = getSelector$1;
exports.getChatSelector = getSelector;
exports.lightTheme = lightTheme;
exports.onResolveVideoEffectDependency = onResolveVideoEffectDependency;
exports.onResolveVideoEffectDependencyLazy = onResolveVideoEffectDependencyLazy;
exports.toFlatCommunicationIdentifier = toFlatCommunicationIdentifier;
exports.useAzureCommunicationCallAdapter = useAzureCommunicationCallAdapter;
exports.useAzureCommunicationCallWithChatAdapter = useAzureCommunicationCallWithChatAdapter;
exports.useAzureCommunicationChatAdapter = useAzureCommunicationChatAdapter;
exports.useCall = useCall;
exports.useCallAgent = useCallAgent;
exports.useCallClient = useCallClient;
exports.useChatClient = useChatClient;
exports.useChatThreadClient = useChatThreadClient;
exports.useDeviceManager = useDeviceManager;
exports.usePropsFor = usePropsFor;
exports.useSelector = useSelector;
exports.useTheme = useTheme;
//# sourceMappingURL=index.js.map
