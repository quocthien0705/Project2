{"version":3,"file":"IEditor.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-types/lib/interface/IEditor.ts"],"names":[],"mappings":"","sourcesContent":["import type BlockElement from './BlockElement';\nimport type ClipboardData from './ClipboardData';\nimport type ContentChangedData from './ContentChangedData';\nimport type DarkColorHandler from './DarkColorHandler';\nimport type DefaultFormat from './DefaultFormat';\nimport type IContentTraverser from './IContentTraverser';\nimport type IPositionContentSearcher from './IPositionContentSearcher';\nimport type NodePosition from './NodePosition';\nimport type Rect from './Rect';\nimport type Region from './Region';\nimport type SelectionPath from './SelectionPath';\nimport type TableSelection from './TableSelection';\nimport type { ChangeSource } from '../enum/ChangeSource';\nimport type { ColorTransformDirection } from '../enum/ColorTransformDirection';\nimport type { ContentPosition } from '../enum/ContentPosition';\nimport type { DOMEventHandler } from '../type/domEventHandler';\nimport type { EditorUndoState, PendableFormatState, StyleBasedFormatState } from './FormatState';\nimport type { ExperimentalFeatures } from '../enum/ExperimentalFeatures';\nimport type { GenericContentEditFeature } from './ContentEditFeature';\nimport type { GetContentMode } from '../enum/GetContentMode';\nimport type { InsertOption } from './InsertOption';\nimport type { PluginEvent } from '../event/PluginEvent';\nimport type { PluginEventData, PluginEventFromType } from '../event/PluginEventData';\nimport type { PluginEventType } from '../enum/PluginEventType';\nimport type { PositionType } from '../enum/PositionType';\nimport type { QueryScope } from '../enum/QueryScope';\nimport type { RegionType } from '../enum/RegionType';\nimport type { SelectionRangeEx } from './SelectionRangeEx';\nimport type { SizeTransformer } from '../type/SizeTransformer';\nimport type { TrustedHTMLHandler } from '../type/TrustedHTMLHandler';\nimport type { CompatiblePluginEventType } from '../compatibleEnum/PluginEventType';\nimport type { CompatibleChangeSource } from '../compatibleEnum/ChangeSource';\nimport type { CompatibleContentPosition } from '../compatibleEnum/ContentPosition';\nimport type { CompatibleExperimentalFeatures } from '../compatibleEnum/ExperimentalFeatures';\nimport type { CompatibleGetContentMode } from '../compatibleEnum/GetContentMode';\nimport type { CompatibleQueryScope } from '../compatibleEnum/QueryScope';\nimport type { CompatibleRegionType } from '../compatibleEnum/RegionType';\nimport type { CompatibleColorTransformDirection } from '../compatibleEnum/ColorTransformDirection';\n\n/**\n * Interface of roosterjs editor object\n */\nexport default interface IEditor {\n    /**\n     * Dispose this editor, dispose all plugins and custom data\n     */\n    dispose(): void;\n\n    /**\n     * Get whether this editor is disposed\n     * @returns True if editor is disposed, otherwise false\n     */\n    isDisposed(): boolean;\n\n    //#region Node API\n\n    /**\n     * Insert node into editor\n     * @param node The node to insert\n     * @param option Insert options. Default value is:\n     *  position: ContentPosition.SelectionStart\n     *  updateCursor: true\n     *  replaceSelection: true\n     *  insertOnNewLine: false\n     * @returns true if node is inserted. Otherwise false\n     */\n    insertNode(node: Node, option?: InsertOption): boolean;\n\n    /**\n     * Delete a node from editor content\n     * @param node The node to delete\n     * @returns true if node is deleted. Otherwise false\n     */\n    deleteNode(node: Node): boolean;\n\n    /**\n     * Replace a node in editor content with another node\n     * @param existingNode The existing node to be replaced\n     * @param toNode node to replace to\n     * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false\n     * @returns true if node is replaced. Otherwise false\n     */\n    replaceNode(existingNode: Node, toNode: Node, transformColorForDarkMode?: boolean): boolean;\n\n    /**\n     * Get BlockElement at given node\n     * @param node The node to create InlineElement\n     * @returns The BlockElement result\n     */\n    getBlockElementAtNode(node: Node): BlockElement | null;\n\n    /**\n     * Check if the node falls in the editor content\n     * @param node The node to check\n     * @returns True if the given node is in editor content, otherwise false\n     */\n    contains(node: Node | null): boolean;\n\n    /**\n     * Check if the range falls in the editor content\n     * @param range The range to check\n     * @returns True if the given range is in editor content, otherwise false\n     */\n    contains(range: Range): boolean;\n\n    /**\n     * Query HTML elements in editor by tag name\n     * @param tag Tag name of the element to query\n     * @param forEachCallback An optional callback to be invoked on each element in query result\n     * @returns HTML Element array of the query result\n     */\n    queryElements<T extends keyof HTMLElementTagNameMap>(\n        tag: T,\n        forEachCallback?: (node: HTMLElementTagNameMap[T]) => any\n    ): HTMLElementTagNameMap[T][];\n\n    /**\n     * Query HTML elements in editor by a selector string\n     * @param selector Selector string to query\n     * @param forEachCallback An optional callback to be invoked on each node in query result\n     * @returns HTML Element array of the query result\n     */\n    queryElements<T extends HTMLElement = HTMLElement>(\n        selector: string,\n        forEachCallback?: (node: T) => any\n    ): T[];\n\n    /**\n     * Query HTML elements with the given scope by tag name\n     * @param tag Tag name of the element to query\n     * @param scope The scope of the query, default value is QueryScope.Body\n     * @param forEachCallback An optional callback to be invoked on each element in query result\n     * @returns HTML Element list of the query result\n     */\n    queryElements<T extends keyof HTMLElementTagNameMap>(\n        tag: T,\n        scope: QueryScope | CompatibleQueryScope,\n        forEachCallback?: (node: HTMLElementTagNameMap[T]) => any\n    ): HTMLElementTagNameMap[T][];\n\n    /**\n     * Query HTML elements with the given scope by a selector string\n     * @param selector Selector string to query\n     * @param scope The scope of the query, default value is QueryScope.Body\n     * @param forEachCallback An optional callback to be invoked on each element in query result\n     * @returns HTML Element array of the query result\n     */\n    queryElements<T extends HTMLElement = HTMLElement>(\n        selector: string,\n        scope: QueryScope | CompatibleQueryScope,\n        forEachCallback?: (node: T) => any\n    ): T[];\n\n    /**\n     * Collapse nodes within the given start and end nodes to their common ancestor node,\n     * split parent nodes if necessary\n     * @param start The start node\n     * @param end The end node\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\n     * and the returned nodes will be all nodes from start through end after splitting\n     * False to disallow split parent\n     * @returns When canSplitParent is true, returns all node from start through end after splitting,\n     * otherwise just return start and end\n     */\n    collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[];\n\n    //#endregion\n\n    //#region Content API\n\n    /**\n     * Check whether the editor contains any visible content\n     * @param trim Whether trim the content string before check. Default is false\n     * @returns True if there's no visible content, otherwise false\n     */\n    isEmpty(trim?: boolean): boolean;\n\n    /**\n     * Get current editor content as HTML string\n     * @param mode specify what kind of HTML content to retrieve\n     * @returns HTML string representing current editor content\n     */\n    getContent(mode?: GetContentMode | CompatibleGetContentMode): string;\n\n    /**\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\n     * @param content HTML content to set in\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\n     */\n    setContent(content: string, triggerContentChangedEvent?: boolean): void;\n\n    /**\n     * Insert HTML content into editor\n     * @param HTML content to insert\n     * @param option Insert options. Default value is:\n     *  position: ContentPosition.SelectionStart\n     *  updateCursor: true\n     *  replaceSelection: true\n     *  insertOnNewLine: false\n     */\n    insertContent(content: string, option?: InsertOption): void;\n\n    /**\n     * Delete selected content\n     */\n    deleteSelectedContent(): NodePosition | null;\n\n    /**\n     * Paste into editor using a clipboardData object\n     * @param clipboardData Clipboard data retrieved from clipboard\n     * @param pasteAsText Force pasting as plain text. Default value is false\n     * @param applyCurrentStyle True if apply format of current selection to the pasted content,\n     * false to keep original format.  Default value is false. When pasteAsText is true, this parameter is ignored\n     * @param pasteAsImage: When set to true, if the clipboardData contains a imageDataUri will paste the image to the editor\n     */\n    paste(\n        clipboardData: ClipboardData,\n        pasteAsText?: boolean,\n        applyCurrentFormat?: boolean,\n        pasteAsImage?: boolean\n    ): void;\n\n    //#endregion\n\n    //#region Focus and Selection\n\n    /**\n     * Get current selection range from Editor.\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\n     * Default value is true\n     * @returns current selection range, or null if editor never got focus before\n     */\n    getSelectionRange(tryGetFromCache?: boolean): Range | null;\n\n    /**\n     * Get current selection range from Editor.\n     * It does a live pull on the selection.\n     * @returns current selection range, or null if editor never got focus before\n     */\n    getSelectionRangeEx(): SelectionRangeEx;\n\n    /**\n     * Get current selection in a serializable format\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\n     * @returns current selection path, or null if editor never got focus before\n     */\n    getSelectionPath(): SelectionPath | null;\n\n    /**\n     * Check if focus is in editor now\n     * @returns true if focus is in editor, otherwise false\n     */\n    hasFocus(): boolean;\n\n    /**\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\n     */\n    focus(): void;\n\n    /**\n     * Select content by range\n     * @param range The range to select\n     * @returns True if content is selected, otherwise false\n     */\n    select(range: Range): boolean;\n\n    /**\n     * Select content by Position and collapse to this position\n     * @param position The position to select\n     * @returns True if content is selected, otherwise false\n     */\n    select(position: NodePosition | null): boolean;\n\n    /**\n     * Select content by a start and end position\n     * @param start The start position to select\n     * @param end The end position to select, if this is the same with start, the selection will be collapsed\n     * @returns True if content is selected, otherwise false\n     */\n    select(start: NodePosition, end: NodePosition): boolean;\n\n    /**\n     * Select content by node\n     * @param node The node to select\n     * @returns True if content is selected, otherwise false\n     */\n    select(node: Node): boolean;\n\n    /**\n     * Select content by node and offset, and collapse to this position\n     * @param node The node to select\n     * @param offset The offset of node to select, can be a number or value of PositionType\n     * @returns True if content is selected, otherwise false\n     */\n    select(node: Node, offset: number | PositionType): boolean;\n\n    /**\n     * Select content by start and end nodes and offsets\n     * @param startNode The node to select start from\n     * @param startOffset The offset to select start from\n     * @param endNode The node to select end to\n     * @param endOffset The offset to select end to\n     * @returns True if content is selected, otherwise false\n     */\n    select(\n        startNode: Node,\n        startOffset: number | PositionType,\n        endNode: Node,\n        endOffset: number | PositionType\n    ): boolean;\n\n    /**\n     * Select content by selection path\n     * @param path A selection path object\n     * @returns True if content is selected, otherwise false\n     */\n    select(path: SelectionPath): boolean;\n\n    /**\n     * Select content using the Table Selection\n     * @param table to select\n     * @param coordinates first and last cell of the range, if null is provided will remove the selection on the table\n     */\n    select(table: HTMLTableElement, coordinates: TableSelection | null): boolean;\n\n    /**\n     * Select content SelectionRangeEx\n     * @param rangeEx SelectionRangeEx object to specify what to select\n     */\n    select(rangeEx: SelectionRangeEx): boolean;\n\n    /**\n     * Get current focused position. Return null if editor doesn't have focus at this time.\n     */\n    getFocusedPosition(): NodePosition | null;\n\n    /**\n     * Get an HTML element from current cursor position.\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\n     * or its parent node (if current node is a Text node).\n     * When expectedTags is specified, return value is the first ancestor of current node which has\n     * one of the expected tags.\n     * If no element found within editor by the given tag, return null.\n     * @param selector Optional, an HTML selector to find HTML element with.\n     * @param startFrom Optional, start search from this node. If not specified, start from current focused position\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\n     * If it is not cached before, query from DOM and cache the result into the event object\n     */\n    getElementAtCursor(\n        selector?: string,\n        startFrom?: Node,\n        event?: PluginEvent\n    ): HTMLElement | null;\n\n    /**\n     * Check if this position is at beginning of the editor.\n     * This will return true if all nodes between the beginning of target node and the position are empty.\n     * @param position The position to check\n     * @returns True if position is at beginning of the editor, otherwise false\n     */\n    isPositionAtBeginning(position: NodePosition): boolean;\n\n    /**\n     * Get impacted regions from selection\n     */\n    getSelectedRegions(type?: RegionType | CompatibleRegionType): Region[];\n\n    //#endregion\n\n    //#region EVENT API\n\n    /**\n     * Add a custom DOM event handler to handle events not handled by roosterjs.\n     * Caller need to take the responsibility to dispose the handler properly\n     * @param eventName DOM event name to handle\n     * @param handler Handler callback\n     * @returns A dispose function. Call the function to dispose this event handler\n     */\n    addDomEventHandler(eventName: string, handler: DOMEventHandler): () => void;\n\n    /**\n     * Add a bunch of custom DOM event handler to handle events not handled by roosterjs.\n     * Caller need to take the responsibility to dispose the handler properly\n     * @param handlerMap A event name => event handler map\n     * @returns A dispose function. Call the function to dispose all event handlers added by this function\n     */\n    addDomEventHandler(handlerMap: Record<string, DOMEventHandler>): () => void;\n\n    /**\n     * Trigger an event to be dispatched to all plugins\n     * @param eventType Type of the event\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\n     * the result of this function provides a chance to read the modified result\n     */\n    triggerPluginEvent<T extends PluginEventType | CompatiblePluginEventType>(\n        eventType: T,\n        data: PluginEventData<T>,\n        broadcast?: boolean\n    ): PluginEventFromType<T>;\n\n    /**\n     * Trigger a ContentChangedEvent\n     * @param source Source of this event, by default is 'SetContent'\n     * @param data additional data for this event\n     */\n    triggerContentChangedEvent(\n        source?: ChangeSource | CompatibleChangeSource | string,\n        data?: any\n    ): void;\n\n    //#endregion\n\n    //#region Undo API\n\n    /**\n     * Undo last edit operation\n     */\n    undo(): void;\n\n    /**\n     * Redo next edit operation\n     */\n    redo(): void;\n\n    /**\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\n     * ContentChangedEvent with given change source.\n     * If this function is called nested, undo snapshot will only be added in the outside one\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\n     * the data field in ContentChangedEvent if changeSource is not null.\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\n     * a ContentChangedEvent will be fired with change source equal to this value\n     * @param canUndoByBackspace True if this action can be undone when user presses Backspace key (aka Auto Complete).\n     * @param additionalData Optional parameter to provide additional data related to the ContentChanged Event.\n     */\n    addUndoSnapshot(\n        callback?: (start: NodePosition | null, end: NodePosition | null) => any,\n        changeSource?: ChangeSource | CompatibleChangeSource | string,\n        canUndoByBackspace?: boolean,\n        additionalData?: ContentChangedData\n    ): void;\n\n    /**\n     * Whether there is an available undo/redo snapshot\n     */\n    getUndoState(): EditorUndoState;\n\n    //#endregion\n\n    //#region Misc\n\n    /**\n     * Get document which contains this editor\n     * @returns The HTML document which contains this editor\n     */\n    getDocument(): Document;\n\n    /**\n     * Get the scroll container of the editor\n     */\n    getScrollContainer(): HTMLElement;\n\n    /**\n     * Get custom data related to this editor\n     * @param key Key of the custom data\n     * @param getter Getter function. If custom data for the given key doesn't exist,\n     * call this function to get one and store it if it is specified. Otherwise return undefined\n     * @param disposer An optional disposer function to dispose this custom data when\n     * dispose editor.\n     */\n    getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T;\n\n    /**\n     * Check if editor is in IME input sequence\n     * @returns True if editor is in IME input sequence, otherwise false\n     */\n    isInIME(): boolean;\n\n    /**\n     * Get default format of this editor\n     * @returns Default format object of this editor\n     */\n    getDefaultFormat(): DefaultFormat;\n\n    /**\n     * Get a content traverser for the whole editor\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\n     */\n    getBodyTraverser(startNode?: Node): IContentTraverser;\n\n    /**\n     * Get a content traverser for current selection\n     * @returns A content traverser, or null if editor never got focus before and no range is provided\n     */\n    getSelectionTraverser(range?: Range): IContentTraverser | null;\n\n    /**\n     * Get a content traverser for current block element start from specified position\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\n     * @returns A content traverser, or null if editor never got focus before\n     */\n    getBlockTraverser(\n        startFrom?: ContentPosition | CompatibleContentPosition\n    ): IContentTraverser | null;\n\n    /**\n     * Get a text traverser of current selection\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\n     * If it is not cached before, query from DOM and cache the result into the event object\n     * @returns A content traverser, or null if editor never got focus before\n     */\n    getContentSearcherOfCursor(event?: PluginEvent | null): IPositionContentSearcher | null;\n\n    /**\n     * Run a callback function asynchronously\n     * @param callback The callback function to run\n     * @returns a function to cancel this async run\n     */\n    runAsync(callback: (editor: IEditor) => void): () => void;\n\n    /**\n     * Set DOM attribute of editor content DIV\n     * @param name Name of the attribute\n     * @param value Value of the attribute\n     */\n    setEditorDomAttribute(name: string, value: string | null): void;\n\n    /**\n     * Get DOM attribute of editor content DIV, null if there is no such attribute.\n     * @param name Name of the attribute\n     */\n    getEditorDomAttribute(name: string): string | null;\n\n    /**\n     * @deprecated Use getVisibleViewport() instead\n     *\n     * Get current relative distance from top-left corner of the given element to top-left corner of editor content DIV.\n     * @param element The element to calculate from. If the given element is not in editor, return value will be null\n     * @param addScroll When pass true, The return value will also add scrollLeft and scrollTop if any. So the value\n     * may be different than what user is seeing from the view. When pass false, scroll position will be ignored.\n     * @returns An [x, y] array which contains the left and top distances, or null if the given element is not in editor.\n     */\n    getRelativeDistanceToEditor(element: HTMLElement, addScroll?: boolean): number[] | null;\n\n    /**\n     * Add a Content Edit feature.\n     * @param feature The feature to add\n     */\n    addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>): void;\n\n    /**\n     * Remove a Content Edit feature.\n     * @param feature The feature to remove\n     */\n    removeContentEditFeature(feature: GenericContentEditFeature<PluginEvent>): void;\n\n    /**\n     * Get style based format state from current selection, including font name/size and colors\n     */\n    getStyleBasedFormatState(node?: Node): StyleBasedFormatState;\n\n    /**\n     * Get the pendable format state from the current selection, including formats as underline, bold, italics\n     * @param forceGetStateFromDOM If set to true, will not consider the cached format and will get the format state directly from DOM tree\n     * @return The pending format state of editor.\n     */\n    getPendableFormatState(forceGetStateFromDOM?: boolean): PendableFormatState;\n\n    /**\n     * Ensure user will type into a container element rather than into the editor content DIV directly\n     * @param position The position that user is about to type to\n     * @param keyboardEvent Optional keyboard event object\n     */\n    ensureTypeInContainer(position: NodePosition, keyboardEvent?: KeyboardEvent): void;\n    //#endregion\n\n    //#region Dark mode APIs\n\n    /**\n     * Set the dark mode state and transforms the content to match the new state.\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\n     */\n    setDarkModeState(nextDarkMode?: boolean): void;\n\n    /**\n     * Check if the editor is in dark mode\n     * @returns True if the editor is in dark mode, otherwise false\n     */\n    isDarkMode(): boolean;\n\n    /**\n     * Transform the given node and all its child nodes to dark mode color if editor is in dark mode\n     * @param node The node to transform\n     * @param direction The transform direction. @default ColorTransformDirection.LightToDark\n     */\n    transformToDarkColor(\n        node: Node,\n        direction?: ColorTransformDirection | CompatibleColorTransformDirection\n    ): void;\n\n    /**\n     * Get a darkColorHandler object for this editor.\n     */\n    getDarkColorHandler(): DarkColorHandler;\n\n    /**\n     * Make the editor in \"Shadow Edit\" mode.\n     * In Shadow Edit mode, all format change will finally be ignored.\n     * This can be used for building a live preview feature for format button, to allow user\n     * see format result without really apply it.\n     * This function can be called repeated. If editor is already in shadow edit mode, we can still\n     * use this function to do more shadow edit operation.\n     */\n    startShadowEdit(): void;\n\n    /**\n     * Leave \"Shadow Edit\" mode, all changes made during shadow edit will be discarded\n     */\n    stopShadowEdit(): void;\n\n    /**\n     * Check if editor is in Shadow Edit mode\n     */\n    isInShadowEdit(): boolean;\n\n    /**\n     * Check if the given experimental feature is enabled\n     * @param feature The feature to check\n     */\n    isFeatureEnabled(feature: ExperimentalFeatures | CompatibleExperimentalFeatures): boolean;\n\n    /**\n     * Get a function to convert HTML string to trusted HTML string.\n     * By default it will just return the input HTML directly. To override this behavior,\n     * pass your own trusted HTML handler to EditorOptions.trustedHTMLHandler\n     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types\n     */\n    getTrustedHTMLHandler(): TrustedHTMLHandler;\n\n    /**\n     * Get current zoom scale, default value is 1\n     * When editor is put under a zoomed container, need to pass the zoom scale number using EditorOptions.zoomScale\n     * to let editor behave correctly especially for those mouse drag/drop behaviors\n     * @returns current zoom scale number\n     */\n    getZoomScale(): number;\n\n    /**\n     * Set current zoom scale, default value is 1\n     * When editor is put under a zoomed container, need to pass the zoom scale number using EditorOptions.zoomScale\n     * to let editor behave correctly especially for those mouse drag/drop behaviors\n     */\n    setZoomScale(scale: number): void;\n\n    /**\n     * @deprecated Use getZoomScale() instead\n     */\n    getSizeTransformer(): SizeTransformer;\n\n    /**\n     * Retrieves the rect of the visible viewport of the editor.\n     */\n    getVisibleViewport(): Rect | null;\n    //#endregion\n}\n"]}