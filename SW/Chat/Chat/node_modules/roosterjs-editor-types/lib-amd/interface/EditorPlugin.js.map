{"version":3,"file":"EditorPlugin.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-types/lib/interface/EditorPlugin.ts"],"names":[],"mappings":"","sourcesContent":["import type IEditor from './IEditor';\nimport type { PluginEvent } from '../event/PluginEvent';\n\n/**\n * Interface of an editor plugin\n */\nexport default interface EditorPlugin {\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName: () => string;\n\n    /**\n     * The first method that editor will call to a plugin when editor is initializing.\n     * It will pass in the editor instance, plugin should take this chance to save the\n     * editor reference so that it can call to any editor method or format API later.\n     * @param editor The editor object\n     */\n    initialize: (editor: IEditor) => void;\n\n    /**\n     * The last method that editor will call to a plugin before it is disposed.\n     * Plugin can take this chance to clear the reference to editor. After this method is\n     * called, plugin should not call to any editor method since it will result in error.\n     */\n    dispose: () => void;\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check:\n     */\n    willHandleEventExclusively?: (event: PluginEvent) => boolean;\n\n    /**\n     * Core method for a plugin. Once an event happens in editor, editor will call this\n     * method of each plugin to handle the event as long as the event is not handled\n     * exclusively by another plugin.\n     * @param event The event to handle:\n     */\n    onPluginEvent?: (event: PluginEvent) => void;\n}\n"]}