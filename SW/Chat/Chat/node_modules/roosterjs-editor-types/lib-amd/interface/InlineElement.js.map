{"version":3,"file":"InlineElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-types/lib/interface/InlineElement.ts"],"names":[],"mappings":"","sourcesContent":["import type BlockElement from './BlockElement';\r\nimport type NodePosition from './NodePosition';\r\n\r\n/**\r\n * This refers to an inline element (as opposed to block) in editor\r\n * Inline and block makes the \"type\" system in editor.\r\n * An inline element is a maximum resolvable \"entity\" within the boundary of a block\r\n * At minimum and also most commonly, it represents a text node.\r\n * It can represent broader \"content\" depending on the resolvers that are available, i.e.\r\n * it can be anchor link, image, emoji, ...\r\n * Two rules:\r\n * 1) every inline element must have a container node (text or span, a etc.)\r\n * 2) inline element cannot be nested\r\n */\r\nexport default interface InlineElement {\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string;\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node;\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement;\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition;\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition;\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean;\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean;\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean;\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element\r\n     */\r\n    applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void;\r\n}\r\n"]}