var _a, _b, _c, _d, _e, _f;
import convertAlphaToDecimals from './convertAlphaToDecimals';
var NumberingTypes;
(function (NumberingTypes) {
    NumberingTypes[NumberingTypes["Decimal"] = 1] = "Decimal";
    NumberingTypes[NumberingTypes["LowerAlpha"] = 2] = "LowerAlpha";
    NumberingTypes[NumberingTypes["UpperAlpha"] = 3] = "UpperAlpha";
    NumberingTypes[NumberingTypes["LowerRoman"] = 4] = "LowerRoman";
    NumberingTypes[NumberingTypes["UpperRoman"] = 5] = "UpperRoman";
})(NumberingTypes || (NumberingTypes = {}));
var Character;
(function (Character) {
    Character[Character["Dot"] = 1] = "Dot";
    Character[Character["Dash"] = 2] = "Dash";
    Character[Character["Parenthesis"] = 3] = "Parenthesis";
    Character[Character["DoubleParenthesis"] = 4] = "DoubleParenthesis";
})(Character || (Character = {}));
var characters = {
    '.': 1 /* Dot */,
    '-': 2 /* Dash */,
    ')': 3 /* Parenthesis */,
};
var lowerRomanTypes = [
    13 /* LowerRoman */,
    16 /* LowerRomanDash */,
    15 /* LowerRomanDoubleParenthesis */,
    14 /* LowerRomanParenthesis */,
];
var upperRomanTypes = [
    17 /* UpperRoman */,
    20 /* UpperRomanDash */,
    19 /* UpperRomanDoubleParenthesis */,
    18 /* UpperRomanParenthesis */,
];
var numberingTriggers = ['1', 'a', 'A', 'I', 'i'];
var lowerRomanNumbers = ['i', 'v', 'x', 'l', 'c', 'd', 'm'];
var upperRomanNumbers = ['I', 'V', 'X', 'L', 'C', 'D', 'M'];
var identifyNumberingType = function (text, previousListStyle) {
    if (!isNaN(parseInt(text))) {
        return 1 /* Decimal */;
    }
    else if (/[a-z]+/g.test(text)) {
        if ((previousListStyle != undefined &&
            lowerRomanTypes.indexOf(previousListStyle) > -1 &&
            lowerRomanNumbers.indexOf(text[0]) > -1) ||
            (!previousListStyle && text === 'i')) {
            return 4 /* LowerRoman */;
        }
        else if (previousListStyle || (!previousListStyle && text === 'a')) {
            return 2 /* LowerAlpha */;
        }
    }
    else if (/[A-Z]+/g.test(text)) {
        if ((previousListStyle != undefined &&
            upperRomanTypes.indexOf(previousListStyle) > -1 &&
            upperRomanNumbers.indexOf(text[0]) > -1) ||
            (!previousListStyle && text === 'I')) {
            return 5 /* UpperRoman */;
        }
        else if (previousListStyle || (!previousListStyle && text === 'A')) {
            return 3 /* UpperAlpha */;
        }
    }
};
var numberingListTypes = (_a = {},
    _a[1 /* Decimal */] = function (char) { return DecimalsTypes[char] || null; },
    _a[2 /* LowerAlpha */] = function (char) { return LowerAlphaTypes[char] || null; },
    _a[3 /* UpperAlpha */] = function (char) { return UpperAlphaTypes[char] || null; },
    _a[4 /* LowerRoman */] = function (char) { return LowerRomanTypes[char] || null; },
    _a[5 /* UpperRoman */] = function (char) { return UpperRomanTypes[char] || null; },
    _a);
var UpperRomanTypes = (_b = {},
    _b[1 /* Dot */] = 17 /* UpperRoman */,
    _b[2 /* Dash */] = 20 /* UpperRomanDash */,
    _b[3 /* Parenthesis */] = 18 /* UpperRomanParenthesis */,
    _b[4 /* DoubleParenthesis */] = 19 /* UpperRomanDoubleParenthesis */,
    _b);
var LowerRomanTypes = (_c = {},
    _c[1 /* Dot */] = 13 /* LowerRoman */,
    _c[2 /* Dash */] = 16 /* LowerRomanDash */,
    _c[3 /* Parenthesis */] = 14 /* LowerRomanParenthesis */,
    _c[4 /* DoubleParenthesis */] = 15 /* LowerRomanDoubleParenthesis */,
    _c);
var UpperAlphaTypes = (_d = {},
    _d[1 /* Dot */] = 9 /* UpperAlpha */,
    _d[2 /* Dash */] = 12 /* UpperAlphaDash */,
    _d[3 /* Parenthesis */] = 10 /* UpperAlphaParenthesis */,
    _d[4 /* DoubleParenthesis */] = 11 /* UpperAlphaDoubleParenthesis */,
    _d);
var LowerAlphaTypes = (_e = {},
    _e[1 /* Dot */] = 5 /* LowerAlpha */,
    _e[2 /* Dash */] = 8 /* LowerAlphaDash */,
    _e[3 /* Parenthesis */] = 6 /* LowerAlphaParenthesis */,
    _e[4 /* DoubleParenthesis */] = 7 /* LowerAlphaDoubleParenthesis */,
    _e);
var DecimalsTypes = (_f = {},
    _f[1 /* Dot */] = 1 /* Decimal */,
    _f[2 /* Dash */] = 2 /* DecimalDash */,
    _f[3 /* Parenthesis */] = 3 /* DecimalParenthesis */,
    _f[4 /* DoubleParenthesis */] = 4 /* DecimalDoubleParenthesis */,
    _f);
var identifyNumberingListType = function (numbering, isDoubleParenthesis, previousListStyle) {
    var separatorCharacter = isDoubleParenthesis
        ? 4 /* DoubleParenthesis */
        : characters[numbering[numbering.length - 1]];
    // if separator is not valid, no need to check if the number is valid.
    if (separatorCharacter) {
        var number = isDoubleParenthesis ? numbering.slice(1, -1) : numbering.slice(0, -1);
        var numberingType = identifyNumberingType(number, previousListStyle);
        return numberingType ? numberingListTypes[numberingType](separatorCharacter) : null;
    }
    return null;
};
/**
 * @internal
 * @param textBeforeCursor The trigger character
 * @param previousListChain @optional This parameters is used to keep the list chain, if the is not a new list
 * @param previousListStyle @optional The list style of the previous list
 * @returns The style of a numbering list triggered by a string
 */
export default function getAutoNumberingListStyle(textBeforeCursor, previousListChain, previousListStyle) {
    var _a;
    var trigger = textBeforeCursor.trim();
    var isDoubleParenthesis = trigger[0] === '(' && trigger[trigger.length - 1] === ')';
    //Only the staring items ['1', 'a', 'A', 'I', 'i'] must trigger a new list. All the other triggers is used to keep the list chain.
    //The index is always the characters before the last character
    var listIndex = isDoubleParenthesis ? trigger.slice(1, -1) : trigger.slice(0, -1);
    var indexNumber = parseInt(listIndex);
    var index = !isNaN(indexNumber) ? indexNumber : convertAlphaToDecimals(listIndex);
    if (!index || index < 1) {
        return null;
    }
    if (previousListChain && index > 1) {
        if ((previousListChain.length < 1 && numberingTriggers.indexOf(listIndex) < 0) ||
            ((previousListChain === null || previousListChain === void 0 ? void 0 : previousListChain.length) > 0 &&
                !((_a = previousListChain[previousListChain.length - 1]) === null || _a === void 0 ? void 0 : _a.canAppendAtCursor(index)))) {
            return null;
        }
    }
    var numberingType = isValidNumbering(listIndex)
        ? identifyNumberingListType(trigger, isDoubleParenthesis, previousListStyle)
        : null;
    return numberingType;
}
/**
 * Check if index has only numbers or only letters to avoid sequence of character such 1:1. trigger a list.
 * @param index
 * @returns
 */
function isValidNumbering(index) {
    return Number(index) || /^[A-Za-z\s]*$/.test(index);
}
//# sourceMappingURL=getAutoNumberingListStyle.js.map