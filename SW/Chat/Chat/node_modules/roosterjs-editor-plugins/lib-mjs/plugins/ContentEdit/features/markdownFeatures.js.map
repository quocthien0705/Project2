{"version":3,"file":"markdownFeatures.js","sourceRoot":"","sources":["../../../../../../packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.ts"],"names":[],"mappings":"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","sourcesContent":["import { cacheGetEventData, createRange, Position, wrap } from 'roosterjs-editor-dom';\nimport { ChangeSource, Keys, PositionType } from 'roosterjs-editor-types';\nimport type { CompatibleKeys } from 'roosterjs-editor-types/lib/compatibleTypes';\nimport type {\n    BuildInEditFeature,\n    IEditor,\n    MarkdownFeatureSettings,\n    NodePosition,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\n\nconst ZERO_WIDTH_SPACE = '\\u200B';\n\nfunction generateBasicMarkdownFeature(\n    key: Keys | CompatibleKeys,\n    triggerCharacter: string,\n    elementTag: string,\n    useShiftKey: boolean\n): BuildInEditFeature<PluginKeyboardEvent> {\n    return {\n        keys: [key],\n        shouldHandleEvent: (event, editor) =>\n            event.rawEvent.shiftKey === useShiftKey &&\n            !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter),\n        handleEvent: (event, editor) => {\n            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.\n            editor.runAsync(editor => {\n                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);\n            });\n        },\n    };\n}\n\nfunction cacheGetRangeForMarkdownOperation(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string\n): Range | null {\n    return cacheGetEventData(event, 'MARKDOWN_RANGE', (): Range | null => {\n        const searcher = editor.getContentSearcherOfCursor(event);\n\n        let startPosition: NodePosition | null = null;\n        let endPosition: NodePosition | null = null;\n        searcher?.forEachTextInlineElement(textInlineElement => {\n            if (endPosition && startPosition) {\n                return true;\n            }\n            const inlineTextContent = textInlineElement.getTextContent();\n\n            // special case for immediately preceding character being whitespace\n            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {\n                return false;\n            }\n\n            //if the text is pasted, it might create a inner element inside the text element,\n            // then is necessary to check the parent block to get whole text\n            const parentBlockText = textInlineElement.getParentBlock().getTextContent();\n\n            // special case for consecutive trigger characters\n            // check parent block in case of pasted text\n            if (parentBlockText[parentBlockText.length - 1].trim() === triggerCharacter) {\n                return false;\n            }\n\n            if (!endPosition) {\n                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);\n            }\n            if (inlineTextContent[0] == triggerCharacter) {\n                startPosition = textInlineElement.getStartPosition();\n            } else {\n                let contentIndex = inlineTextContent.length - 1;\n                for (; contentIndex > 0; contentIndex--) {\n                    if (startPosition) {\n                        return true;\n                    }\n                    if (\n                        inlineTextContent[contentIndex] == triggerCharacter &&\n                        inlineTextContent[contentIndex - 1].trim().length == 0\n                    ) {\n                        startPosition = textInlineElement.getStartPosition().move(contentIndex);\n                        return true;\n                    }\n                }\n            }\n        });\n        return startPosition && endPosition && createRange(startPosition, endPosition);\n    });\n}\n\nfunction handleMarkdownEvent(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string,\n    elementTag: string\n) {\n    editor.addUndoSnapshot(\n        () => {\n            const range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);\n            if (!range) {\n                return;\n            }\n            const lastTypedTriggerPosition = new Position(range.endContainer, PositionType.End);\n            const hasLastTypedTrigger = range.endOffset + 1 <= lastTypedTriggerPosition.offset;\n            if (!!range && hasLastTypedTrigger) {\n                // get the text content range\n                const textContentRange = range.cloneRange();\n                textContentRange.setStart(\n                    textContentRange.startContainer,\n                    textContentRange.startOffset + 1\n                );\n\n                const text = textContentRange.extractContents().textContent;\n                const textNode = editor.getDocument().createTextNode(text ?? '');\n\n                // extract content and put it into a new element.\n                const elementToWrap = wrap(textNode, elementTag);\n                //include last typed character\n                range.setEnd(range.endContainer, range.endOffset + 1);\n                range.deleteContents();\n\n                // ZWS here ensures we don't end up inside the newly created node.\n                const nonPrintedSpaceTextNode = editor\n                    .getDocument()\n                    .createTextNode(ZERO_WIDTH_SPACE);\n                range.insertNode(nonPrintedSpaceTextNode);\n                range.insertNode(elementToWrap);\n\n                editor.select(nonPrintedSpaceTextNode, PositionType.End);\n            }\n        },\n        ChangeSource.Format,\n        true /*canUndoByBackspace*/\n    );\n}\n\n/**\n * Markdown bold feature. Make bold text with markdown shortcuts.\n */\nconst MarkdownBold: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.EIGHT_ASTERISK,\n    '*',\n    'b',\n    true /* useShiftKey */\n);\n\n/**\n * Markdown italics feature. Make italic text with markdown shortcuts.\n */\nconst MarkdownItalic: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.DASH_UNDERSCORE,\n    '_',\n    'i',\n    true /* useShiftKey */\n);\n\n/**\n * Markdown strikethrough feature. MAke strikethrough text with markdown shortcuts.\n */\nconst MarkdownStrikethrough: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '~',\n    's',\n    true /* useShiftKey */\n);\n\n/**\n * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.\n */\nconst MarkdownInlineCode: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '`',\n    'code',\n    false /* useShiftKey */\n);\n\n/**\n * @internal\n */\nexport const MarkdownFeatures: Record<\n    keyof MarkdownFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    markdownBold: MarkdownBold,\n    markdownItalic: MarkdownItalic,\n    markdownStrikethru: MarkdownStrikethrough,\n    markdownInlineCode: MarkdownInlineCode,\n};\n"]}