import { editTable, setIndentation } from 'roosterjs-editor-api';
import { cacheGetEventData, contains, getTagOfNode, isVoidHtmlElement, isWholeTableSelected, Position, VTable, } from 'roosterjs-editor-dom';
/**
 * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table
 */
var TabInTable = {
    keys: [9 /* TAB */],
    shouldHandleEvent: function (event, editor) {
        return cacheGetTableCell(event, editor) && !cacheIsWholeTableSelected(event, editor);
    },
    handleEvent: function (event, editor) {
        var _a, _b, _c;
        var shift = event.rawEvent.shiftKey;
        var td = cacheGetTableCell(event, editor);
        if (!td) {
            return;
        }
        var vtable = cacheVTable(event, td);
        for (var step = shift ? -1 : 1, row = (_a = vtable.row) !== null && _a !== void 0 ? _a : 0, col = ((_b = vtable.col) !== null && _b !== void 0 ? _b : 0) + step;; col += step) {
            var tableCells = (_c = vtable.cells) !== null && _c !== void 0 ? _c : [];
            if (col < 0 || col >= tableCells[row].length) {
                row += step;
                if (row < 0) {
                    editor.select(vtable.table, -2 /* Before */);
                    break;
                }
                else if (row >= tableCells.length) {
                    editTable(editor, 1 /* InsertBelow */);
                    break;
                }
                col = shift ? tableCells[row].length - 1 : 0;
            }
            var cell = vtable.getCell(row, col);
            if (cell.td) {
                var newPos = new Position(cell.td, 0 /* Begin */).normalize();
                editor.select(newPos);
                break;
            }
        }
        event.rawEvent.preventDefault();
    },
};
/**
 * IndentTableOnTab edit feature, provides the ability to indent the table if it is all cells are selected.
 */
var IndentTableOnTab = {
    keys: [9 /* TAB */],
    shouldHandleEvent: function (event, editor) {
        return cacheGetTableCell(event, editor) && cacheIsWholeTableSelected(event, editor);
    },
    handleEvent: function (event, editor) {
        event.rawEvent.preventDefault();
        editor.addUndoSnapshot(function () {
            var shift = event.rawEvent.shiftKey;
            var selection = editor.getSelectionRangeEx();
            var td = cacheGetTableCell(event, editor);
            if (!td) {
                return;
            }
            var vtable = cacheVTable(event, td);
            if (shift && editor.getElementAtCursor('blockquote', vtable.table, event)) {
                setIndentation(editor, 1 /* Decrease */);
            }
            else if (!shift) {
                setIndentation(editor, 0 /* Increase */);
            }
            if (selection.coordinates) {
                editor.select(selection.table, selection.coordinates);
            }
        });
    },
};
/**
 * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN
 * in table
 */
var UpDownInTable = {
    keys: [38 /* UP */, 40 /* DOWN */],
    shouldHandleEvent: function (event, editor) {
        return cacheGetTableCell(event, editor) && !cacheIsWholeTableSelected(event, editor);
    },
    handleEvent: function (event, editor) {
        var _a, _b, _c;
        var td = cacheGetTableCell(event, editor);
        if (!td) {
            return;
        }
        var vtable = new VTable(td);
        var isUp = event.rawEvent.which == 38 /* UP */;
        var step = isUp ? -1 : 1;
        var hasShiftKey = event.rawEvent.shiftKey;
        var selection = (_a = editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
        var targetTd = null;
        if (selection) {
            var anchorNode_1 = selection.anchorNode, anchorOffset_1 = selection.anchorOffset;
            for (var row = (_b = vtable.row) !== null && _b !== void 0 ? _b : 0; row >= 0 && vtable.cells && row < vtable.cells.length; row += step) {
                var cell = vtable.getCell(row, (_c = vtable.col) !== null && _c !== void 0 ? _c : 0);
                if (cell.td && cell.td != td) {
                    targetTd = cell.td;
                    break;
                }
            }
            editor.runAsync(function (editor) {
                var _a;
                var newContainer = editor.getElementAtCursor();
                if (contains(vtable.table, newContainer) &&
                    !contains(td, newContainer, true /*treatSameNodeAsContain*/)) {
                    var newPos = targetTd
                        ? new Position(targetTd, 0 /* Begin */)
                        : new Position(vtable.table, isUp ? -2 /* Before */ : -3 /* After */);
                    if (hasShiftKey) {
                        newPos =
                            newPos.node.nodeType == 1 /* Element */ &&
                                isVoidHtmlElement(newPos.node)
                                ? new Position(newPos.node, newPos.isAtEnd ? -3 /* After */ : -2 /* Before */)
                                : newPos;
                        var selection_1 = (_a = editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
                        if (anchorNode_1) {
                            selection_1 === null || selection_1 === void 0 ? void 0 : selection_1.setBaseAndExtent(anchorNode_1, anchorOffset_1, newPos.node, newPos.offset);
                        }
                    }
                    else {
                        editor.select(newPos.normalize());
                    }
                }
            });
        }
    },
};
/**
 * Requires @see ExperimentalFeatures.DeleteTableWithBackspace
 * Delete a table selected with the table selector pressing Backspace key
 */
var DeleteTableWithBackspace = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        return editor.isFeatureEnabled("DeleteTableWithBackspace" /* DeleteTableWithBackspace */) &&
            cacheIsWholeTableSelected(event, editor);
    },
    handleEvent: function (event, editor) {
        var td = cacheGetTableCell(event, editor);
        if (!td) {
            return;
        }
        var vtable = new VTable(td);
        vtable.edit(4 /* DeleteTable */);
        vtable.writeBack();
    },
};
function cacheGetTableCell(event, editor) {
    return cacheGetEventData(event, 'TABLE_CELL_FOR_TABLE_FEATURES', function () {
        var pos = editor.getFocusedPosition();
        var firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);
        return (firstTd && (getTagOfNode(firstTd) == 'LI' ? null : firstTd));
    });
}
function cacheIsWholeTableSelected(event, editor) {
    return cacheGetEventData(event, 'WHOLE_TABLE_SELECTED_FOR_FEATURES', function () {
        var td = cacheGetTableCell(event, editor);
        if (!td) {
            return false;
        }
        var vtable = cacheVTable(event, td);
        var selection = editor.getSelectionRangeEx();
        return (selection.type == 1 /* TableSelection */ &&
            selection.coordinates &&
            isWholeTableSelected(vtable, selection.coordinates));
    });
}
function cacheVTable(event, td) {
    return cacheGetEventData(event, 'VTABLE_FOR_TABLE_FEATURES', function () {
        return new VTable(td);
    });
}
/**
 * @internal
 */
export var TableFeatures = {
    tabInTable: TabInTable,
    upDownInTable: UpDownInTable,
    indentTableOnTab: IndentTableOnTab,
    deleteTableWithBackspace: DeleteTableWithBackspace,
};
//# sourceMappingURL=tableFeatures.js.map