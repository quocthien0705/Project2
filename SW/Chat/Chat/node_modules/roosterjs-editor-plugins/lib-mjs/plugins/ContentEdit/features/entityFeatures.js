import { __read } from "tslib";
import { ContentTraverser, addDelimiters, cacheGetEventData, createRange, getComputedStyle, getDelimiterFromElement, getEntityFromElement, getEntitySelector, isBlockElement, matchesSelector, Position, } from 'roosterjs-editor-dom';
/**
 * A content edit feature to trigger EntityOperation event with operation "Click" when user
 * clicks on a readonly entity.
 */
var ClickOnEntityFeature = {
    keys: [13 /* ENTER */],
    shouldHandleEvent: function (event, editor) { return cacheGetReadonlyEntityElement(event, editor); },
    handleEvent: function (event, editor) {
        cacheGetReadonlyEntityElement(event, editor, 1 /* Click */);
    },
};
/**
 * A content edit feature to trigger EntityOperation event with operation "Escape" when user
 * presses ESC on a readonly entity.
 */
var EscapeFromEntityFeature = {
    keys: [27 /* ESCAPE */],
    shouldHandleEvent: function (event, editor) { return cacheGetReadonlyEntityElement(event, editor); },
    handleEvent: function (event, editor) {
        cacheGetReadonlyEntityElement(event, editor, 3 /* Escape */);
    },
};
function cacheGetReadonlyEntityElement(event, editor, operation) {
    var element = cacheGetEventData(event, 'READONLY_ENTITY_ELEMENT', function () {
        var node = event.rawEvent.target;
        var entityElement = node && editor.getElementAtCursor(getEntitySelector(), node);
        return entityElement && !entityElement.isContentEditable ? entityElement : null;
    });
    if (element && operation !== undefined) {
        var entity = getEntityFromElement(element);
        if (entity) {
            editor.triggerPluginEvent(15 /* EntityOperation */, {
                operation: operation,
                rawEvent: event.rawEvent,
                entity: entity,
            });
        }
    }
    return element;
}
/**
 * A content edit feature to split current line into two lines at the cursor when user presses
 * ENTER right before a readonly entity.
 * Browser's default behavior will insert an extra BR tag before the entity which causes an extra
 * empty line. So we override the default behavior here.
 */
var EnterBeforeReadonlyEntityFeature = {
    keys: [13 /* ENTER */],
    shouldHandleEvent: function (event, editor) {
        return cacheGetNeighborEntityElement(event, editor, true /*isNext*/, false /*collapseOnly*/);
    },
    handleEvent: function (event, editor) {
        var _a, _b, _c;
        event.rawEvent.preventDefault();
        var range = editor.getSelectionRange();
        if (!range) {
            return;
        }
        var node = Position.getEnd(range).normalize().node;
        var br = editor.getDocument().createElement('BR');
        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(br, node.nextSibling);
        var block = editor.getBlockElementAtNode(node);
        var newContainer;
        if (block) {
            newContainer = block.collapseToSingleElement();
            (_b = br.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(br);
        }
        (_c = editor.getSelectionRange()) === null || _c === void 0 ? void 0 : _c.deleteContents();
        if (newContainer === null || newContainer === void 0 ? void 0 : newContainer.nextSibling) {
            editor.select(newContainer.nextSibling, 0 /* Begin */);
        }
    },
};
/**
 * A content edit feature to trigger EntityOperation event with operation "RemoveFromEnd" when user
 * press BACKSPACE right after an entity
 */
var BackspaceAfterEntityFeature = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        return cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/);
    },
    handleEvent: function (event, editor) {
        cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/, 5 /* RemoveFromEnd */);
    },
};
/**
 * A content edit feature to trigger EntityOperation event with operation "RemoveFromStart" when user
 * press DELETE right after an entity
 */
var DeleteBeforeEntityFeature = {
    keys: [46 /* DELETE */],
    shouldHandleEvent: function (event, editor) {
        return cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/);
    },
    handleEvent: function (event, editor) {
        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/, 4 /* RemoveFromStart */);
    },
};
function cacheGetNeighborEntityElement(event, editor, isNext, collapseOnly, operation) {
    var element = cacheGetEventData(event, 'NEIGHBOR_ENTITY_ELEMENT_' + isNext + '_' + collapseOnly, function () {
        var _a;
        var range = editor.getSelectionRange();
        if (!range || (collapseOnly && !range.collapsed)) {
            return null;
        }
        var regions = editor.getSelectedRegions();
        var regionRoot = (_a = regions[0]) === null || _a === void 0 ? void 0 : _a.rootNode;
        range.commonAncestorContainer.normalize();
        var pos = Position.getEnd(range).normalize();
        var isAtBeginOrEnd = pos.offset == 0 || pos.isAtEnd;
        var entityNode = null;
        if (isAtBeginOrEnd && regionRoot) {
            var traverser = ContentTraverser.createBodyTraverser(regionRoot, pos.node);
            var sibling = isNext
                ? pos.offset == 0
                    ? traverser.currentInlineElement
                    : traverser.getNextInlineElement()
                : pos.isAtEnd
                    ? traverser.currentInlineElement
                    : traverser.getPreviousInlineElement();
            var node = sibling && sibling.getContainerNode();
            if (!collapseOnly) {
                var block = editor.getBlockElementAtNode(pos.node);
                if (!block || (node && !block.contains(node))) {
                    node = null;
                }
            }
            entityNode = node && editor.getElementAtCursor(getEntitySelector(), node);
        }
        return entityNode;
    });
    if (element && operation !== undefined) {
        var entity = getEntityFromElement(element);
        if (entity) {
            triggerOperation(entity, editor, operation, event);
        }
    }
    return element;
}
/**
 * Content edit feature to move the cursor from Delimiters around Entities when using Right or Left Arrow Keys
 */
var MoveBetweenDelimitersFeature = {
    keys: [39 /* RIGHT */, 37 /* LEFT */],
    allowFunctionKeys: true,
    shouldHandleEvent: function (event, editor) {
        if (event.rawEvent.altKey) {
            return false;
        }
        var element = editor.getElementAtCursor();
        if (!element) {
            return false;
        }
        var isRTL = getComputedStyle(element, 'direction') === 'rtl';
        var shouldCheckBefore = isRTL == (event.rawEvent.which === 37 /* LEFT */);
        return getIsDelimiterAtCursor(event, editor, shouldCheckBefore);
    },
    handleEvent: function (event, editor) {
        var checkBefore = cacheGetCheckBefore(event);
        var delimiter = cacheDelimiter(event, checkBefore);
        if (!delimiter) {
            return;
        }
        var _a = getRelatedElements(delimiter, checkBefore, editor), delimiterPair = _a.delimiterPair, entity = _a.entity;
        if (delimiterPair && entity && matchesSelector(entity, getEntitySelector())) {
            event.rawEvent.preventDefault();
            editor.runAsync(function () {
                var positionType = checkBefore
                    ? event.rawEvent.shiftKey
                        ? -3 /* After */
                        : -1 /* End */
                    : -2 /* Before */;
                var position = new Position(delimiterPair, positionType);
                if (event.rawEvent.shiftKey) {
                    var selection = delimiterPair.ownerDocument.getSelection();
                    selection === null || selection === void 0 ? void 0 : selection.extend(position.node, position.offset);
                }
                else {
                    editor.select(position);
                }
            });
        }
    },
};
/**
 * Content edit Feature to trigger a Delete Entity Operation when one of the Delimiter is about to be removed with DELETE or Backspace
 */
var RemoveEntityBetweenDelimitersFeature = {
    keys: [8 /* BACKSPACE */, 46 /* DELETE */],
    shouldHandleEvent: function (event, editor) {
        var range = editor.getSelectionRange();
        if (!(range === null || range === void 0 ? void 0 : range.collapsed)) {
            return false;
        }
        var checkBefore = event.rawEvent.which === 46 /* DELETE */;
        var isDelimiter = getIsDelimiterAtCursor(event, editor, checkBefore);
        if (isDelimiter) {
            var delimiter = cacheDelimiter(event, checkBefore);
            var entityElement = checkBefore
                ? delimiter === null || delimiter === void 0 ? void 0 : delimiter.nextElementSibling
                : delimiter === null || delimiter === void 0 ? void 0 : delimiter.previousElementSibling;
            return !!cacheEntityBetweenDelimiter(event, editor, checkBefore, entityElement);
        }
        return false;
    },
    handleEvent: function (event, editor) {
        var checkBefore = event.rawEvent.which === 46 /* DELETE */;
        cacheEntityBetweenDelimiter(event, editor, checkBefore, null, checkBefore ? 4 /* RemoveFromStart */ : 5 /* RemoveFromEnd */);
    },
};
function getIsDelimiterAtCursor(event, editor, checkBefore) {
    var _a;
    var position = (_a = editor.getFocusedPosition()) === null || _a === void 0 ? void 0 : _a.normalize();
    cacheGetCheckBefore(event, checkBefore);
    if (!position) {
        return false;
    }
    var focusedElement = position.node.nodeType == 3 /* Text */
        ? position.node
        : position.node == position.element
            ? position.element.childNodes.item(position.offset)
            : position.element;
    var data = checkBefore
        ? {
            class: "entityDelimiterBefore" /* DELIMITER_BEFORE */,
            pairClass: "entityDelimiterAfter" /* DELIMITER_AFTER */,
            isAtEndOrBeginning: position.isAtEnd,
        }
        : {
            class: "entityDelimiterAfter" /* DELIMITER_AFTER */,
            pairClass: "entityDelimiterBefore" /* DELIMITER_BEFORE */,
            isAtEndOrBeginning: position.offset == 0,
        };
    var sibling = getNextSibling(editor, focusedElement, checkBefore);
    if (data.isAtEndOrBeginning && sibling) {
        var elAtCursor = editor.getElementAtCursor('.' + data.class, sibling);
        if (elAtCursor && !!shouldHandle(elAtCursor)) {
            return true;
        }
    }
    var entityAtCursor = focusedElement && editor.getElementAtCursor('.' + data.class, focusedElement);
    return !!shouldHandle(entityAtCursor);
    function shouldHandle(element) {
        if (!element) {
            return false;
        }
        var delimiterPair = getRelatedElements(element, checkBefore, editor).delimiterPair;
        return (delimiterPair &&
            (delimiterPair.className || '').indexOf(data.pairClass) > -1 &&
            cacheDelimiter(event, checkBefore, element));
    }
}
function getNextSibling(editor, element, checkBefore) {
    var traverser = getBlockTraverser(editor, element);
    if (!traverser) {
        return undefined;
    }
    var traverseFn = function (t) {
        return checkBefore ? t.getNextInlineElement() : t.getPreviousInlineElement();
    };
    var currentInline = traverser.currentInlineElement;
    while (currentInline && currentInline.getContainerNode() === element) {
        currentInline = traverseFn(traverser);
    }
    return currentInline === null || currentInline === void 0 ? void 0 : currentInline.getContainerNode();
}
function getBlockTraverser(editor, element) {
    var _a;
    if (!element) {
        return undefined;
    }
    var blockElement = (_a = editor.getBlockElementAtNode(element)) === null || _a === void 0 ? void 0 : _a.getStartNode();
    if (!blockElement || !isBlockElement(blockElement)) {
        return undefined;
    }
    return ContentTraverser.createBodyTraverser(blockElement, element);
}
function cacheDelimiter(event, checkBefore, delimiter) {
    return cacheGetEventData(event, 'delimiter_cache_key_' + checkBefore, function () { return delimiter; });
}
function cacheEntityBetweenDelimiter(event, editor, checkBefore, entity, operation) {
    var element = cacheGetEventData(event, 'entity_delimiter_cache_key_' + checkBefore, function () { return entity && editor.getElementAtCursor(getEntitySelector(), entity); });
    if (element && operation !== undefined) {
        var entity_1 = getEntityFromElement(element);
        if (entity_1) {
            triggerOperation(entity_1, editor, operation, event);
        }
    }
    return element;
}
function triggerOperation(entity, editor, operation, event) {
    var _a = entity.wrapper, nextElementSibling = _a.nextElementSibling, previousElementSibling = _a.previousElementSibling;
    editor.triggerPluginEvent(15 /* EntityOperation */, {
        operation: operation,
        rawEvent: event.rawEvent,
        entity: entity,
    });
    if (entity.isReadonly && !isBlockElement(entity.wrapper)) {
        if (event.rawEvent.defaultPrevented) {
            editor.runAsync(function () {
                if (!editor.contains(entity.wrapper)) {
                    removeDelimiters(nextElementSibling, previousElementSibling);
                }
                else {
                    var _a = __read(addDelimiters(entity.wrapper), 1), delimiterAfter = _a[0];
                    if (delimiterAfter) {
                        editor.select(delimiterAfter, -3 /* After */);
                    }
                }
            });
        }
        else if (getDelimiterFromElement(nextElementSibling) &&
            getDelimiterFromElement(previousElementSibling)) {
            editor.select(createRange(previousElementSibling, nextElementSibling));
        }
    }
}
function removeDelimiters(nextElementSibling, previousElementSibling) {
    [nextElementSibling, previousElementSibling].forEach(function (sibling) {
        var _a;
        if (getDelimiterFromElement(sibling)) {
            (_a = sibling === null || sibling === void 0 ? void 0 : sibling.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);
        }
    });
}
function cacheGetCheckBefore(event, checkBefore) {
    return !!cacheGetEventData(event, 'Check_Before', function () { return checkBefore; });
}
function getRelatedElements(delimiter, checkBefore, editor) {
    var entity = null;
    var delimiterPair = null;
    var traverser = getBlockTraverser(editor, delimiter);
    if (!traverser) {
        return { delimiterPair: delimiterPair, entity: entity };
    }
    var selector = "." + (checkBefore ? "entityDelimiterAfter" /* DELIMITER_AFTER */ : "entityDelimiterBefore" /* DELIMITER_BEFORE */);
    var traverseFn = function (t) {
        return checkBefore ? t.getNextInlineElement() : t.getPreviousInlineElement();
    };
    var getElementFromInline = function (element, selector) {
        var _a;
        var node = element === null || element === void 0 ? void 0 : element.getContainerNode();
        return (_a = (node && editor.getElementAtCursor(selector, node))) !== null && _a !== void 0 ? _a : null;
    };
    var entitySelector = getEntitySelector();
    var current = traverser.currentInlineElement;
    while (current && (!entity || !delimiterPair)) {
        entity = entity || getElementFromInline(current, entitySelector);
        delimiterPair = delimiterPair || getElementFromInline(current, selector);
        if (entity) {
            // If we found the entity but the next inline after the entity is not a delimiter,
            // it means that the delimiter pair got removed or is invalid, return null instead.
            if (!delimiterPair && !getElementFromInline(current, entitySelector)) {
                delimiterPair = null;
                break;
            }
            // If the delimiter is not editable keep looking for a editable one, by setting the value as null,
            //  in case the entity is wrapping another inline readonly entity
            if (delimiterPair && !delimiterPair.isContentEditable) {
                delimiterPair = null;
            }
        }
        current = traverseFn(traverser);
    }
    return { entity: entity, delimiterPair: delimiterPair };
}
/**
 * @internal
 */
export var EntityFeatures = {
    clickOnEntity: ClickOnEntityFeature,
    escapeFromEntity: EscapeFromEntityFeature,
    enterBeforeReadonlyEntity: EnterBeforeReadonlyEntityFeature,
    backspaceAfterEntity: BackspaceAfterEntityFeature,
    deleteBeforeEntity: DeleteBeforeEntityFeature,
    moveBetweenDelimitersFeature: MoveBetweenDelimitersFeature,
    removeEntityBetweenDelimiters: RemoveEntityBetweenDelimitersFeature,
};
//# sourceMappingURL=entityFeatures.js.map