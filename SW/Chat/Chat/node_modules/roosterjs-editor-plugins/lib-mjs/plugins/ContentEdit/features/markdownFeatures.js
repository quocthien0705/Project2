import { cacheGetEventData, createRange, Position, wrap } from 'roosterjs-editor-dom';
var ZERO_WIDTH_SPACE = '\u200B';
function generateBasicMarkdownFeature(key, triggerCharacter, elementTag, useShiftKey) {
    return {
        keys: [key],
        shouldHandleEvent: function (event, editor) {
            return event.rawEvent.shiftKey === useShiftKey &&
                !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);
        },
        handleEvent: function (event, editor) {
            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.
            editor.runAsync(function (editor) {
                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);
            });
        },
    };
}
function cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter) {
    return cacheGetEventData(event, 'MARKDOWN_RANGE', function () {
        var searcher = editor.getContentSearcherOfCursor(event);
        var startPosition = null;
        var endPosition = null;
        searcher === null || searcher === void 0 ? void 0 : searcher.forEachTextInlineElement(function (textInlineElement) {
            if (endPosition && startPosition) {
                return true;
            }
            var inlineTextContent = textInlineElement.getTextContent();
            // special case for immediately preceding character being whitespace
            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {
                return false;
            }
            //if the text is pasted, it might create a inner element inside the text element,
            // then is necessary to check the parent block to get whole text
            var parentBlockText = textInlineElement.getParentBlock().getTextContent();
            // special case for consecutive trigger characters
            // check parent block in case of pasted text
            if (parentBlockText[parentBlockText.length - 1].trim() === triggerCharacter) {
                return false;
            }
            if (!endPosition) {
                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);
            }
            if (inlineTextContent[0] == triggerCharacter) {
                startPosition = textInlineElement.getStartPosition();
            }
            else {
                var contentIndex = inlineTextContent.length - 1;
                for (; contentIndex > 0; contentIndex--) {
                    if (startPosition) {
                        return true;
                    }
                    if (inlineTextContent[contentIndex] == triggerCharacter &&
                        inlineTextContent[contentIndex - 1].trim().length == 0) {
                        startPosition = textInlineElement.getStartPosition().move(contentIndex);
                        return true;
                    }
                }
            }
        });
        return startPosition && endPosition && createRange(startPosition, endPosition);
    });
}
function handleMarkdownEvent(event, editor, triggerCharacter, elementTag) {
    editor.addUndoSnapshot(function () {
        var range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);
        if (!range) {
            return;
        }
        var lastTypedTriggerPosition = new Position(range.endContainer, -1 /* End */);
        var hasLastTypedTrigger = range.endOffset + 1 <= lastTypedTriggerPosition.offset;
        if (!!range && hasLastTypedTrigger) {
            // get the text content range
            var textContentRange = range.cloneRange();
            textContentRange.setStart(textContentRange.startContainer, textContentRange.startOffset + 1);
            var text = textContentRange.extractContents().textContent;
            var textNode = editor.getDocument().createTextNode(text !== null && text !== void 0 ? text : '');
            // extract content and put it into a new element.
            var elementToWrap = wrap(textNode, elementTag);
            //include last typed character
            range.setEnd(range.endContainer, range.endOffset + 1);
            range.deleteContents();
            // ZWS here ensures we don't end up inside the newly created node.
            var nonPrintedSpaceTextNode = editor
                .getDocument()
                .createTextNode(ZERO_WIDTH_SPACE);
            range.insertNode(nonPrintedSpaceTextNode);
            range.insertNode(elementToWrap);
            editor.select(nonPrintedSpaceTextNode, -1 /* End */);
        }
    }, "Format" /* Format */, true /*canUndoByBackspace*/);
}
/**
 * Markdown bold feature. Make bold text with markdown shortcuts.
 */
var MarkdownBold = generateBasicMarkdownFeature(56 /* EIGHT_ASTERISK */, '*', 'b', true /* useShiftKey */);
/**
 * Markdown italics feature. Make italic text with markdown shortcuts.
 */
var MarkdownItalic = generateBasicMarkdownFeature(189 /* DASH_UNDERSCORE */, '_', 'i', true /* useShiftKey */);
/**
 * Markdown strikethrough feature. MAke strikethrough text with markdown shortcuts.
 */
var MarkdownStrikethrough = generateBasicMarkdownFeature(192 /* GRAVE_TILDE */, '~', 's', true /* useShiftKey */);
/**
 * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.
 */
var MarkdownInlineCode = generateBasicMarkdownFeature(192 /* GRAVE_TILDE */, '`', 'code', false /* useShiftKey */);
/**
 * @internal
 */
export var MarkdownFeatures = {
    markdownBold: MarkdownBold,
    markdownItalic: MarkdownItalic,
    markdownStrikethru: MarkdownStrikethrough,
    markdownInlineCode: MarkdownInlineCode,
};
//# sourceMappingURL=markdownFeatures.js.map