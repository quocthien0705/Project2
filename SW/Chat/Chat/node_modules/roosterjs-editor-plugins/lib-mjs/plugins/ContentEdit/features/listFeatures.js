import getAnnounceDataForList from '../../../pluginUtils/announceData/getAnnounceDataForList';
import getAutoBulletListStyle from '../utils/getAutoBulletListStyle';
import getAutoNumberingListStyle from '../utils/getAutoNumberingListStyle';
import { Browser, cacheGetEventData, createNumberDefinition, createObjectDefinition, createVListFromRegion, findClosestElementAncestor, getComputedStyle, getMetadata, getTagOfNode, isBlockElement, isNodeEmpty, isPositionAtBeginningOf, Position, safeInstanceOf, VList, VListChain, } from 'roosterjs-editor-dom';
import { blockFormat, commitListChains, setIndentation, toggleBullet, toggleNumbering, toggleListType, } from 'roosterjs-editor-api';
var PREVIOUS_BLOCK_CACHE_KEY = 'previousBlock';
var NEXT_BLOCK_CACHE_KEY = 'nextBlock';
var ListStyleDefinitionMetadata = createObjectDefinition({
    orderedStyleType: createNumberDefinition(true /** isOptional */, undefined /** value **/, 1 /* Min */, 20 /* Max */),
    unorderedStyleType: createNumberDefinition(true /** isOptional */, undefined /** value **/, 1 /* Min */, 9 /* Max */),
}, true /** isOptional */, true /** allowNull */);
var shouldHandleIndentationEvent = function (indenting) { return function (event, editor) {
    var _a = event.rawEvent, keyCode = _a.keyCode, altKey = _a.altKey, shiftKey = _a.shiftKey, ctrlKey = _a.ctrlKey, metaKey = _a.metaKey;
    return (!ctrlKey &&
        !metaKey &&
        (keyCode === 9 /* TAB */
            ? !altKey && shiftKey === !indenting
            : shiftKey && altKey && keyCode === (indenting ? 39 /* RIGHT */ : 37 /* LEFT */)) &&
        cacheGetListElement(event, editor));
}; };
var handleIndentationEvent = function (indenting) { return function (event, editor) {
    var currentElement = null;
    var isRTL = event.rawEvent.keyCode !== 9 /* TAB */ &&
        (currentElement = editor.getElementAtCursor()) &&
        getComputedStyle(currentElement, 'direction') == 'rtl';
    editor.addUndoSnapshot(function () {
        setIndentation(editor, isRTL == indenting ? 1 /* Decrease */ : 0 /* Increase */);
    }, "Format" /* Format */, false /* canUndoByBackspace */, {
        getAnnounceData: function () {
            return getAnnounceDataForList(editor.getElementAtCursor('OL,UL'), editor.getElementAtCursor('LI'));
        },
    });
    event.rawEvent.preventDefault();
}; };
/**
 * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB
 */
var IndentWhenTab = {
    keys: [9 /* TAB */],
    shouldHandleEvent: shouldHandleIndentationEvent(true),
    handleEvent: handleIndentationEvent(true),
};
/**
 * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB
 */
var OutdentWhenShiftTab = {
    keys: [9 /* TAB */],
    shouldHandleEvent: shouldHandleIndentationEvent(false),
    handleEvent: handleIndentationEvent(false),
    allowFunctionKeys: true,
};
/**
 * indentWhenAltShiftRight edit feature, provides the ability to indent or outdent current list when user press Alt+shift+Right
 */
var IndentWhenAltShiftRight = {
    keys: [39 /* RIGHT */],
    shouldHandleEvent: shouldHandleIndentationEvent(true),
    handleEvent: handleIndentationEvent(true),
    allowFunctionKeys: true,
    defaultDisabled: Browser.isMac,
};
/**
 * outdentWhenAltShiftLeft edit feature, provides the ability to indent or outdent current list when user press Alt+shift+Left
 */
var OutdentWhenAltShiftLeft = {
    keys: [37 /* LEFT */],
    shouldHandleEvent: shouldHandleIndentationEvent(false),
    handleEvent: handleIndentationEvent(false),
    allowFunctionKeys: true,
    defaultDisabled: Browser.isMac,
};
/**
 * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press
 * BACKSPACE at beginning of a list item
 */
var MergeInNewLine = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        var li = editor.getElementAtCursor('LI', undefined /*startFrom*/, event);
        var range = editor.getSelectionRange();
        return li && (range === null || range === void 0 ? void 0 : range.collapsed) && isPositionAtBeginningOf(Position.getStart(range), li);
    },
    handleEvent: function (event, editor) {
        var li = editor.getElementAtCursor('LI', undefined /*startFrom*/, event);
        if (li === null || li === void 0 ? void 0 : li.previousSibling) {
            blockFormat(editor, function (region, start, end) {
                var vList = createVListFromRegion(region, false /*includeSiblingList*/, li !== null && li !== void 0 ? li : undefined);
                if (vList && start && end) {
                    vList.setIndentation(start, end, 1 /* Decrease */, true /*softOutdent*/);
                    vList.writeBack(editor.isFeatureEnabled("ReuseAllAncestorListElements" /* ReuseAllAncestorListElements */), editor.isFeatureEnabled("DisableListChain" /* DisableListChain */));
                    event.rawEvent.preventDefault();
                }
            });
        }
        else {
            toggleListAndPreventDefault(event, editor);
        }
    },
    defaultDisabled: true,
};
/**
 * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press
 * BACKSPACE at the first and empty line of a list
 */
var OutdentWhenBackOn1stEmptyLine = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        var li = editor.getElementAtCursor('LI', undefined /*startFrom*/, event);
        return (li &&
            isNodeEmpty(li) &&
            !li.previousSibling &&
            !li.getElementsByTagName('blockquote').length);
    },
    handleEvent: toggleListAndPreventDefault,
};
/**
 * MaintainListChainWhenDelete edit feature, provides the ability to indent the list if user press
 * DELETE before the first item of a list
 */
var MaintainListChainWhenDelete = {
    keys: [46 /* DELETE */],
    shouldHandleEvent: function (event, editor) {
        var li = editor.getElementAtCursor('LI', undefined /*startFrom*/, event);
        var range = editor.getSelectionRange();
        if (li || !range) {
            return false;
        }
        var isAtEnd = Position.getEnd(range).isAtEnd;
        var nextSibling = isAtEnd ? getCacheNextSibling(event, editor) : undefined;
        var isAtEndAndBeforeLI = editor.getElementAtCursor('LI', nextSibling, event);
        return isAtEndAndBeforeLI;
    },
    handleEvent: function (event, editor) {
        var chains = getListChains(editor);
        editor.runAsync(function (editor) { return commitListChains(editor, chains); });
    },
};
/**
 * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press
 * ENTER at the beginning of an empty line of a list
 */
var OutdentWhenEnterOnEmptyLine = {
    keys: [13 /* ENTER */],
    shouldHandleEvent: function (event, editor) {
        var li = editor.getElementAtCursor('LI', undefined /*startFrom*/, event);
        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);
    },
    handleEvent: function (event, editor) {
        editor.addUndoSnapshot(function () { return toggleListAndPreventDefault(event, editor, false /* includeSiblingLists */); }, undefined /*changeSource*/, true /*canUndoByBackspace*/);
    },
    defaultDisabled: !Browser.isIE && !Browser.isChrome,
};
/**
 * @deprecated Use AutoBulletList and AutoNumberingList instead
 */
var AutoBullet = {
    keys: [32 /* SPACE */],
    shouldHandleEvent: function (event, editor) {
        return false;
    },
    handleEvent: function (event, editor) { },
    defaultDisabled: true,
};
/**
 * AutoBulletList edit feature, provides the ability to automatically convert current line into a bullet list.
 */
var AutoBulletList = {
    keys: [32 /* SPACE */],
    shouldHandleEvent: function (event, editor) {
        if (!cacheGetListElement(event, editor)) {
            return shouldTriggerList(event, editor, getAutoBulletListStyle, 2 /* Unordered */);
        }
        return false;
    },
    handleEvent: function (event, editor) {
        editor.insertContent('&nbsp;');
        event.rawEvent.preventDefault();
        editor.addUndoSnapshot(function () {
            var _a;
            var searcher = editor.getContentSearcherOfCursor();
            if (!searcher) {
                return;
            }
            var textBeforeCursor = searcher.getSubStringBefore(5);
            var textRange = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/);
            var listStyle = getAutoBulletListStyle(textBeforeCursor);
            if (textRange) {
                prepareAutoBullet(editor, textRange);
                toggleBullet(editor, listStyle !== null && listStyle !== void 0 ? listStyle : undefined, 'autoToggleList' /** apiNameOverride */);
            }
            (_a = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/)) === null || _a === void 0 ? void 0 : _a.deleteContents();
        }, undefined /*changeSource*/, true /*canUndoByBackspace*/);
    },
};
/**
 * AutoNumberingList edit feature, provides the ability to automatically convert current line into a numbering list.
 */
var AutoNumberingList = {
    keys: [32 /* SPACE */],
    shouldHandleEvent: function (event, editor) {
        if (!cacheGetListElement(event, editor)) {
            return shouldTriggerList(event, editor, getAutoNumberingListStyle, 1 /* Ordered */);
        }
        return false;
    },
    handleEvent: function (event, editor) {
        editor.insertContent('&nbsp;');
        event.rawEvent.preventDefault();
        editor.addUndoSnapshot(function () {
            var _a, _b;
            var searcher = editor.getContentSearcherOfCursor();
            if (!searcher) {
                return;
            }
            var textBeforeCursor = searcher.getSubStringBefore(5);
            var textRange = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/);
            if (textRange) {
                var number = isFirstItemOfAList(textBeforeCursor)
                    ? 1
                    : parseInt(textBeforeCursor);
                var isLi = getPreviousListItem(editor, textRange);
                var listStyle = (_a = getAutoNumberingListStyle(textBeforeCursor)) !== null && _a !== void 0 ? _a : undefined;
                prepareAutoBullet(editor, textRange);
                toggleNumbering(editor, isLi && number !== 1 ? undefined : number /** startNumber */, listStyle, 'autoToggleList' /** apiNameOverride */);
            }
            (_b = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/)) === null || _b === void 0 ? void 0 : _b.deleteContents();
        }, undefined /*changeSource*/, true /*canUndoByBackspace*/);
    },
};
var getPreviousListItem = function (editor, textRange) {
    var _a;
    var blockElement = editor
        .getBodyTraverser(textRange === null || textRange === void 0 ? void 0 : textRange.startContainer)
        .getPreviousBlockElement();
    var previousNode = (_a = blockElement === null || blockElement === void 0 ? void 0 : blockElement.getEndNode()) !== null && _a !== void 0 ? _a : null;
    return getTagOfNode(previousNode) === 'LI' ? previousNode : undefined;
};
var getPreviousListType = function (editor, textRange, listType) {
    var type = listType === 1 /* Ordered */ ? 'orderedStyleType' : 'unorderedStyleType';
    var listItem = getPreviousListItem(editor, textRange);
    var list = listItem
        ? findClosestElementAncestor(listItem, undefined /** root*/, listType === 1 /* Ordered */ ? 'ol' : 'ul')
        : null;
    var metadata = list ? getMetadata(list, ListStyleDefinitionMetadata) : null;
    return metadata ? metadata[type] : null;
};
var isFirstItemOfAList = function (item) {
    var number = parseInt(item);
    if (number && number === 1) {
        return 1;
    }
    else {
        var letter = item.replace(/\(|\)|\-|\./g, '').trim();
        return letter.length === 1 && ['i', 'a', 'I', 'A'].indexOf(letter) > -1 ? 1 : undefined;
    }
};
/**
 * Maintain the list numbers in list chain
 * e.g. we have two lists:
 * 1, 2, 3 and 4, 5, 6
 * Now we delete list item 2, so the first one becomes "1, 2".
 * This edit feature can maintain the list number of the second list to become "3, 4, 5"
 */
var MaintainListChain = {
    keys: [13 /* ENTER */, 9 /* TAB */, 46 /* DELETE */, 8 /* BACKSPACE */, 258 /* RANGE */],
    shouldHandleEvent: function (event, editor) {
        return editor
            .queryElements('li', 1 /* OnSelection */)
            .filter(function (li) { return !li.getElementsByTagName('blockquote').length; }).length > 0;
    },
    handleEvent: function (event, editor) {
        var chains = getListChains(editor);
        editor.runAsync(function (editor) { return commitListChains(editor, chains); });
    },
};
function getListChains(editor) {
    return VListChain.createListChains(editor.getSelectedRegions());
}
function getCacheNextSibling(event, editor) {
    var element = cacheGetEventData(event, 'nextSibling', function () {
        var _a;
        var range = editor.getSelectionRange();
        var pos = range && Position.getEnd(range).normalize();
        var traverser = pos && editor.getBodyTraverser(pos.node);
        return (_a = traverser === null || traverser === void 0 ? void 0 : traverser.getNextBlockElement()) === null || _a === void 0 ? void 0 : _a.getStartNode();
    });
    return element;
}
function prepareAutoBullet(editor, range) {
    var _a;
    var block = editor.getBlockElementAtNode(range.startContainer);
    var endNode = block === null || block === void 0 ? void 0 : block.getEndNode();
    if (endNode && getTagOfNode(endNode) != 'BR') {
        var br = editor.getDocument().createElement('BR');
        if (isBlockElement(endNode)) {
            endNode.appendChild(br);
        }
        else {
            (_a = endNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(br, endNode.nextSibling);
        }
        editor.select(range.startContainer, range.startOffset);
    }
}
function toggleListAndPreventDefault(event, editor, includeSiblingLists) {
    if (includeSiblingLists === void 0) { includeSiblingLists = true; }
    var listInfo = cacheGetListElement(event, editor);
    if (listInfo) {
        var listElement = listInfo[0];
        var tag = getTagOfNode(listElement);
        if (tag == 'UL' || tag == 'OL') {
            toggleListType(editor, tag == 'UL' ? 2 /* Unordered */ : 1 /* Ordered */, undefined /* startNumber */, includeSiblingLists);
        }
        editor.focus();
        event.rawEvent.preventDefault();
    }
}
function cacheGetListElement(event, editor) {
    var li = editor.getElementAtCursor('LI,TABLE', undefined /*startFrom*/, event);
    var listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);
    return listElement ? [listElement, li] : null;
}
function shouldTriggerList(event, editor, getListStyle, listType) {
    var searcher = editor.getContentSearcherOfCursor(event);
    if (!searcher) {
        return false;
    }
    var textBeforeCursor = searcher.getSubStringBefore(4);
    var traverser = editor.getBlockTraverser();
    var text = traverser && traverser.currentBlockElement
        ? traverser.currentBlockElement.getTextContent().slice(0, textBeforeCursor.length)
        : null;
    var isATheBeginning = text && text === textBeforeCursor;
    var listChains = getListChains(editor);
    var textRange = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/);
    var previousListType = textRange && getPreviousListType(editor, textRange, listType);
    var isFirstItem = isFirstItemOfAList(textBeforeCursor);
    var listStyle = getListStyle(textBeforeCursor, listChains, previousListType !== null && previousListType !== void 0 ? previousListType : undefined);
    var shouldTriggerNewListStyle = isFirstItem ||
        !previousListType ||
        previousListType === listStyle ||
        listType === 2 /* Unordered */;
    return (isATheBeginning &&
        !searcher.getNearestNonTextInlineElement() &&
        listStyle &&
        shouldTriggerNewListStyle);
}
/**
 * MergeListOnBackspaceAfterList edit feature, provides the ability to merge list on backspace on block after a list.
 */
var MergeListOnBackspaceAfterList = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        var _a, _b;
        var target = editor.getElementAtCursor();
        if (target) {
            var cursorBlock = (_a = editor.getBlockElementAtNode(target)) === null || _a === void 0 ? void 0 : _a.getStartNode();
            var previousBlock_1 = (_b = cursorBlock === null || cursorBlock === void 0 ? void 0 : cursorBlock.previousElementSibling) !== null && _b !== void 0 ? _b : null;
            if (isList(previousBlock_1)) {
                var range = editor.getSelectionRange();
                var searcher = editor.getContentSearcherOfCursor(event);
                var textBeforeCursor = searcher === null || searcher === void 0 ? void 0 : searcher.getSubStringBefore(4);
                var nearestInline = searcher === null || searcher === void 0 ? void 0 : searcher.getNearestNonTextInlineElement();
                if (range && range.collapsed && textBeforeCursor === '' && !nearestInline) {
                    var tempBlock = cursorBlock === null || cursorBlock === void 0 ? void 0 : cursorBlock.nextElementSibling;
                    var nextBlock_1 = isList(tempBlock) ? tempBlock : tempBlock === null || tempBlock === void 0 ? void 0 : tempBlock.firstChild;
                    if (isList(nextBlock_1) &&
                        getTagOfNode(previousBlock_1) == getTagOfNode(nextBlock_1)) {
                        var element = cacheGetEventData(event, PREVIOUS_BLOCK_CACHE_KEY, function () { return previousBlock_1; });
                        var nextElement = cacheGetEventData(event, NEXT_BLOCK_CACHE_KEY, function () { return nextBlock_1; });
                        return !!element && !!nextElement;
                    }
                }
            }
        }
        return false;
    },
    handleEvent: function (event, editor) {
        editor.runAsync(function (editor) {
            var previousList = cacheGetEventData(event, PREVIOUS_BLOCK_CACHE_KEY, function () { return null; });
            var targetBlock = cacheGetEventData(event, NEXT_BLOCK_CACHE_KEY, function () { return null; });
            var rangeBeforeWriteBack = editor.getSelectionRange();
            if (previousList && targetBlock && rangeBeforeWriteBack) {
                var fvList = new VList(previousList);
                fvList.mergeVList(new VList(targetBlock));
                var span = editor.getDocument().createElement('span');
                span.id = 'restoreRange';
                rangeBeforeWriteBack.insertNode(span);
                fvList.writeBack();
                span = editor.queryElements('#restoreRange')[0];
                if (span.parentElement) {
                    editor.select(new Position(span, -3 /* After */));
                    span.parentElement.removeChild(span);
                }
            }
        });
    },
};
/**
 * @internal
 */
export var ListFeatures = {
    autoBullet: AutoBullet,
    indentWhenTab: IndentWhenTab,
    outdentWhenShiftTab: OutdentWhenShiftTab,
    outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,
    outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,
    mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,
    maintainListChain: MaintainListChain,
    maintainListChainWhenDelete: MaintainListChainWhenDelete,
    autoNumberingList: AutoNumberingList,
    autoBulletList: AutoBulletList,
    mergeListOnBackspaceAfterList: MergeListOnBackspaceAfterList,
    outdentWhenAltShiftLeft: OutdentWhenAltShiftLeft,
    indentWhenAltShiftRight: IndentWhenAltShiftRight,
};
function isList(element) {
    return (!!element &&
        (safeInstanceOf(element, 'HTMLOListElement') || safeInstanceOf(element, 'HTMLUListElement')));
}
//# sourceMappingURL=listFeatures.js.map