import { clearFormat } from 'roosterjs-editor-api';
import { cacheGetEventData, getTagOfNode, isNodeEmpty, safeInstanceOf, splitBalancedNodeRange, toArray, unwrap, wrap, } from 'roosterjs-editor-dom';
var QUOTE_TAG = 'BLOCKQUOTE';
var STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');
/**
 * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when
 * user press BACKSPACE on first and empty line of a BLOCKQUOTE
 */
var UnquoteWhenBackOnEmpty1stLine = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        var childOfQuote = cacheGetQuoteChild(event, editor);
        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;
    },
    handleEvent: splitQuote,
};
/**
 * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when
 * user press ENTER on an empty line of a BLOCKQUOTE
 */
var UnquoteWhenEnterOnEmptyLine = {
    keys: [13 /* ENTER */],
    shouldHandleEvent: function (event, editor) {
        var childOfQuote = cacheGetQuoteChild(event, editor);
        var shift = event.rawEvent.shiftKey;
        return !shift && childOfQuote && isNodeEmpty(childOfQuote);
    },
    handleEvent: function (event, editor) {
        return editor.addUndoSnapshot(function () { return splitQuote(event, editor); }, undefined /*changeSource*/, true /*canUndoByBackspace*/);
    },
};
function cacheGetQuoteChild(event, editor) {
    return cacheGetEventData(event, 'QUOTE_CHILD', function () {
        var quote = editor.getElementAtCursor(STRUCTURED_TAGS);
        if (quote && getTagOfNode(quote) == QUOTE_TAG) {
            var pos = editor.getFocusedPosition();
            var block = pos && editor.getBlockElementAtNode(pos.normalize().node);
            if (block) {
                var node = block.getStartNode() == quote
                    ? block.getStartNode()
                    : block.collapseToSingleElement();
                return isNodeEmpty(node) ? node : null;
            }
        }
        return null;
    });
}
function splitQuote(event, editor) {
    editor.addUndoSnapshot(function () {
        var childOfQuote = cacheGetQuoteChild(event, editor);
        if (!childOfQuote) {
            return;
        }
        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {
            childOfQuote = wrap(toArray(childOfQuote.childNodes));
        }
        var parent = splitBalancedNodeRange(childOfQuote);
        var shouldClearFormat = !!parent && isStyledBlockquote(parent);
        var newParent = parent && unwrap(parent);
        editor.select(childOfQuote, 0 /* Begin */);
        if (shouldClearFormat) {
            if (safeInstanceOf(newParent, 'HTMLLIElement')) {
                newParent.style.removeProperty('color');
            }
            clearFormat(editor);
        }
    });
    event.rawEvent.preventDefault();
}
var isStyledBlockquote = function (element) {
    if (element &&
        safeInstanceOf(element, 'HTMLQuoteElement') &&
        element.style.borderLeft &&
        element.style.borderColor &&
        element.style.paddingLeft &&
        element.style.color) {
        return true;
    }
    return false;
};
/**
 * @internal
 */
export var QuoteFeatures = {
    unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,
    unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,
};
//# sourceMappingURL=quoteFeatures.js.map