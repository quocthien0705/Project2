{"version":3,"file":"handleLineMerge.js","sourceRoot":"","sources":["../../../../../../packages/roosterjs-editor-plugins/lib/plugins/Paste/lineMerge/handleLineMerge.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    changeElementTag,\n    ContentTraverser,\n    findClosestElementAncestor,\n    getBlockElementAtNode,\n    getNextLeafSibling,\n    getPreviousLeafSibling,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Process pasted content, if there are multiple blocks that are not wrapped by a shared ancestor node,\n * change the tag of first and last node to be SPAN so that it will be merged into current block\n * @param root Root node of content to process\n */\nexport default function handleLineMerge(root: Node) {\n    const traverser = ContentTraverser.createBodyTraverser(root);\n    const blocks: { start: Node; end: Node }[] = [];\n\n    for (\n        let block = traverser?.currentBlockElement;\n        block;\n        block = traverser.getNextBlockElement()\n    ) {\n        blocks.push({\n            start: block.getStartNode(),\n            end: block.getEndNode(),\n        });\n    }\n\n    if (blocks.length > 0) {\n        const blocksLength = blocks.length - 1;\n        processBlock(blocks[0]);\n        processBlock(blocks[blocksLength]);\n        checkAndAddBr(root, blocks[0], true /*isFirst*/);\n        checkAndAddBr(root, blocks[blocksLength], false /*isFirst*/, blocks[0]);\n    }\n}\n\nfunction processBlock(block: { start: Node; end: Node }) {\n    const { start, end } = block;\n\n    if (start == end && getTagOfNode(start) == 'DIV') {\n        const node = changeElementTag(start as HTMLElement, 'SPAN') as Node;\n        block.start = node;\n        block.end = node;\n\n        if (node && node.lastChild && getTagOfNode(node.lastChild) == 'BR') {\n            node.removeChild(node.lastChild);\n        }\n    } else if (getTagOfNode(end) == 'BR') {\n        const node = end.ownerDocument?.createTextNode('');\n        if (node) {\n            end.parentNode?.insertBefore(node, end);\n            block.end = node;\n            end.parentNode?.removeChild(end);\n        }\n    }\n}\n\nfunction checkAndAddBr(\n    root: Node,\n    block: { start: Node; end: Node },\n    isFirst: boolean,\n    firstBlock?: { start: Node; end: Node }\n) {\n    const blockElement = getBlockElementAtNode(root, block.start);\n    const sibling = isFirst\n        ? getNextLeafSibling(root, block.end)\n        : getPreviousLeafSibling(root, block.start);\n\n    if (!sibling) {\n        return;\n    }\n\n    if (blockElement?.contains(sibling)) {\n        const br = block.start.ownerDocument?.createElement('br');\n        if (br) {\n            const blockToUse = isFirst ? block.end : block.start;\n            blockToUse.parentNode?.insertBefore(br, isFirst ? block.end.nextSibling : block.start);\n        }\n    } else if (\n        firstBlock &&\n        firstBlock.end == firstBlock.start &&\n        getTagOfNode(firstBlock.end) == 'SPAN'\n    ) {\n        // If the first block and the last block are Siblings, add a BR before so the only two\n        // lines that are being pasted are not merged.\n        const previousSibling = getPreviousLeafSibling(root, block.start);\n        if (\n            firstBlock.end.contains(previousSibling) &&\n            !findClosestElementAncestor(block.start, root, 'li')\n        ) {\n            const br = block.start.ownerDocument?.createElement('br');\n            if (br) {\n                block.start.parentNode?.insertBefore(br, block.start);\n            }\n        }\n    }\n}\n"]}