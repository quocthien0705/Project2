import { changeElementTag, ContentTraverser, findClosestElementAncestor, getBlockElementAtNode, getNextLeafSibling, getPreviousLeafSibling, getTagOfNode, } from 'roosterjs-editor-dom';
/**
 * @internal
 * Process pasted content, if there are multiple blocks that are not wrapped by a shared ancestor node,
 * change the tag of first and last node to be SPAN so that it will be merged into current block
 * @param root Root node of content to process
 */
export default function handleLineMerge(root) {
    var traverser = ContentTraverser.createBodyTraverser(root);
    var blocks = [];
    for (var block = traverser === null || traverser === void 0 ? void 0 : traverser.currentBlockElement; block; block = traverser.getNextBlockElement()) {
        blocks.push({
            start: block.getStartNode(),
            end: block.getEndNode(),
        });
    }
    if (blocks.length > 0) {
        var blocksLength = blocks.length - 1;
        processBlock(blocks[0]);
        processBlock(blocks[blocksLength]);
        checkAndAddBr(root, blocks[0], true /*isFirst*/);
        checkAndAddBr(root, blocks[blocksLength], false /*isFirst*/, blocks[0]);
    }
}
function processBlock(block) {
    var _a, _b, _c;
    var start = block.start, end = block.end;
    if (start == end && getTagOfNode(start) == 'DIV') {
        var node = changeElementTag(start, 'SPAN');
        block.start = node;
        block.end = node;
        if (node && node.lastChild && getTagOfNode(node.lastChild) == 'BR') {
            node.removeChild(node.lastChild);
        }
    }
    else if (getTagOfNode(end) == 'BR') {
        var node = (_a = end.ownerDocument) === null || _a === void 0 ? void 0 : _a.createTextNode('');
        if (node) {
            (_b = end.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(node, end);
            block.end = node;
            (_c = end.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(end);
        }
    }
}
function checkAndAddBr(root, block, isFirst, firstBlock) {
    var _a, _b, _c, _d;
    var blockElement = getBlockElementAtNode(root, block.start);
    var sibling = isFirst
        ? getNextLeafSibling(root, block.end)
        : getPreviousLeafSibling(root, block.start);
    if (!sibling) {
        return;
    }
    if (blockElement === null || blockElement === void 0 ? void 0 : blockElement.contains(sibling)) {
        var br = (_a = block.start.ownerDocument) === null || _a === void 0 ? void 0 : _a.createElement('br');
        if (br) {
            var blockToUse = isFirst ? block.end : block.start;
            (_b = blockToUse.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(br, isFirst ? block.end.nextSibling : block.start);
        }
    }
    else if (firstBlock &&
        firstBlock.end == firstBlock.start &&
        getTagOfNode(firstBlock.end) == 'SPAN') {
        // If the first block and the last block are Siblings, add a BR before so the only two
        // lines that are being pasted are not merged.
        var previousSibling = getPreviousLeafSibling(root, block.start);
        if (firstBlock.end.contains(previousSibling) &&
            !findClosestElementAncestor(block.start, root, 'li')) {
            var br = (_c = block.start.ownerDocument) === null || _c === void 0 ? void 0 : _c.createElement('br');
            if (br) {
                (_d = block.start.parentNode) === null || _d === void 0 ? void 0 : _d.insertBefore(br, block.start);
            }
        }
    }
}
//# sourceMappingURL=handleLineMerge.js.map