import normalizeTableSelection from '../utils/normalizeTableSelection';
import { clearState } from '../utils/clearState';
import { contains, getTagOfNode, safeInstanceOf, VTable } from 'roosterjs-editor-dom';
import { getCellAtCursor } from '../utils/getCellAtCursor';
import { getCellCoordinates } from '../utils/getCellCoordinates';
import { getTableAtCursor } from '../utils/getTableAtCursor';
import { prepareSelection } from '../utils/prepareSelection';
import { restoreSelection } from '../utils/restoreSelection';
import { selectTable } from '../utils/selectTable';
import { setData } from '../utils/setData';
import { TABLE_CELL_SELECTOR } from '../constants';
import { updateSelection } from '../utils/updateSelection';
var LEFT_CLICK = 1;
var RIGHT_CLICK = 3;
/**
 * @internal
 */
export function handleMouseDownEvent(event, state, editor) {
    var _a;
    var _b = event.rawEvent, which = _b.which, shiftKey = _b.shiftKey, target = _b.target, detail = _b.detail;
    var table = editor.getElementAtCursor('table', target, event);
    var tripleClick = detail >= 3;
    if (table && !table.isContentEditable) {
        return;
    }
    var td = editor.getElementAtCursor(TABLE_CELL_SELECTOR);
    if (which == RIGHT_CLICK && state.tableSelection && state.vTable && td) {
        //If the user is right clicking To open context menu
        var coord = getCellCoordinates(state.vTable, td);
        if (coord) {
            var _c = normalizeTableSelection(state.vTable) || {}, firstCell = _c.firstCell, lastCell = _c.lastCell;
            if (firstCell &&
                lastCell &&
                coord.y >= firstCell.y &&
                coord.y <= lastCell.y &&
                coord.x >= firstCell.x &&
                coord.x <= lastCell.x) {
                state.firstTarget = state.vTable.getCell(firstCell.y, firstCell.x).td;
                state.lastTarget = state.vTable.getCell(lastCell.y, lastCell.x).td;
                if (state.firstTarget && state.lastTarget) {
                    var selection = (_a = editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
                    selection === null || selection === void 0 ? void 0 : selection.setBaseAndExtent(state.firstTarget, 0, state.lastTarget, 0);
                    selectTable(editor, state);
                }
                return;
            }
        }
    }
    if (which == LEFT_CLICK) {
        if (!shiftKey && !tripleClick) {
            clearState(state, editor);
            if (getTableAtCursor(editor, event.rawEvent.target)) {
                var doc_1 = editor.getDocument() || document;
                var mouseUpListener_1 = getOnMouseUp(state);
                var mouseMoveListener_1 = onMouseMove(state, editor);
                doc_1.addEventListener('mouseup', mouseUpListener_1, true /*setCapture*/);
                doc_1.addEventListener('mousemove', mouseMoveListener_1, true /*setCapture*/);
                state.mouseMoveDisposer = function () {
                    doc_1.removeEventListener('mouseup', mouseUpListener_1, true /*setCapture*/);
                    doc_1.removeEventListener('mousemove', mouseMoveListener_1, true /*setCapture*/);
                };
                state.startedSelection = true;
            }
        }
        if (shiftKey || tripleClick) {
            editor.runAsync(function (editor) {
                var _a;
                var sel = (_a = editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
                var first = getCellAtCursor(editor, sel === null || sel === void 0 ? void 0 : sel.anchorNode);
                // Triple clicking a cell will select that cell only
                // Assign last the same as first to make sure we can select the cell
                var last = tripleClick ? first : getCellAtCursor(editor, sel === null || sel === void 0 ? void 0 : sel.focusNode);
                var firstTable = getTableAtCursor(editor, first);
                if (firstTable &&
                    safeInstanceOf(first, 'HTMLTableCellElement') &&
                    safeInstanceOf(last, 'HTMLTableCellElement')) {
                    state.vTable = new VTable(first);
                    var firstCord = getCellCoordinates(state.vTable, first);
                    var lastCord = getCellCoordinates(state.vTable, last);
                    if (!firstCord || !lastCord) {
                        return;
                    }
                    state.vTable.selection = {
                        firstCell: firstCord,
                        lastCell: lastCord,
                    };
                    state.firstTarget = first;
                    state.lastTarget = last;
                    selectTable(editor, state);
                    state.tableSelection = true;
                    state.firstTable = firstTable;
                    state.targetTable = firstTable;
                    updateSelection(editor, first, 0);
                }
            });
        }
    }
}
function getOnMouseUp(state) {
    return function () {
        removeMouseUpEventListener(state);
    };
}
function onMouseMove(state, editor) {
    return function (event) {
        if (!editor.contains(event.target)) {
            return;
        }
        //If already in table selection and the new target is contained in the last target cell, no need to
        //Apply selection styles again.
        if (state.tableSelection &&
            state.firstTarget &&
            contains(state.lastTarget, event.target, true)) {
            updateSelection(editor, state.firstTarget, 0);
            event.preventDefault();
            return;
        }
        if (getTagOfNode(event.target) == 'TABLE') {
            event.preventDefault();
            return;
        }
        setData(event.target, state, editor);
        // If there is a first target, but is not inside a table, no more actions to perform.
        if (state.firstTarget && !state.firstTable) {
            return;
        }
        //Ignore if
        // Is a DIV that only contains a Table
        // If the event target is not contained in the editor.
        if (state.lastTarget &&
            ((state.lastTarget.lastChild == state.lastTarget.firstChild &&
                getTagOfNode(state.lastTarget.lastChild) == 'TABLE' &&
                getTagOfNode(state.lastTarget) == 'DIV') ||
                !editor.contains(state.lastTarget))) {
            event.preventDefault();
            return;
        }
        prepareSelection(state, editor);
        var isNewTDContainingFirstTable = safeInstanceOf(state.lastTarget, 'HTMLTableCellElement')
            ? contains(state.lastTarget, state.firstTable)
            : false;
        if ((state.firstTable && state.firstTable == state.targetTable) ||
            isNewTDContainingFirstTable) {
            //When starting selection inside of a table and ends inside of the same table.
            selectionInsideTableMouseMove(event, state, editor);
        }
        else if (state.tableSelection) {
            restoreSelection(state, editor);
        }
        if (state.tableSelection && state.firstTarget) {
            updateSelection(editor, state.firstTarget, 0);
            event.preventDefault();
        }
    };
}
/**
 * @internal
 */
export function selectionInsideTableMouseMove(event, state, editor) {
    var _a;
    if (state.firstTarget &&
        state.firstTable &&
        state.lastTarget != state.firstTarget &&
        state.lastTarget) {
        updateSelection(editor, state.firstTarget, 0);
        if (state.firstTable != state.targetTable &&
            ((_a = state.targetTable) === null || _a === void 0 ? void 0 : _a.contains(state.firstTable))) {
            //If selection started in a table that is inside of another table and moves to parent table
            //Make the firstTarget the TD of the parent table.
            state.firstTarget = editor.getElementAtCursor(TABLE_CELL_SELECTOR, state.lastTarget);
        }
        if (state.firstTable && state.firstTarget) {
            state.tableSelection = true;
            state.vTable = state.vTable || new VTable(state.firstTable);
            var firstCell = getCellCoordinates(state.vTable, state.firstTarget);
            var lastCell = getCellCoordinates(state.vTable, state.lastTarget);
            if (!firstCell || !lastCell) {
                return;
            }
            state.vTable.selection = {
                firstCell: firstCell,
                lastCell: lastCell,
            };
            selectTable(editor, state);
        }
        event.preventDefault();
    }
    else if (state.lastTarget == state.firstTarget &&
        state.tableSelection &&
        state.firstTable &&
        state.firstTarget) {
        state.vTable = new VTable(state.firstTable);
        var cell = getCellCoordinates(state.vTable, state.firstTarget);
        if (cell) {
            state.vTable.selection = {
                firstCell: cell,
                lastCell: cell,
            };
        }
        selectTable(editor, state);
    }
}
function removeMouseUpEventListener(state) {
    var _a;
    if (state.startedSelection) {
        state.startedSelection = false;
        (_a = state.mouseMoveDisposer) === null || _a === void 0 ? void 0 : _a.call(state);
    }
}
//# sourceMappingURL=handleMouseDownEvent.js.map