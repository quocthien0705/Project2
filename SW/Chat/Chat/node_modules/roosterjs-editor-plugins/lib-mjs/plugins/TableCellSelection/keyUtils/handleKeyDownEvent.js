import { getCellAtCursor } from '../utils/getCellAtCursor';
import { getCellCoordinates } from '../utils/getCellCoordinates';
import { isAfter } from '../utils/isAfter';
import { prepareSelection } from '../utils/prepareSelection';
import { selectTable } from '../utils/selectTable';
import { setData } from '../utils/setData';
import { TABLE_CELL_SELECTOR } from '../constants';
import { updateSelection } from '../utils/updateSelection';
import { contains, createRange, isCtrlOrMetaPressed, Position, safeInstanceOf, VTable, } from 'roosterjs-editor-dom';
/**
 * @internal
 */
export function handleKeyDownEvent(event, state, editor) {
    var _a = event.rawEvent, shiftKey = _a.shiftKey, ctrlKey = _a.ctrlKey, metaKey = _a.metaKey, which = _a.which, defaultPrevented = _a.defaultPrevented;
    if ((shiftKey && (ctrlKey || metaKey)) || which == 16 /* SHIFT */ || defaultPrevented) {
        state.preventKeyUp = defaultPrevented;
        return;
    }
    var range = editor.getSelectionRangeEx();
    if (shiftKey) {
        if (!state.firstTarget) {
            var pos = editor.getFocusedPosition();
            var cell = pos && getCellAtCursor(editor, pos.node);
            state.firstTarget = cell;
        }
        //If first target is not a table cell, we should ignore this plugin
        if (!safeInstanceOf(state.firstTarget, 'HTMLTableCellElement')) {
            return;
        }
        editor.runAsync(function (editor) {
            var pos = editor.getFocusedPosition();
            var newTarget = state.tableSelection ? state.lastTarget : pos === null || pos === void 0 ? void 0 : pos.node;
            if (newTarget) {
                setData(newTarget, state, editor);
            }
            if (state.firstTable == state.targetTable) {
                if (!shouldConvertToTableSelection(state, editor) && !state.tableSelection) {
                    return;
                }
                //When selection start and end is inside of the same table
                handleKeySelectionInsideTable(event, state, editor);
            }
            else if (state.tableSelection) {
                if (state.firstTable) {
                    editor.select(state.firstTable, null /* coordinates */);
                }
                state.tableSelection = false;
            }
        });
    }
    else if ((range === null || range === void 0 ? void 0 : range.type) == 1 /* TableSelection */ &&
        (!isCtrlOrMetaPressed(event.rawEvent) || which == 36 /* HOME */ || which == 35 /* END */)) {
        // Select all content in the first cell
        var row = range.ranges[0];
        var firstCell = row.startContainer.childNodes[row.startOffset];
        var children = firstCell.childNodes;
        var contentRange = createRange(children[0], children[children.length - 1]);
        editor.select(contentRange);
    }
}
/**
 * @internal
 */
function handleKeySelectionInsideTable(event, state, editor) {
    var _a, _b;
    state.firstTarget = getCellAtCursor(editor, state.firstTarget);
    state.lastTarget = getCellAtCursor(editor, state.lastTarget);
    updateSelection(editor, state.firstTarget, 0);
    state.vTable = state.vTable || new VTable(state.firstTable);
    var firstCell = getCellCoordinates(state.vTable, state.firstTarget);
    var lastCell = getNextTD(event, editor, state);
    if (!firstCell || !lastCell) {
        return;
    }
    state.vTable.selection = {
        firstCell: firstCell,
        lastCell: lastCell,
    };
    var selection = state.vTable.selection;
    if (!selection.lastCell ||
        (state.vTable.cells && selection.lastCell.y > state.vTable.cells.length - 1) ||
        selection.lastCell.y == -1) {
        //When selection is moving from inside of a table to outside
        state.lastTarget = editor.getElementAtCursor(TABLE_CELL_SELECTOR + ',div', (_a = state.firstTable) !== null && _a !== void 0 ? _a : undefined);
        if (safeInstanceOf(state.lastTarget, 'HTMLTableCellElement')) {
            prepareSelection(state, editor);
        }
        else {
            var position = state.targetTable &&
                new Position(state.targetTable, selection.lastCell.y == null || selection.lastCell.y == -1
                    ? -2 /* Before */
                    : -3 /* After */);
            var sel = (_b = editor.getDocument().defaultView) === null || _b === void 0 ? void 0 : _b.getSelection();
            var _c = sel || {}, anchorNode = _c.anchorNode, anchorOffset = _c.anchorOffset;
            if (sel &&
                anchorNode &&
                anchorOffset != undefined &&
                anchorOffset != null &&
                position) {
                editor.select(sel.getRangeAt(0));
                sel.setBaseAndExtent(anchorNode, anchorOffset, position.node, position.offset);
                state.lastTarget = position.node;
                event.rawEvent.preventDefault();
                return;
            }
        }
    }
    selectTable(editor, state);
    var isBeginAboveEnd = isAfter(state.firstTarget, state.lastTarget);
    if (state.lastTarget) {
        var targetPosition = new Position(state.lastTarget, isBeginAboveEnd ? 0 /* Begin */ : -1 /* End */);
        updateSelection(editor, targetPosition.node, targetPosition.offset);
    }
    state.tableSelection = true;
    event.rawEvent.preventDefault();
}
function getNextTD(event, editor, state) {
    var _a;
    state.lastTarget =
        state.lastTarget && editor.getElementAtCursor(TABLE_CELL_SELECTOR, state.lastTarget);
    if (safeInstanceOf(state.lastTarget, 'HTMLTableCellElement') && ((_a = state.vTable) === null || _a === void 0 ? void 0 : _a.cells)) {
        var coordinates = getCellCoordinates(state.vTable, state.lastTarget);
        if (state.tableSelection && coordinates) {
            switch (event.rawEvent.which) {
                case 39 /* RIGHT */:
                    coordinates.x += state.lastTarget.colSpan;
                    if (state.vTable.cells[coordinates.y][coordinates.x] == null) {
                        coordinates.x = state.vTable.cells[coordinates.y].length - 1;
                        coordinates.y++;
                    }
                    break;
                case 37 /* LEFT */:
                    if (coordinates.x == 0) {
                        coordinates.y--;
                    }
                    else {
                        coordinates.x--;
                    }
                    break;
                case 38 /* UP */:
                    coordinates.y--;
                    break;
                case 40 /* DOWN */:
                    coordinates.y++;
                    break;
            }
        }
        if (coordinates && coordinates.y >= 0 && coordinates.x >= 0) {
            state.lastTarget = state.vTable.getTd(coordinates.y, coordinates.x);
        }
        return coordinates;
    }
    return undefined;
}
function shouldConvertToTableSelection(state, editor) {
    if (!state.firstTable || !editor) {
        return false;
    }
    var regions = editor.getSelectedRegions();
    if (regions.length == 1) {
        return false;
    }
    var result = true;
    regions.forEach(function (value) {
        if (!contains(state.firstTable, value.rootNode)) {
            result = false;
        }
    });
    return result;
}
//# sourceMappingURL=handleKeyDownEvent.js.map