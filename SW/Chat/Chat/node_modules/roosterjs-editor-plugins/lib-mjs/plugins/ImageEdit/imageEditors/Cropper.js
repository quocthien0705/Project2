import { __assign, __read } from "tslib";
import { rotateCoordinate } from './Resizer';
import { CROP_HANDLE_SIZE, CROP_HANDLE_WIDTH, ROTATION, XS_CROP, YS_CROP, } from '../constants/constants';
/**
 * @internal
 * Crop handle for DragAndDropHelper
 */
export var Cropper = {
    onDragStart: function (_a) {
        var editInfo = _a.editInfo;
        return (__assign({}, editInfo));
    },
    onDragging: function (_a, e, base, dx, dy) {
        var _b;
        var editInfo = _a.editInfo, x = _a.x, y = _a.y, options = _a.options;
        _b = __read(rotateCoordinate(dx, dy, editInfo.angleRad), 2), dx = _b[0], dy = _b[1];
        var widthPx = editInfo.widthPx, heightPx = editInfo.heightPx, leftPercent = editInfo.leftPercent, rightPercent = editInfo.rightPercent, topPercent = editInfo.topPercent, bottomPercent = editInfo.bottomPercent;
        var minWidth = options.minWidth, minHeight = options.minHeight;
        var widthPercent = 1 - leftPercent - rightPercent;
        var heightPercent = 1 - topPercent - bottomPercent;
        if (widthPercent > 0 &&
            heightPercent > 0 &&
            minWidth !== undefined &&
            minHeight !== undefined) {
            var fullWidth = widthPx / widthPercent;
            var fullHeight = heightPx / heightPercent;
            var newLeft = x != 'e'
                ? crop(base.leftPercent, dx, fullWidth, rightPercent, minWidth)
                : leftPercent;
            var newRight = x != 'w'
                ? crop(base.rightPercent, -dx, fullWidth, leftPercent, minWidth)
                : rightPercent;
            var newTop = y != 's'
                ? crop(base.topPercent, dy, fullHeight, bottomPercent, minHeight)
                : topPercent;
            var newBottom = y != 'n'
                ? crop(base.bottomPercent, -dy, fullHeight, topPercent, minHeight)
                : bottomPercent;
            editInfo.leftPercent = newLeft;
            editInfo.rightPercent = newRight;
            editInfo.topPercent = newTop;
            editInfo.bottomPercent = newBottom;
            editInfo.widthPx = fullWidth * (1 - newLeft - newRight);
            editInfo.heightPx = fullHeight * (1 - newTop - newBottom);
            return true;
        }
        else {
            return false;
        }
    },
};
function crop(basePercentage, deltaValue, fullValue, currentPercentage, minValue) {
    var maxValue = fullValue * (1 - currentPercentage) - minValue;
    var newValue = fullValue * basePercentage + deltaValue;
    var validValue = Math.max(Math.min(newValue, maxValue), 0);
    return validValue / fullValue;
}
/**
 * @internal
 * Get HTML for crop elements, including 4 overlays (to show dark shadow), 1 container and 4 crop handles
 */
export function getCropHTML() {
    var overlayHTML = {
        tag: 'div',
        style: 'position:absolute;background-color:rgb(0,0,0,0.5);pointer-events:none',
        className: "r_cropO" /* CropOverlay */,
    };
    var containerHTML = {
        tag: 'div',
        style: 'position:absolute;overflow:hidden',
        className: "r_cropC" /* CropContainer */,
        children: [],
    };
    if (containerHTML) {
        XS_CROP.forEach(function (x) {
            return YS_CROP.forEach(function (y) { var _a; return (_a = containerHTML.children) === null || _a === void 0 ? void 0 : _a.push(getCropHTMLInternal(x, y)); });
        });
    }
    return [containerHTML, overlayHTML, overlayHTML, overlayHTML, overlayHTML];
}
function getCropHTMLInternal(x, y) {
    var leftOrRight = x == 'w' ? 'left' : 'right';
    var topOrBottom = y == 'n' ? 'top' : 'bottom';
    var rotation = ROTATION[y + x];
    return {
        tag: 'div',
        className: "r_cropH" /* CropHandle */,
        style: "position:absolute;pointer-events:auto;cursor:" + y + x + "-resize;" + leftOrRight + ":0;" + topOrBottom + ":0;width:" + CROP_HANDLE_SIZE + "px;height:" + CROP_HANDLE_SIZE + "px;transform:rotate(" + rotation + "deg)",
        dataset: { x: x, y: y },
        children: getCropHandleHTML(),
    };
}
function getCropHandleHTML() {
    var result = [];
    [0, 1].forEach(function (layer) {
        return [0, 1].forEach(function (dir) {
            result.push(getCropHandleHTMLInternal(layer, dir));
        });
    });
    return result;
}
function getCropHandleHTMLInternal(layer, dir) {
    var position = dir == 0
        ? "right:" + layer + "px;height:" + (CROP_HANDLE_WIDTH - layer * 2) + "px;"
        : "top:" + layer + "px;width:" + (CROP_HANDLE_WIDTH - layer * 2) + "px;";
    var bgColor = layer == 0 ? 'white' : 'black';
    return {
        tag: 'div',
        style: "position:absolute;left:" + layer + "px;bottom:" + layer + "px;" + position + ";background-color:" + bgColor,
    };
}
//# sourceMappingURL=Cropper.js.map