import { __assign } from "tslib";
import { DEFAULT_ROTATE_HANDLE_HEIGHT, DEG_PER_RAD, RESIZE_HANDLE_MARGIN, ROTATE_GAP, ROTATE_HANDLE_TOP, ROTATE_ICON_MARGIN, ROTATE_SIZE, ROTATE_WIDTH, } from '../constants/constants';
/**
 * @internal
 * The rotate drag and drop handler
 */
export var Rotator = {
    onDragStart: function (_a) {
        var editInfo = _a.editInfo;
        return (__assign({}, editInfo));
    },
    onDragging: function (_a, e, base, deltaX, deltaY) {
        var editInfo = _a.editInfo, options = _a.options;
        var distance = editInfo.heightPx / 2 + DEFAULT_ROTATE_HANDLE_HEIGHT;
        var newX = distance * Math.sin(base.angleRad) + deltaX;
        var newY = distance * Math.cos(base.angleRad) - deltaY;
        var angleInRad = Math.atan2(newX, newY);
        if (!e.altKey && options && options.minRotateDeg !== undefined) {
            var angleInDeg = angleInRad * DEG_PER_RAD;
            var adjustedAngleInDeg = Math.round(angleInDeg / options.minRotateDeg) * options.minRotateDeg;
            angleInRad = adjustedAngleInDeg / DEG_PER_RAD;
        }
        if (editInfo.angleRad != angleInRad) {
            editInfo.angleRad = angleInRad;
            return true;
        }
        else {
            return false;
        }
    },
};
/**
 * @internal
 * Move rotate handle. When image is very close to the border of editor, rotate handle may not be visible.
 * Fix it by reduce the distance from image to rotate handle
 */
export function updateRotateHandleState(editorRect, angleRad, wrapper, rotateCenter, rotateHandle, isSmallImage) {
    if (isSmallImage) {
        rotateCenter.style.display = 'none';
        rotateHandle.style.display = 'none';
        return;
    }
    else {
        rotateCenter.style.display = '';
        rotateHandle.style.display = '';
        var rotateCenterRect = rotateCenter.getBoundingClientRect();
        var wrapperRect = wrapper.getBoundingClientRect();
        var ROTATOR_HEIGHT = ROTATE_SIZE + ROTATE_GAP + RESIZE_HANDLE_MARGIN;
        if (rotateCenterRect && wrapperRect) {
            var adjustedDistance = Number.MAX_SAFE_INTEGER;
            var angle = angleRad * DEG_PER_RAD;
            if (angle < 45 && angle > -45 && wrapperRect.top - editorRect.top < ROTATOR_HEIGHT) {
                var top_1 = rotateCenterRect.top - editorRect.top;
                adjustedDistance = top_1;
            }
            else if (angle <= -80 &&
                angle >= -100 &&
                wrapperRect.left - editorRect.left < ROTATOR_HEIGHT) {
                var left = rotateCenterRect.left - editorRect.left;
                adjustedDistance = left;
            }
            else if (angle >= 80 &&
                angle <= 100 &&
                editorRect.right - wrapperRect.right < ROTATOR_HEIGHT) {
                var right = rotateCenterRect.right - editorRect.right;
                adjustedDistance = Math.min(editorRect.right - wrapperRect.right, right);
            }
            else if ((angle <= -160 || angle >= 160) &&
                editorRect.bottom - wrapperRect.bottom < ROTATOR_HEIGHT) {
                var bottom = rotateCenterRect.bottom - editorRect.bottom;
                adjustedDistance = Math.min(editorRect.bottom - wrapperRect.bottom, bottom);
            }
            var rotateGap = Math.max(Math.min(ROTATE_GAP, adjustedDistance), 0);
            var rotateTop = Math.max(Math.min(ROTATE_SIZE, adjustedDistance - rotateGap), 0);
            rotateCenter.style.top = -rotateGap - RESIZE_HANDLE_MARGIN + 'px';
            rotateCenter.style.height = rotateGap + 'px';
            rotateHandle.style.top = -rotateTop + 'px';
        }
    }
}
/**
 * @internal
 * Get HTML for rotate elements, including the rotate handle with icon, and a line between the handle and the image
 */
export function getRotateHTML(_a) {
    var borderColor = _a.borderColor, rotateHandleBackColor = _a.rotateHandleBackColor;
    var handleLeft = ROTATE_SIZE / 2;
    return [
        {
            tag: 'div',
            className: "r_rotateC" /* RotateCenter */,
            style: "position:absolute;left:50%;width:1px;background-color:" + borderColor + ";top:" + -ROTATE_HANDLE_TOP + "px;height:" + ROTATE_GAP + "px;margin-left:" + -ROTATE_WIDTH + "px;",
            children: [
                {
                    tag: 'div',
                    className: "r_rotateH" /* RotateHandle */,
                    style: "position:absolute;background-color:" + rotateHandleBackColor + ";border:solid 1px " + borderColor + ";border-radius:50%;width:" + ROTATE_SIZE + "px;height:" + ROTATE_SIZE + "px;left:-" + (handleLeft + ROTATE_WIDTH) + "px;cursor:move;top:" + -ROTATE_SIZE + "px;line-height: 0px;",
                    children: [getRotateIconHTML(borderColor)],
                },
            ],
        },
    ];
}
function getRotateIconHTML(borderColor) {
    var _a;
    return {
        tag: 'svg',
        namespace: 'http://www.w3.org/2000/svg',
        style: "width:16px;height:16px;margin: " + ROTATE_ICON_MARGIN + "px " + ROTATE_ICON_MARGIN + "px",
        children: [
            {
                tag: 'path',
                namespace: 'http://www.w3.org/2000/svg',
                attributes: (_a = {
                        d: 'M 10.5,10.0 A 3.8,3.8 0 1 1 6.7,6.3',
                        transform: 'matrix(1.1 1.1 -1.1 1.1 11.6 -10.8)'
                    },
                    _a['fill-opacity'] = '0',
                    _a.stroke = borderColor,
                    _a),
            },
            {
                tag: 'path',
                namespace: 'http://www.w3.org/2000/svg',
                attributes: {
                    d: 'M12.0 3.648l.884-.884.53 2.298-2.298-.53z',
                    stroke: borderColor,
                },
            },
        ],
    };
}
//# sourceMappingURL=Rotator.js.map