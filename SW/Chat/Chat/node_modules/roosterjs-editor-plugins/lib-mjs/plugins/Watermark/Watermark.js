import { applyFormat, getEntitySelector, getTagOfNode } from 'roosterjs-editor-dom';
import { insertEntity } from 'roosterjs-editor-api';
var ENTITY_TYPE = 'WATERMARK_WRAPPER';
/**
 * A watermark plugin to manage watermark string for roosterjs
 */
var Watermark = /** @class */ (function () {
    /**
     * Create an instance of Watermark plugin
     * @param watermark The watermark string
     */
    function Watermark(watermark, format, customClass) {
        var _this = this;
        this.watermark = watermark;
        this.customClass = customClass;
        this.editor = null;
        this.disposer = null;
        this.showHideWatermark = function () {
            if (!_this.editor) {
                return;
            }
            var hasFocus = _this.editor.hasFocus();
            var watermarks = _this.editor.queryElements(getEntitySelector(ENTITY_TYPE));
            var isShowing = watermarks.length > 0;
            if (hasFocus && isShowing) {
                watermarks.forEach(_this.removeWatermark);
                _this.editor.focus();
            }
            else if (!hasFocus && !isShowing && _this.editor.isEmpty()) {
                var newEntity = insertEntity(_this.editor, ENTITY_TYPE, _this.editor.getDocument().createTextNode(_this.watermark), false /*isBlock*/, false /*isReadonly*/, 0 /* Begin */);
                if (_this.customClass) {
                    newEntity.wrapper.classList.add(_this.customClass);
                }
            }
        };
        this.removeWatermark = function (wrapper) {
            var _a;
            var parentNode = wrapper.parentNode;
            parentNode === null || parentNode === void 0 ? void 0 : parentNode.removeChild(wrapper);
            // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line
            if (parentNode &&
                ((_a = _this.editor) === null || _a === void 0 ? void 0 : _a.contains(parentNode)) &&
                getTagOfNode(parentNode) == 'DIV' &&
                !parentNode.firstChild) {
                parentNode.appendChild(_this.editor.getDocument().createElement('BR'));
            }
        };
        this.format = format || {
            fontSize: '14px',
            textColors: {
                lightModeColor: '#AAAAAA',
                darkModeColor: '#6B6B6B',
            },
        };
    }
    /**
     * Updates the watermark text.
     * @param watermark - The new watermark text.
     */
    Watermark.prototype.updateWatermark = function (watermark) {
        this.watermark = watermark;
        if (!this.editor) {
            return;
        }
        var watermarks = this.editor.queryElements(getEntitySelector(ENTITY_TYPE));
        var isShowing = watermarks.length > 0;
        // re-render watermark only if it's already displayed
        if (isShowing) {
            // hide watermark
            var watermarks_1 = this.editor.queryElements(getEntitySelector(ENTITY_TYPE));
            watermarks_1.forEach(this.removeWatermark);
            // show watermark
            this.showHideWatermark();
        }
    };
    /**
     * Get a friendly name of  this plugin
     */
    Watermark.prototype.getName = function () {
        return 'Watermark';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    Watermark.prototype.initialize = function (editor) {
        this.editor = editor;
        this.disposer = this.editor.addDomEventHandler({
            focus: this.showHideWatermark,
            blur: this.showHideWatermark,
        });
    };
    /**
     * Dispose this plugin
     */
    Watermark.prototype.dispose = function () {
        var _a;
        (_a = this.disposer) === null || _a === void 0 ? void 0 : _a.call(this);
        this.disposer = null;
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    Watermark.prototype.onPluginEvent = function (event) {
        var _a;
        if (event.eventType == 11 /* EditorReady */ ||
            (event.eventType == 7 /* ContentChanged */ &&
                ((_a = event.data) === null || _a === void 0 ? void 0 : _a.type) != ENTITY_TYPE)) {
            this.showHideWatermark();
        }
        else if (event.eventType == 15 /* EntityOperation */ &&
            event.entity.type == ENTITY_TYPE &&
            this.editor) {
            var operation = event.operation, wrapper = event.entity.wrapper;
            if (operation == 8 /* ReplaceTemporaryContent */) {
                this.removeWatermark(wrapper);
            }
            else if (event.operation == 0 /* NewEntity */) {
                applyFormat(wrapper, this.format, this.editor.isDarkMode(), this.editor.getDarkColorHandler());
                wrapper.spellcheck = false;
            }
        }
    };
    return Watermark;
}());
export default Watermark;
//# sourceMappingURL=Watermark.js.map