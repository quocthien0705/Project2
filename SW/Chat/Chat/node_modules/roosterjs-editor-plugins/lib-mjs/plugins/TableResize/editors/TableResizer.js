import DragAndDropHelper from '../../../pluginUtils/DragAndDropHelper';
import { createElement, getComputedStyle, normalizeRect, safeInstanceOf, VTable, } from 'roosterjs-editor-dom';
var TABLE_RESIZER_LENGTH = 12;
var MIN_CELL_WIDTH = 30;
var MIN_CELL_HEIGHT = 20;
/**
 * @internal
 */
export default function createTableResizer(table, editor, onStart, onEnd, onShowHelperElement, contentDiv, anchorContainer) {
    var rect = normalizeRect(table.getBoundingClientRect());
    if (!isTableBottomVisible(editor, rect, contentDiv)) {
        return null;
    }
    var document = table.ownerDocument;
    var isRTL = getComputedStyle(table, 'direction') == 'rtl';
    var zoomScale = editor.getZoomScale();
    var createElementData = {
        tag: 'div',
        style: "position: fixed; cursor: " + (isRTL ? 'ne' : 'nw') + "-resize; user-select: none; border: 1px solid #808080",
    };
    onShowHelperElement === null || onShowHelperElement === void 0 ? void 0 : onShowHelperElement(createElementData, 'TableResizer', table);
    var div = createElement(createElementData, document);
    div.style.width = TABLE_RESIZER_LENGTH + "px";
    div.style.height = TABLE_RESIZER_LENGTH + "px";
    (anchorContainer || document.body).appendChild(div);
    var context = {
        isRTL: isRTL,
        table: table,
        zoomScale: zoomScale,
        onStart: onStart,
        onEnd: onEnd,
        div: div,
        editor: editor,
        contentDiv: contentDiv,
    };
    setDivPosition(context, div);
    var featureHandler = new DragAndDropHelper(div, context, hideResizer, // Resizer is hidden while dragging only
    {
        onDragStart: onDragStart,
        onDragging: onDragging,
        onDragEnd: onDragEnd,
    }, zoomScale);
    return { node: table, div: div, featureHandler: featureHandler };
}
function onDragStart(context) {
    context.onStart();
    return {
        originalRect: context.table.getBoundingClientRect(),
        vTable: new VTable(context.table, true /*normalizeTable*/, context.zoomScale),
    };
}
function onDragging(context, event, initValue, deltaX, deltaY) {
    var _a, _b;
    var isRTL = context.isRTL, zoomScale = context.zoomScale;
    var originalRect = initValue.originalRect, vTable = initValue.vTable;
    var ratioX = 1.0 + (deltaX / originalRect.width) * zoomScale * (isRTL ? -1 : 1);
    var ratioY = 1.0 + (deltaY / originalRect.height) * zoomScale;
    var shouldResizeX = Math.abs(ratioX - 1.0) > 1e-3;
    var shouldResizeY = Math.abs(ratioY - 1.0) > 1e-3;
    if (vTable.cells && (shouldResizeX || shouldResizeY)) {
        for (var i = 0; i < vTable.cells.length; i++) {
            for (var j = 0; j < vTable.cells[i].length; j++) {
                var cell = vTable.cells[i][j];
                if (cell.td) {
                    if (shouldResizeX) {
                        // the width of some external table is fixed, we need to make it resizable
                        vTable.table.style.setProperty('width', null);
                        var newWidth = (((_a = cell.width) !== null && _a !== void 0 ? _a : 0) * ratioX) / zoomScale;
                        cell.td.style.boxSizing = 'border-box';
                        if (newWidth >= MIN_CELL_WIDTH) {
                            cell.td.style.wordBreak = 'break-word';
                            cell.td.style.whiteSpace = 'normal';
                            cell.td.style.width = newWidth + "px";
                        }
                    }
                    if (shouldResizeY) {
                        // the height of some external table is fixed, we need to make it resizable
                        vTable.table.style.setProperty('height', null);
                        if (j == 0) {
                            var newHeight = (((_b = cell.height) !== null && _b !== void 0 ? _b : 0) * ratioY) / zoomScale;
                            if (newHeight >= MIN_CELL_HEIGHT) {
                                cell.td.style.height = newHeight + "px";
                            }
                        }
                        else {
                            cell.td.style.setProperty('height', null);
                        }
                    }
                }
            }
        }
        // To avoid apply format styles when the table is being resizing, the skipApplyFormat is set to true.
        vTable.writeBack(true /**skipApplyFormat*/);
        return true;
    }
    else {
        return false;
    }
}
function onDragEnd(context, event, initValue) {
    if (isTableBottomVisible(context.editor, normalizeRect(context.table.getBoundingClientRect()), context.contentDiv)) {
        context.div.style.visibility = 'visible';
        setDivPosition(context, context.div);
    }
    context.onEnd();
    return false;
}
function setDivPosition(context, trigger) {
    var table = context.table, isRTL = context.isRTL;
    var rect = normalizeRect(table.getBoundingClientRect());
    if (rect) {
        trigger.style.top = rect.bottom + "px";
        trigger.style.left = isRTL
            ? rect.left - TABLE_RESIZER_LENGTH - 2 + "px"
            : rect.right + "px";
    }
}
function hideResizer(context, trigger) {
    trigger.style.visibility = 'hidden';
}
function isTableBottomVisible(editor, rect, contentDiv) {
    var visibleViewport = editor.getVisibleViewport();
    if (contentDiv && safeInstanceOf(contentDiv, 'HTMLElement') && visibleViewport && rect) {
        var containerRect = normalizeRect(contentDiv.getBoundingClientRect());
        return (!!containerRect &&
            containerRect.bottom >= rect.bottom &&
            visibleViewport.bottom >= rect.bottom);
    }
    return true;
}
//# sourceMappingURL=TableResizer.js.map