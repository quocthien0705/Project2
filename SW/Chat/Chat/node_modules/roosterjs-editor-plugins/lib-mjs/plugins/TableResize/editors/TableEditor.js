import createCellResizer from './CellResizer';
import createTableInserter from './TableInserter';
import createTableResizer from './TableResizer';
import createTableSelector from './TableSelector';
import { disposeTableEditFeature } from './TableEditorFeature';
import { contains, getComputedStyle, normalizeRect, Position, safeInstanceOf, VTable, } from 'roosterjs-editor-dom';
var INSERTER_HOVER_OFFSET = 6;
var TOP_OR_SIDE;
(function (TOP_OR_SIDE) {
    TOP_OR_SIDE[TOP_OR_SIDE["top"] = 0] = "top";
    TOP_OR_SIDE[TOP_OR_SIDE["side"] = 1] = "side";
})(TOP_OR_SIDE || (TOP_OR_SIDE = {}));
/**
 * @internal
 *
 * A table has 6 hot areas to be resized/edited (take LTR example):
 *
 *   [6]  [                ]
 *       +[      1         ]+--------------------+
 *       |[                ]|                    |
 *      [ ]               [ ]                    |
 *      [ ]               [ ]                    |
 *      [2]               [3]                    |
 *      [ ]               [ ]                    |
 *      [ ][       4       ]|                    |
 *       +------------------+--------------------+
 *       |                  |                    |
 *       |                  |                    |
 *       |                  |                    |
 *       +------------------+--------------------+
 *                                                [5]
 *
 * 1 - Hover area to show insert column button
 * 2 - Hover area to show insert row button
 * 3 - Hover area to show vertical resizing bar
 * 4 - Hover area to show horizontal resizing bar
 * 5 - Hover area to show whole table resize button
 * 6 - Hover area to show whole table selector button
 *
 * When set a different current table or change current TD, we need to update these areas
 */
var TableEditor = /** @class */ (function () {
    function TableEditor(editor, table, onChanged, onShowHelperElement, anchorContainer, contentDiv) {
        var _this = this;
        this.editor = editor;
        this.table = table;
        this.onChanged = onChanged;
        this.onShowHelperElement = onShowHelperElement;
        this.anchorContainer = anchorContainer;
        this.contentDiv = contentDiv;
        // 1, 2 - Insert a column or a row
        this.horizontalInserter = null;
        this.verticalInserter = null;
        // 3, 4 - Resize a column or a row from a cell
        this.horizontalResizer = null;
        this.verticalResizer = null;
        // 5 - Resize whole table
        this.tableResizer = null;
        // 6 - Select whole table
        this.tableSelector = null;
        this.start = null;
        this.end = null;
        this.onFinishEditing = function () {
            _this.editor.focus();
            if (_this.start && _this.end) {
                _this.editor.select(_this.start, _this.end);
            }
            _this.editor.addUndoSnapshot(function () { }, "Format" /* Format */); // Pass in an empty callback to make sure ContentChangedEvent is triggered
            _this.onChanged();
            _this.isCurrentlyEditing = false;
            return false;
        };
        this.onStartTableResize = function () {
            _this.isCurrentlyEditing = true;
            _this.onStartResize();
        };
        this.onStartCellResize = function () {
            _this.isCurrentlyEditing = true;
            _this.disposeTableResizer();
            _this.onStartResize();
        };
        this.onInserted = function (table) {
            _this.editor.transformToDarkColor(table);
            _this.disposeTableResizer();
            _this.onFinishEditing();
        };
        /**
         * Public only for testing purposes
         * @param table the table to select
         */
        this.onSelect = function (table) {
            _this.editor.focus();
            if (table) {
                var vTable = new VTable(table);
                if (vTable.cells) {
                    var rows = vTable.cells.length - 1;
                    var lastCellIndex_1 = 0;
                    vTable.cells[rows].forEach(function (cell, index) {
                        lastCellIndex_1 = index;
                    });
                    var selection = {
                        firstCell: {
                            x: 0,
                            y: 0,
                        },
                        lastCell: {
                            y: rows,
                            x: lastCellIndex_1,
                        },
                    };
                    _this.editor.select(table, selection);
                }
            }
        };
        this.getOnMouseOut = function (feature) {
            return function (ev) {
                if (feature &&
                    ev.relatedTarget != feature &&
                    safeInstanceOf(_this.contentDiv, 'HTMLElement') &&
                    safeInstanceOf(ev.relatedTarget, 'HTMLElement') &&
                    !contains(_this.contentDiv, ev.relatedTarget, true /* treatSameNodeAsContain */)) {
                    _this.dispose();
                }
            };
        };
        this.isRTL = getComputedStyle(table, 'direction') == 'rtl';
        this.setEditorFeatures();
        this.isCurrentlyEditing = false;
    }
    TableEditor.prototype.dispose = function () {
        this.disposeTableResizer();
        this.disposeCellResizers();
        this.disposeTableInserter();
        this.disposeTableSelector();
    };
    TableEditor.prototype.isEditing = function () {
        return this.isCurrentlyEditing;
    };
    TableEditor.prototype.isOwnedElement = function (node) {
        return [
            this.tableResizer,
            this.tableSelector,
            this.horizontalInserter,
            this.verticalInserter,
            this.horizontalResizer,
            this.verticalResizer,
        ]
            .filter(function (feature) { return !!(feature === null || feature === void 0 ? void 0 : feature.div); })
            .some(function (feature) { return contains(feature === null || feature === void 0 ? void 0 : feature.div, node, true /* treatSameNodeAsContain */); });
    };
    TableEditor.prototype.onMouseMove = function (x, y) {
        var _a;
        // Get whole table rect
        var tableRect = normalizeRect(this.table.getBoundingClientRect());
        if (!tableRect) {
            return;
        }
        // Determine if cursor is on top or side
        var topOrSide = y <= tableRect.top + INSERTER_HOVER_OFFSET
            ? 0 /* top */
            : this.isRTL
                ? x >= tableRect.right - INSERTER_HOVER_OFFSET
                    ? 1 /* side */
                    : undefined
                : x <= tableRect.left + INSERTER_HOVER_OFFSET
                    ? 1 /* side */
                    : undefined;
        var topOrSideBinary = topOrSide ? 1 : 0;
        // i is row index, j is column index
        for (var i = 0; i < this.table.rows.length; i++) {
            var tr = this.table.rows[i];
            var j = 0;
            for (; j < tr.cells.length; j++) {
                var td = tr.cells[j];
                var tdRect = normalizeRect(td.getBoundingClientRect());
                if (!tdRect || !tableRect) {
                    continue;
                }
                // Determine the cell the cursor is in range of
                // Offset is only used for first row and column
                var lessThanBottom = y <= tdRect.bottom;
                var lessThanRight = this.isRTL
                    ? x <= tdRect.right + INSERTER_HOVER_OFFSET * topOrSideBinary
                    : x <= tdRect.right;
                var moreThanLeft = this.isRTL
                    ? x >= tdRect.left
                    : x >= tdRect.left - INSERTER_HOVER_OFFSET * topOrSideBinary;
                if (lessThanBottom && lessThanRight && moreThanLeft) {
                    if (i === 0 && topOrSide == 0 /* top */) {
                        var center = (tdRect.left + tdRect.right) / 2;
                        var isOnRightHalf = this.isRTL ? x < center : x > center;
                        this.setInserterTd(isOnRightHalf ? td : tr.cells[j - 1], false /*isHorizontal*/);
                    }
                    else if (j === 0 && topOrSide == 1 /* side */) {
                        var tdAbove = (_a = this.table.rows[i - 1]) === null || _a === void 0 ? void 0 : _a.cells[0];
                        var tdAboveRect = tdAbove
                            ? normalizeRect(tdAbove.getBoundingClientRect())
                            : null;
                        var isTdNotAboveMerged = !tdAboveRect
                            ? null
                            : this.isRTL
                                ? tdAboveRect.right === tdRect.right
                                : tdAboveRect.left === tdRect.left;
                        this.setInserterTd(y < (tdRect.top + tdRect.bottom) / 2 && isTdNotAboveMerged
                            ? tdAbove
                            : td, true /*isHorizontal*/);
                    }
                    else {
                        this.setInserterTd(null);
                    }
                    this.setResizingTd(td);
                    //Cell found
                    break;
                }
            }
            if (j < tr.cells.length) {
                break;
            }
        }
        // Create Selector and Resizer
        this.setEditorFeatures();
    };
    TableEditor.prototype.setEditorFeatures = function () {
        if (!this.tableSelector) {
            this.tableSelector = createTableSelector(this.table, this.editor, this.onSelect, this.getOnMouseOut, this.onShowHelperElement, this.contentDiv, this.anchorContainer);
        }
        if (!this.tableResizer) {
            this.tableResizer = createTableResizer(this.table, this.editor, this.onStartTableResize, this.onFinishEditing, this.onShowHelperElement, this.contentDiv, this.anchorContainer);
        }
    };
    TableEditor.prototype.setResizingTd = function (td) {
        if (this.horizontalResizer && this.horizontalResizer.node != td) {
            this.disposeCellResizers();
        }
        if (!this.horizontalResizer && td) {
            var zoomScale = this.editor.getZoomScale();
            this.horizontalResizer = createCellResizer(td, zoomScale, this.isRTL, true /*isHorizontal*/, this.onStartCellResize, this.onFinishEditing, this.onShowHelperElement, this.anchorContainer);
            this.verticalResizer = createCellResizer(td, zoomScale, this.isRTL, false /*isHorizontal*/, this.onStartCellResize, this.onFinishEditing, this.onShowHelperElement, this.anchorContainer);
        }
    };
    /**
     * create or remove TableInserter
     * @param td td to attach to, set this to null to remove inserters (both horizontal and vertical)
     */
    TableEditor.prototype.setInserterTd = function (td, isHorizontal) {
        var inserter = isHorizontal ? this.horizontalInserter : this.verticalInserter;
        if (td === null || (inserter && inserter.node != td)) {
            this.disposeTableInserter();
        }
        if (!this.horizontalInserter && !this.verticalInserter && td) {
            var newInserter = createTableInserter(this.editor, td, this.isRTL, !!isHorizontal, this.onInserted, this.getOnMouseOut, this.onShowHelperElement, this.anchorContainer);
            if (isHorizontal) {
                this.horizontalInserter = newInserter;
            }
            else {
                this.verticalInserter = newInserter;
            }
        }
    };
    TableEditor.prototype.disposeTableResizer = function () {
        if (this.tableResizer) {
            disposeTableEditFeature(this.tableResizer);
            this.tableResizer = null;
        }
    };
    TableEditor.prototype.disposeTableInserter = function () {
        if (this.horizontalInserter) {
            disposeTableEditFeature(this.horizontalInserter);
            this.horizontalInserter = null;
        }
        if (this.verticalInserter) {
            disposeTableEditFeature(this.verticalInserter);
            this.verticalInserter = null;
        }
    };
    TableEditor.prototype.disposeCellResizers = function () {
        if (this.horizontalResizer) {
            disposeTableEditFeature(this.horizontalResizer);
            this.horizontalResizer = null;
        }
        if (this.verticalResizer) {
            disposeTableEditFeature(this.verticalResizer);
            this.verticalResizer = null;
        }
    };
    TableEditor.prototype.disposeTableSelector = function () {
        if (this.tableSelector) {
            disposeTableEditFeature(this.tableSelector);
            this.tableSelector = null;
        }
    };
    TableEditor.prototype.onStartResize = function () {
        this.isCurrentlyEditing = true;
        var range = this.editor.getSelectionRange();
        if (range) {
            this.start = Position.getStart(range);
            this.end = Position.getEnd(range);
        }
        this.editor.addUndoSnapshot();
    };
    return TableEditor;
}());
export default TableEditor;
//# sourceMappingURL=TableEditor.js.map