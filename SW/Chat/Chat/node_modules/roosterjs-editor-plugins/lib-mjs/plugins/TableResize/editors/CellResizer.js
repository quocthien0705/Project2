import DragAndDropHelper from '../../../pluginUtils/DragAndDropHelper';
import { createElement, normalizeRect, VTable } from 'roosterjs-editor-dom';
var CELL_RESIZER_WIDTH = 4;
var MIN_CELL_WIDTH = 30;
/**
 * @internal
 */
export default function createCellResizer(td, zoomScale, isRTL, isHorizontal, onStart, onEnd, onShowHelperElement, anchorContainer) {
    var document = td.ownerDocument;
    var createElementData = {
        tag: 'div',
        style: "position: fixed; cursor: " + (isHorizontal ? 'row' : 'col') + "-resize; user-select: none",
    };
    onShowHelperElement === null || onShowHelperElement === void 0 ? void 0 : onShowHelperElement(createElementData, 'CellResizer', td);
    var div = createElement(createElementData, document);
    (anchorContainer || document.body).appendChild(div);
    var context = { td: td, isRTL: isRTL, zoomScale: zoomScale, onStart: onStart };
    var setPosition = isHorizontal ? setHorizontalPosition : setVerticalPosition;
    setPosition(context, div);
    var handler = {
        onDragStart: onDragStart,
        onDragging: isHorizontal ? onDraggingHorizontal : onDraggingVertical,
        onDragEnd: onEnd,
    };
    var featureHandler = new DragAndDropHelper(div, context, setPosition, handler, zoomScale);
    return { node: td, div: div, featureHandler: featureHandler };
}
function onDragStart(context, event) {
    var td = context.td, isRTL = context.isRTL, zoomScale = context.zoomScale, onStart = context.onStart;
    var vTable = new VTable(td, true /*normalizeSize*/, zoomScale);
    var rect = normalizeRect(td.getBoundingClientRect());
    if (rect) {
        onStart();
        // calculate and retrieve the cells of the two columns shared by the current vertical resizer
        var currentCells = vTable.getCellsWithBorder(isRTL ? rect.left : rect.right, !isRTL);
        var nextCells = vTable.getCellsWithBorder(isRTL ? rect.left : rect.right, isRTL);
        return {
            vTable: vTable,
            currentCells: currentCells,
            nextCells: nextCells,
            initialX: event.pageX,
        };
    }
    else {
        return { vTable: vTable, currentCells: [], nextCells: [], initialX: 0 }; // Just a fallback
    }
}
function onDraggingHorizontal(context, event, initValue, deltaX, deltaY) {
    var td = context.td, zoomScale = context.zoomScale;
    var vTable = initValue.vTable;
    vTable.table.removeAttribute('height');
    vTable.table.style.setProperty('height', null);
    vTable.forEachCellOfCurrentRow(function (cell) {
        var _a;
        if (cell.td) {
            cell.td.style.setProperty('height', cell.td == td ? ((_a = cell.height) !== null && _a !== void 0 ? _a : 0) / zoomScale + deltaY + "px" : null);
        }
    });
    // To avoid apply format styles when the table is being resizing, the skipApplyFormat is set to true.
    vTable.writeBack(true /**skipApplyFormat*/);
    return true;
}
function onDraggingVertical(context, event, initValue, deltaX) {
    var isRTL = context.isRTL, zoomScale = context.zoomScale;
    var vTable = initValue.vTable, nextCells = initValue.nextCells, currentCells = initValue.currentCells, initialX = initValue.initialX;
    if (!canResizeColumns(event.pageX, currentCells, nextCells, isRTL, zoomScale)) {
        return false;
    }
    // Since we allow the user to resize the table width on adjusting the border of the last cell,
    // we need to make the table width resizable by setting it as null;
    // We also allow the user to resize the table width if Shift key is pressed
    var isLastCell = nextCells.length == 0;
    var isShiftPressed = event.shiftKey;
    if (isLastCell || isShiftPressed) {
        vTable.table.style.setProperty('width', null);
    }
    var newWidthList = new Map();
    currentCells.forEach(function (td) {
        var rect = normalizeRect(td.getBoundingClientRect());
        if (rect) {
            td.style.wordBreak = 'break-word';
            td.style.whiteSpace = 'normal';
            td.style.boxSizing = 'border-box';
            var newWidth = getHorizontalDistance(rect, event.pageX, !isRTL) / zoomScale;
            newWidthList.set(td, newWidth);
        }
    });
    newWidthList.forEach(function (newWidth, td) {
        td.style.width = newWidth + "px";
    });
    if (!isShiftPressed) {
        nextCells.forEach(function (td) {
            var width = td.rowSpan > 1 ? 0 : td.getBoundingClientRect().right - initialX;
            td.style.wordBreak = 'break-word';
            td.style.whiteSpace = 'normal';
            td.style.boxSizing = 'border-box';
            td.style.width = td.rowSpan > 1 ? '' : width / zoomScale - deltaX + 'px';
        });
    }
    // To avoid apply format styles when the table is being resizing, the skipApplyFormat is set to true.
    vTable.writeBack(true /**skipApplyFormat*/);
    return true;
}
function getHorizontalDistance(rect, pos, toLeft) {
    return toLeft ? pos - rect.left : rect.right - pos;
}
function setHorizontalPosition(context, trigger) {
    var td = context.td;
    var rect = normalizeRect(td.getBoundingClientRect());
    if (rect) {
        trigger.style.top = rect.bottom - CELL_RESIZER_WIDTH + 'px';
        trigger.style.left = rect.left + 'px';
        trigger.style.width = rect.right - rect.left + 'px';
        trigger.style.height = CELL_RESIZER_WIDTH + 'px';
    }
}
function setVerticalPosition(context, trigger) {
    var td = context.td, isRTL = context.isRTL;
    var rect = normalizeRect(td.getBoundingClientRect());
    if (rect) {
        trigger.style.top = rect.top + 'px';
        trigger.style.left = (isRTL ? rect.left : rect.right) - CELL_RESIZER_WIDTH + 1 + 'px';
        trigger.style.width = CELL_RESIZER_WIDTH + 'px';
        trigger.style.height = rect.bottom - rect.top + 'px';
    }
}
/**
 *
 * @param newPos The position to where we want to move the vertical border
 * @returns if the move is allowed, or, if any of the cells on either side of the vertical border is smaller than
 * the minimum width, such move is not allowed
 */
function canResizeColumns(newPos, currentCells, nextCells, isRTL, zoomScale) {
    for (var i = 0; i < currentCells.length; i++) {
        var td = currentCells[i];
        var rect = normalizeRect(td.getBoundingClientRect());
        if (rect) {
            var width = getHorizontalDistance(rect, newPos, !isRTL) / zoomScale;
            if (width < MIN_CELL_WIDTH) {
                return false;
            }
        }
    }
    for (var i = 0; i < nextCells.length; i++) {
        var td = nextCells[i];
        var width = Number.MAX_SAFE_INTEGER;
        if (td) {
            var rect = normalizeRect(td.getBoundingClientRect());
            if (rect) {
                width = getHorizontalDistance(rect, newPos, isRTL) / zoomScale;
            }
        }
        if (width < MIN_CELL_WIDTH) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=CellResizer.js.map