import { isCharacterValue, isCtrlOrMetaPressed, matchLink } from 'roosterjs-editor-dom';
/**
 * An editor plugin that show a tooltip for existing link
 */
var HyperLink = /** @class */ (function () {
    /**
     * Create a new instance of HyperLink class
     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.
     * Default value is to return the href itself. If null, there will be no tooltip text.
     * @param target (Optional) Target window name for hyperlink. If null, will use "_blank"
     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)
     */
    function HyperLink(getTooltipCallback, target, onLinkClick) {
        var _this = this;
        if (getTooltipCallback === void 0) { getTooltipCallback = function (href) { return href; }; }
        this.getTooltipCallback = getTooltipCallback;
        this.target = target;
        this.onLinkClick = onLinkClick;
        this.originalHref = null;
        this.trackedLink = null;
        this.editor = null;
        this.disposer = null;
        this.onMouse = function (e) {
            var _a, _b;
            var a = (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.getElementAtCursor('a[href]', e.target);
            var href = a && _this.tryGetHref(a);
            if (href) {
                (_b = _this.editor) === null || _b === void 0 ? void 0 : _b.setEditorDomAttribute('title', e.type == 'mouseover' ? _this.getTooltipCallback(href, a) : null);
            }
        };
        this.onBlur = function (e) {
            if (_this.trackedLink) {
                _this.updateLinkHrefIfShouldUpdate();
            }
            _this.resetLinkTracking();
        };
    }
    /**
     * Get a friendly name of  this plugin
     */
    HyperLink.prototype.getName = function () {
        return 'Hyperlink';
    };
    /**
     * Initialize this plugin
     * @param editor The editor instance
     */
    HyperLink.prototype.initialize = function (editor) {
        this.editor = editor;
        this.disposer = editor.addDomEventHandler({
            mouseover: this.onMouse,
            mouseout: this.onMouse,
            blur: this.onBlur,
        });
    };
    /**
     * Dispose this plugin
     */
    HyperLink.prototype.dispose = function () {
        if (this.disposer) {
            this.disposer();
            this.disposer = null;
        }
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    HyperLink.prototype.onPluginEvent = function (event) {
        var _a, _b, _c;
        if (event.eventType == 6 /* MouseUp */ ||
            (event.eventType == 2 /* KeyUp */ &&
                (!this.isContentEditValue(event.rawEvent) || event.rawEvent.which == 32 /* SPACE */)) ||
            event.eventType == 7 /* ContentChanged */) {
            var anchor = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getElementAtCursor('A[href]', undefined /*startFrom*/, event);
            var shouldCheckUpdateLink = (anchor && anchor !== this.trackedLink) ||
                event.eventType == 2 /* KeyUp */ ||
                event.eventType == 7 /* ContentChanged */;
            if (event.eventType == 7 /* ContentChanged */ &&
                event.source == "Keyboard" /* Keyboard */ &&
                this.trackedLink != anchor &&
                anchor) {
                // For Keyboard event that causes content change (mostly come from Content Model), this tracked list may be staled.
                // So we need to get an up-to-date link element
                // TODO: This is a temporary solution. Later when Content Model can fully take over this behavior, we can remove this code.
                this.trackedLink = anchor;
            }
            if (this.trackedLink &&
                (shouldCheckUpdateLink || this.tryGetHref(this.trackedLink) !== this.originalHref)) {
                // If cursor has moved out of previously tracked link
                // update link href if display text doesn't match href anymore.
                if (shouldCheckUpdateLink) {
                    this.updateLinkHrefIfShouldUpdate();
                }
                // If the link's href value was edited, or the cursor has moved out of the
                // previously tracked link, stop tracking the link.
                this.resetLinkTracking();
            }
            // Cache link and href value if its href attribute currently matches its display text
            if (!this.trackedLink && anchor && this.doesLinkDisplayMatchHref(anchor)) {
                this.trackedLink = anchor;
                this.originalHref = this.tryGetHref(anchor);
            }
        }
        if (event.eventType == 6 /* MouseUp */) {
            var anchor = (_b = this.editor) === null || _b === void 0 ? void 0 : _b.getElementAtCursor('A', event.rawEvent.srcElement);
            if (anchor) {
                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {
                    return;
                }
                var href = void 0;
                if ((href = this.tryGetHref(anchor)) &&
                    isCtrlOrMetaPressed(event.rawEvent) &&
                    event.rawEvent.button === 0) {
                    event.rawEvent.preventDefault();
                    try {
                        var target = this.target || '_blank';
                        var window_1 = (_c = this.editor) === null || _c === void 0 ? void 0 : _c.getDocument().defaultView;
                        window_1 === null || window_1 === void 0 ? void 0 : window_1.open(href, target);
                    }
                    catch (_d) { }
                }
            }
        }
    };
    /**
     * Try get href from an anchor element
     * The reason this is put in a try-catch is that
     * it has been seen that accessing href may throw an exception, in particular on IE/Edge
     */
    HyperLink.prototype.tryGetHref = function (anchor) {
        try {
            return anchor ? anchor.href : null;
        }
        catch (_a) {
            return null;
        }
    };
    /**
     * Determines if KeyboardEvent is meant to edit content
     */
    HyperLink.prototype.isContentEditValue = function (event) {
        return (isCharacterValue(event) || event.which == 8 /* BACKSPACE */ || event.which == 46 /* DELETE */);
    };
    /**
     * Updates the href of the tracked link if the display text doesn't match href anymore
     */
    HyperLink.prototype.updateLinkHrefIfShouldUpdate = function () {
        if (this.trackedLink && !this.doesLinkDisplayMatchHref(this.trackedLink)) {
            this.updateLinkHref();
        }
    };
    /**
     * Clears the tracked link and its original href value so that it's back to default state
     */
    HyperLink.prototype.resetLinkTracking = function () {
        this.trackedLink = null;
        this.originalHref = '';
    };
    /**
     * Compares the normalized URL of inner text of element to its href to see if they match.
     */
    HyperLink.prototype.doesLinkDisplayMatchHref = function (element) {
        if (element) {
            var display = element.innerText.trim();
            // We first escape the display text so that any text passed into the regex is not
            // treated as a special character.
            var escapedDisplay = display.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            var rule = new RegExp("^(?:https?:\\/\\/)?" + escapedDisplay + "\\/?", 'i');
            var href = this.tryGetHref(element);
            if (href !== null) {
                return rule.test(href);
            }
        }
        return false;
    };
    /**
     * Update href of an element in place to new display text if it's a valid URL
     */
    HyperLink.prototype.updateLinkHref = function () {
        var _this = this;
        var _a;
        if (this.trackedLink) {
            var linkData_1 = matchLink(this.trackedLink.innerText.trim());
            if (linkData_1 !== null) {
                (_a = this.editor) === null || _a === void 0 ? void 0 : _a.addUndoSnapshot(function () {
                    _this.trackedLink.href = linkData_1.normalizedUrl;
                });
            }
        }
    };
    return HyperLink;
}());
export default HyperLink;
//# sourceMappingURL=HyperLink.js.map