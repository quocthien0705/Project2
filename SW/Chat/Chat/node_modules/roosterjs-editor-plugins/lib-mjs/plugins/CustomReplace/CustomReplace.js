import { __read, __values } from "tslib";
var makeReplacement = function (sourceString, replacementHTML, matchSourceCaseSensitive, shouldReplace) { return ({
    sourceString: sourceString,
    replacementHTML: replacementHTML,
    matchSourceCaseSensitive: matchSourceCaseSensitive,
    shouldReplace: shouldReplace,
}); };
var defaultReplacements = [
    makeReplacement(':)', '🙂', true),
    makeReplacement(';)', '😉', true),
    makeReplacement(':O', '😲', true),
    makeReplacement(':o', '😯', true),
    makeReplacement('<3', '❤️', true),
];
/**
 * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the
 * content edit feature
 */
var CustomReplacePlugin = /** @class */ (function () {
    /**
     * Create instance of CustomReplace plugin
     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied
     */
    function CustomReplacePlugin(replacements) {
        if (replacements === void 0) { replacements = defaultReplacements; }
        this.longestReplacementLength = null;
        this.editor = null;
        this.replacements = null;
        this.replacementEndCharacters = null;
        this.updateReplacements(replacements);
    }
    /**
     * Set the replacements that this plugin is looking for.
     * @param newReplacements new set of replacements for this plugin
     */
    CustomReplacePlugin.prototype.updateReplacements = function (newReplacements) {
        this.replacements = newReplacements;
        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);
        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);
    };
    /**
     * Get a friendly name of this plugin
     */
    CustomReplacePlugin.prototype.getName = function () {
        return 'CustomReplace';
    };
    /**
     * Initialize this plugin
     * @param editor The editor instance
     */
    CustomReplacePlugin.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    /**
     * Dispose this plugin
     */
    CustomReplacePlugin.prototype.dispose = function () {
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    CustomReplacePlugin.prototype.onPluginEvent = function (event) {
        var _this = this;
        var _a;
        if (event.eventType != 3 /* Input */ || !this.editor || this.editor.isInIME()) {
            return;
        }
        // Exit early on input events that do not insert a replacement's final character.
        if (!event.rawEvent.data || !((_a = this.replacementEndCharacters) === null || _a === void 0 ? void 0 : _a.has(event.rawEvent.data))) {
            return;
        }
        // Get the matching replacement
        var searcher = this.editor.getContentSearcherOfCursor(event);
        if (!searcher || this.longestReplacementLength == null) {
            return;
        }
        var stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);
        var replacement = this.getMatchingReplacement(stringToSearch);
        if (!replacement ||
            (replacement.shouldReplace &&
                searcher &&
                !replacement.shouldReplace(replacement, searcher.getWordBefore(), this.editor))) {
            return;
        }
        // Reconstruct a selection of the text on the document that matches the
        // replacement we selected.
        var matchingText = searcher.getSubStringBefore(replacement.sourceString.length);
        var matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);
        // parse the html string off the dom and inline the resulting element.
        var document = this.editor.getDocument();
        var parsingSpan = document.createElement('span');
        parsingSpan.innerHTML = this.editor.getTrustedHTMLHandler()(replacement.replacementHTML);
        var nodeToInsert = parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;
        // Switch the node for the selection range
        if (matchingRange) {
            this.editor.addUndoSnapshot(function () {
                var _a;
                matchingRange.deleteContents();
                matchingRange.insertNode(nodeToInsert);
                (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.select(nodeToInsert, -1 /* End */);
            }, undefined /*changeSource*/, true /*canUndoByBackspace*/);
        }
    };
    CustomReplacePlugin.prototype.getMatchingReplacement = function (stringToSearch) {
        var e_1, _a;
        if (stringToSearch.length == 0 || !this.replacements) {
            return null;
        }
        var originalStringToSearch = stringToSearch.replace(/\s/g, ' ');
        var lowerCaseStringToSearch = originalStringToSearch.toLocaleLowerCase();
        try {
            for (var _b = __values(this.replacements), _c = _b.next(); !_c.done; _c = _b.next()) {
                var replacement = _c.value;
                var _d = __read(replacement.matchSourceCaseSensitive
                    ? [originalStringToSearch, replacement.sourceString]
                    : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()], 2), sourceMatch = _d[0], replacementMatch = _d[1];
                if (sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==
                    replacementMatch) {
                    return replacement;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
    };
    return CustomReplacePlugin;
}());
export default CustomReplacePlugin;
function getLongestReplacementSourceLength(replacements) {
    return Math.max.apply(null, replacements.map(function (replacement) { return replacement.sourceString.length; }));
}
function getReplacementEndCharacters(replacements) {
    var e_2, _a;
    var endChars = new Set();
    try {
        for (var replacements_1 = __values(replacements), replacements_1_1 = replacements_1.next(); !replacements_1_1.done; replacements_1_1 = replacements_1.next()) {
            var replacement = replacements_1_1.value;
            var sourceString = replacement.sourceString;
            if (sourceString.length == 0) {
                continue;
            }
            var lastChar = sourceString[sourceString.length - 1];
            if (!replacement.matchSourceCaseSensitive) {
                endChars.add(lastChar.toLocaleLowerCase());
                endChars.add(lastChar.toLocaleUpperCase());
            }
            else {
                endChars.add(lastChar);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (replacements_1_1 && !replacements_1_1.done && (_a = replacements_1.return)) _a.call(replacements_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return endChars;
}
//# sourceMappingURL=CustomReplace.js.map