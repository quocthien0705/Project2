"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuoteFeatures = void 0;
var roosterjs_editor_api_1 = require("roosterjs-editor-api");
var roosterjs_editor_dom_1 = require("roosterjs-editor-dom");
var QUOTE_TAG = 'BLOCKQUOTE';
var STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');
/**
 * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when
 * user press BACKSPACE on first and empty line of a BLOCKQUOTE
 */
var UnquoteWhenBackOnEmpty1stLine = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        var childOfQuote = cacheGetQuoteChild(event, editor);
        return childOfQuote && (0, roosterjs_editor_dom_1.isNodeEmpty)(childOfQuote) && !childOfQuote.previousSibling;
    },
    handleEvent: splitQuote,
};
/**
 * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when
 * user press ENTER on an empty line of a BLOCKQUOTE
 */
var UnquoteWhenEnterOnEmptyLine = {
    keys: [13 /* ENTER */],
    shouldHandleEvent: function (event, editor) {
        var childOfQuote = cacheGetQuoteChild(event, editor);
        var shift = event.rawEvent.shiftKey;
        return !shift && childOfQuote && (0, roosterjs_editor_dom_1.isNodeEmpty)(childOfQuote);
    },
    handleEvent: function (event, editor) {
        return editor.addUndoSnapshot(function () { return splitQuote(event, editor); }, undefined /*changeSource*/, true /*canUndoByBackspace*/);
    },
};
function cacheGetQuoteChild(event, editor) {
    return (0, roosterjs_editor_dom_1.cacheGetEventData)(event, 'QUOTE_CHILD', function () {
        var quote = editor.getElementAtCursor(STRUCTURED_TAGS);
        if (quote && (0, roosterjs_editor_dom_1.getTagOfNode)(quote) == QUOTE_TAG) {
            var pos = editor.getFocusedPosition();
            var block = pos && editor.getBlockElementAtNode(pos.normalize().node);
            if (block) {
                var node = block.getStartNode() == quote
                    ? block.getStartNode()
                    : block.collapseToSingleElement();
                return (0, roosterjs_editor_dom_1.isNodeEmpty)(node) ? node : null;
            }
        }
        return null;
    });
}
function splitQuote(event, editor) {
    editor.addUndoSnapshot(function () {
        var childOfQuote = cacheGetQuoteChild(event, editor);
        if (!childOfQuote) {
            return;
        }
        if ((0, roosterjs_editor_dom_1.getTagOfNode)(childOfQuote) == QUOTE_TAG) {
            childOfQuote = (0, roosterjs_editor_dom_1.wrap)((0, roosterjs_editor_dom_1.toArray)(childOfQuote.childNodes));
        }
        var parent = (0, roosterjs_editor_dom_1.splitBalancedNodeRange)(childOfQuote);
        var shouldClearFormat = !!parent && isStyledBlockquote(parent);
        var newParent = parent && (0, roosterjs_editor_dom_1.unwrap)(parent);
        editor.select(childOfQuote, 0 /* Begin */);
        if (shouldClearFormat) {
            if ((0, roosterjs_editor_dom_1.safeInstanceOf)(newParent, 'HTMLLIElement')) {
                newParent.style.removeProperty('color');
            }
            (0, roosterjs_editor_api_1.clearFormat)(editor);
        }
    });
    event.rawEvent.preventDefault();
}
var isStyledBlockquote = function (element) {
    if (element &&
        (0, roosterjs_editor_dom_1.safeInstanceOf)(element, 'HTMLQuoteElement') &&
        element.style.borderLeft &&
        element.style.borderColor &&
        element.style.paddingLeft &&
        element.style.color) {
        return true;
    }
    return false;
};
/**
 * @internal
 */
exports.QuoteFeatures = {
    unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,
    unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,
};
//# sourceMappingURL=quoteFeatures.js.map