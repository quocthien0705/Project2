{"version":3,"file":"converterUtils.js","sourceRoot":"","sources":["../../../../../../packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { createLevelLists } from './LevelLists';\nimport { getObject, setObject } from './WordCustomData';\nimport { getStyles, getTagOfNode, moveChildNodes } from 'roosterjs-editor-dom';\nimport { NodeType } from 'roosterjs-editor-types';\nimport type ListItemMetadata from './ListItemMetadata';\nimport type ListMetadata from './ListMetadata';\nimport type WordConverter from './wordConverter';\nimport type WordConverterArguments from './WordConverterArguments';\n\n/** Word list metadata style name */\nconst LOOKUP_DEPTH = 5;\n\n/** Name for the word list id property in the custom data */\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\n\n/** Word list metadata style name */\nconst MSO_LIST_STYLE_NAME = 'mso-list';\n\n/** Regular expression to match line breaks */\nconst LINE_BREAKS = /[\\n|\\r]/gi;\n\n/**\n * @internal\n * Handles the pass 1: Discovery\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\n */\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\n    const args = wordConverter.wordConverterArgs;\n    if (!args) {\n        return false;\n    }\n    while (args.currentIndex < args.nodes.length) {\n        const node = args.nodes.item(args.currentIndex);\n\n        // Try to get the list metadata for the specified node\n        const itemMetadata = getListItemMetadata(node);\n        if (itemMetadata) {\n            const levelInfo =\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\n\n            // We need to drop some list information if this is not an item next to another\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\n                // This list item is not next to the previous one. This means that there is some content in between them\n                // so we need to reset our list of list ids per level\n                resetCurrentLists(args);\n            }\n\n            // Get the list metadata for the list that will hold this item\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\n            if (!listMetadata) {\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\n                const firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n\n                // This is a the first item of a list.. We'll create the list metadata using the information\n                // we already have from this first item\n                listMetadata = {\n                    numberOfItems: 0,\n                    uniqueListId: wordConverter.nextUniqueId++,\n                    firstFakeBullet: firstFakeBullet,\n\n                    // If the bullet we got is empty or not found, we ignore the list out.. this means\n                    // that this is not an item we need to convert of that the format doesn't match what\n                    // we are expecting\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\n\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\n                    // item, we'll perform a better comparison, but for one item lists, this will be check that will determine the list type\n                    tagName: getFakeBulletTagName(firstFakeBullet),\n                };\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\n                // items we have an decide if we create ordered or unordered lists based on this.\n                // This is the best way we can do this since we cannot read the metadata that Word\n                // puts in the head of the HTML...\n                const secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n                listMetadata.tagName =\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\n            }\n\n            // Set the unique id to the list\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\n\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\n            // it, or we'll know it because the previous list items are not next to this one\n            if (\n                listMetadata.ignore ||\n                (listMetadata.tagName == 'OL' &&\n                    listMetadata.numberOfItems > 0 &&\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\n            ) {\n                // We need to ignore this item... and we also need to forget about the lists that\n                // are not at the root level\n                listMetadata.ignore = true;\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\n            } else {\n                // This is an item we don't need to ignore... If added lists deep under this one before\n                // we'll drop their ids from the list of ids per level.. this is because this list item\n                // breaks the deeper lists.\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\n                        0,\n                        itemMetadata.level\n                    );\n                }\n\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\n\n                // Add the list item into the list of items to be processed\n                args.listItems.push(itemMetadata);\n                listMetadata.numberOfItems++;\n            }\n\n            args.lastProcessedItem = node;\n        } else {\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\n            // the list conversion thinking that the list items are not together...\n            const last = args.lastProcessedItem;\n            if (\n                last &&\n                getRealPreviousSibling(node) == last &&\n                node.tagName == last.tagName &&\n                node.className == last.className\n            ) {\n                // Add 2 line breaks and move all the nodes to the last item\n                last.appendChild(last.ownerDocument.createElement('br'));\n                last.appendChild(last.ownerDocument.createElement('br'));\n                moveChildNodes(last, node, true /*keepExistingChildren*/);\n\n                // Remove the item that we don't need anymore\n                node.parentNode?.removeChild(node);\n            }\n        }\n\n        // Move to the next element are return true if more elements need to be processed\n        args.currentIndex++;\n    }\n    return args.listItems.length > 0;\n}\n\n/**\n * @internal\n * Handles the pass 2: Conversion\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\n * conversion needed\n */\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\n    const args = wordConverter.wordConverterArgs;\n    if (args) {\n        args.currentIndex = 0;\n\n        while (args.currentIndex < args.listItems.length) {\n            const metadata = args.listItems[args.currentIndex];\n            const node = metadata.originalNode;\n            const listMetadata = args.lists[metadata.uniqueListId.toString()];\n            if (!listMetadata.ignore) {\n                // We have a list item that we need to convert, get or create the list\n                // that hold this item out\n                const list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\n                if (list) {\n                    // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\n                    cleanupListIgnore(node, LOOKUP_DEPTH);\n\n                    // Create a new list item and transfer the children\n                    const li = node.ownerDocument.createElement('LI');\n                    if (getTagOfNode(node).startsWith('H')) {\n                        const clone = node.cloneNode(true /* deep */) as HTMLHeadingElement;\n                        clone.style.textIndent = '';\n                        clone.style.marginLeft = '';\n                        clone.style.marginRight = '';\n                        li.appendChild(clone);\n                    } else {\n                        moveChildNodes(li, node);\n                    }\n\n                    // Append the list item into the list\n                    list.appendChild(li);\n\n                    // Remove the node we just converted\n                    node.parentNode?.removeChild(node);\n\n                    if (listMetadata.tagName == 'UL') {\n                        wordConverter.numBulletsConverted++;\n                    } else {\n                        wordConverter.numNumberedConverted++;\n                    }\n                }\n            }\n            args.currentIndex++;\n        }\n    }\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\n}\n\n/**\n * Gets or creates the list (UL or OL) that holds this item out based on the\n * items content and the specified metadata\n */\nfunction getOrCreateListForNode(\n    wordConverter: WordConverter,\n    node: HTMLElement,\n    metadata: ListItemMetadata,\n    listMetadata: ListMetadata\n): Node {\n    // First get the last list next to this node under the specified level. This code\n    // path will return the list or will create lists if needed\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\n\n    // Here use the unique list ID to detect if we have the right list...\n    // it is possible to have 2 different lists next to each other with different formats, so\n    // we want to detect this an create separate lists for those cases\n    const listId = getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\n\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\n    // is a completely new list, so we'll append a new list for that\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\n        const newList = node.ownerDocument.createElement(listMetadata.tagName);\n        list.parentNode?.insertBefore(newList, list.nextSibling);\n        list = newList;\n    }\n\n    // Set the list id into the custom data\n    setObject(\n        wordConverter.wordCustomData,\n        list,\n        UNIQUE_LIST_ID_CUSTOM_DATA,\n        metadata.uniqueListId\n    );\n\n    // This call will convert the list if needed to the right type of list required. This can happen\n    // on the cases where the first list item for this list is located after a deeper list. for that\n    // case, we will have created a UL for it, and we may need to convert it\n    return convertListIfNeeded(wordConverter, list, listMetadata);\n}\n\n/**\n * Converts the list between UL and OL if needed, by using the fake bullet and\n * information already stored in the list itself\n */\nfunction convertListIfNeeded(\n    wordConverter: WordConverter,\n    list: Node,\n    listMetadata: ListMetadata\n): Node {\n    // Check if we need to convert the list out\n    if (listMetadata.tagName != getTagOfNode(list)) {\n        // We have the wrong list type.. convert it, set the id again and transfer all the children\n        const newList = list.ownerDocument?.createElement(listMetadata.tagName);\n        if (newList) {\n            setObject(\n                wordConverter.wordCustomData,\n                newList,\n                UNIQUE_LIST_ID_CUSTOM_DATA,\n                getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\n            );\n            moveChildNodes(newList, list);\n\n            list.parentNode?.insertBefore(newList, list);\n            list.parentNode?.removeChild(list);\n            list = newList;\n        }\n    }\n\n    return list;\n}\n\n/**\n * Gets or creates the specified list\n */\nfunction recurringGetOrCreateListAtNode(\n    node: HTMLElement,\n    level: number,\n    listMetadata: ListMetadata | null\n): Node {\n    let parent: Node | null = null;\n    let possibleList: Node | null = null;\n    if (level == 1) {\n        // Root case, we'll check if the list is the previous sibling of the node\n        possibleList = getRealPreviousSibling(node);\n    } else {\n        // If we get here, we are looking for level 2 or deeper... get the upper list\n        // and check if the last element is a list\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\n        if (parent.lastChild) {\n            possibleList = parent.lastChild;\n        }\n    }\n\n    // Check the element that we got and verify that it is a list\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\n        const tag = getTagOfNode(possibleList);\n        if (tag == 'UL' || tag == 'OL') {\n            // We have a list.. use it\n            return possibleList;\n        }\n    }\n\n    // If we get here, it means we don't have a list and we need to create one\n    // this code path will always create new lists as UL lists\n    const newList = node.ownerDocument?.createElement(listMetadata ? listMetadata.tagName : 'UL');\n    if (level == 1) {\n        // For level 1, we'll insert the list before the node\n        node.parentNode?.insertBefore(newList, node);\n    } else {\n        // Any level 2 or above, we insert the list as the last\n        // child of the upper level list\n        parent?.appendChild(newList);\n    }\n\n    return newList;\n}\n\n/**\n * Cleans up the node children by removing the children marked as mso-list: Ignore.\n * This nodes hold the fake bullet information that Word puts in and when\n * conversion is happening, we want to get rid of these elements\n */\nfunction cleanupListIgnore(node: Node, levels: number) {\n    const nodesToRemove: Node[] = [];\n\n    for (let child: Node | null = node.firstChild; child; child = child.nextSibling) {\n        if (child) {\n            // Clean up the item internally first if we need to based on the number of levels\n            if (child && child.nodeType == NodeType.Element && levels > 1) {\n                cleanupListIgnore(child, levels - 1);\n            }\n\n            // Try to convert word comments into ignore elements if we haven't done so for this element\n            child = fixWordListComments(child, true /*removeComments*/);\n\n            // Check if we can remove this item out\n            if (isEmptySpan(child) || isIgnoreNode(child)) {\n                nodesToRemove.push(child);\n            }\n        }\n    }\n\n    nodesToRemove.forEach(child => node.removeChild(child));\n}\n\n/**\n * Reads the word list meta dada out of the specified node. If the node\n * is not a Word list item, it returns null.\n */\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata | null {\n    if (node.nodeType == NodeType.Element) {\n        const listAttribute = getStyleValue(node, MSO_LIST_STYLE_NAME);\n        if (listAttribute && listAttribute.length > 0) {\n            try {\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\n                // Where:\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; meta data\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\n                // for almost all cases, it maps to the list indentation (or level). We'll use it as the\n                // list indentation value\n                // (2) Contains a specific list identifier.\n                // Example value: \"l0 level1 lfo1\"\n                const listProps = listAttribute.split(' ');\n                if (listProps.length == 3) {\n                    return <ListItemMetadata>{\n                        level: parseInt(listProps[1].substr('level'.length)),\n                        wordListId: listAttribute,\n                        originalNode: node,\n                        uniqueListId: 0,\n                    };\n                }\n            } catch (e) {}\n        }\n    }\n    return null;\n}\n\nfunction isFakeBullet(fakeBullet: string): boolean {\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\n}\n\n/** Given a fake bullet text, returns the type of list that should be used for it */\nfunction getFakeBulletTagName(fakeBullet: string): string {\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\n}\n\n/**\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\n * a bullet string. If not found, it returns null...\n */\nfunction getFakeBulletText(node: Node, levels: number): string {\n    // Word uses the following format for their bullets:\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\n    // &lt;span style=\"...\"&gt;\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\n    // &lt;/span&gt;\n    // Content here...\n    // &lt;/p&gt;\n    //\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\n    // text or image node will be the fake bullet we are looking for\n    let result: string = '';\n    let child: Node | null = node.firstChild;\n    while (!result && child) {\n        // First, check if we need to convert the Word list comments into real elements\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\n        if (isIgnoreNode(child)) {\n            // Yes... this is the node that holds either the text or image data\n            result = child.textContent?.trim() ?? '';\n\n            // This is the case for image case\n            if (result.length == 0) {\n                result = 'o';\n            }\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\n            // If this is an element and we are not in the last level, try to get the fake bullet\n            // out of the child\n            result = getFakeBulletText(child, levels - 1);\n        }\n\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * If the specified element is a Word List comments, this code verifies and fixes\n * the markup when needed to ensure that Chrome bullet conversions work as expected\n * -----\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\n * styles of the span, but we'll use these comments to recreate them out\n */\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\n    if (child.nodeType == NodeType.Comment) {\n        let value = (child as Comment).data;\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\n            // We have a list ignore start, find the end.. We know is not more than\n            // 3 nodes away, so we'll optimize our checks\n            let nextElement: Node | null = child;\n            let endComment: Node | null = null;\n            for (let j = 0; j < 4; j++) {\n                nextElement = getRealNextSibling(nextElement);\n                if (!nextElement) {\n                    break;\n                }\n                if (nextElement.nodeType == NodeType.Comment) {\n                    value = (nextElement as Comment).data;\n                    if (value && value.trim().toLowerCase() == '[endif]') {\n                        endComment = nextElement;\n                        break;\n                    }\n                }\n            }\n\n            // if we found the end node, wrap everything out\n            if (endComment) {\n                const newSpan = child.ownerDocument?.createElement('span');\n                newSpan?.setAttribute('style', 'mso-list: ignore');\n\n                nextElement = getRealNextSibling(child);\n                while (nextElement != endComment) {\n                    nextElement = nextElement?.nextSibling as HTMLElement;\n                    if (nextElement.previousSibling) {\n                        newSpan?.appendChild(nextElement.previousSibling);\n                    }\n                }\n\n                // Insert the element out and use that one as the current child\n                if (newSpan) {\n                    endComment.parentNode?.insertBefore(newSpan, endComment);\n                }\n\n                // Remove the comments out if the call specified it out\n                if (removeComments) {\n                    child.parentNode?.removeChild(child);\n                    endComment.parentNode?.removeChild(endComment);\n                }\n\n                // Last, make sure we return the new element out instead of the comment\n                if (newSpan) {\n                    child = newSpan;\n                }\n            }\n        }\n    }\n\n    return child;\n}\n\n/** Finds the real previous sibling, ignoring empty text nodes */\nfunction getRealPreviousSibling(node: Node): Node | null {\n    let prevSibling: Node | null = node;\n    do {\n        prevSibling = prevSibling.previousSibling;\n    } while (prevSibling && isEmptyTextNode(prevSibling));\n    return prevSibling;\n}\n\n/** Finds the real next sibling, ignoring empty text nodes */\nfunction getRealNextSibling(node: Node): Node | null {\n    let nextSibling: Node | null = node;\n    do {\n        nextSibling = nextSibling.nextSibling;\n    } while (nextSibling && isEmptyTextNode(nextSibling));\n\n    return nextSibling;\n}\n\n/**\n * Checks if the specified node is marked as a mso-list: Ignore. These\n * nodes need to be ignored when a list item is converted into standard\n * HTML lists\n */\nfunction isIgnoreNode(node: Node): boolean {\n    if (node.nodeType == NodeType.Element) {\n        const listAttribute = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\n        if (\n            listAttribute &&\n            listAttribute.length > 0 &&\n            listAttribute.trim().toLowerCase() == 'ignore'\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/** Checks if the specified node is an empty span. */\nfunction isEmptySpan(node: Node): boolean {\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\n}\n\n/** Reads the specified style value from the node */\nfunction getStyleValue(node: HTMLElement, styleName: string): string | null {\n    // Word uses non-standard names for the metadata that puts in the style of the element...\n    // Most browsers will not provide the information for those nonstandard values through the node.style\n    // property, so the only reliable way to read them is to get the attribute directly and do\n    // the required parsing..\n    return getStyles(node)[styleName] || null;\n}\n\n/** Checks if the node is an empty text node that can be ignored */\nfunction isEmptyTextNode(node: Node): boolean {\n    // No node is empty\n    if (!node) {\n        return true;\n    }\n\n    // Empty text node is empty\n    if (node.nodeType == NodeType.Text) {\n        let value = node.nodeValue;\n        value = value?.replace(LINE_BREAKS, '') ?? '';\n        return value?.trim().length == 0;\n    }\n\n    // Span or Font with an empty child node is empty\n    const tagName = getTagOfNode(node);\n    if (\n        node.firstChild &&\n        node.firstChild == node.lastChild &&\n        (tagName == 'SPAN' || tagName == 'FONT')\n    ) {\n        return isEmptyTextNode(node.firstChild);\n    }\n\n    // If not found, then this is not empty\n    return false;\n}\n\n/** Resets the list */\nfunction resetCurrentLists(args: WordConverterArguments) {\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\n        const ll = args.currentListIdsByLevels[i];\n        if (ll) {\n            ll.currentUniqueListId = -1;\n        }\n    }\n}\n"]}