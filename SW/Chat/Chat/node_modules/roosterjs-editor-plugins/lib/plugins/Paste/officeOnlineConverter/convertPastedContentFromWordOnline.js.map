{"version":3,"file":"convertPastedContentFromWordOnline.js","sourceRoot":"","sources":["../../../../../../packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.ts"],"names":[],"mappings":"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","sourcesContent":["import { createListItemBlock } from './ListItemBlock';\nimport type ListItemBlock from './ListItemBlock';\n\nimport {\n    splitParentNode,\n    getNextLeafSibling,\n    getFirstLeafNode,\n    getTagOfNode,\n    collapseNodes,\n    unwrap,\n    toArray,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\nconst WORD_ONLINE_IDENTIFYING_SELECTOR =\n    'div.ListContainerWrapper>ul[class^=\"BulletListStyle\"],div.ListContainerWrapper>ol[class^=\"NumberListStyle\"],span.WACImageContainer > img';\nconst LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';\nconst IMAGE_CONTAINER_ELEMENT_CLASS_NAME = 'WACImageContainer';\n\n//When the list style is a symbol and the value is not in the clipboard, WordOnline\nconst VALID_LIST_STYLE_CHAR_CODES = [\n    '111', //'o'\n    '9643', //'▫'\n    '9830', //'♦'\n];\n\n/**\n * @internal\n */\nexport function isWordOnlineWithList(fragment: DocumentFragment): boolean {\n    return !!(fragment && fragment.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));\n}\n\n// Word Online pasted content DOM structure as of July 12th 2019\n//<html>\n//  <body>\n//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste\n//          <div class=\"OutlineElement\">  ----------> text content\n//              <p></p>\n//          </div>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper\n//              <ul>                                       list items in the same list can be divided into different ListItemWrapper\n//                  <li></li>                              list items in the same list can also be divided into different Outline Group;\n//                  <li></li>\n//              </ul>\n//          </div>\n//      </div>\n//      <div class='OutlineGroup'>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for ordered list, each items has it's own wrapper\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//          <div class=\"ListItemWrapper\">\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//      </div>\n//  </body>\n//</html>\n//\n\n/**\n * @internal\n * Convert text copied from word online into text that's workable with rooster editor\n * @param fragment Document fragment that is being pasted into editor.\n */\nexport default function convertPastedContentFromWordOnline(fragment: DocumentFragment) {\n    sanitizeListItemContainer(fragment);\n    const listItemBlocks: ListItemBlock[] = getListItemBlocks(fragment);\n\n    listItemBlocks.forEach(itemBlock => {\n        // There are cases where consecutive List Elements are separated into different nodes:\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // in the above case we want to collapse the two root level div into one and unwrap the list item nodes.\n        // after the following flattening the list will become following:\n        //\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // Then we are start processing.\n        flattenListBlock(fragment, itemBlock);\n\n        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.\n        itemBlock.insertPositionNode = itemBlock.endElement?.nextSibling ?? null;\n\n        let convertedListElement: Element | undefined = undefined;\n        const doc = fragment.ownerDocument;\n\n        itemBlock.listItemContainers.forEach(listItemContainer => {\n            const listType: 'OL' | 'UL' | null = getContainerListType(listItemContainer); // list type that is contained by iterator.\n            if (listType) {\n                // Initialize processed element with proper listType if this is the first element\n                if (!convertedListElement) {\n                    convertedListElement = createNewList(listItemContainer, doc, listType);\n                }\n\n                // Get all list items(<li>) in the current iterator element.\n                const currentListItems = toArray(listItemContainer.querySelectorAll('li'));\n                currentListItems.forEach(item => {\n                    // If item is in root level and the type of list changes then\n                    // insert the current list into body and then reinitialize the convertedListElement\n                    // Word Online is using data-aria-level to determine the the depth of the list item.\n                    const itemLevel = parseInt(item.getAttribute('data-aria-level') ?? '');\n                    // In first level list, there are cases where a consecutive list item DIV may have different list type\n                    // When that happens we need to insert the processed elements into the document, then change the list type\n                    // and keep the processing going.\n                    if (\n                        convertedListElement &&\n                        getTagOfNode(convertedListElement) != listType &&\n                        itemLevel == 1 &&\n                        listType\n                    ) {\n                        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n                        convertedListElement = createNewList(listItemContainer, doc, listType);\n                    }\n                    if (convertedListElement && listType) {\n                        insertListItem(convertedListElement, item, listType, doc);\n                    }\n                });\n            }\n        });\n        if (convertedListElement) {\n            insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n        }\n\n        // Once we finish the process the list items and put them into a list.\n        // After inserting the processed element,\n        // we need to remove all the non processed node from the parent node.\n        const parentContainer = itemBlock.startElement?.parentNode;\n        if (parentContainer) {\n            itemBlock.listItemContainers.forEach(listItemContainer => {\n                parentContainer.removeChild(listItemContainer);\n            });\n        }\n    });\n\n    const imageNodes = getImageNodes(fragment);\n    imageNodes.forEach(node => {\n        //   Structure when pasting Word Wac Image as of 10/22/2021\n        //   <span class='WACImageContainer'>\n        //        <img class=\"WACImage\" >\n        //        <span style=\"display:block\">\n        //        </span>\n        //   </span>\n        //\n        //   Since the second span inside of WACImageContainer have style display block it displays an additional space at the bottom of the image.\n        //   Removing the nodes that are not img will resolve the additional space\n        if (safeInstanceOf(node, 'HTMLSpanElement')) {\n            node.childNodes.forEach(childNode => {\n                if (getTagOfNode(childNode) != 'IMG') {\n                    childNode.parentElement?.removeChild(childNode);\n                }\n            });\n        }\n    });\n}\n\nfunction createNewList(listItemContainer: Element, doc: Document, tag: 'OL' | 'UL') {\n    const newList = doc.createElement(tag);\n    const startAttribute = listItemContainer.firstElementChild?.getAttribute('start');\n    if (startAttribute) {\n        newList.setAttribute('start', startAttribute);\n    }\n    return newList;\n}\n\n/**\n * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class\n * However the html might be malformed, this function is to split all the other elements out of ListContainerWrapper\n * @param fragment pasted document that contains all the list element.\n */\nfunction sanitizeListItemContainer(fragment: DocumentFragment) {\n    const listItemContainerListEl = toArray(\n        fragment.querySelectorAll(WORD_ONLINE_IDENTIFYING_SELECTOR)\n    );\n    listItemContainerListEl.forEach(el => {\n        const replaceRegex = new RegExp(`\\\\b${LIST_CONTAINER_ELEMENT_CLASS_NAME}\\\\b`, 'g');\n        if (el.previousSibling) {\n            const prevParent = splitParentNode(el, true) as HTMLElement;\n            prevParent.className = prevParent.className.replace(replaceRegex, '');\n        }\n        if (el.nextSibling) {\n            const nextParent = splitParentNode(el, false) as HTMLElement;\n            nextParent.className = nextParent.className.replace(replaceRegex, '');\n        }\n    });\n}\n\n/**\n * Take all the list items in the document, and group the consecutive list times in a list block;\n * @param fragment pasted document that contains all the list element.\n */\nfunction getListItemBlocks(fragment: DocumentFragment): ListItemBlock[] {\n    const listElements = fragment.querySelectorAll('.' + LIST_CONTAINER_ELEMENT_CLASS_NAME);\n    const result: ListItemBlock[] = [];\n    let curListItemBlock: ListItemBlock | null = null;\n    for (let i = 0; i < listElements.length; i++) {\n        const curItem = listElements[i];\n        if (!curListItemBlock) {\n            curListItemBlock = createListItemBlock(curItem);\n        } else {\n            const { listItemContainers } = curListItemBlock;\n            const lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];\n            if (\n                curItem == lastItemInCurBlock.nextSibling ||\n                (lastItemInCurBlock.parentNode &&\n                    getFirstLeafNode(curItem) ==\n                        getNextLeafSibling(lastItemInCurBlock.parentNode, lastItemInCurBlock))\n            ) {\n                listItemContainers.push(curItem);\n                curListItemBlock.endElement = curItem;\n            } else {\n                curListItemBlock.endElement = lastItemInCurBlock;\n                result.push(curListItemBlock);\n                curListItemBlock = createListItemBlock(curItem);\n            }\n        }\n    }\n\n    if (curListItemBlock && curListItemBlock.listItemContainers.length > 0) {\n        result.push(curListItemBlock);\n    }\n\n    return result;\n}\n\n/**\n * Flatten the list items, so that all the consecutive list items are under the same parent.\n * @param fragment Root element of that contains the element.\n * @param listItemBlock The list item block needed to be flattened.\n */\nfunction flattenListBlock(fragment: DocumentFragment, listItemBlock: ListItemBlock) {\n    if (listItemBlock.startElement && listItemBlock.endElement) {\n        const collapsedListItemSections = collapseNodes(\n            fragment,\n            listItemBlock.startElement,\n            listItemBlock.endElement,\n            true\n        );\n        collapsedListItemSections.forEach(section => {\n            if (getTagOfNode(section.firstChild) == 'DIV') {\n                unwrap(section);\n            }\n        });\n    }\n}\n\n/**\n * Get the list type that the container contains. If there is no list in the container\n * return null;\n * @param listItemContainer Container that contains a list\n */\nfunction getContainerListType(listItemContainer: Element): 'OL' | 'UL' | null {\n    const tag = getTagOfNode(listItemContainer.firstChild);\n    return tag == 'UL' || tag == 'OL' ? tag : null;\n}\n\n/**\n * Insert list item into the correct position of a list\n * @param listRootElement Root element of the list that is accepting a coming element.\n * @param itemToInsert List item that needed to be inserted.\n * @param listType Type of list(ul/ol)\n */\nfunction insertListItem(\n    listRootElement: Element,\n    itemToInsert: HTMLElement,\n    listType: 'UL' | 'OL',\n    doc: HTMLDocument\n): void {\n    if (!listType) {\n        return;\n    }\n    // Get item level from 'data-aria-level' attribute\n    let itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level') ?? '');\n\n    // Try to reuse the List Marker\n    const style = itemToInsert.getAttribute('data-leveltext');\n    if (\n        listType == 'UL' &&\n        style &&\n        VALID_LIST_STYLE_CHAR_CODES.indexOf(style.charCodeAt(0).toString()) > -1\n    ) {\n        itemToInsert.style.listStyleType = `\"${style}  \"`;\n    }\n\n    let curListLevel = listRootElement; // Level iterator to find the correct place for the current element.\n    // if the itemLevel is 1 it means the level iterator is at the correct place.\n    while (itemLevel > 1) {\n        if (!curListLevel.firstChild) {\n            // If the current level is empty, create empty list within the current level\n            // then move the level iterator into the next level.\n            curListLevel.appendChild(doc.createElement(listType));\n            if (curListLevel.firstElementChild) {\n                curListLevel = curListLevel.firstElementChild;\n            }\n        } else {\n            // If the current level is not empty, the last item in the needs to be a UL or OL\n            // and the level iterator should move to the UL/OL at the last position.\n            const lastChild = curListLevel.lastElementChild;\n            const lastChildTag = getTagOfNode(lastChild);\n            if (lastChild && (lastChildTag == 'UL' || lastChildTag == 'OL')) {\n                // If the last child is a list(UL/OL), then move the level iterator to last child.\n                curListLevel = lastChild;\n            } else {\n                // If the last child is not a list, then append a new list to the level\n                // and move the level iterator to the new level.\n                curListLevel.appendChild(doc.createElement(listType));\n                if (curListLevel.lastElementChild) {\n                    curListLevel = curListLevel.lastElementChild;\n                }\n            }\n        }\n        itemLevel--;\n    }\n\n    // Once the level iterator is at the right place, then append the list item in the level.\n    curListLevel.appendChild(itemToInsert);\n}\n\n/**\n * Insert the converted list item into the correct place.\n * @param convertedListElement List element that is converted from list item block\n * @param fragment Root element of that contains the converted listItemBlock\n * @param listItemBlock List item block that was converted.\n */\nfunction insertConvertedListToDoc(\n    convertedListElement: Element,\n    fragment: DocumentFragment,\n    listItemBlock: ListItemBlock\n) {\n    if (!convertedListElement) {\n        return;\n    }\n\n    const { insertPositionNode } = listItemBlock;\n    if (insertPositionNode) {\n        const parentNode = insertPositionNode.parentNode;\n        if (parentNode) {\n            parentNode.insertBefore(convertedListElement, insertPositionNode);\n        }\n    } else {\n        const parentNode = listItemBlock.startElement?.parentNode;\n        if (parentNode) {\n            parentNode.appendChild(convertedListElement);\n        } else {\n            fragment.appendChild(convertedListElement);\n        }\n    }\n}\n\nfunction getImageNodes(fragment: DocumentFragment) {\n    return fragment.querySelectorAll('.' + IMAGE_CONTAINER_ELEMENT_CLASS_NAME);\n}\n"]}