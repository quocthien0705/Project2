"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_api_1 = require("roosterjs-editor-api");
var roosterjs_editor_dom_1 = require("roosterjs-editor-dom");
// Character codes.
// IE11 uses different character codes. which are noted below.
// If adding a new key, test in IE to figure out what the code is.
var BACKSPACE_CHAR_CODE = 'Backspace';
var TAB_CHAR_CODE = 'Tab';
var ENTER_CHAR_CODE = 'Enter';
var ESC_CHAR_CODE = !roosterjs_editor_dom_1.Browser.isIE ? 'Escape' : 'Esc';
var LEFT_ARROW_CHAR_CODE = !roosterjs_editor_dom_1.Browser.isIE ? 'ArrowLeft' : 'Left';
var UP_ARROW_CHAR_CODE = !roosterjs_editor_dom_1.Browser.isIE ? 'ArrowUp' : 'Up';
var RIGHT_ARROW_CHAR_CODE = !roosterjs_editor_dom_1.Browser.isIE ? 'ArrowRight' : 'Right';
var DOWN_ARROW_CHAR_CODE = !roosterjs_editor_dom_1.Browser.isIE ? 'ArrowDown' : 'Down';
var DELETE_CHAR_CODE = !roosterjs_editor_dom_1.Browser.isIE ? 'Delete' : 'Del';
// Input event input types.
var DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';
// Unidentified key, the code for Android keyboard events.
var UNIDENTIFIED_KEY = 'Unidentified';
// the char code for Android keyboard events on Webview below 51.
var UNIDENTIFIED_CODE = [0, 229];
/**
 * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including
 * - Show picker when special trigger key is pressed
 * - Hide picker
 * - Change selection in picker by Up/Down/Left/Right
 * - Apply selected item in picker
 *
 * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.
 */
var PickerPlugin = /** @class */ (function () {
    function PickerPlugin(dataProvider, pickerOptions) {
        this.dataProvider = dataProvider;
        this.pickerOptions = pickerOptions;
        this.editor = null;
        this.eventHandledOnKeyDown = false;
        this.blockSuggestions = false;
        this.isSuggesting = false;
        this.lastKnownRange = null;
        // For detecting backspace in Android
        this.isPendingInputEventHandling = false;
        this.currentInputLength = 0;
        this.newInputLength = 0;
    }
    /**
     * Get a friendly name
     */
    PickerPlugin.prototype.getName = function () {
        return 'Picker';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    PickerPlugin.prototype.initialize = function (editor) {
        var _this = this;
        this.editor = editor;
        this.dataProvider.onInitalize(function (htmlNode) {
            if (_this.editor) {
                _this.editor.focus();
                var wordToReplace_1 = _this.getWord(null);
                // Safari drops our focus out so we get an empty word to replace when we call getWord.
                // We fall back to using the lastKnownRange to try to get around this.
                if ((!wordToReplace_1 || wordToReplace_1.length == 0) && _this.lastKnownRange) {
                    _this.editor.select(_this.lastKnownRange);
                    wordToReplace_1 = _this.getWord(null);
                }
                var insertNode = function () {
                    var _a;
                    if (wordToReplace_1 && _this.editor) {
                        (0, roosterjs_editor_api_1.replaceWithNode)(_this.editor, wordToReplace_1, htmlNode, true /* exactMatch */);
                    }
                    else {
                        (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.insertNode(htmlNode);
                    }
                    _this.setIsSuggesting(false);
                };
                _this.editor.addUndoSnapshot(insertNode, _this.pickerOptions.changeSource, _this.pickerOptions.handleAutoComplete);
            }
        }, function (isSuggesting) {
            _this.setIsSuggesting(isSuggesting);
        }, editor);
    };
    /**
     * Dispose this plugin
     */
    PickerPlugin.prototype.dispose = function () {
        this.editor = null;
        this.isSuggesting = false;
        this.blockSuggestions = false;
        this.eventHandledOnKeyDown = false;
        this.lastKnownRange = null;
        this.isPendingInputEventHandling = false;
        this.currentInputLength = 0;
        this.newInputLength = 0;
        this.dataProvider.onDispose();
    };
    /**
     * Check if the plugin should handle the given event exclusively.
     * Handle an event exclusively means other plugin will not receive this event in
     * onPluginEvent method.
     * If two plugins will return true in willHandleEventExclusively() for the same event,
     * the final result depends on the order of the plugins are added into editor
     * @param event The event to check
     */
    PickerPlugin.prototype.willHandleEventExclusively = function (event) {
        return (this.isSuggesting &&
            (event.eventType == 0 /* KeyDown */ ||
                event.eventType == 2 /* KeyUp */ ||
                event.eventType == 3 /* Input */));
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    PickerPlugin.prototype.onPluginEvent = function (event) {
        var _a;
        switch (event.eventType) {
            case 7 /* ContentChanged */:
                if (event.source == "SetContent" /* SetContent */ && this.dataProvider.onContentChanged) {
                    // Stop suggesting since content is fully changed
                    if (this.isSuggesting) {
                        this.setIsSuggesting(false);
                    }
                    // Undo and other major changes to document content fire this type of event.
                    // Inform the data provider of the current picker placed elements in the body.
                    var elementIds_1 = [];
                    (_a = this.editor) === null || _a === void 0 ? void 0 : _a.queryElements("[id^='" + this.pickerOptions.elementIdPrefix + "']", function (element) {
                        if (element.id) {
                            elementIds_1.push(element.id);
                        }
                    });
                    this.dataProvider.onContentChanged(elementIds_1);
                }
                break;
            case 0 /* KeyDown */:
                this.eventHandledOnKeyDown = false;
                if (this.isAndroidKeyboardEvent(event)) {
                    // On Android, the key for KeyboardEvent is "Unidentified" or undefined,
                    // so handling should be done using the input rather than key down event
                    // Since the key down event happens right before the input event, calculate the input
                    // length here in preparation for onAndroidInputEvent
                    this.currentInputLength = this.calcInputLength(event);
                    this.isPendingInputEventHandling = true;
                }
                else {
                    this.onKeyDownEvent(event);
                    this.isPendingInputEventHandling = false;
                }
                break;
            case 3 /* Input */:
                if (this.isPendingInputEventHandling) {
                    this.onAndroidInputEvent(event);
                }
                break;
            case 2 /* KeyUp */:
                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {
                    this.onKeyUpDomEvent(event);
                    this.isPendingInputEventHandling = false;
                }
                break;
            case 6 /* MouseUp */:
                if (this.isSuggesting) {
                    this.setIsSuggesting(false);
                }
                break;
            case 14 /* Scroll */:
                if (this.dataProvider.onScroll) {
                    // Dispatch scroll event to data provider
                    this.dataProvider.onScroll(event.scrollContainer);
                }
                break;
        }
    };
    PickerPlugin.prototype.setLastKnownRange = function (range) {
        this.lastKnownRange = range;
    };
    PickerPlugin.prototype.setIsSuggesting = function (isSuggesting) {
        this.isSuggesting = isSuggesting;
        if (!isSuggesting) {
            this.setLastKnownRange(null);
        }
        this.dataProvider.onIsSuggestingChanged(isSuggesting);
        this.setAriaOwns(isSuggesting);
        this.setAriaActiveDescendant(isSuggesting ? 0 : null);
    };
    PickerPlugin.prototype.cancelDefaultKeyDownEvent = function (event) {
        this.eventHandledOnKeyDown = true;
        event.rawEvent.preventDefault();
        event.rawEvent.stopImmediatePropagation();
    };
    PickerPlugin.prototype.getIdValue = function (node) {
        if ((0, roosterjs_editor_dom_1.safeInstanceOf)(node, 'HTMLElement')) {
            var attribute = node.attributes.getNamedItem('id');
            return attribute ? attribute.value : null;
        }
        else {
            return null;
        }
    };
    PickerPlugin.prototype.getWordBeforeCursor = function (event) {
        var _a;
        var searcher = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getContentSearcherOfCursor(event);
        return searcher ? searcher.getWordBefore() : null;
    };
    PickerPlugin.prototype.replaceNode = function (currentNode, replacementNode) {
        var _this = this;
        var _a;
        (_a = this.editor) === null || _a === void 0 ? void 0 : _a.addUndoSnapshot(function () {
            var _a, _b;
            if (currentNode) {
                (_a = _this.editor) === null || _a === void 0 ? void 0 : _a.deleteNode(currentNode);
            }
            if (replacementNode) {
                (_b = _this.editor) === null || _b === void 0 ? void 0 : _b.insertNode(replacementNode);
            }
        }, "Keyboard" /* Keyboard */);
    };
    PickerPlugin.prototype.getRangeUntilAt = function (event) {
        var _this = this;
        var _a, _b, _c;
        var positionContentSearcher = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getContentSearcherOfCursor(event);
        var startPos = undefined;
        var endPos = undefined;
        positionContentSearcher === null || positionContentSearcher === void 0 ? void 0 : positionContentSearcher.forEachTextInlineElement(function (textInline) {
            var hasMatched = false;
            var nodeContent = textInline.getTextContent();
            var nodeIndex = nodeContent ? nodeContent.length : -1;
            while (nodeIndex >= 0) {
                if (nodeContent[nodeIndex] == _this.pickerOptions.triggerCharacter) {
                    startPos = textInline.getStartPosition().move(nodeIndex);
                    hasMatched = true;
                    break;
                }
                nodeIndex--;
            }
            if (hasMatched) {
                endPos = textInline.getEndPosition();
            }
            return hasMatched;
        });
        return startPos
            ? (0, roosterjs_editor_dom_1.createRange)(startPos, endPos)
            : (_c = (_b = this.editor) === null || _b === void 0 ? void 0 : _b.getDocument().createRange()) !== null && _c !== void 0 ? _c : null;
    };
    PickerPlugin.prototype.shouldHandleKeyUpEvent = function (event) {
        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed
        // This check will always fail on Android since the KeyboardEvent's key is "Unidentified" or undefined
        // However, we don't need to check for modifier events on mobile, so can ignore this check
        return (this.isAndroidKeyboardEvent(event) ||
            (0, roosterjs_editor_dom_1.isCharacterValue)(event.rawEvent) ||
            (this.isSuggesting && !(0, roosterjs_editor_dom_1.isModifierKey)(event.rawEvent)));
    };
    PickerPlugin.prototype.onKeyUpDomEvent = function (event) {
        var _a, _b, _c, _d, _e;
        if (this.editor) {
            if (this.isSuggesting) {
                // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.
                var wordBeforeCursor = this.getWord(event);
                if (wordBeforeCursor !== null) {
                    var wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);
                    var trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();
                    // If we hit a case where wordBeforeCursor is just the trigger character,
                    // that means we've gotten an onKeyUp event right after it's been typed.
                    // Otherwise, update the query string when:
                    // 1. There's an actual value
                    // 2. That actual value isn't just pure whitespace
                    // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)
                    // Otherwise, we want to dismiss the picker plugin's UX.
                    if (wordBeforeCursor == this.pickerOptions.triggerCharacter ||
                        (trimmedWordBeforeCursor &&
                            trimmedWordBeforeCursor.length > 0 &&
                            trimmedWordBeforeCursor.split(' ').length <= 4)) {
                        this.dataProvider.queryStringUpdated(trimmedWordBeforeCursor, wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor);
                        this.setLastKnownRange((_a = this.editor.getSelectionRange()) !== null && _a !== void 0 ? _a : null);
                    }
                    else {
                        this.setIsSuggesting(false);
                    }
                }
            }
            else {
                var wordBeforeCursor = this.getWordBeforeCursor(event);
                if (!this.blockSuggestions) {
                    if (wordBeforeCursor != null &&
                        wordBeforeCursor.split(' ').length <= 4 &&
                        (wordBeforeCursor[0] == this.pickerOptions.triggerCharacter ||
                            (wordBeforeCursor[0] == '(' &&
                                wordBeforeCursor[1] == this.pickerOptions.triggerCharacter))) {
                        this.setIsSuggesting(true);
                        var wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);
                        var trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();
                        this.dataProvider.queryStringUpdated(trimmedWordBeforeCursor, wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor);
                        this.setLastKnownRange((_b = this.editor.getSelectionRange()) !== null && _b !== void 0 ? _b : null);
                        if (this.dataProvider.setCursorPoint) {
                            // Determine the bounding rectangle for the @mention
                            var searcher = this.editor.getContentSearcherOfCursor(event);
                            var rangeNode = this.editor.getDocument().createRange();
                            if (rangeNode) {
                                var nodeBeforeCursor = (_d = (_c = searcher === null || searcher === void 0 ? void 0 : searcher.getInlineElementBefore()) === null || _c === void 0 ? void 0 : _c.getContainerNode()) !== null && _d !== void 0 ? _d : null;
                                var rangeStartSuccessfullySet = this.setRangeStart(rangeNode, nodeBeforeCursor, wordBeforeCursor);
                                if (!rangeStartSuccessfullySet) {
                                    // VSO 24891: Out of range error is occurring because nodeBeforeCursor
                                    // is not including the trigger character. In this case, the node before
                                    // the node before cursor is the trigger character, and this is where the range should start.
                                    var nodeBeforeNodeBeforeCursor = (_e = nodeBeforeCursor === null || nodeBeforeCursor === void 0 ? void 0 : nodeBeforeCursor.previousSibling) !== null && _e !== void 0 ? _e : null;
                                    this.setRangeStart(rangeNode, nodeBeforeNodeBeforeCursor, this.pickerOptions.triggerCharacter);
                                }
                                var rect = rangeNode.getBoundingClientRect();
                                // Safari's support for range.getBoundingClientRect is incomplete.
                                // We perform this check to fall back to getClientRects in case it's at the page origin.
                                if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {
                                    rect = rangeNode.getClientRects()[0];
                                }
                                if (rect) {
                                    rangeNode.detach();
                                    // Display the @mention popup in the correct place
                                    var targetPoint = {
                                        x: rect.left,
                                        y: (rect.bottom + rect.top) / 2,
                                    };
                                    var bufferZone = (rect.bottom - rect.top) / 2;
                                    this.dataProvider.setCursorPoint(targetPoint, bufferZone);
                                }
                            }
                        }
                    }
                }
                else {
                    if (wordBeforeCursor != null &&
                        wordBeforeCursor[0] != this.pickerOptions.triggerCharacter) {
                        this.blockSuggestions = false;
                    }
                }
            }
        }
    };
    PickerPlugin.prototype.onKeyDownEvent = function (event) {
        var _a;
        var keyboardEvent = event.rawEvent;
        if (this.isSuggesting) {
            if (keyboardEvent.key == ESC_CHAR_CODE) {
                this.setIsSuggesting(false);
                this.blockSuggestions = true;
                this.cancelDefaultKeyDownEvent(event);
            }
            else if (keyboardEvent.key == BACKSPACE_CHAR_CODE) {
                // #483: If we are backspacing over the trigger character that triggered this Picker
                // then we need to hide the Picker
                var wordBeforeCursor = this.getWord(event);
                if (wordBeforeCursor == this.pickerOptions.triggerCharacter) {
                    this.setIsSuggesting(false);
                }
            }
            else if (this.dataProvider.shiftHighlight &&
                (this.pickerOptions.isHorizontal
                    ? keyboardEvent.key == LEFT_ARROW_CHAR_CODE ||
                        keyboardEvent.key == RIGHT_ARROW_CHAR_CODE
                    : keyboardEvent.key == UP_ARROW_CHAR_CODE ||
                        keyboardEvent.key == DOWN_ARROW_CHAR_CODE)) {
                this.dataProvider.shiftHighlight(this.pickerOptions.isHorizontal
                    ? keyboardEvent.key == RIGHT_ARROW_CHAR_CODE
                    : keyboardEvent.key == DOWN_ARROW_CHAR_CODE);
                if (this.dataProvider.getSelectedIndex) {
                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());
                }
                this.cancelDefaultKeyDownEvent(event);
            }
            else if (this.dataProvider.selectOption &&
                (keyboardEvent.key == ENTER_CHAR_CODE || keyboardEvent.key == TAB_CHAR_CODE)) {
                this.dataProvider.selectOption();
                this.cancelDefaultKeyDownEvent(event);
            }
            else {
                // Currently no op.
            }
        }
        else {
            if (keyboardEvent.key == BACKSPACE_CHAR_CODE) {
                var nodeRemoved = this.tryRemoveNode(event);
                if (nodeRemoved) {
                    this.cancelDefaultKeyDownEvent(event);
                }
            }
            else if (keyboardEvent.key == DELETE_CHAR_CODE) {
                var searcher = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getContentSearcherOfCursor(event);
                if (searcher) {
                    var inlineElementAfter = searcher.getInlineElementAfter();
                    var nodeAfterCursor = inlineElementAfter
                        ? inlineElementAfter.getContainerNode()
                        : null;
                    nodeAfterCursor = this.getParentNodeIfTextNode(nodeAfterCursor);
                    var nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;
                    if (nodeId &&
                        nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&
                        nodeAfterCursor) {
                        var replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);
                        this.replaceNode(nodeAfterCursor, replacementNode);
                        this.cancelDefaultKeyDownEvent(event);
                    }
                }
            }
        }
    };
    PickerPlugin.prototype.getParentNodeIfTextNode = function (node) {
        if ((0, roosterjs_editor_dom_1.safeInstanceOf)(node, 'Text')) {
            node = node.parentNode;
        }
        return node;
    };
    PickerPlugin.prototype.onAndroidInputEvent = function (event) {
        this.newInputLength = this.calcInputLength(event);
        if (this.newInputLength < this.currentInputLength ||
            event.rawEvent.inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE) {
            var nodeRemoved = this.tryRemoveNode(event);
            if (nodeRemoved) {
                this.eventHandledOnKeyDown = true;
            }
        }
    };
    PickerPlugin.prototype.calcInputLength = function (event) {
        var wordBeforeCursor = this.getInlineElementBeforeCursor(event);
        return wordBeforeCursor ? wordBeforeCursor.length : 0;
    };
    PickerPlugin.prototype.tryRemoveNode = function (event) {
        if (!this.editor) {
            return false;
        }
        var searcher = this.editor.getContentSearcherOfCursor(event);
        if (!searcher) {
            return false;
        }
        var inlineElementBefore = searcher.getInlineElementBefore();
        var nodeBeforeCursor = inlineElementBefore ? inlineElementBefore.getContainerNode() : null;
        nodeBeforeCursor = this.getParentNodeIfTextNode(nodeBeforeCursor);
        var nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;
        var inlineElementAfter = searcher.getInlineElementAfter();
        if (nodeBeforeCursor &&
            nodeId &&
            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&
            (inlineElementAfter == null || !(inlineElementAfter instanceof roosterjs_editor_dom_1.PartialInlineElement))) {
            var replacementNode_1 = this.dataProvider.onRemove(nodeBeforeCursor, true);
            if (replacementNode_1) {
                this.replaceNode(nodeBeforeCursor, replacementNode_1);
                if (this.isPendingInputEventHandling) {
                    this.editor.runAsync(function (editor) {
                        editor.select(replacementNode_1, -3 /* After */);
                    });
                }
                else {
                    this.editor.select(replacementNode_1, -3 /* After */);
                }
                return true;
            }
            else {
                // Select the node then let browser delete it
                this.editor.select(nodeBeforeCursor);
                return false;
            }
        }
        return false;
    };
    PickerPlugin.prototype.getWord = function (event) {
        var _a, _b;
        var wordFromRange = (_b = (_a = this.getRangeUntilAt(event)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '';
        var wordFromCache = this.getWordBeforeCursor(event);
        // VSO 24891: In picker, trigger and mention are separated into two nodes.
        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,
        // so wordFromCache is what we want to return.
        if (wordFromRange == this.pickerOptions.triggerCharacter &&
            wordFromRange != wordFromCache) {
            return wordFromCache;
        }
        return wordFromRange;
    };
    PickerPlugin.prototype.setRangeStart = function (rangeNode, node, target) {
        var nodeOffset = (node === null || node === void 0 ? void 0 : node.textContent) ? node.textContent.lastIndexOf(target) : -1;
        if (node && nodeOffset > -1) {
            rangeNode.setStart(node, nodeOffset);
            return true;
        }
        return false;
    };
    PickerPlugin.prototype.setAriaOwns = function (isSuggesting) {
        var _a;
        (_a = this.editor) === null || _a === void 0 ? void 0 : _a.setEditorDomAttribute('aria-owns', isSuggesting && this.pickerOptions.suggestionsLabel
            ? this.pickerOptions.suggestionsLabel
            : null);
    };
    PickerPlugin.prototype.setAriaActiveDescendant = function (selectedIndex) {
        var _a;
        (_a = this.editor) === null || _a === void 0 ? void 0 : _a.setEditorDomAttribute('aria-activedescendant', selectedIndex != null && this.pickerOptions.suggestionLabelPrefix
            ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()
            : null);
    };
    PickerPlugin.prototype.getInlineElementBeforeCursor = function (event) {
        var _a;
        var searcher = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getContentSearcherOfCursor(event);
        var element = searcher ? searcher.getInlineElementBefore() : null;
        return element ? element.getTextContent() : null;
    };
    PickerPlugin.prototype.isAndroidKeyboardEvent = function (event) {
        // Check keyboard events on Android for further handling.
        // On Android Webview later 51, the KeyboardEvent's key is "Unidentified".
        // On Android Webview below 51, the KeyboardEvent's key is not supported and always returns undefined,
        // so using the charCode property, which is 0 or 229.
        return (event.rawEvent.key == UNIDENTIFIED_KEY ||
            (event.rawEvent.key == undefined &&
                UNIDENTIFIED_CODE.indexOf(event.rawEvent.charCode) > -1));
    };
    return PickerPlugin;
}());
exports.default = PickerPlugin;
//# sourceMappingURL=PickerPlugin.js.map