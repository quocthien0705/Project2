{"version":3,"file":"HyperLink.js","sourceRoot":"","sources":["../../../../../packages/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChangeSource, Keys, PluginEventType } from 'roosterjs-editor-types';\nimport { isCharacterValue, isCtrlOrMetaPressed, matchLink } from 'roosterjs-editor-dom';\nimport type { DOMEventHandler, EditorPlugin, IEditor, PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * An editor plugin that show a tooltip for existing link\n */\nexport default class HyperLink implements EditorPlugin {\n    private originalHref: string | null = null;\n    private trackedLink: HTMLAnchorElement | null = null;\n    private editor: IEditor | null = null;\n    private disposer: (() => void) | null = null;\n\n    /**\n     * Create a new instance of HyperLink class\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\n     * Default value is to return the href itself. If null, there will be no tooltip text.\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\n     */\n    constructor(\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\n        private target?: string,\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Hyperlink';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n        this.disposer = editor.addDomEventHandler({\n            mouseover: <DOMEventHandler>this.onMouse,\n            mouseout: <DOMEventHandler>this.onMouse,\n            blur: <DOMEventHandler>this.onBlur,\n        });\n    }\n\n    protected onMouse = (e: MouseEvent) => {\n        const a = this.editor?.getElementAtCursor(\n            'a[href]',\n            <Node>e.target\n        ) as HTMLAnchorElement | null;\n        const href = a && this.tryGetHref(a);\n\n        if (href) {\n            this.editor?.setEditorDomAttribute(\n                'title',\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\n            );\n        }\n    };\n\n    protected onBlur = (e: FocusEvent) => {\n        if (this.trackedLink) {\n            this.updateLinkHrefIfShouldUpdate();\n        }\n\n        this.resetLinkTracking();\n    };\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent): void {\n        if (\n            event.eventType == PluginEventType.MouseUp ||\n            (event.eventType == PluginEventType.KeyUp &&\n                (!this.isContentEditValue(event.rawEvent) || event.rawEvent.which == Keys.SPACE)) ||\n            event.eventType == PluginEventType.ContentChanged\n        ) {\n            const anchor = this.editor?.getElementAtCursor(\n                'A[href]',\n                undefined /*startFrom*/,\n                event\n            ) as HTMLAnchorElement | null;\n\n            const shouldCheckUpdateLink =\n                (anchor && anchor !== this.trackedLink) ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.ContentChanged;\n\n            if (\n                event.eventType == PluginEventType.ContentChanged &&\n                event.source == ChangeSource.Keyboard &&\n                this.trackedLink != anchor &&\n                anchor\n            ) {\n                // For Keyboard event that causes content change (mostly come from Content Model), this tracked list may be staled.\n                // So we need to get an up-to-date link element\n                // TODO: This is a temporary solution. Later when Content Model can fully take over this behavior, we can remove this code.\n                this.trackedLink = anchor;\n            }\n\n            if (\n                this.trackedLink &&\n                (shouldCheckUpdateLink || this.tryGetHref(this.trackedLink) !== this.originalHref)\n            ) {\n                // If cursor has moved out of previously tracked link\n                // update link href if display text doesn't match href anymore.\n                if (shouldCheckUpdateLink) {\n                    this.updateLinkHrefIfShouldUpdate();\n                }\n\n                // If the link's href value was edited, or the cursor has moved out of the\n                // previously tracked link, stop tracking the link.\n                this.resetLinkTracking();\n            }\n\n            // Cache link and href value if its href attribute currently matches its display text\n            if (!this.trackedLink && anchor && this.doesLinkDisplayMatchHref(anchor)) {\n                this.trackedLink = anchor;\n                this.originalHref = this.tryGetHref(anchor);\n            }\n        }\n\n        if (event.eventType == PluginEventType.MouseUp) {\n            const anchor = this.editor?.getElementAtCursor(\n                'A',\n                <Node>event.rawEvent.srcElement\n            ) as HTMLAnchorElement | null;\n\n            if (anchor) {\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\n                    return;\n                }\n\n                let href: string | null;\n                if (\n                    (href = this.tryGetHref(anchor)) &&\n                    isCtrlOrMetaPressed(event.rawEvent) &&\n                    event.rawEvent.button === 0\n                ) {\n                    event.rawEvent.preventDefault();\n                    try {\n                        const target = this.target || '_blank';\n                        const window = this.editor?.getDocument().defaultView;\n                        window?.open(href, target);\n                    } catch {}\n                }\n            }\n        }\n    }\n\n    /**\n     * Try get href from an anchor element\n     * The reason this is put in a try-catch is that\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\n     */\n    private tryGetHref(anchor: HTMLAnchorElement): string | null {\n        try {\n            return anchor ? anchor.href : null;\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Determines if KeyboardEvent is meant to edit content\n     */\n    private isContentEditValue(event: KeyboardEvent): boolean {\n        return (\n            isCharacterValue(event) || event.which == Keys.BACKSPACE || event.which == Keys.DELETE\n        );\n    }\n\n    /**\n     * Updates the href of the tracked link if the display text doesn't match href anymore\n     */\n    private updateLinkHrefIfShouldUpdate() {\n        if (this.trackedLink && !this.doesLinkDisplayMatchHref(this.trackedLink)) {\n            this.updateLinkHref();\n        }\n    }\n\n    /**\n     * Clears the tracked link and its original href value so that it's back to default state\n     */\n    private resetLinkTracking() {\n        this.trackedLink = null;\n        this.originalHref = '';\n    }\n\n    /**\n     * Compares the normalized URL of inner text of element to its href to see if they match.\n     */\n    private doesLinkDisplayMatchHref(element: HTMLAnchorElement): boolean {\n        if (element) {\n            const display = element.innerText.trim();\n\n            // We first escape the display text so that any text passed into the regex is not\n            // treated as a special character.\n            const escapedDisplay = display.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n            const rule = new RegExp(`^(?:https?:\\\\/\\\\/)?${escapedDisplay}\\\\/?`, 'i');\n            const href = this.tryGetHref(element);\n            if (href !== null) {\n                return rule.test(href);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Update href of an element in place to new display text if it's a valid URL\n     */\n    private updateLinkHref() {\n        if (this.trackedLink) {\n            const linkData = matchLink(this.trackedLink.innerText.trim());\n            if (linkData !== null) {\n                this.editor?.addUndoSnapshot(() => {\n                    this.trackedLink!.href = linkData!.normalizedUrl;\n                });\n            }\n        }\n    }\n}\n"]}