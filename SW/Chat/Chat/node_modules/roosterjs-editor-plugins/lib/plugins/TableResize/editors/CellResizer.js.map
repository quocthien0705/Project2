{"version":3,"file":"CellResizer.js","sourceRoot":"","sources":["../../../../../../packages/roosterjs-editor-plugins/lib/plugins/TableResize/editors/CellResizer.ts"],"names":[],"mappings":"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","sourcesContent":["import DragAndDropHelper from '../../../pluginUtils/DragAndDropHelper';\nimport { createElement, normalizeRect, VTable } from 'roosterjs-editor-dom';\nimport type DragAndDropHandler from '../../../pluginUtils/DragAndDropHandler';\nimport type TableEditFeature from './TableEditorFeature';\nimport type { CreateElementData, Rect } from 'roosterjs-editor-types';\n\nconst CELL_RESIZER_WIDTH = 4;\nconst MIN_CELL_WIDTH = 30;\n\n/**\n * @internal\n */\nexport default function createCellResizer(\n    td: HTMLTableCellElement,\n    zoomScale: number,\n    isRTL: boolean,\n    isHorizontal: boolean,\n    onStart: () => void,\n    onEnd: () => false,\n    onShowHelperElement?: (\n        elementData: CreateElementData,\n        helperType: 'CellResizer' | 'TableInserter' | 'TableResizer' | 'TableSelector',\n        td: HTMLTableCellElement\n    ) => void,\n    anchorContainer?: HTMLElement\n): TableEditFeature | null {\n    const document = td.ownerDocument;\n    const createElementData = {\n        tag: 'div',\n        style: `position: fixed; cursor: ${isHorizontal ? 'row' : 'col'}-resize; user-select: none`,\n    };\n\n    onShowHelperElement?.(createElementData, 'CellResizer', td);\n\n    const div = createElement(createElementData, document) as HTMLDivElement;\n\n    (anchorContainer || document.body).appendChild(div);\n\n    const context: DragAndDropContext = { td, isRTL, zoomScale, onStart };\n    const setPosition = isHorizontal ? setHorizontalPosition : setVerticalPosition;\n    setPosition(context, div);\n\n    const handler: DragAndDropHandler<DragAndDropContext, DragAndDropInitValue> = {\n        onDragStart,\n        onDragging: isHorizontal ? onDraggingHorizontal : onDraggingVertical,\n        onDragEnd: onEnd,\n    };\n\n    const featureHandler = new DragAndDropHelper<DragAndDropContext, DragAndDropInitValue>(\n        div,\n        context,\n        setPosition,\n        handler,\n        zoomScale\n    );\n\n    return { node: td, div, featureHandler };\n}\n\ninterface DragAndDropContext {\n    td: HTMLTableCellElement;\n    isRTL: boolean;\n    zoomScale: number;\n    onStart: () => void;\n}\n\ninterface DragAndDropInitValue {\n    vTable: VTable;\n    currentCells: HTMLTableCellElement[];\n    nextCells: HTMLTableCellElement[];\n    initialX: number;\n}\n\nfunction onDragStart(context: DragAndDropContext, event: MouseEvent): DragAndDropInitValue {\n    const { td, isRTL, zoomScale, onStart } = context;\n    const vTable = new VTable(td, true /*normalizeSize*/, zoomScale);\n    const rect = normalizeRect(td.getBoundingClientRect());\n\n    if (rect) {\n        onStart();\n\n        // calculate and retrieve the cells of the two columns shared by the current vertical resizer\n        const currentCells = vTable.getCellsWithBorder(isRTL ? rect.left : rect.right, !isRTL);\n        const nextCells = vTable.getCellsWithBorder(isRTL ? rect.left : rect.right, isRTL);\n\n        return {\n            vTable,\n            currentCells,\n            nextCells,\n            initialX: event.pageX,\n        };\n    } else {\n        return { vTable, currentCells: [], nextCells: [], initialX: 0 }; // Just a fallback\n    }\n}\n\nfunction onDraggingHorizontal(\n    context: DragAndDropContext,\n    event: MouseEvent,\n    initValue: DragAndDropInitValue,\n    deltaX: number,\n    deltaY: number\n) {\n    const { td, zoomScale } = context;\n    const { vTable } = initValue;\n\n    vTable.table.removeAttribute('height');\n    vTable.table.style.setProperty('height', null);\n    vTable.forEachCellOfCurrentRow(cell => {\n        if (cell.td) {\n            cell.td.style.setProperty(\n                'height',\n                cell.td == td ? `${(cell.height ?? 0) / zoomScale + deltaY}px` : null\n            );\n        }\n    });\n\n    // To avoid apply format styles when the table is being resizing, the skipApplyFormat is set to true.\n    vTable.writeBack(true /**skipApplyFormat*/);\n    return true;\n}\n\nfunction onDraggingVertical(\n    context: DragAndDropContext,\n    event: MouseEvent,\n    initValue: DragAndDropInitValue,\n    deltaX: number\n) {\n    const { isRTL, zoomScale } = context;\n    const { vTable, nextCells, currentCells, initialX } = initValue;\n\n    if (!canResizeColumns(event.pageX, currentCells, nextCells, isRTL, zoomScale)) {\n        return false;\n    }\n\n    // Since we allow the user to resize the table width on adjusting the border of the last cell,\n    // we need to make the table width resizable by setting it as null;\n    // We also allow the user to resize the table width if Shift key is pressed\n    const isLastCell = nextCells.length == 0;\n    const isShiftPressed = event.shiftKey;\n\n    if (isLastCell || isShiftPressed) {\n        vTable.table.style.setProperty('width', null);\n    }\n\n    const newWidthList = new Map<HTMLTableCellElement, number>();\n    currentCells.forEach(td => {\n        const rect = normalizeRect(td.getBoundingClientRect());\n\n        if (rect) {\n            td.style.wordBreak = 'break-word';\n            td.style.whiteSpace = 'normal';\n            td.style.boxSizing = 'border-box';\n            const newWidth = getHorizontalDistance(rect, event.pageX, !isRTL) / zoomScale;\n            newWidthList.set(td, newWidth);\n        }\n    });\n    newWidthList.forEach((newWidth, td) => {\n        td.style.width = `${newWidth}px`;\n    });\n    if (!isShiftPressed) {\n        nextCells.forEach(td => {\n            const width = td.rowSpan > 1 ? 0 : td.getBoundingClientRect().right - initialX;\n            td.style.wordBreak = 'break-word';\n            td.style.whiteSpace = 'normal';\n            td.style.boxSizing = 'border-box';\n            td.style.width = td.rowSpan > 1 ? '' : width / zoomScale - deltaX + 'px';\n        });\n    }\n\n    // To avoid apply format styles when the table is being resizing, the skipApplyFormat is set to true.\n    vTable.writeBack(true /**skipApplyFormat*/);\n    return true;\n}\n\nfunction getHorizontalDistance(rect: Rect, pos: number, toLeft: boolean): number {\n    return toLeft ? pos - rect.left : rect.right - pos;\n}\n\nfunction setHorizontalPosition(context: DragAndDropContext, trigger: HTMLElement) {\n    const { td } = context;\n    const rect = normalizeRect(td.getBoundingClientRect());\n    if (rect) {\n        trigger.style.top = rect.bottom - CELL_RESIZER_WIDTH + 'px';\n        trigger.style.left = rect.left + 'px';\n        trigger.style.width = rect.right - rect.left + 'px';\n        trigger.style.height = CELL_RESIZER_WIDTH + 'px';\n    }\n}\n\nfunction setVerticalPosition(context: DragAndDropContext, trigger: HTMLElement) {\n    const { td, isRTL } = context;\n    const rect = normalizeRect(td.getBoundingClientRect());\n    if (rect) {\n        trigger.style.top = rect.top + 'px';\n        trigger.style.left = (isRTL ? rect.left : rect.right) - CELL_RESIZER_WIDTH + 1 + 'px';\n        trigger.style.width = CELL_RESIZER_WIDTH + 'px';\n        trigger.style.height = rect.bottom - rect.top + 'px';\n    }\n}\n\n/**\n *\n * @param newPos The position to where we want to move the vertical border\n * @returns if the move is allowed, or, if any of the cells on either side of the vertical border is smaller than\n * the minimum width, such move is not allowed\n */\nfunction canResizeColumns(\n    newPos: number,\n    currentCells: HTMLTableCellElement[],\n    nextCells: HTMLTableCellElement[],\n    isRTL: boolean,\n    zoomScale: number\n) {\n    for (let i = 0; i < currentCells.length; i++) {\n        const td = currentCells[i];\n        const rect = normalizeRect(td.getBoundingClientRect());\n        if (rect) {\n            const width = getHorizontalDistance(rect, newPos, !isRTL) / zoomScale;\n            if (width < MIN_CELL_WIDTH) {\n                return false;\n            }\n        }\n    }\n\n    for (let i = 0; i < nextCells.length; i++) {\n        const td = nextCells[i];\n        let width: number = Number.MAX_SAFE_INTEGER;\n        if (td) {\n            const rect = normalizeRect(td.getBoundingClientRect());\n\n            if (rect) {\n                width = getHorizontalDistance(rect, newPos, isRTL) / zoomScale;\n            }\n        }\n\n        if (width < MIN_CELL_WIDTH) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"]}