define(["require", "exports", "tslib", "./editInfoUtils/applyChange", "./api/canRegenerateImage", "../../pluginUtils/DragAndDropHelper", "./editInfoUtils/getGeneratedImageSize", "./imageEditors/Cropper", "./editInfoUtils/editInfo", "./imageEditors/Rotator", "./constants/constants", "roosterjs-editor-dom", "./imageEditors/Resizer"], function (require, exports, tslib_1, applyChange_1, canRegenerateImage_1, DragAndDropHelper_1, getGeneratedImageSize_1, Cropper_1, editInfo_1, Rotator_1, constants_1, roosterjs_editor_dom_1, Resizer_1) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    var PI = Math.PI;
    var DIRECTIONS = 8;
    var DirectionRad = (PI * 2) / DIRECTIONS;
    var DirectionOrder = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
    /**
     * Default image edit options
     */
    var DefaultOptions = {
        borderColor: '#DB626C',
        minWidth: 10,
        minHeight: 10,
        preserveRatio: false,
        minRotateDeg: 5,
        imageSelector: 'img',
        rotateIconHTML: '',
        disableCrop: false,
        disableRotate: false,
        disableSideResize: false,
        onSelectState: 7 /* ResizeAndRotate */,
        applyChangesOnMouseUp: false,
    };
    /**
     * Map the image edit operation to a function that returns editing elements HTML to help
     * build image editing UI
     */
    var ImageEditHTMLMap = (_a = {},
        _a[1 /* CornerResize */] = Resizer_1.getCornerResizeHTML,
        _a[2 /* SideResize */] = Resizer_1.getSideResizeHTML,
        _a[4 /* Rotate */] = Rotator_1.getRotateHTML,
        _a[8 /* Crop */] = Cropper_1.getCropHTML,
        _a);
    /**
     * Default background colors for rotate handle
     */
    var LIGHT_MODE_BGCOLOR = 'white';
    var DARK_MODE_BGCOLOR = '#333';
    /**
     * ImageEdit plugin provides the ability to edit an inline image in editor, including image resizing, rotation and cropping
     */
    var ImageEdit = /** @class */ (function () {
        /**
         * Create a new instance of ImageEdit
         * @param options Image editing options
         * @param onShowResizeHandle An optional callback to allow customize resize handle element of image resizing.
         * To customize the resize handle element, add this callback and change the attributes of elementData then it
         * will be picked up by ImageEdit code
         */
        function ImageEdit(options, onShowResizeHandle) {
            var _this = this;
            this.onShowResizeHandle = onShowResizeHandle;
            this.editor = null;
            this.disposer = null;
            // Current editing image
            this.image = null;
            // Image cloned from the current editing image
            this.clonedImage = null;
            // The image wrapper
            this.wrapper = null;
            // Current edit info of the image. All changes user made will be stored in this object.
            // We use this object to update the editing UI, and finally we will use this object to generate
            // the new image if necessary
            this.editInfo = null;
            // Src of the image before current editing
            this.lastSrc = null;
            // Drag and drop helper objects
            this.dndHelpers = [];
            /**
             * Identify if the image was resized by the user.
             */
            this.wasResized = false;
            /**
             * The span element that wraps the image and opens shadow dom
             */
            this.shadowSpan = null;
            /**
             * The span element that wraps the image and opens shadow dom
             */
            this.isCropping = false;
            /**
             * quit editing mode when editor lose focus
             */
            this.onBlur = function () {
                _this.setEditingImage(null, false /* selectImage */);
            };
            /**
             * Remove the temp wrapper of the image
             */
            this.removeWrapper = function () {
                var _a;
                if (_this.shadowSpan) {
                    (0, roosterjs_editor_dom_1.unwrap)(_this.shadowSpan);
                }
                if (_this.options.applyChangesOnMouseUp) {
                    (_a = _this.wrapper) === null || _a === void 0 ? void 0 : _a.removeEventListener('mouseup', _this.changesWhenMouseUp, true /* useCapture*/);
                }
                _this.wrapper = null;
                _this.shadowSpan = null;
            };
            this.changesWhenMouseUp = function () {
                if (_this.editor && _this.image && _this.editInfo && _this.lastSrc && _this.clonedImage) {
                    (0, applyChange_1.default)(_this.editor, _this.image, _this.editInfo, _this.lastSrc, _this.wasResized, _this.clonedImage, _this.options.applyChangesOnMouseUp);
                }
            };
            /**
             * Update image edit elements to reflect current editing result
             * @param context
             */
            this.updateWrapper = function (context) {
                var _a, _b;
                var wrapper = _this.wrapper;
                if (wrapper &&
                    _this.editInfo &&
                    _this.image &&
                    _this.clonedImage &&
                    _this.options &&
                    ((_a = _this.shadowSpan) === null || _a === void 0 ? void 0 : _a.parentElement)) {
                    // Prepare: get related editing elements
                    var cropContainers = getEditElements(wrapper, "r_cropC" /* CropContainer */);
                    var cropOverlays = getEditElements(wrapper, "r_cropO" /* CropOverlay */);
                    var resizeHandles = getEditElements(wrapper, "r_resizeH" /* ResizeHandle */);
                    var rotateCenter = getEditElements(wrapper, "r_rotateC" /* RotateCenter */)[0];
                    var rotateHandle = getEditElements(wrapper, "r_rotateH" /* RotateHandle */)[0];
                    var cropHandles = getEditElements(wrapper, "r_cropH" /* CropHandle */);
                    // Cropping and resizing will show different UI, so check if it is cropping here first
                    _this.isCropping = cropContainers.length == 1 && cropOverlays.length == 4;
                    var _c = _this.editInfo, angleRad = _c.angleRad, bottomPercent = _c.bottomPercent, leftPercent = _c.leftPercent, rightPercent = _c.rightPercent, topPercent = _c.topPercent, flippedHorizontal = _c.flippedHorizontal, flippedVertical = _c.flippedVertical;
                    // Width/height of the image
                    var _d = (0, getGeneratedImageSize_1.default)(_this.editInfo, _this.isCropping), targetWidth = _d.targetWidth, targetHeight = _d.targetHeight, originalWidth = _d.originalWidth, originalHeight = _d.originalHeight, visibleWidth = _d.visibleWidth, visibleHeight = _d.visibleHeight;
                    var marginHorizontal = (targetWidth - visibleWidth) / 2;
                    var marginVertical = (targetHeight - visibleHeight) / 2;
                    var cropLeftPx = originalWidth * leftPercent;
                    var cropRightPx = originalWidth * rightPercent;
                    var cropTopPx = originalHeight * topPercent;
                    var cropBottomPx = originalHeight * bottomPercent;
                    // Update size and margin of the wrapper
                    wrapper.style.margin = marginVertical + "px " + marginHorizontal + "px";
                    wrapper.style.transform = "rotate(" + angleRad + "rad)";
                    setWrapperSizeDimensions(wrapper, _this.image, visibleWidth, visibleHeight);
                    // Update the text-alignment to avoid the image to overflow if the parent element have align center or right
                    // or if the direction is Right To Left
                    wrapper.style.textAlign = isRtl(_this.shadowSpan.parentElement) ? 'right' : 'left';
                    // Update size of the image
                    _this.clonedImage.style.width = getPx(originalWidth);
                    _this.clonedImage.style.height = getPx(originalHeight);
                    //Update flip direction
                    setFlipped(_this.clonedImage.parentElement, flippedHorizontal, flippedVertical);
                    if (_this.isCropping) {
                        // For crop, we also need to set position of the overlays
                        setSize(cropContainers[0], cropLeftPx, cropTopPx, cropRightPx, cropBottomPx, undefined, undefined);
                        setSize(cropOverlays[0], 0, 0, cropRightPx, undefined, undefined, cropTopPx);
                        setSize(cropOverlays[1], undefined, 0, 0, cropBottomPx, cropRightPx, undefined);
                        setSize(cropOverlays[2], cropLeftPx, undefined, 0, 0, undefined, cropBottomPx);
                        setSize(cropOverlays[3], 0, cropTopPx, undefined, 0, cropLeftPx, undefined);
                        updateHandleCursor(cropHandles, angleRad);
                    }
                    else {
                        // For rotate/resize, set the margin of the image so that cropped part won't be visible
                        _this.clonedImage.style.margin = -cropTopPx + "px 0 0 " + -cropLeftPx + "px";
                        // Double check resize
                        if ((context === null || context === void 0 ? void 0 : context.elementClass) == "r_resizeH" /* ResizeHandle */) {
                            var clientWidth = wrapper.clientWidth;
                            var clientHeight = wrapper.clientHeight;
                            _this.wasResized = true;
                            (0, Resizer_1.doubleCheckResize)(_this.editInfo, _this.options.preserveRatio || false, clientWidth, clientHeight);
                            _this.updateWrapper();
                        }
                        var viewport = (_b = _this.editor) === null || _b === void 0 ? void 0 : _b.getVisibleViewport();
                        var isSmall = isASmallImage(targetWidth, targetHeight);
                        if (rotateHandle && rotateCenter && viewport) {
                            (0, Rotator_1.updateRotateHandleState)(viewport, angleRad, wrapper, rotateCenter, rotateHandle, isSmall);
                        }
                        updateSideHandlesVisibility(resizeHandles, isSmall);
                        updateHandleCursor(resizeHandles, angleRad);
                    }
                }
            };
            this.options = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, DefaultOptions), (options || {}));
            this.allowedOperations =
                1 /* CornerResize */ |
                    (this.options.disableCrop ? 0 : 8 /* Crop */) |
                    (this.options.disableRotate ? 0 : 4 /* Rotate */) |
                    (this.options.disableSideResize ? 0 : 2 /* SideResize */);
        }
        /**
         * Get a friendly name of this plugin
         */
        ImageEdit.prototype.getName = function () {
            return 'ImageEdit';
        };
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        ImageEdit.prototype.initialize = function (editor) {
            var _this = this;
            this.editor = editor;
            this.disposer = editor.addDomEventHandler({
                blur: function () { return _this.onBlur(); },
                dragstart: function (e) {
                    if (_this.image) {
                        e.preventDefault();
                    }
                },
            });
        };
        /**
         * Dispose this plugin
         */
        ImageEdit.prototype.dispose = function () {
            var _a;
            this.clearDndHelpers();
            (_a = this.disposer) === null || _a === void 0 ? void 0 : _a.call(this);
            this.disposer = null;
            this.editor = null;
        };
        /**
         * Handle events triggered from editor
         * @param e PluginEvent object
         */
        ImageEdit.prototype.onPluginEvent = function (e) {
            var _a;
            switch (e.eventType) {
                case 22 /* SelectionChanged */:
                    if (e.selectionRangeEx &&
                        e.selectionRangeEx.type === 2 /* ImageSelection */ &&
                        this.options &&
                        this.options.onSelectState !== undefined) {
                        this.setEditingImage(e.selectionRangeEx.image, this.options.onSelectState);
                    }
                    break;
                case 5 /* MouseDown */:
                    // When left click in a image that already in editing mode, do not quit edit mode
                    var mouseTarget = e.rawEvent.target;
                    var button = e.rawEvent.button;
                    if (this.shadowSpan !== mouseTarget ||
                        (this.shadowSpan === mouseTarget && button !== 0) ||
                        this.isCropping) {
                        this.setEditingImage(null);
                    }
                    break;
                case 6 /* MouseUp */:
                    if (this.editor && this.image && this.shadowSpan) {
                        // When mouse up, if the image and the shadow span exists, the editing mode is on.
                        // To make sure the selection did not jump to the shadow root, reselect the image.
                        this.editor.select(this.image);
                    }
                    break;
                case 0 /* KeyDown */:
                    this.setEditingImage(null);
                    break;
                case 7 /* ContentChanged */:
                    //After contentChanged event, the current image wrapper may not be valid any more, remove all of them if any
                    this.removeWrapper();
                    break;
                case 8 /* ExtractContentWithDom */:
                    // When extract content, remove all image info since they may not be valid when load the content again
                    if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.imageSelector) {
                        (0, roosterjs_editor_dom_1.toArray)(e.clonedRoot.querySelectorAll(this.options.imageSelector)).forEach(function (img) {
                            (0, editInfo_1.deleteEditInfo)(img);
                        });
                    }
                    break;
                case 12 /* BeforeDispose */:
                    this.removeWrapper();
                    break;
            }
        };
        /**
         * Check if the given image edit operation is allowed by this plugin
         * @param operation The image edit operation to check
         * @returns True means it is allowed, otherwise false
         */
        ImageEdit.prototype.isOperationAllowed = function (operation) {
            return !!(this.allowedOperations & operation);
        };
        ImageEdit.prototype.setEditingImage = function (image, operationOrSelect) {
            var _this = this;
            var operation = typeof operationOrSelect === 'number' ? operationOrSelect : 0 /* None */;
            var selectImage = typeof operationOrSelect === 'number' ? false : !!operationOrSelect;
            if (!image &&
                this.image &&
                this.editor &&
                this.editInfo &&
                this.lastSrc &&
                this.clonedImage) {
                // When there is image in editing, clean up any cached objects and elements
                this.clearDndHelpers();
                // Apply the changes, and add undo snapshot if necessary
                (0, applyChange_1.default)(this.editor, this.image, this.editInfo, this.lastSrc, this.wasResized || this.isCropping, this.clonedImage);
                // Remove editing wrapper
                this.removeWrapper();
                this.editor.addUndoSnapshot(function () { return _this.image; }, "ImageResize" /* ImageResize */);
                if (selectImage) {
                    this.editor.select(this.image);
                }
                this.image = null;
                this.editInfo = null;
                this.lastSrc = null;
                this.clonedImage = null;
                this.isCropping = false;
            }
            if (!this.image && (image === null || image === void 0 ? void 0 : image.isContentEditable) && this.editor) {
                // If there is new image to edit, enter editing mode for this image
                this.editor.addUndoSnapshot();
                this.image = image;
                // Get initial edit info
                this.editInfo = (0, editInfo_1.getEditInfoFromImage)(image);
                //Check if the image was resized by the user
                this.wasResized = checkIfImageWasResized(this.image);
                operation =
                    ((0, canRegenerateImage_1.default)(image) ? operation : 3 /* Resize */) &
                        this.allowedOperations;
                // Create and update editing wrapper and elements
                this.createWrapper(operation);
                this.updateWrapper();
                // Init drag and drop
                this.dndHelpers = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(this.createDndHelpers("r_resizeH" /* ResizeHandle */, Resizer_1.Resizer)), false), (0, tslib_1.__read)(this.createDndHelpers("r_rotateH" /* RotateHandle */, Rotator_1.Rotator)), false), (0, tslib_1.__read)(this.createDndHelpers("r_cropH" /* CropHandle */, Cropper_1.Cropper)), false), (0, tslib_1.__read)(this.createDndHelpers("r_cropC" /* CropContainer */, Cropper_1.Cropper)), false);
                this.editor.select(this.image);
            }
        };
        /**
         * Flip the image.
         * @param image The image to be flipped
         * @param direction
         */
        ImageEdit.prototype.flipImage = function (image, direction) {
            var _a;
            this.image = image;
            this.editInfo = (0, editInfo_1.getEditInfoFromImage)(image);
            var angleRad = this.editInfo.angleRad;
            var isInVerticalPostion = (angleRad >= Math.PI / 2 && angleRad < (3 * Math.PI) / 4) ||
                (angleRad <= -Math.PI / 2 && angleRad > (-3 * Math.PI) / 4);
            if (isInVerticalPostion) {
                if (direction === 'horizontal') {
                    this.editInfo.flippedVertical = !this.editInfo.flippedVertical;
                }
                else {
                    this.editInfo.flippedHorizontal = !this.editInfo.flippedHorizontal;
                }
            }
            else {
                if (direction === 'vertical') {
                    this.editInfo.flippedVertical = !this.editInfo.flippedVertical;
                }
                else {
                    this.editInfo.flippedHorizontal = !this.editInfo.flippedHorizontal;
                }
            }
            this.createWrapper(4 /* Rotate */);
            this.updateWrapper();
            this.setEditingImage(null);
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.select(image);
        };
        /**
         * Rotate the image in radian angle.
         * @param image The image to be rotated
         * @param angleRad The angle in radian that the image must be rotated.
         */
        ImageEdit.prototype.rotateImage = function (image, angleRad) {
            var _a;
            this.image = image;
            this.editInfo = (0, editInfo_1.getEditInfoFromImage)(image);
            this.editInfo.angleRad = this.editInfo.angleRad + angleRad;
            this.createWrapper(4 /* Rotate */);
            this.updateWrapper();
            this.setEditingImage(null);
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.select(image);
        };
        /**
         * Create editing wrapper for the image
         */
        ImageEdit.prototype.createWrapper = function (operation) {
            var _this = this;
            var _a, _b;
            if (this.image && this.editor && this.options && this.editInfo) {
                //Clone the image and insert the clone in a entity
                this.clonedImage = this.image.cloneNode(true);
                this.clonedImage.removeAttribute('id');
                this.clonedImage.style.removeProperty('max-width');
                this.clonedImage.style.removeProperty('max-height');
                this.clonedImage.style.width = this.editInfo.widthPx + 'px';
                this.clonedImage.style.height = this.editInfo.heightPx + 'px';
                this.wrapper = (0, roosterjs_editor_dom_1.createElement)(6 /* ImageEditWrapper */, this.image.ownerDocument);
                (_b = (_a = this.wrapper) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.appendChild(this.clonedImage);
                this.wrapper.style.display = roosterjs_editor_dom_1.Browser.isSafari ? 'inline-block' : 'inline-flex';
                // Cache current src so that we can compare it after edit see if src is changed
                this.lastSrc = this.image.getAttribute('src');
                // Set image src to original src to help show editing UI, also it will be used when regenerate image dataURL after editing
                if (this.clonedImage) {
                    this.clonedImage.src = this.editInfo.src;
                    this.clonedImage.style.position = 'absolute';
                }
                // Get HTML for all edit elements (resize handle, rotate handle, crop handle and overlay, ...) and create HTML element
                var options_1 = {
                    borderColor: getColorString(this.options.borderColor, this.editor.isDarkMode()),
                    rotateIconHTML: this.options.rotateIconHTML,
                    rotateHandleBackColor: this.editor.isDarkMode()
                        ? DARK_MODE_BGCOLOR
                        : LIGHT_MODE_BGCOLOR,
                    isSmallImage: isASmallImage(this.editInfo.widthPx, this.editInfo.heightPx),
                };
                var htmlData_1 = [(0, Resizer_1.getResizeBordersHTML)(options_1)];
                (0, roosterjs_editor_dom_1.getObjectKeys)(ImageEditHTMLMap).forEach(function (thisOperation) {
                    var element = ImageEditHTMLMap[thisOperation](options_1, _this.onShowResizeHandle);
                    if ((operation & thisOperation) == thisOperation && element) {
                        (0, roosterjs_editor_dom_1.arrayPush)(htmlData_1, element);
                    }
                });
                htmlData_1.forEach(function (data) {
                    var element = (0, roosterjs_editor_dom_1.createElement)(data, _this.image.ownerDocument);
                    if (element && _this.wrapper) {
                        _this.wrapper.appendChild(element);
                    }
                });
                this.insertImageWrapper(this.wrapper);
            }
        };
        /**
         * EXPORTED FOR TESTING PURPOSES ONLY
         * @param wrapper
         */
        ImageEdit.prototype.insertImageWrapper = function (wrapper) {
            if (this.image) {
                this.shadowSpan = (0, roosterjs_editor_dom_1.wrap)(this.image, 'span');
                if (this.shadowSpan) {
                    var shadowRoot = this.shadowSpan.attachShadow({
                        mode: 'open',
                    });
                    this.shadowSpan.style.verticalAlign = 'bottom';
                    wrapper.style.fontSize = '24px';
                    if (this.options.applyChangesOnMouseUp) {
                        wrapper.addEventListener('mouseup', this.changesWhenMouseUp, true /* useCapture*/);
                    }
                    shadowRoot.appendChild(wrapper);
                }
            }
        };
        /**
         * Create drag and drop helpers
         * @param wrapper
         * @param elementClass
         * @param dragAndDrop
         */
        ImageEdit.prototype.createDndHelpers = function (elementClass, dragAndDrop) {
            var _this = this;
            var wrapper = this.wrapper;
            return wrapper && this.editInfo
                ? getEditElements(wrapper, elementClass).map(function (element) {
                    return new DragAndDropHelper_1.default(element, {
                        editInfo: _this.editInfo,
                        options: _this.options,
                        elementClass: elementClass,
                        x: element.dataset.x,
                        y: element.dataset.y,
                    }, _this.updateWrapper, dragAndDrop, _this.editor ? _this.editor.getZoomScale() : 1);
                })
                : [];
        };
        /**
         * Clean up drag and drop helpers
         */
        ImageEdit.prototype.clearDndHelpers = function () {
            var _a;
            (_a = this.dndHelpers) === null || _a === void 0 ? void 0 : _a.forEach(function (helper) { return helper.dispose(); });
            this.dndHelpers = [];
        };
        return ImageEdit;
    }());
    exports.default = ImageEdit;
    function setSize(element, left, top, right, bottom, width, height) {
        element.style.left = left !== undefined ? getPx(left) : element.style.left;
        element.style.top = top !== undefined ? getPx(top) : element.style.top;
        element.style.right = right !== undefined ? getPx(right) : element.style.right;
        element.style.bottom = bottom !== undefined ? getPx(bottom) : element.style.bottom;
        element.style.width = width !== undefined ? getPx(width) : element.style.width;
        element.style.height = height !== undefined ? getPx(height) : element.style.height;
    }
    function setWrapperSizeDimensions(wrapper, image, width, height) {
        var hasBorder = image.style.borderStyle;
        if (hasBorder) {
            var borderWidth = image.style.borderWidth ? 2 * parseInt(image.style.borderWidth) : 2;
            wrapper.style.width = getPx(width + borderWidth);
            wrapper.style.height = getPx(height + borderWidth);
            return;
        }
        wrapper.style.width = getPx(width);
        wrapper.style.height = getPx(height);
    }
    function getPx(value) {
        return value + 'px';
    }
    function getEditElements(wrapper, elementClass) {
        return (0, roosterjs_editor_dom_1.toArray)(wrapper.querySelectorAll('.' + elementClass));
    }
    function isRtl(element) {
        return (0, roosterjs_editor_dom_1.safeInstanceOf)(element, 'HTMLElement')
            ? (0, roosterjs_editor_dom_1.getComputedStyle)(element, 'direction') == 'rtl'
            : false;
    }
    function handleRadIndexCalculator(angleRad) {
        var idx = Math.round(angleRad / DirectionRad) % DIRECTIONS;
        return idx < 0 ? idx + DIRECTIONS : idx;
    }
    function rotateHandles(angleRad, y, x) {
        if (y === void 0) { y = ''; }
        if (x === void 0) { x = ''; }
        var radIndex = handleRadIndexCalculator(angleRad);
        var originalDirection = y + x;
        var originalIndex = DirectionOrder.indexOf(originalDirection);
        var rotatedIndex = originalIndex >= 0 && originalIndex + radIndex;
        return rotatedIndex ? DirectionOrder[rotatedIndex % DIRECTIONS] : '';
    }
    /**
     * Rotate the resizer and cropper handles according to the image position.
     * @param handles The resizer handles.
     * @param angleRad The angle that the image was rotated.
     */
    function updateHandleCursor(handles, angleRad) {
        handles.forEach(function (handle) {
            var _a = handle.dataset, y = _a.y, x = _a.x;
            handle.style.cursor = rotateHandles(angleRad, y, x) + "-resize";
        });
    }
    function updateSideHandlesVisibility(handles, isSmall) {
        handles.forEach(function (handle) {
            var _a = handle.dataset, y = _a.y, x = _a.x;
            var coordinate = (y !== null && y !== void 0 ? y : '') + (x !== null && x !== void 0 ? x : '');
            var directions = ['n', 's', 'e', 'w'];
            var isSideHandle = directions.indexOf(coordinate) > -1;
            handle.style.display = isSideHandle && isSmall ? 'none' : '';
        });
    }
    /**
     * Check if the current image was resized by the user
     * @param image the current image
     * @returns if the user resized the image, returns true, otherwise, returns false
     */
    function checkIfImageWasResized(image) {
        var width = image.width, height = image.height, style = image.style;
        var isMaxWidthInitial = style.maxWidth === '' || style.maxWidth === 'initial' || style.maxWidth === 'auto';
        if (isMaxWidthInitial &&
            (isFixedNumberValue(style.height) ||
                isFixedNumberValue(style.width) ||
                isFixedNumberValue(width) ||
                isFixedNumberValue(height))) {
            return true;
        }
        else {
            return false;
        }
    }
    function isFixedNumberValue(value) {
        var numberValue = typeof value === 'string' ? parseInt(value) : value;
        return !isNaN(numberValue);
    }
    function isASmallImage(widthPx, heightPx) {
        return widthPx && heightPx && (widthPx < constants_1.MIN_HEIGHT_WIDTH || heightPx < constants_1.MIN_HEIGHT_WIDTH)
            ? true
            : false;
    }
    function getColorString(color, isDarkMode) {
        if (typeof color === 'string') {
            return color.trim();
        }
        return isDarkMode ? color.darkModeColor.trim() : color.lightModeColor.trim();
    }
    function setFlipped(element, flippedHorizontally, flippedVertically) {
        if (element) {
            element.style.transform = "scale(" + (flippedHorizontally ? -1 : 1) + ", " + (flippedVertically ? -1 : 1) + ")";
        }
    }
});
//# sourceMappingURL=ImageEdit.js.map