define(["require", "exports", "tslib"], function (require, exports, tslib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageEditInfoState = void 0;
    var RESIZE_KEYS = ['widthPx', 'heightPx'];
    var ROTATE_KEYS = ['angleRad'];
    var CROP_KEYS = [
        'leftPercent',
        'rightPercent',
        'topPercent',
        'bottomPercent',
    ];
    var ROTATE_CROP_KEYS = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(ROTATE_KEYS), false), (0, tslib_1.__read)(CROP_KEYS), false);
    var ALL_KEYS = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(ROTATE_CROP_KEYS), false), (0, tslib_1.__read)(RESIZE_KEYS), false);
    /**
     * @internal
     * State of an edit info object for image editing.
     * It is returned by checkEditInfoState() function
     */
    // eslint-disable-next-line etc/no-const-enum
    var ImageEditInfoState;
    (function (ImageEditInfoState) {
        /**
         * Invalid edit info. It means the given edit info object is either null,
         * or not all its member are of correct type
         */
        ImageEditInfoState[ImageEditInfoState["Invalid"] = 0] = "Invalid";
        /**
         * The edit info shows that it is only potentially edited by resizing action.
         * Image is not rotated or cropped, or event not changed at all.
         */
        ImageEditInfoState[ImageEditInfoState["ResizeOnly"] = 1] = "ResizeOnly";
        /**
         * When compare with another edit info, this value can be returned when both current
         * edit info and the other one are not been rotated, and they have same cropping
         * percentages. So that they can share the same image src, only width and height
         * need to be adjusted.
         */
        ImageEditInfoState[ImageEditInfoState["SameWithLast"] = 2] = "SameWithLast";
        /**
         * When this value is returned, it means the image is edited by either cropping or
         * rotation, or both. Image source can't be reused, need to generate a new image src
         * data uri.
         */
        ImageEditInfoState[ImageEditInfoState["FullyChanged"] = 3] = "FullyChanged";
    })(ImageEditInfoState = exports.ImageEditInfoState || (exports.ImageEditInfoState = {}));
    /**
     * @internal
     * Check the state of an edit info
     * @param editInfo The edit info to check
     * @param compareTo An optional edit info to compare to
     * @returns If the source edit info is not valid (wrong type, missing field, ...), returns Invalid.
     * If the source edit info doesn't contain any rotation or cropping, returns ResizeOnly
     * If the compare edit info exists, and both of them don't contain rotation, and the have same cropping values,
     * returns SameWithLast. Otherwise, returns FullyChanged
     */
    function checkEditInfoState(editInfo, compareTo) {
        if (!editInfo || !editInfo.src || ALL_KEYS.some(function (key) { return !isNumber(editInfo[key]); })) {
            return 0 /* Invalid */;
        }
        else if (ROTATE_CROP_KEYS.every(function (key) { return areSameNumber(editInfo[key], 0); }) &&
            !editInfo.flippedHorizontal &&
            !editInfo.flippedVertical &&
            (!compareTo || (compareTo && editInfo.angleRad === compareTo.angleRad))) {
            return 1 /* ResizeOnly */;
        }
        else if (compareTo &&
            ROTATE_KEYS.every(function (key) { return areSameNumber(editInfo[key], 0); }) &&
            ROTATE_KEYS.every(function (key) { return areSameNumber(compareTo[key], 0); }) &&
            CROP_KEYS.every(function (key) { return areSameNumber(editInfo[key], compareTo[key]); }) &&
            compareTo.flippedHorizontal === editInfo.flippedHorizontal &&
            compareTo.flippedVertical === editInfo.flippedVertical) {
            return 2 /* SameWithLast */;
        }
        else {
            return 3 /* FullyChanged */;
        }
    }
    exports.default = checkEditInfoState;
    function isNumber(o) {
        return typeof o === 'number';
    }
    function areSameNumber(n1, n2) {
        return Math.abs(n1 - n2) < 1e-3;
    }
});
//# sourceMappingURL=checkEditInfoState.js.map