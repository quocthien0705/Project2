define(["require", "exports", "tslib", "../constants/constants"], function (require, exports, tslib_1, constants_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getResizeBordersHTML = exports.getSideResizeHTML = exports.getCornerResizeHTML = exports.doubleCheckResize = exports.rotateCoordinate = exports.Resizer = void 0;
    var HandleTypes;
    (function (HandleTypes) {
        HandleTypes[HandleTypes["SquareHandles"] = 0] = "SquareHandles";
        HandleTypes[HandleTypes["CircularHandlesCorner"] = 1] = "CircularHandlesCorner";
    })(HandleTypes || (HandleTypes = {}));
    /**
     * @internal
     * The resize drag and drop handler
     */
    exports.Resizer = {
        onDragStart: function (_a) {
            var editInfo = _a.editInfo;
            return ((0, tslib_1.__assign)({}, editInfo));
        },
        onDragging: function (_a, e, base, deltaX, deltaY) {
            var _b;
            var x = _a.x, y = _a.y, editInfo = _a.editInfo, options = _a.options;
            var ratio = base.widthPx > 0 && base.heightPx > 0 ? (base.widthPx * 1.0) / base.heightPx : 0;
            _b = (0, tslib_1.__read)(rotateCoordinate(deltaX, deltaY, editInfo.angleRad), 2), deltaX = _b[0], deltaY = _b[1];
            if (options.minWidth !== undefined && options.minHeight !== undefined) {
                var horizontalOnly = x == '';
                var verticalOnly = y == '';
                var shouldPreserveRatio = !(horizontalOnly || verticalOnly) && (options.preserveRatio || e.shiftKey);
                var newWidth = horizontalOnly
                    ? base.widthPx
                    : Math.max(base.widthPx + deltaX * (x == 'w' ? -1 : 1), options.minWidth);
                var newHeight = verticalOnly
                    ? base.heightPx
                    : Math.max(base.heightPx + deltaY * (y == 'n' ? -1 : 1), options.minHeight);
                if (shouldPreserveRatio && ratio > 0) {
                    if (ratio > 1) {
                        // first sure newHeight is right，calculate newWidth
                        newWidth = newHeight * ratio;
                        if (newWidth < options.minWidth) {
                            newWidth = options.minWidth;
                            newHeight = newWidth / ratio;
                        }
                    }
                    else {
                        // first sure newWidth is right，calculate newHeight
                        newHeight = newWidth / ratio;
                        if (newHeight < options.minHeight) {
                            newHeight = options.minHeight;
                            newWidth = newHeight * ratio;
                        }
                    }
                }
                editInfo.widthPx = newWidth;
                editInfo.heightPx = newHeight;
                return true;
            }
            else {
                return false;
            }
        },
    };
    /**
     * @internal Calculate the rotated x and y distance for mouse moving
     * @param x Original x distance
     * @param y Original y distance
     * @param angle Rotated angle, in radian
     * @returns rotated x and y distances
     */
    function rotateCoordinate(x, y, angle) {
        if (x == 0 && y == 0) {
            return [0, 0];
        }
        var hypotenuse = Math.sqrt(x * x + y * y);
        angle = Math.atan2(y, x) - angle;
        return [hypotenuse * Math.cos(angle), hypotenuse * Math.sin(angle)];
    }
    exports.rotateCoordinate = rotateCoordinate;
    /**
     * @internal
     * Double check if the changed size can satisfy current width of container.
     * When resize an image and preserve ratio, its size can be limited by the size of container.
     * So we need to check the actual size and calculate the size again
     * @param editInfo Edit info of the image
     * @param preserveRatio Whether w/h ratio need to be preserved
     * @param actualWidth Actual width of the image after resize
     * @param actualHeight Actual height of the image after resize
     */
    function doubleCheckResize(editInfo, preserveRatio, actualWidth, actualHeight) {
        var widthPx = editInfo.widthPx, heightPx = editInfo.heightPx;
        var ratio = heightPx > 0 ? widthPx / heightPx : 0;
        actualWidth = Math.floor(actualWidth);
        actualHeight = Math.floor(actualHeight);
        widthPx = Math.floor(widthPx);
        heightPx = Math.floor(heightPx);
        editInfo.widthPx = actualWidth;
        editInfo.heightPx = actualHeight;
        if (preserveRatio && ratio > 0 && (widthPx !== actualWidth || heightPx !== actualHeight)) {
            if (actualWidth < widthPx) {
                editInfo.heightPx = actualWidth / ratio;
            }
            else {
                editInfo.widthPx = actualHeight * ratio;
            }
        }
    }
    exports.doubleCheckResize = doubleCheckResize;
    /**
     * @internal
     * Get HTML for resize handles at the corners
     */
    function getCornerResizeHTML(_a, onShowResizeHandle) {
        var resizeBorderColor = _a.borderColor;
        var result = [];
        constants_1.Xs.forEach(function (x) {
            return constants_1.Ys.forEach(function (y) {
                var elementData = (x == '') == (y == '')
                    ? getResizeHandleHTML(x, y, resizeBorderColor, 1 /* CircularHandlesCorner */)
                    : null;
                if (onShowResizeHandle && elementData) {
                    onShowResizeHandle(elementData, x, y);
                }
                if (elementData) {
                    result.push(elementData);
                }
            });
        });
        return result;
    }
    exports.getCornerResizeHTML = getCornerResizeHTML;
    /**
     * @internal
     * Get HTML for resize handles on the sides
     */
    function getSideResizeHTML(_a, onShowResizeHandle) {
        var resizeBorderColor = _a.borderColor;
        var result = [];
        constants_1.Xs.forEach(function (x) {
            return constants_1.Ys.forEach(function (y) {
                var elementData = (x == '') != (y == '')
                    ? getResizeHandleHTML(x, y, resizeBorderColor, 1 /* CircularHandlesCorner */)
                    : null;
                if (onShowResizeHandle && elementData) {
                    onShowResizeHandle(elementData, x, y);
                }
                if (elementData) {
                    result.push(elementData);
                }
            });
        });
        return result;
    }
    exports.getSideResizeHTML = getSideResizeHTML;
    /**
     * @internal
     * Get HTML for resize borders
     */
    function getResizeBordersHTML(_a) {
        var resizeBorderColor = _a.borderColor;
        return {
            tag: 'div',
            style: "position:absolute;left:0;right:0;top:0;bottom:0;border:solid 2px " + resizeBorderColor + ";pointer-events:none;",
        };
    }
    exports.getResizeBordersHTML = getResizeBordersHTML;
    function getResizeHandleHTML(x, y, borderColor, handleTypes) {
        var leftOrRight = x == 'w' ? 'left' : 'right';
        var topOrBottom = y == 'n' ? 'top' : 'bottom';
        var leftOrRightValue = x == '' ? '50%' : '0px';
        var topOrBottomValue = y == '' ? '50%' : '0px';
        var direction = y + x;
        return x == '' && y == ''
            ? null
            : {
                tag: 'div',
                style: "position:absolute;" + leftOrRight + ":" + leftOrRightValue + ";" + topOrBottom + ":" + topOrBottomValue,
                children: [
                    {
                        tag: 'div',
                        style: setHandleStyle[handleTypes](direction, topOrBottom, leftOrRight, borderColor),
                        className: "r_resizeH" /* ResizeHandle */,
                        dataset: { x: x, y: y },
                    },
                ],
            };
    }
    var setHandleStyle = {
        0: function (direction, leftOrRight, topOrBottom, borderColor) {
            return "position:relative;width:" + constants_1.RESIZE_HANDLE_SIZE + "px;height:" + constants_1.RESIZE_HANDLE_SIZE + "px;background-color: " + borderColor + ";cursor:" + direction + "-resize;" + topOrBottom + ":-" + constants_1.RESIZE_HANDLE_MARGIN + "px;" + leftOrRight + ":-" + constants_1.RESIZE_HANDLE_MARGIN + "px;";
        },
        1: function (direction, leftOrRight, topOrBottom) {
            return "position:relative;width:" + constants_1.RESIZE_HANDLE_SIZE + "px;height:" + constants_1.RESIZE_HANDLE_SIZE + "px;background-color: #FFFFFF;cursor:" + direction + "-resize;" + topOrBottom + ":-" + constants_1.RESIZE_HANDLE_MARGIN + "px;" + leftOrRight + ":-" + constants_1.RESIZE_HANDLE_MARGIN + "px;border-radius:100%;border: 2px solid #bfbfbf;box-shadow: 0px 0.36316px 1.36185px rgba(100, 100, 100, 0.25);";
        },
    };
});
//# sourceMappingURL=Resizer.js.map