{"version":3,"file":"HyperLink.js","sourceRoot":"","sources":["../../../../../packages/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChangeSource, Keys, PluginEventType } from 'roosterjs-editor-types';\nimport { isCharacterValue, isCtrlOrMetaPressed, matchLink } from 'roosterjs-editor-dom';\nimport type { DOMEventHandler, EditorPlugin, IEditor, PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * An editor plugin that show a tooltip for existing link\n */\nexport default class HyperLink implements EditorPlugin {\n    private originalHref: string | null = null;\n    private trackedLink: HTMLAnchorElement | null = null;\n    private editor: IEditor | null = null;\n    private disposer: (() => void) | null = null;\n\n    /**\n     * Create a new instance of HyperLink class\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\n     * Default value is to return the href itself. If null, there will be no tooltip text.\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\n     */\n    constructor(\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\n        private target?: string,\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Hyperlink';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n        this.disposer = editor.addDomEventHandler({\n            mouseover: <DOMEventHandler>this.onMouse,\n            mouseout: <DOMEventHandler>this.onMouse,\n            blur: <DOMEventHandler>this.onBlur,\n        });\n    }\n\n    protected onMouse = (e: MouseEvent) => {\n        const a = this.editor?.getElementAtCursor(\n            'a[href]',\n            <Node>e.target\n        ) as HTMLAnchorElement | null;\n        const href = a && this.tryGetHref(a);\n\n        if (href) {\n            this.editor?.setEditorDomAttribute(\n                'title',\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\n            );\n        }\n    };\n\n    protected onBlur = (e: FocusEvent) => {\n        if (this.trackedLink) {\n            this.updateLinkHrefIfShouldUpdate();\n        }\n\n        this.resetLinkTracking();\n    };\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent): void {\n        if (\n            event.eventType == PluginEventType.MouseUp ||\n            (event.eventType == PluginEventType.KeyUp &&\n                (!this.isContentEditValue(event.rawEvent) || event.rawEvent.which == Keys.SPACE)) ||\n            event.eventType == PluginEventType.ContentChanged\n        ) {\n            const anchor = this.editor?.getElementAtCursor(\n                'A[href]',\n                undefined /*startFrom*/,\n                event\n            ) as HTMLAnchorElement | null;\n\n            const shouldCheckUpdateLink =\n                (anchor && anchor !== this.trackedLink) ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.ContentChanged;\n\n            if (\n                event.eventType == PluginEventType.ContentChanged &&\n                event.source == ChangeSource.Keyboard &&\n                this.trackedLink != anchor &&\n                anchor\n            ) {\n                // For Keyboard event that causes content change (mostly come from Content Model), this tracked list may be staled.\n                // So we need to get an up-to-date link element\n                // TODO: This is a temporary solution. Later when Content Model can fully take over this behavior, we can remove this code.\n                this.trackedLink = anchor;\n            }\n\n            if (\n                this.trackedLink &&\n                (shouldCheckUpdateLink || this.tryGetHref(this.trackedLink) !== this.originalHref)\n            ) {\n                // If cursor has moved out of previously tracked link\n                // update link href if display text doesn't match href anymore.\n                if (shouldCheckUpdateLink) {\n                    this.updateLinkHrefIfShouldUpdate();\n                }\n\n                // If the link's href value was edited, or the cursor has moved out of the\n                // previously tracked link, stop tracking the link.\n                this.resetLinkTracking();\n            }\n\n            // Cache link and href value if its href attribute currently matches its display text\n            if (!this.trackedLink && anchor && this.doesLinkDisplayMatchHref(anchor)) {\n                this.trackedLink = anchor;\n                this.originalHref = this.tryGetHref(anchor);\n            }\n        }\n\n        if (event.eventType == PluginEventType.MouseUp) {\n            const anchor = this.editor?.getElementAtCursor(\n                'A',\n                <Node>event.rawEvent.srcElement\n            ) as HTMLAnchorElement | null;\n\n            if (anchor) {\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\n                    return;\n                }\n\n                let href: string | null;\n                if (\n                    (href = this.tryGetHref(anchor)) &&\n                    isCtrlOrMetaPressed(event.rawEvent) &&\n                    event.rawEvent.button === 0\n                ) {\n                    event.rawEvent.preventDefault();\n                    try {\n                        const target = this.target || '_blank';\n                        const window = this.editor?.getDocument().defaultView;\n                        window?.open(href, target);\n                    } catch {}\n                }\n            }\n        }\n    }\n\n    /**\n     * Try get href from an anchor element\n     * The reason this is put in a try-catch is that\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\n     */\n    private tryGetHref(anchor: HTMLAnchorElement): string | null {\n        try {\n            return anchor ? anchor.href : null;\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Determines if KeyboardEvent is meant to edit content\n     */\n    private isContentEditValue(event: KeyboardEvent): boolean {\n        return (\n            isCharacterValue(event) || event.which == Keys.BACKSPACE || event.which == Keys.DELETE\n        );\n    }\n\n    /**\n     * Updates the href of the tracked link if the display text doesn't match href anymore\n     */\n    private updateLinkHrefIfShouldUpdate() {\n        if (this.trackedLink && !this.doesLinkDisplayMatchHref(this.trackedLink)) {\n            this.updateLinkHref();\n        }\n    }\n\n    /**\n     * Clears the tracked link and its original href value so that it's back to default state\n     */\n    private resetLinkTracking() {\n        this.trackedLink = null;\n        this.originalHref = '';\n    }\n\n    /**\n     * Compares the normalized URL of inner text of element to its href to see if they match.\n     */\n    private doesLinkDisplayMatchHref(element: HTMLAnchorElement): boolean {\n        if (element) {\n            const display = element.innerText.trim();\n\n            // We first escape the display text so that any text passed into the regex is not\n            // treated as a special character.\n            const escapedDisplay = display.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n            const rule = new RegExp(`^(?:https?:\\\\/\\\\/)?${escapedDisplay}\\\\/?`, 'i');\n            const href = this.tryGetHref(element);\n            if (href !== null) {\n                return rule.test(href);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Update href of an element in place to new display text if it's a valid URL\n     */\n    private updateLinkHref() {\n        if (this.trackedLink) {\n            const linkData = matchLink(this.trackedLink.innerText.trim());\n            if (linkData !== null) {\n                this.editor?.addUndoSnapshot(() => {\n                    this.trackedLink!.href = linkData!.normalizedUrl;\n                });\n            }\n        }\n    }\n}\n"]}