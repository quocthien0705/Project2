{"version":3,"file":"markdownFeatures.js","sourceRoot":"","sources":["../../../../../../packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.ts"],"names":[],"mappings":"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","sourcesContent":["import { cacheGetEventData, createRange, Position, wrap } from 'roosterjs-editor-dom';\nimport { ChangeSource, Keys, PositionType } from 'roosterjs-editor-types';\nimport type { CompatibleKeys } from 'roosterjs-editor-types/lib/compatibleTypes';\nimport type {\n    BuildInEditFeature,\n    IEditor,\n    MarkdownFeatureSettings,\n    NodePosition,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\n\nconst ZERO_WIDTH_SPACE = '\\u200B';\n\nfunction generateBasicMarkdownFeature(\n    key: Keys | CompatibleKeys,\n    triggerCharacter: string,\n    elementTag: string,\n    useShiftKey: boolean\n): BuildInEditFeature<PluginKeyboardEvent> {\n    return {\n        keys: [key],\n        shouldHandleEvent: (event, editor) =>\n            event.rawEvent.shiftKey === useShiftKey &&\n            !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter),\n        handleEvent: (event, editor) => {\n            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.\n            editor.runAsync(editor => {\n                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);\n            });\n        },\n    };\n}\n\nfunction cacheGetRangeForMarkdownOperation(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string\n): Range | null {\n    return cacheGetEventData(event, 'MARKDOWN_RANGE', (): Range | null => {\n        const searcher = editor.getContentSearcherOfCursor(event);\n\n        let startPosition: NodePosition | null = null;\n        let endPosition: NodePosition | null = null;\n        searcher?.forEachTextInlineElement(textInlineElement => {\n            if (endPosition && startPosition) {\n                return true;\n            }\n            const inlineTextContent = textInlineElement.getTextContent();\n\n            // special case for immediately preceding character being whitespace\n            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {\n                return false;\n            }\n\n            //if the text is pasted, it might create a inner element inside the text element,\n            // then is necessary to check the parent block to get whole text\n            const parentBlockText = textInlineElement.getParentBlock().getTextContent();\n\n            // special case for consecutive trigger characters\n            // check parent block in case of pasted text\n            if (parentBlockText[parentBlockText.length - 1].trim() === triggerCharacter) {\n                return false;\n            }\n\n            if (!endPosition) {\n                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);\n            }\n            if (inlineTextContent[0] == triggerCharacter) {\n                startPosition = textInlineElement.getStartPosition();\n            } else {\n                let contentIndex = inlineTextContent.length - 1;\n                for (; contentIndex > 0; contentIndex--) {\n                    if (startPosition) {\n                        return true;\n                    }\n                    if (\n                        inlineTextContent[contentIndex] == triggerCharacter &&\n                        inlineTextContent[contentIndex - 1].trim().length == 0\n                    ) {\n                        startPosition = textInlineElement.getStartPosition().move(contentIndex);\n                        return true;\n                    }\n                }\n            }\n        });\n        return startPosition && endPosition && createRange(startPosition, endPosition);\n    });\n}\n\nfunction handleMarkdownEvent(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string,\n    elementTag: string\n) {\n    editor.addUndoSnapshot(\n        () => {\n            const range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);\n            if (!range) {\n                return;\n            }\n            const lastTypedTriggerPosition = new Position(range.endContainer, PositionType.End);\n            const hasLastTypedTrigger = range.endOffset + 1 <= lastTypedTriggerPosition.offset;\n            if (!!range && hasLastTypedTrigger) {\n                // get the text content range\n                const textContentRange = range.cloneRange();\n                textContentRange.setStart(\n                    textContentRange.startContainer,\n                    textContentRange.startOffset + 1\n                );\n\n                const text = textContentRange.extractContents().textContent;\n                const textNode = editor.getDocument().createTextNode(text ?? '');\n\n                // extract content and put it into a new element.\n                const elementToWrap = wrap(textNode, elementTag);\n                //include last typed character\n                range.setEnd(range.endContainer, range.endOffset + 1);\n                range.deleteContents();\n\n                // ZWS here ensures we don't end up inside the newly created node.\n                const nonPrintedSpaceTextNode = editor\n                    .getDocument()\n                    .createTextNode(ZERO_WIDTH_SPACE);\n                range.insertNode(nonPrintedSpaceTextNode);\n                range.insertNode(elementToWrap);\n\n                editor.select(nonPrintedSpaceTextNode, PositionType.End);\n            }\n        },\n        ChangeSource.Format,\n        true /*canUndoByBackspace*/\n    );\n}\n\n/**\n * Markdown bold feature. Make bold text with markdown shortcuts.\n */\nconst MarkdownBold: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.EIGHT_ASTERISK,\n    '*',\n    'b',\n    true /* useShiftKey */\n);\n\n/**\n * Markdown italics feature. Make italic text with markdown shortcuts.\n */\nconst MarkdownItalic: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.DASH_UNDERSCORE,\n    '_',\n    'i',\n    true /* useShiftKey */\n);\n\n/**\n * Markdown strikethrough feature. MAke strikethrough text with markdown shortcuts.\n */\nconst MarkdownStrikethrough: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '~',\n    's',\n    true /* useShiftKey */\n);\n\n/**\n * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.\n */\nconst MarkdownInlineCode: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '`',\n    'code',\n    false /* useShiftKey */\n);\n\n/**\n * @internal\n */\nexport const MarkdownFeatures: Record<\n    keyof MarkdownFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    markdownBold: MarkdownBold,\n    markdownItalic: MarkdownItalic,\n    markdownStrikethru: MarkdownStrikethrough,\n    markdownInlineCode: MarkdownInlineCode,\n};\n"]}