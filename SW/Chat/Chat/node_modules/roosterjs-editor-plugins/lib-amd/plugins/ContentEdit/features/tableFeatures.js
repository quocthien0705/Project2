define(["require", "exports", "roosterjs-editor-api", "roosterjs-editor-dom"], function (require, exports, roosterjs_editor_api_1, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableFeatures = void 0;
    /**
     * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table
     */
    var TabInTable = {
        keys: [9 /* TAB */],
        shouldHandleEvent: function (event, editor) {
            return cacheGetTableCell(event, editor) && !cacheIsWholeTableSelected(event, editor);
        },
        handleEvent: function (event, editor) {
            var _a, _b, _c;
            var shift = event.rawEvent.shiftKey;
            var td = cacheGetTableCell(event, editor);
            if (!td) {
                return;
            }
            var vtable = cacheVTable(event, td);
            for (var step = shift ? -1 : 1, row = (_a = vtable.row) !== null && _a !== void 0 ? _a : 0, col = ((_b = vtable.col) !== null && _b !== void 0 ? _b : 0) + step;; col += step) {
                var tableCells = (_c = vtable.cells) !== null && _c !== void 0 ? _c : [];
                if (col < 0 || col >= tableCells[row].length) {
                    row += step;
                    if (row < 0) {
                        editor.select(vtable.table, -2 /* Before */);
                        break;
                    }
                    else if (row >= tableCells.length) {
                        (0, roosterjs_editor_api_1.editTable)(editor, 1 /* InsertBelow */);
                        break;
                    }
                    col = shift ? tableCells[row].length - 1 : 0;
                }
                var cell = vtable.getCell(row, col);
                if (cell.td) {
                    var newPos = new roosterjs_editor_dom_1.Position(cell.td, 0 /* Begin */).normalize();
                    editor.select(newPos);
                    break;
                }
            }
            event.rawEvent.preventDefault();
        },
    };
    /**
     * IndentTableOnTab edit feature, provides the ability to indent the table if it is all cells are selected.
     */
    var IndentTableOnTab = {
        keys: [9 /* TAB */],
        shouldHandleEvent: function (event, editor) {
            return cacheGetTableCell(event, editor) && cacheIsWholeTableSelected(event, editor);
        },
        handleEvent: function (event, editor) {
            event.rawEvent.preventDefault();
            editor.addUndoSnapshot(function () {
                var shift = event.rawEvent.shiftKey;
                var selection = editor.getSelectionRangeEx();
                var td = cacheGetTableCell(event, editor);
                if (!td) {
                    return;
                }
                var vtable = cacheVTable(event, td);
                if (shift && editor.getElementAtCursor('blockquote', vtable.table, event)) {
                    (0, roosterjs_editor_api_1.setIndentation)(editor, 1 /* Decrease */);
                }
                else if (!shift) {
                    (0, roosterjs_editor_api_1.setIndentation)(editor, 0 /* Increase */);
                }
                if (selection.coordinates) {
                    editor.select(selection.table, selection.coordinates);
                }
            });
        },
    };
    /**
     * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN
     * in table
     */
    var UpDownInTable = {
        keys: [38 /* UP */, 40 /* DOWN */],
        shouldHandleEvent: function (event, editor) {
            return cacheGetTableCell(event, editor) && !cacheIsWholeTableSelected(event, editor);
        },
        handleEvent: function (event, editor) {
            var _a, _b, _c;
            var td = cacheGetTableCell(event, editor);
            if (!td) {
                return;
            }
            var vtable = new roosterjs_editor_dom_1.VTable(td);
            var isUp = event.rawEvent.which == 38 /* UP */;
            var step = isUp ? -1 : 1;
            var hasShiftKey = event.rawEvent.shiftKey;
            var selection = (_a = editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
            var targetTd = null;
            if (selection) {
                var anchorNode_1 = selection.anchorNode, anchorOffset_1 = selection.anchorOffset;
                for (var row = (_b = vtable.row) !== null && _b !== void 0 ? _b : 0; row >= 0 && vtable.cells && row < vtable.cells.length; row += step) {
                    var cell = vtable.getCell(row, (_c = vtable.col) !== null && _c !== void 0 ? _c : 0);
                    if (cell.td && cell.td != td) {
                        targetTd = cell.td;
                        break;
                    }
                }
                editor.runAsync(function (editor) {
                    var _a;
                    var newContainer = editor.getElementAtCursor();
                    if ((0, roosterjs_editor_dom_1.contains)(vtable.table, newContainer) &&
                        !(0, roosterjs_editor_dom_1.contains)(td, newContainer, true /*treatSameNodeAsContain*/)) {
                        var newPos = targetTd
                            ? new roosterjs_editor_dom_1.Position(targetTd, 0 /* Begin */)
                            : new roosterjs_editor_dom_1.Position(vtable.table, isUp ? -2 /* Before */ : -3 /* After */);
                        if (hasShiftKey) {
                            newPos =
                                newPos.node.nodeType == 1 /* Element */ &&
                                    (0, roosterjs_editor_dom_1.isVoidHtmlElement)(newPos.node)
                                    ? new roosterjs_editor_dom_1.Position(newPos.node, newPos.isAtEnd ? -3 /* After */ : -2 /* Before */)
                                    : newPos;
                            var selection_1 = (_a = editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
                            if (anchorNode_1) {
                                selection_1 === null || selection_1 === void 0 ? void 0 : selection_1.setBaseAndExtent(anchorNode_1, anchorOffset_1, newPos.node, newPos.offset);
                            }
                        }
                        else {
                            editor.select(newPos.normalize());
                        }
                    }
                });
            }
        },
    };
    /**
     * Requires @see ExperimentalFeatures.DeleteTableWithBackspace
     * Delete a table selected with the table selector pressing Backspace key
     */
    var DeleteTableWithBackspace = {
        keys: [8 /* BACKSPACE */],
        shouldHandleEvent: function (event, editor) {
            return editor.isFeatureEnabled("DeleteTableWithBackspace" /* DeleteTableWithBackspace */) &&
                cacheIsWholeTableSelected(event, editor);
        },
        handleEvent: function (event, editor) {
            var td = cacheGetTableCell(event, editor);
            if (!td) {
                return;
            }
            var vtable = new roosterjs_editor_dom_1.VTable(td);
            vtable.edit(4 /* DeleteTable */);
            vtable.writeBack();
        },
    };
    function cacheGetTableCell(event, editor) {
        return (0, roosterjs_editor_dom_1.cacheGetEventData)(event, 'TABLE_CELL_FOR_TABLE_FEATURES', function () {
            var pos = editor.getFocusedPosition();
            var firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);
            return (firstTd && ((0, roosterjs_editor_dom_1.getTagOfNode)(firstTd) == 'LI' ? null : firstTd));
        });
    }
    function cacheIsWholeTableSelected(event, editor) {
        return (0, roosterjs_editor_dom_1.cacheGetEventData)(event, 'WHOLE_TABLE_SELECTED_FOR_FEATURES', function () {
            var td = cacheGetTableCell(event, editor);
            if (!td) {
                return false;
            }
            var vtable = cacheVTable(event, td);
            var selection = editor.getSelectionRangeEx();
            return (selection.type == 1 /* TableSelection */ &&
                selection.coordinates &&
                (0, roosterjs_editor_dom_1.isWholeTableSelected)(vtable, selection.coordinates));
        });
    }
    function cacheVTable(event, td) {
        return (0, roosterjs_editor_dom_1.cacheGetEventData)(event, 'VTABLE_FOR_TABLE_FEATURES', function () {
            return new roosterjs_editor_dom_1.VTable(td);
        });
    }
    /**
     * @internal
     */
    exports.TableFeatures = {
        tabInTable: TabInTable,
        upDownInTable: UpDownInTable,
        indentTableOnTab: IndentTableOnTab,
        deleteTableWithBackspace: DeleteTableWithBackspace,
    };
});
//# sourceMappingURL=tableFeatures.js.map