define(["require", "exports", "../utils/normalizeTableSelection", "../utils/clearState", "roosterjs-editor-dom", "../utils/getCellAtCursor", "../utils/getCellCoordinates", "../utils/getTableAtCursor", "../utils/prepareSelection", "../utils/restoreSelection", "../utils/selectTable", "../utils/setData", "../constants", "../utils/updateSelection"], function (require, exports, normalizeTableSelection_1, clearState_1, roosterjs_editor_dom_1, getCellAtCursor_1, getCellCoordinates_1, getTableAtCursor_1, prepareSelection_1, restoreSelection_1, selectTable_1, setData_1, constants_1, updateSelection_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.selectionInsideTableMouseMove = exports.handleMouseDownEvent = void 0;
    var LEFT_CLICK = 1;
    var RIGHT_CLICK = 3;
    /**
     * @internal
     */
    function handleMouseDownEvent(event, state, editor) {
        var _a;
        var _b = event.rawEvent, which = _b.which, shiftKey = _b.shiftKey, target = _b.target, detail = _b.detail;
        var table = editor.getElementAtCursor('table', target, event);
        var tripleClick = detail >= 3;
        if (table && !table.isContentEditable) {
            return;
        }
        var td = editor.getElementAtCursor(constants_1.TABLE_CELL_SELECTOR);
        if (which == RIGHT_CLICK && state.tableSelection && state.vTable && td) {
            //If the user is right clicking To open context menu
            var coord = (0, getCellCoordinates_1.getCellCoordinates)(state.vTable, td);
            if (coord) {
                var _c = (0, normalizeTableSelection_1.default)(state.vTable) || {}, firstCell = _c.firstCell, lastCell = _c.lastCell;
                if (firstCell &&
                    lastCell &&
                    coord.y >= firstCell.y &&
                    coord.y <= lastCell.y &&
                    coord.x >= firstCell.x &&
                    coord.x <= lastCell.x) {
                    state.firstTarget = state.vTable.getCell(firstCell.y, firstCell.x).td;
                    state.lastTarget = state.vTable.getCell(lastCell.y, lastCell.x).td;
                    if (state.firstTarget && state.lastTarget) {
                        var selection = (_a = editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
                        selection === null || selection === void 0 ? void 0 : selection.setBaseAndExtent(state.firstTarget, 0, state.lastTarget, 0);
                        (0, selectTable_1.selectTable)(editor, state);
                    }
                    return;
                }
            }
        }
        if (which == LEFT_CLICK) {
            if (!shiftKey && !tripleClick) {
                (0, clearState_1.clearState)(state, editor);
                if ((0, getTableAtCursor_1.getTableAtCursor)(editor, event.rawEvent.target)) {
                    var doc_1 = editor.getDocument() || document;
                    var mouseUpListener_1 = getOnMouseUp(state);
                    var mouseMoveListener_1 = onMouseMove(state, editor);
                    doc_1.addEventListener('mouseup', mouseUpListener_1, true /*setCapture*/);
                    doc_1.addEventListener('mousemove', mouseMoveListener_1, true /*setCapture*/);
                    state.mouseMoveDisposer = function () {
                        doc_1.removeEventListener('mouseup', mouseUpListener_1, true /*setCapture*/);
                        doc_1.removeEventListener('mousemove', mouseMoveListener_1, true /*setCapture*/);
                    };
                    state.startedSelection = true;
                }
            }
            if (shiftKey || tripleClick) {
                editor.runAsync(function (editor) {
                    var _a;
                    var sel = (_a = editor.getDocument().defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
                    var first = (0, getCellAtCursor_1.getCellAtCursor)(editor, sel === null || sel === void 0 ? void 0 : sel.anchorNode);
                    // Triple clicking a cell will select that cell only
                    // Assign last the same as first to make sure we can select the cell
                    var last = tripleClick ? first : (0, getCellAtCursor_1.getCellAtCursor)(editor, sel === null || sel === void 0 ? void 0 : sel.focusNode);
                    var firstTable = (0, getTableAtCursor_1.getTableAtCursor)(editor, first);
                    if (firstTable &&
                        (0, roosterjs_editor_dom_1.safeInstanceOf)(first, 'HTMLTableCellElement') &&
                        (0, roosterjs_editor_dom_1.safeInstanceOf)(last, 'HTMLTableCellElement')) {
                        state.vTable = new roosterjs_editor_dom_1.VTable(first);
                        var firstCord = (0, getCellCoordinates_1.getCellCoordinates)(state.vTable, first);
                        var lastCord = (0, getCellCoordinates_1.getCellCoordinates)(state.vTable, last);
                        if (!firstCord || !lastCord) {
                            return;
                        }
                        state.vTable.selection = {
                            firstCell: firstCord,
                            lastCell: lastCord,
                        };
                        state.firstTarget = first;
                        state.lastTarget = last;
                        (0, selectTable_1.selectTable)(editor, state);
                        state.tableSelection = true;
                        state.firstTable = firstTable;
                        state.targetTable = firstTable;
                        (0, updateSelection_1.updateSelection)(editor, first, 0);
                    }
                });
            }
        }
    }
    exports.handleMouseDownEvent = handleMouseDownEvent;
    function getOnMouseUp(state) {
        return function () {
            removeMouseUpEventListener(state);
        };
    }
    function onMouseMove(state, editor) {
        return function (event) {
            if (!editor.contains(event.target)) {
                return;
            }
            //If already in table selection and the new target is contained in the last target cell, no need to
            //Apply selection styles again.
            if (state.tableSelection &&
                state.firstTarget &&
                (0, roosterjs_editor_dom_1.contains)(state.lastTarget, event.target, true)) {
                (0, updateSelection_1.updateSelection)(editor, state.firstTarget, 0);
                event.preventDefault();
                return;
            }
            if ((0, roosterjs_editor_dom_1.getTagOfNode)(event.target) == 'TABLE') {
                event.preventDefault();
                return;
            }
            (0, setData_1.setData)(event.target, state, editor);
            // If there is a first target, but is not inside a table, no more actions to perform.
            if (state.firstTarget && !state.firstTable) {
                return;
            }
            //Ignore if
            // Is a DIV that only contains a Table
            // If the event target is not contained in the editor.
            if (state.lastTarget &&
                ((state.lastTarget.lastChild == state.lastTarget.firstChild &&
                    (0, roosterjs_editor_dom_1.getTagOfNode)(state.lastTarget.lastChild) == 'TABLE' &&
                    (0, roosterjs_editor_dom_1.getTagOfNode)(state.lastTarget) == 'DIV') ||
                    !editor.contains(state.lastTarget))) {
                event.preventDefault();
                return;
            }
            (0, prepareSelection_1.prepareSelection)(state, editor);
            var isNewTDContainingFirstTable = (0, roosterjs_editor_dom_1.safeInstanceOf)(state.lastTarget, 'HTMLTableCellElement')
                ? (0, roosterjs_editor_dom_1.contains)(state.lastTarget, state.firstTable)
                : false;
            if ((state.firstTable && state.firstTable == state.targetTable) ||
                isNewTDContainingFirstTable) {
                //When starting selection inside of a table and ends inside of the same table.
                selectionInsideTableMouseMove(event, state, editor);
            }
            else if (state.tableSelection) {
                (0, restoreSelection_1.restoreSelection)(state, editor);
            }
            if (state.tableSelection && state.firstTarget) {
                (0, updateSelection_1.updateSelection)(editor, state.firstTarget, 0);
                event.preventDefault();
            }
        };
    }
    /**
     * @internal
     */
    function selectionInsideTableMouseMove(event, state, editor) {
        var _a;
        if (state.firstTarget &&
            state.firstTable &&
            state.lastTarget != state.firstTarget &&
            state.lastTarget) {
            (0, updateSelection_1.updateSelection)(editor, state.firstTarget, 0);
            if (state.firstTable != state.targetTable &&
                ((_a = state.targetTable) === null || _a === void 0 ? void 0 : _a.contains(state.firstTable))) {
                //If selection started in a table that is inside of another table and moves to parent table
                //Make the firstTarget the TD of the parent table.
                state.firstTarget = editor.getElementAtCursor(constants_1.TABLE_CELL_SELECTOR, state.lastTarget);
            }
            if (state.firstTable && state.firstTarget) {
                state.tableSelection = true;
                state.vTable = state.vTable || new roosterjs_editor_dom_1.VTable(state.firstTable);
                var firstCell = (0, getCellCoordinates_1.getCellCoordinates)(state.vTable, state.firstTarget);
                var lastCell = (0, getCellCoordinates_1.getCellCoordinates)(state.vTable, state.lastTarget);
                if (!firstCell || !lastCell) {
                    return;
                }
                state.vTable.selection = {
                    firstCell: firstCell,
                    lastCell: lastCell,
                };
                (0, selectTable_1.selectTable)(editor, state);
            }
            event.preventDefault();
        }
        else if (state.lastTarget == state.firstTarget &&
            state.tableSelection &&
            state.firstTable &&
            state.firstTarget) {
            state.vTable = new roosterjs_editor_dom_1.VTable(state.firstTable);
            var cell = (0, getCellCoordinates_1.getCellCoordinates)(state.vTable, state.firstTarget);
            if (cell) {
                state.vTable.selection = {
                    firstCell: cell,
                    lastCell: cell,
                };
            }
            (0, selectTable_1.selectTable)(editor, state);
        }
    }
    exports.selectionInsideTableMouseMove = selectionInsideTableMouseMove;
    function removeMouseUpEventListener(state) {
        var _a;
        if (state.startedSelection) {
            state.startedSelection = false;
            (_a = state.mouseMoveDisposer) === null || _a === void 0 ? void 0 : _a.call(state);
        }
    }
});
//# sourceMappingURL=handleMouseDownEvent.js.map