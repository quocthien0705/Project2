define(["require", "exports", "../utils/getCellAtCursor", "../utils/getCellCoordinates", "../utils/isAfter", "../utils/prepareSelection", "../utils/selectTable", "../utils/setData", "../constants", "../utils/updateSelection", "roosterjs-editor-dom"], function (require, exports, getCellAtCursor_1, getCellCoordinates_1, isAfter_1, prepareSelection_1, selectTable_1, setData_1, constants_1, updateSelection_1, roosterjs_editor_dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleKeyDownEvent = void 0;
    /**
     * @internal
     */
    function handleKeyDownEvent(event, state, editor) {
        var _a = event.rawEvent, shiftKey = _a.shiftKey, ctrlKey = _a.ctrlKey, metaKey = _a.metaKey, which = _a.which, defaultPrevented = _a.defaultPrevented;
        if ((shiftKey && (ctrlKey || metaKey)) || which == 16 /* SHIFT */ || defaultPrevented) {
            state.preventKeyUp = defaultPrevented;
            return;
        }
        var range = editor.getSelectionRangeEx();
        if (shiftKey) {
            if (!state.firstTarget) {
                var pos = editor.getFocusedPosition();
                var cell = pos && (0, getCellAtCursor_1.getCellAtCursor)(editor, pos.node);
                state.firstTarget = cell;
            }
            //If first target is not a table cell, we should ignore this plugin
            if (!(0, roosterjs_editor_dom_1.safeInstanceOf)(state.firstTarget, 'HTMLTableCellElement')) {
                return;
            }
            editor.runAsync(function (editor) {
                var pos = editor.getFocusedPosition();
                var newTarget = state.tableSelection ? state.lastTarget : pos === null || pos === void 0 ? void 0 : pos.node;
                if (newTarget) {
                    (0, setData_1.setData)(newTarget, state, editor);
                }
                if (state.firstTable == state.targetTable) {
                    if (!shouldConvertToTableSelection(state, editor) && !state.tableSelection) {
                        return;
                    }
                    //When selection start and end is inside of the same table
                    handleKeySelectionInsideTable(event, state, editor);
                }
                else if (state.tableSelection) {
                    if (state.firstTable) {
                        editor.select(state.firstTable, null /* coordinates */);
                    }
                    state.tableSelection = false;
                }
            });
        }
        else if ((range === null || range === void 0 ? void 0 : range.type) == 1 /* TableSelection */ &&
            (!(0, roosterjs_editor_dom_1.isCtrlOrMetaPressed)(event.rawEvent) || which == 36 /* HOME */ || which == 35 /* END */)) {
            // Select all content in the first cell
            var row = range.ranges[0];
            var firstCell = row.startContainer.childNodes[row.startOffset];
            var children = firstCell.childNodes;
            var contentRange = (0, roosterjs_editor_dom_1.createRange)(children[0], children[children.length - 1]);
            editor.select(contentRange);
        }
    }
    exports.handleKeyDownEvent = handleKeyDownEvent;
    /**
     * @internal
     */
    function handleKeySelectionInsideTable(event, state, editor) {
        var _a, _b;
        state.firstTarget = (0, getCellAtCursor_1.getCellAtCursor)(editor, state.firstTarget);
        state.lastTarget = (0, getCellAtCursor_1.getCellAtCursor)(editor, state.lastTarget);
        (0, updateSelection_1.updateSelection)(editor, state.firstTarget, 0);
        state.vTable = state.vTable || new roosterjs_editor_dom_1.VTable(state.firstTable);
        var firstCell = (0, getCellCoordinates_1.getCellCoordinates)(state.vTable, state.firstTarget);
        var lastCell = getNextTD(event, editor, state);
        if (!firstCell || !lastCell) {
            return;
        }
        state.vTable.selection = {
            firstCell: firstCell,
            lastCell: lastCell,
        };
        var selection = state.vTable.selection;
        if (!selection.lastCell ||
            (state.vTable.cells && selection.lastCell.y > state.vTable.cells.length - 1) ||
            selection.lastCell.y == -1) {
            //When selection is moving from inside of a table to outside
            state.lastTarget = editor.getElementAtCursor(constants_1.TABLE_CELL_SELECTOR + ',div', (_a = state.firstTable) !== null && _a !== void 0 ? _a : undefined);
            if ((0, roosterjs_editor_dom_1.safeInstanceOf)(state.lastTarget, 'HTMLTableCellElement')) {
                (0, prepareSelection_1.prepareSelection)(state, editor);
            }
            else {
                var position = state.targetTable &&
                    new roosterjs_editor_dom_1.Position(state.targetTable, selection.lastCell.y == null || selection.lastCell.y == -1
                        ? -2 /* Before */
                        : -3 /* After */);
                var sel = (_b = editor.getDocument().defaultView) === null || _b === void 0 ? void 0 : _b.getSelection();
                var _c = sel || {}, anchorNode = _c.anchorNode, anchorOffset = _c.anchorOffset;
                if (sel &&
                    anchorNode &&
                    anchorOffset != undefined &&
                    anchorOffset != null &&
                    position) {
                    editor.select(sel.getRangeAt(0));
                    sel.setBaseAndExtent(anchorNode, anchorOffset, position.node, position.offset);
                    state.lastTarget = position.node;
                    event.rawEvent.preventDefault();
                    return;
                }
            }
        }
        (0, selectTable_1.selectTable)(editor, state);
        var isBeginAboveEnd = (0, isAfter_1.isAfter)(state.firstTarget, state.lastTarget);
        if (state.lastTarget) {
            var targetPosition = new roosterjs_editor_dom_1.Position(state.lastTarget, isBeginAboveEnd ? 0 /* Begin */ : -1 /* End */);
            (0, updateSelection_1.updateSelection)(editor, targetPosition.node, targetPosition.offset);
        }
        state.tableSelection = true;
        event.rawEvent.preventDefault();
    }
    function getNextTD(event, editor, state) {
        var _a;
        state.lastTarget =
            state.lastTarget && editor.getElementAtCursor(constants_1.TABLE_CELL_SELECTOR, state.lastTarget);
        if ((0, roosterjs_editor_dom_1.safeInstanceOf)(state.lastTarget, 'HTMLTableCellElement') && ((_a = state.vTable) === null || _a === void 0 ? void 0 : _a.cells)) {
            var coordinates = (0, getCellCoordinates_1.getCellCoordinates)(state.vTable, state.lastTarget);
            if (state.tableSelection && coordinates) {
                switch (event.rawEvent.which) {
                    case 39 /* RIGHT */:
                        coordinates.x += state.lastTarget.colSpan;
                        if (state.vTable.cells[coordinates.y][coordinates.x] == null) {
                            coordinates.x = state.vTable.cells[coordinates.y].length - 1;
                            coordinates.y++;
                        }
                        break;
                    case 37 /* LEFT */:
                        if (coordinates.x == 0) {
                            coordinates.y--;
                        }
                        else {
                            coordinates.x--;
                        }
                        break;
                    case 38 /* UP */:
                        coordinates.y--;
                        break;
                    case 40 /* DOWN */:
                        coordinates.y++;
                        break;
                }
            }
            if (coordinates && coordinates.y >= 0 && coordinates.x >= 0) {
                state.lastTarget = state.vTable.getTd(coordinates.y, coordinates.x);
            }
            return coordinates;
        }
        return undefined;
    }
    function shouldConvertToTableSelection(state, editor) {
        if (!state.firstTable || !editor) {
            return false;
        }
        var regions = editor.getSelectedRegions();
        if (regions.length == 1) {
            return false;
        }
        var result = true;
        regions.forEach(function (value) {
            if (!(0, roosterjs_editor_dom_1.contains)(state.firstTable, value.rootNode)) {
                result = false;
            }
        });
        return result;
    }
});
//# sourceMappingURL=handleKeyDownEvent.js.map