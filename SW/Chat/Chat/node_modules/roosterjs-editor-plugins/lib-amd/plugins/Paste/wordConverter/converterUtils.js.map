{"version":3,"file":"converterUtils.js","sourceRoot":"","sources":["../../../../../../packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.ts"],"names":[],"mappings":";;;;IASA,oCAAoC;IACpC,IAAM,YAAY,GAAG,CAAC,CAAC;IAEvB,4DAA4D;IAC5D,IAAM,0BAA0B,GAAG,cAAc,CAAC;IAElD,oCAAoC;IACpC,IAAM,mBAAmB,GAAG,UAAU,CAAC;IAEvC,8CAA8C;IAC9C,IAAM,WAAW,GAAG,WAAW,CAAC;IAEhC;;;;;;OAMG;IACH,SAAgB,qBAAqB,CAAC,aAA4B;;QAC9D,IAAM,IAAI,GAAG,aAAa,CAAC,iBAAiB,CAAC;QAC7C,IAAI,CAAC,IAAI,EAAE;YACP,OAAO,KAAK,CAAC;SAChB;QACD,OAAO,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YAC1C,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAEhD,sDAAsD;YACtD,IAAM,YAAY,GAAG,mBAAmB,CAAC,IAAI,CAAC,CAAC;YAC/C,IAAI,YAAY,EAAE;gBACd,IAAM,SAAS,GACX,IAAI,CAAC,sBAAsB,CAAC,YAAY,CAAC,KAAK,GAAG,CAAC,CAAC,IAAI,IAAA,6BAAgB,GAAE,CAAC;gBAC9E,IAAI,CAAC,sBAAsB,CAAC,YAAY,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,SAAS,CAAC;gBAEhE,+EAA+E;gBAC/E,IAAI,IAAI,CAAC,iBAAiB,IAAI,sBAAsB,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,iBAAiB,EAAE;oBAClF,wGAAwG;oBACxG,qDAAqD;oBACrD,iBAAiB,CAAC,IAAI,CAAC,CAAC;iBAC3B;gBAED,8DAA8D;gBAC9D,IAAI,YAAY,GAAG,SAAS,CAAC,aAAa,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBACpE,IAAI,CAAC,YAAY,EAAE;oBACf,mGAAmG;oBACnG,IAAM,eAAe,GAAG,iBAAiB,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;oBAE9D,4FAA4F;oBAC5F,uCAAuC;oBACvC,YAAY,GAAG;wBACX,aAAa,EAAE,CAAC;wBAChB,YAAY,EAAE,aAAa,CAAC,YAAY,EAAE;wBAC1C,eAAe,EAAE,eAAe;wBAEhC,kFAAkF;wBAClF,oFAAoF;wBACpF,mBAAmB;wBACnB,MAAM,EAAE,CAAC,eAAe,IAAI,eAAe,CAAC,MAAM,IAAI,CAAC;wBAEvD,+GAA+G;wBAC/G,wHAAwH;wBACxH,OAAO,EAAE,oBAAoB,CAAC,eAAe,CAAC;qBACjD,CAAC;oBACF,SAAS,CAAC,aAAa,CAAC,YAAY,CAAC,UAAU,CAAC,GAAG,YAAY,CAAC;oBAChE,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,GAAG,YAAY,CAAC;iBACnE;qBAAM,IAAI,CAAC,YAAY,CAAC,MAAM,IAAI,YAAY,CAAC,aAAa,IAAI,CAAC,EAAE;oBAChE,qFAAqF;oBACrF,iFAAiF;oBACjF,kFAAkF;oBAClF,kCAAkC;oBAClC,IAAM,gBAAgB,GAAG,iBAAiB,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;oBAC/D,YAAY,CAAC,OAAO;wBAChB,YAAY,CAAC,eAAe,IAAI,gBAAgB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;iBACtE;gBAED,gCAAgC;gBAChC,YAAY,CAAC,YAAY,GAAG,YAAY,CAAC,YAAY,CAAC;gBAEtD,2FAA2F;gBAC3F,gFAAgF;gBAChF,IACI,YAAY,CAAC,MAAM;oBACnB,CAAC,YAAY,CAAC,OAAO,IAAI,IAAI;wBACzB,YAAY,CAAC,aAAa,GAAG,CAAC;wBAC9B,SAAS,CAAC,mBAAmB,IAAI,YAAY,CAAC,YAAY,CAAC,EACjE;oBACE,iFAAiF;oBACjF,4BAA4B;oBAC5B,YAAY,CAAC,MAAM,GAAG,IAAI,CAAC;oBAC3B,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,mBAAmB,GAAG,CAAC,CAAC,CAAC;oBACxD,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,sBAAsB,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;iBACzE;qBAAM;oBACH,uFAAuF;oBACvF,uFAAuF;oBACvF,2BAA2B;oBAC3B,IAAI,IAAI,CAAC,sBAAsB,CAAC,MAAM,GAAG,YAAY,CAAC,KAAK,EAAE;wBACzD,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,sBAAsB,CAAC,KAAK,CAC3D,CAAC,EACD,YAAY,CAAC,KAAK,CACrB,CAAC;qBACL;oBAED,SAAS,CAAC,mBAAmB,GAAG,YAAY,CAAC,YAAY,CAAC;oBAE1D,2DAA2D;oBAC3D,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;oBAClC,YAAY,CAAC,aAAa,EAAE,CAAC;iBAChC;gBAED,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;aACjC;iBAAM;gBACH,6GAA6G;gBAC7G,oIAAoI;gBACpI,kIAAkI;gBAClI,kIAAkI;gBAClI,uEAAuE;gBACvE,IAAM,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC;gBACpC,IACI,IAAI;oBACJ,sBAAsB,CAAC,IAAI,CAAC,IAAI,IAAI;oBACpC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO;oBAC5B,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,EAClC;oBACE,4DAA4D;oBAC5D,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;oBACzD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;oBACzD,IAAA,qCAAc,EAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,wBAAwB,CAAC,CAAC;oBAE1D,6CAA6C;oBAC7C,MAAA,IAAI,CAAC,UAAU,0CAAE,WAAW,CAAC,IAAI,CAAC,CAAC;iBACtC;aACJ;YAED,iFAAiF;YACjF,IAAI,CAAC,YAAY,EAAE,CAAC;SACvB;QACD,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC;IACrC,CAAC;IAtHD,sDAsHC;IAED;;;;;OAKG;IACH,SAAgB,kBAAkB,CAAC,aAA4B;;QAC3D,IAAM,IAAI,GAAG,aAAa,CAAC,iBAAiB,CAAC;QAC7C,IAAI,IAAI,EAAE;YACN,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;YAEtB,OAAO,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;gBAC9C,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;gBACnD,IAAM,IAAI,GAAG,QAAQ,CAAC,YAAY,CAAC;gBACnC,IAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;gBAClE,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;oBACtB,sEAAsE;oBACtE,0BAA0B;oBAC1B,IAAM,IAAI,GAAG,sBAAsB,CAAC,aAAa,EAAE,IAAI,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC;oBACjF,IAAI,IAAI,EAAE;wBACN,mFAAmF;wBACnF,iBAAiB,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;wBAEtC,mDAAmD;wBACnD,IAAM,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;wBAClD,IAAI,IAAA,mCAAY,EAAC,IAAI,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;4BACpC,IAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAuB,CAAC;4BACpE,KAAK,CAAC,KAAK,CAAC,UAAU,GAAG,EAAE,CAAC;4BAC5B,KAAK,CAAC,KAAK,CAAC,UAAU,GAAG,EAAE,CAAC;4BAC5B,KAAK,CAAC,KAAK,CAAC,WAAW,GAAG,EAAE,CAAC;4BAC7B,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;yBACzB;6BAAM;4BACH,IAAA,qCAAc,EAAC,EAAE,EAAE,IAAI,CAAC,CAAC;yBAC5B;wBAED,qCAAqC;wBACrC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;wBAErB,oCAAoC;wBACpC,MAAA,IAAI,CAAC,UAAU,0CAAE,WAAW,CAAC,IAAI,CAAC,CAAC;wBAEnC,IAAI,YAAY,CAAC,OAAO,IAAI,IAAI,EAAE;4BAC9B,aAAa,CAAC,mBAAmB,EAAE,CAAC;yBACvC;6BAAM;4BACH,aAAa,CAAC,oBAAoB,EAAE,CAAC;yBACxC;qBACJ;iBACJ;gBACD,IAAI,CAAC,YAAY,EAAE,CAAC;aACvB;SACJ;QACD,OAAO,aAAa,CAAC,mBAAmB,GAAG,CAAC,IAAI,aAAa,CAAC,oBAAoB,GAAG,CAAC,CAAC;IAC3F,CAAC;IA9CD,gDA8CC;IAED;;;OAGG;IACH,SAAS,sBAAsB,CAC3B,aAA4B,EAC5B,IAAiB,EACjB,QAA0B,EAC1B,YAA0B;;QAE1B,iFAAiF;QACjF,2DAA2D;QAC3D,IAAI,IAAI,GAAG,8BAA8B,CAAC,IAAI,EAAE,QAAQ,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;QAE9E,qEAAqE;QACrE,yFAAyF;QACzF,kEAAkE;QAClE,IAAM,MAAM,GAAG,IAAA,0BAAS,EAAC,aAAa,CAAC,cAAc,EAAE,IAAI,EAAE,0BAA0B,CAAC,CAAC;QAEzF,8FAA8F;QAC9F,gEAAgE;QAChE,IAAI,CAAC,MAAM,IAAI,MAAM,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,CAAC,EAAE;YAC7E,IAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;YACvE,MAAA,IAAI,CAAC,UAAU,0CAAE,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;YACzD,IAAI,GAAG,OAAO,CAAC;SAClB;QAED,uCAAuC;QACvC,IAAA,0BAAS,EACL,aAAa,CAAC,cAAc,EAC5B,IAAI,EACJ,0BAA0B,EAC1B,QAAQ,CAAC,YAAY,CACxB,CAAC;QAEF,gGAAgG;QAChG,gGAAgG;QAChG,wEAAwE;QACxE,OAAO,mBAAmB,CAAC,aAAa,EAAE,IAAI,EAAE,YAAY,CAAC,CAAC;IAClE,CAAC;IAED;;;OAGG;IACH,SAAS,mBAAmB,CACxB,aAA4B,EAC5B,IAAU,EACV,YAA0B;;QAE1B,2CAA2C;QAC3C,IAAI,YAAY,CAAC,OAAO,IAAI,IAAA,mCAAY,EAAC,IAAI,CAAC,EAAE;YAC5C,2FAA2F;YAC3F,IAAM,OAAO,GAAG,MAAA,IAAI,CAAC,aAAa,0CAAE,aAAa,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;YACxE,IAAI,OAAO,EAAE;gBACT,IAAA,0BAAS,EACL,aAAa,CAAC,cAAc,EAC5B,OAAO,EACP,0BAA0B,EAC1B,IAAA,0BAAS,EAAC,aAAa,CAAC,cAAc,EAAE,IAAI,EAAE,0BAA0B,CAAC,CAC5E,CAAC;gBACF,IAAA,qCAAc,EAAC,OAAO,EAAE,IAAI,CAAC,CAAC;gBAE9B,MAAA,IAAI,CAAC,UAAU,0CAAE,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;gBAC7C,MAAA,IAAI,CAAC,UAAU,0CAAE,WAAW,CAAC,IAAI,CAAC,CAAC;gBACnC,IAAI,GAAG,OAAO,CAAC;aAClB;SACJ;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACH,SAAS,8BAA8B,CACnC,IAAiB,EACjB,KAAa,EACb,YAAiC;;QAEjC,IAAI,MAAM,GAAgB,IAAI,CAAC;QAC/B,IAAI,YAAY,GAAgB,IAAI,CAAC;QACrC,IAAI,KAAK,IAAI,CAAC,EAAE;YACZ,yEAAyE;YACzE,YAAY,GAAG,sBAAsB,CAAC,IAAI,CAAC,CAAC;SAC/C;aAAM;YACH,6EAA6E;YAC7E,0CAA0C;YAC1C,MAAM,GAAG,8BAA8B,CAAC,IAAI,EAAE,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC;YAC/D,IAAI,MAAM,CAAC,SAAS,EAAE;gBAClB,YAAY,GAAG,MAAM,CAAC,SAAS,CAAC;aACnC;SACJ;QAED,6DAA6D;QAC7D,IAAI,YAAY,IAAI,YAAY,CAAC,QAAQ,mBAAoB,EAAE;YAC3D,IAAM,GAAG,GAAG,IAAA,mCAAY,EAAC,YAAY,CAAC,CAAC;YACvC,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,EAAE;gBAC5B,0BAA0B;gBAC1B,OAAO,YAAY,CAAC;aACvB;SACJ;QAED,0EAA0E;QAC1E,0DAA0D;QAC1D,IAAM,OAAO,GAAG,MAAA,IAAI,CAAC,aAAa,0CAAE,aAAa,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAC9F,IAAI,KAAK,IAAI,CAAC,EAAE;YACZ,qDAAqD;YACrD,MAAA,IAAI,CAAC,UAAU,0CAAE,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;SAChD;aAAM;YACH,uDAAuD;YACvD,gCAAgC;YAChC,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,WAAW,CAAC,OAAO,CAAC,CAAC;SAChC;QAED,OAAO,OAAO,CAAC;IACnB,CAAC;IAED;;;;OAIG;IACH,SAAS,iBAAiB,CAAC,IAAU,EAAE,MAAc;QACjD,IAAM,aAAa,GAAW,EAAE,CAAC;QAEjC,KAAK,IAAI,KAAK,GAAgB,IAAI,CAAC,UAAU,EAAE,KAAK,EAAE,KAAK,GAAG,KAAK,CAAC,WAAW,EAAE;YAC7E,IAAI,KAAK,EAAE;gBACP,iFAAiF;gBACjF,IAAI,KAAK,IAAI,KAAK,CAAC,QAAQ,mBAAoB,IAAI,MAAM,GAAG,CAAC,EAAE;oBAC3D,iBAAiB,CAAC,KAAK,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC;iBACxC;gBAED,2FAA2F;gBAC3F,KAAK,GAAG,mBAAmB,CAAC,KAAK,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC;gBAE5D,uCAAuC;gBACvC,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,YAAY,CAAC,KAAK,CAAC,EAAE;oBAC3C,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBAC7B;aACJ;SACJ;QAED,aAAa,CAAC,OAAO,CAAC,UAAA,KAAK,IAAI,OAAA,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAvB,CAAuB,CAAC,CAAC;IAC5D,CAAC;IAED;;;OAGG;IACH,SAAS,mBAAmB,CAAC,IAAiB;QAC1C,IAAI,IAAI,CAAC,QAAQ,mBAAoB,EAAE;YACnC,IAAM,aAAa,GAAG,aAAa,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC;YAC/D,IAAI,aAAa,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC3C,IAAI;oBACA,kGAAkG;oBAClG,SAAS;oBACT,sHAAsH;oBACtH,8FAA8F;oBAC9F,wFAAwF;oBACxF,yBAAyB;oBACzB,2CAA2C;oBAC3C,kCAAkC;oBAClC,IAAM,SAAS,GAAG,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBAC3C,IAAI,SAAS,CAAC,MAAM,IAAI,CAAC,EAAE;wBACvB,OAAyB;4BACrB,KAAK,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;4BACpD,UAAU,EAAE,aAAa;4BACzB,YAAY,EAAE,IAAI;4BAClB,YAAY,EAAE,CAAC;yBAClB,CAAC;qBACL;iBACJ;gBAAC,OAAO,CAAC,EAAE,GAAE;aACjB;SACJ;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,SAAS,YAAY,CAAC,UAAkB;QACpC,OAAO,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;IACzD,CAAC;IAED,oFAAoF;IACpF,SAAS,oBAAoB,CAAC,UAAkB;QAC5C,OAAO,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;IAClD,CAAC;IAED;;;OAGG;IACH,SAAS,iBAAiB,CAAC,IAAU,EAAE,MAAc;;QACjD,oDAAoD;QACpD,4CAA4C;QAC5C,2BAA2B;QAC3B,+HAA+H;QAC/H,gBAAgB;QAChB,kBAAkB;QAClB,aAAa;QACb,EAAE;QACF,yGAAyG;QACzG,gEAAgE;QAChE,IAAI,MAAM,GAAW,EAAE,CAAC;QACxB,IAAI,KAAK,GAAgB,IAAI,CAAC,UAAU,CAAC;QACzC,OAAO,CAAC,MAAM,IAAI,KAAK,EAAE;YACrB,+EAA+E;YAC/E,KAAK,GAAG,mBAAmB,CAAC,KAAK,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC;YAE5D,2EAA2E;YAC3E,IAAI,YAAY,CAAC,KAAK,CAAC,EAAE;gBACrB,mEAAmE;gBACnE,MAAM,GAAG,MAAA,MAAA,KAAK,CAAC,WAAW,0CAAE,IAAI,EAAE,mCAAI,EAAE,CAAC;gBAEzC,kCAAkC;gBAClC,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,EAAE;oBACpB,MAAM,GAAG,GAAG,CAAC;iBAChB;aACJ;iBAAM,IAAI,KAAK,CAAC,QAAQ,mBAAoB,IAAI,MAAM,GAAG,CAAC,EAAE;gBACzD,qFAAqF;gBACrF,mBAAmB;gBACnB,MAAM,GAAG,iBAAiB,CAAC,KAAK,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC;aACjD;YAED,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC;SAC7B;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAED;;;;;;;OAOG;IACH,SAAS,mBAAmB,CAAC,KAAW,EAAE,cAAuB;;QAC7D,IAAI,KAAK,CAAC,QAAQ,mBAAoB,EAAE;YACpC,IAAI,KAAK,GAAI,KAAiB,CAAC,IAAI,CAAC;YACpC,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,IAAI,oBAAoB,EAAE;gBAC7D,uEAAuE;gBACvE,6CAA6C;gBAC7C,IAAI,WAAW,GAAgB,KAAK,CAAC;gBACrC,IAAI,UAAU,GAAgB,IAAI,CAAC;gBACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;oBACxB,WAAW,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC;oBAC9C,IAAI,CAAC,WAAW,EAAE;wBACd,MAAM;qBACT;oBACD,IAAI,WAAW,CAAC,QAAQ,mBAAoB,EAAE;wBAC1C,KAAK,GAAI,WAAuB,CAAC,IAAI,CAAC;wBACtC,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,IAAI,SAAS,EAAE;4BAClD,UAAU,GAAG,WAAW,CAAC;4BACzB,MAAM;yBACT;qBACJ;iBACJ;gBAED,gDAAgD;gBAChD,IAAI,UAAU,EAAE;oBACZ,IAAM,OAAO,GAAG,MAAA,KAAK,CAAC,aAAa,0CAAE,aAAa,CAAC,MAAM,CAAC,CAAC;oBAC3D,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,YAAY,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;oBAEnD,WAAW,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;oBACxC,OAAO,WAAW,IAAI,UAAU,EAAE;wBAC9B,WAAW,GAAG,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,WAA0B,CAAC;wBACtD,IAAI,WAAW,CAAC,eAAe,EAAE;4BAC7B,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC;yBACrD;qBACJ;oBAED,+DAA+D;oBAC/D,IAAI,OAAO,EAAE;wBACT,MAAA,UAAU,CAAC,UAAU,0CAAE,YAAY,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;qBAC5D;oBAED,uDAAuD;oBACvD,IAAI,cAAc,EAAE;wBAChB,MAAA,KAAK,CAAC,UAAU,0CAAE,WAAW,CAAC,KAAK,CAAC,CAAC;wBACrC,MAAA,UAAU,CAAC,UAAU,0CAAE,WAAW,CAAC,UAAU,CAAC,CAAC;qBAClD;oBAED,uEAAuE;oBACvE,IAAI,OAAO,EAAE;wBACT,KAAK,GAAG,OAAO,CAAC;qBACnB;iBACJ;aACJ;SACJ;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAED,iEAAiE;IACjE,SAAS,sBAAsB,CAAC,IAAU;QACtC,IAAI,WAAW,GAAgB,IAAI,CAAC;QACpC,GAAG;YACC,WAAW,GAAG,WAAW,CAAC,eAAe,CAAC;SAC7C,QAAQ,WAAW,IAAI,eAAe,CAAC,WAAW,CAAC,EAAE;QACtD,OAAO,WAAW,CAAC;IACvB,CAAC;IAED,6DAA6D;IAC7D,SAAS,kBAAkB,CAAC,IAAU;QAClC,IAAI,WAAW,GAAgB,IAAI,CAAC;QACpC,GAAG;YACC,WAAW,GAAG,WAAW,CAAC,WAAW,CAAC;SACzC,QAAQ,WAAW,IAAI,eAAe,CAAC,WAAW,CAAC,EAAE;QAEtD,OAAO,WAAW,CAAC;IACvB,CAAC;IAED;;;;OAIG;IACH,SAAS,YAAY,CAAC,IAAU;QAC5B,IAAI,IAAI,CAAC,QAAQ,mBAAoB,EAAE;YACnC,IAAM,aAAa,GAAG,aAAa,CAAC,IAAmB,EAAE,mBAAmB,CAAC,CAAC;YAC9E,IACI,aAAa;gBACb,aAAa,CAAC,MAAM,GAAG,CAAC;gBACxB,aAAa,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,IAAI,QAAQ,EAChD;gBACE,OAAO,IAAI,CAAC;aACf;SACJ;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAED,qDAAqD;IACrD,SAAS,WAAW,CAAC,IAAU;QAC3B,OAAO,IAAA,mCAAY,EAAC,IAAI,CAAC,IAAI,MAAM,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;IAC5D,CAAC;IAED,oDAAoD;IACpD,SAAS,aAAa,CAAC,IAAiB,EAAE,SAAiB;QACvD,yFAAyF;QACzF,qGAAqG;QACrG,0FAA0F;QAC1F,yBAAyB;QACzB,OAAO,IAAA,gCAAS,EAAC,IAAI,CAAC,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC;IAC9C,CAAC;IAED,mEAAmE;IACnE,SAAS,eAAe,CAAC,IAAU;;QAC/B,mBAAmB;QACnB,IAAI,CAAC,IAAI,EAAE;YACP,OAAO,IAAI,CAAC;SACf;QAED,2BAA2B;QAC3B,IAAI,IAAI,CAAC,QAAQ,gBAAiB,EAAE;YAChC,IAAI,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC;YAC3B,KAAK,GAAG,MAAA,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,mCAAI,EAAE,CAAC;YAC9C,OAAO,CAAA,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,IAAI,GAAG,MAAM,KAAI,CAAC,CAAC;SACpC;QAED,iDAAiD;QACjD,IAAM,OAAO,GAAG,IAAA,mCAAY,EAAC,IAAI,CAAC,CAAC;QACnC,IACI,IAAI,CAAC,UAAU;YACf,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,SAAS;YACjC,CAAC,OAAO,IAAI,MAAM,IAAI,OAAO,IAAI,MAAM,CAAC,EAC1C;YACE,OAAO,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SAC3C;QAED,uCAAuC;QACvC,OAAO,KAAK,CAAC;IACjB,CAAC;IAED,sBAAsB;IACtB,SAAS,iBAAiB,CAAC,IAA4B;QACnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,sBAAsB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACzD,IAAM,EAAE,GAAG,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC;YAC1C,IAAI,EAAE,EAAE;gBACJ,EAAE,CAAC,mBAAmB,GAAG,CAAC,CAAC,CAAC;aAC/B;SACJ;IACL,CAAC","sourcesContent":["import { createLevelLists } from './LevelLists';\nimport { getObject, setObject } from './WordCustomData';\nimport { getStyles, getTagOfNode, moveChildNodes } from 'roosterjs-editor-dom';\nimport { NodeType } from 'roosterjs-editor-types';\nimport type ListItemMetadata from './ListItemMetadata';\nimport type ListMetadata from './ListMetadata';\nimport type WordConverter from './wordConverter';\nimport type WordConverterArguments from './WordConverterArguments';\n\n/** Word list metadata style name */\nconst LOOKUP_DEPTH = 5;\n\n/** Name for the word list id property in the custom data */\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\n\n/** Word list metadata style name */\nconst MSO_LIST_STYLE_NAME = 'mso-list';\n\n/** Regular expression to match line breaks */\nconst LINE_BREAKS = /[\\n|\\r]/gi;\n\n/**\n * @internal\n * Handles the pass 1: Discovery\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\n */\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\n    const args = wordConverter.wordConverterArgs;\n    if (!args) {\n        return false;\n    }\n    while (args.currentIndex < args.nodes.length) {\n        const node = args.nodes.item(args.currentIndex);\n\n        // Try to get the list metadata for the specified node\n        const itemMetadata = getListItemMetadata(node);\n        if (itemMetadata) {\n            const levelInfo =\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\n\n            // We need to drop some list information if this is not an item next to another\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\n                // This list item is not next to the previous one. This means that there is some content in between them\n                // so we need to reset our list of list ids per level\n                resetCurrentLists(args);\n            }\n\n            // Get the list metadata for the list that will hold this item\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\n            if (!listMetadata) {\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\n                const firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n\n                // This is a the first item of a list.. We'll create the list metadata using the information\n                // we already have from this first item\n                listMetadata = {\n                    numberOfItems: 0,\n                    uniqueListId: wordConverter.nextUniqueId++,\n                    firstFakeBullet: firstFakeBullet,\n\n                    // If the bullet we got is empty or not found, we ignore the list out.. this means\n                    // that this is not an item we need to convert of that the format doesn't match what\n                    // we are expecting\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\n\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\n                    // item, we'll perform a better comparison, but for one item lists, this will be check that will determine the list type\n                    tagName: getFakeBulletTagName(firstFakeBullet),\n                };\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\n                // items we have an decide if we create ordered or unordered lists based on this.\n                // This is the best way we can do this since we cannot read the metadata that Word\n                // puts in the head of the HTML...\n                const secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n                listMetadata.tagName =\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\n            }\n\n            // Set the unique id to the list\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\n\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\n            // it, or we'll know it because the previous list items are not next to this one\n            if (\n                listMetadata.ignore ||\n                (listMetadata.tagName == 'OL' &&\n                    listMetadata.numberOfItems > 0 &&\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\n            ) {\n                // We need to ignore this item... and we also need to forget about the lists that\n                // are not at the root level\n                listMetadata.ignore = true;\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\n            } else {\n                // This is an item we don't need to ignore... If added lists deep under this one before\n                // we'll drop their ids from the list of ids per level.. this is because this list item\n                // breaks the deeper lists.\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\n                        0,\n                        itemMetadata.level\n                    );\n                }\n\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\n\n                // Add the list item into the list of items to be processed\n                args.listItems.push(itemMetadata);\n                listMetadata.numberOfItems++;\n            }\n\n            args.lastProcessedItem = node;\n        } else {\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\n            // the list conversion thinking that the list items are not together...\n            const last = args.lastProcessedItem;\n            if (\n                last &&\n                getRealPreviousSibling(node) == last &&\n                node.tagName == last.tagName &&\n                node.className == last.className\n            ) {\n                // Add 2 line breaks and move all the nodes to the last item\n                last.appendChild(last.ownerDocument.createElement('br'));\n                last.appendChild(last.ownerDocument.createElement('br'));\n                moveChildNodes(last, node, true /*keepExistingChildren*/);\n\n                // Remove the item that we don't need anymore\n                node.parentNode?.removeChild(node);\n            }\n        }\n\n        // Move to the next element are return true if more elements need to be processed\n        args.currentIndex++;\n    }\n    return args.listItems.length > 0;\n}\n\n/**\n * @internal\n * Handles the pass 2: Conversion\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\n * conversion needed\n */\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\n    const args = wordConverter.wordConverterArgs;\n    if (args) {\n        args.currentIndex = 0;\n\n        while (args.currentIndex < args.listItems.length) {\n            const metadata = args.listItems[args.currentIndex];\n            const node = metadata.originalNode;\n            const listMetadata = args.lists[metadata.uniqueListId.toString()];\n            if (!listMetadata.ignore) {\n                // We have a list item that we need to convert, get or create the list\n                // that hold this item out\n                const list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\n                if (list) {\n                    // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\n                    cleanupListIgnore(node, LOOKUP_DEPTH);\n\n                    // Create a new list item and transfer the children\n                    const li = node.ownerDocument.createElement('LI');\n                    if (getTagOfNode(node).startsWith('H')) {\n                        const clone = node.cloneNode(true /* deep */) as HTMLHeadingElement;\n                        clone.style.textIndent = '';\n                        clone.style.marginLeft = '';\n                        clone.style.marginRight = '';\n                        li.appendChild(clone);\n                    } else {\n                        moveChildNodes(li, node);\n                    }\n\n                    // Append the list item into the list\n                    list.appendChild(li);\n\n                    // Remove the node we just converted\n                    node.parentNode?.removeChild(node);\n\n                    if (listMetadata.tagName == 'UL') {\n                        wordConverter.numBulletsConverted++;\n                    } else {\n                        wordConverter.numNumberedConverted++;\n                    }\n                }\n            }\n            args.currentIndex++;\n        }\n    }\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\n}\n\n/**\n * Gets or creates the list (UL or OL) that holds this item out based on the\n * items content and the specified metadata\n */\nfunction getOrCreateListForNode(\n    wordConverter: WordConverter,\n    node: HTMLElement,\n    metadata: ListItemMetadata,\n    listMetadata: ListMetadata\n): Node {\n    // First get the last list next to this node under the specified level. This code\n    // path will return the list or will create lists if needed\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\n\n    // Here use the unique list ID to detect if we have the right list...\n    // it is possible to have 2 different lists next to each other with different formats, so\n    // we want to detect this an create separate lists for those cases\n    const listId = getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\n\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\n    // is a completely new list, so we'll append a new list for that\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\n        const newList = node.ownerDocument.createElement(listMetadata.tagName);\n        list.parentNode?.insertBefore(newList, list.nextSibling);\n        list = newList;\n    }\n\n    // Set the list id into the custom data\n    setObject(\n        wordConverter.wordCustomData,\n        list,\n        UNIQUE_LIST_ID_CUSTOM_DATA,\n        metadata.uniqueListId\n    );\n\n    // This call will convert the list if needed to the right type of list required. This can happen\n    // on the cases where the first list item for this list is located after a deeper list. for that\n    // case, we will have created a UL for it, and we may need to convert it\n    return convertListIfNeeded(wordConverter, list, listMetadata);\n}\n\n/**\n * Converts the list between UL and OL if needed, by using the fake bullet and\n * information already stored in the list itself\n */\nfunction convertListIfNeeded(\n    wordConverter: WordConverter,\n    list: Node,\n    listMetadata: ListMetadata\n): Node {\n    // Check if we need to convert the list out\n    if (listMetadata.tagName != getTagOfNode(list)) {\n        // We have the wrong list type.. convert it, set the id again and transfer all the children\n        const newList = list.ownerDocument?.createElement(listMetadata.tagName);\n        if (newList) {\n            setObject(\n                wordConverter.wordCustomData,\n                newList,\n                UNIQUE_LIST_ID_CUSTOM_DATA,\n                getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\n            );\n            moveChildNodes(newList, list);\n\n            list.parentNode?.insertBefore(newList, list);\n            list.parentNode?.removeChild(list);\n            list = newList;\n        }\n    }\n\n    return list;\n}\n\n/**\n * Gets or creates the specified list\n */\nfunction recurringGetOrCreateListAtNode(\n    node: HTMLElement,\n    level: number,\n    listMetadata: ListMetadata | null\n): Node {\n    let parent: Node | null = null;\n    let possibleList: Node | null = null;\n    if (level == 1) {\n        // Root case, we'll check if the list is the previous sibling of the node\n        possibleList = getRealPreviousSibling(node);\n    } else {\n        // If we get here, we are looking for level 2 or deeper... get the upper list\n        // and check if the last element is a list\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\n        if (parent.lastChild) {\n            possibleList = parent.lastChild;\n        }\n    }\n\n    // Check the element that we got and verify that it is a list\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\n        const tag = getTagOfNode(possibleList);\n        if (tag == 'UL' || tag == 'OL') {\n            // We have a list.. use it\n            return possibleList;\n        }\n    }\n\n    // If we get here, it means we don't have a list and we need to create one\n    // this code path will always create new lists as UL lists\n    const newList = node.ownerDocument?.createElement(listMetadata ? listMetadata.tagName : 'UL');\n    if (level == 1) {\n        // For level 1, we'll insert the list before the node\n        node.parentNode?.insertBefore(newList, node);\n    } else {\n        // Any level 2 or above, we insert the list as the last\n        // child of the upper level list\n        parent?.appendChild(newList);\n    }\n\n    return newList;\n}\n\n/**\n * Cleans up the node children by removing the children marked as mso-list: Ignore.\n * This nodes hold the fake bullet information that Word puts in and when\n * conversion is happening, we want to get rid of these elements\n */\nfunction cleanupListIgnore(node: Node, levels: number) {\n    const nodesToRemove: Node[] = [];\n\n    for (let child: Node | null = node.firstChild; child; child = child.nextSibling) {\n        if (child) {\n            // Clean up the item internally first if we need to based on the number of levels\n            if (child && child.nodeType == NodeType.Element && levels > 1) {\n                cleanupListIgnore(child, levels - 1);\n            }\n\n            // Try to convert word comments into ignore elements if we haven't done so for this element\n            child = fixWordListComments(child, true /*removeComments*/);\n\n            // Check if we can remove this item out\n            if (isEmptySpan(child) || isIgnoreNode(child)) {\n                nodesToRemove.push(child);\n            }\n        }\n    }\n\n    nodesToRemove.forEach(child => node.removeChild(child));\n}\n\n/**\n * Reads the word list meta dada out of the specified node. If the node\n * is not a Word list item, it returns null.\n */\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata | null {\n    if (node.nodeType == NodeType.Element) {\n        const listAttribute = getStyleValue(node, MSO_LIST_STYLE_NAME);\n        if (listAttribute && listAttribute.length > 0) {\n            try {\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\n                // Where:\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; meta data\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\n                // for almost all cases, it maps to the list indentation (or level). We'll use it as the\n                // list indentation value\n                // (2) Contains a specific list identifier.\n                // Example value: \"l0 level1 lfo1\"\n                const listProps = listAttribute.split(' ');\n                if (listProps.length == 3) {\n                    return <ListItemMetadata>{\n                        level: parseInt(listProps[1].substr('level'.length)),\n                        wordListId: listAttribute,\n                        originalNode: node,\n                        uniqueListId: 0,\n                    };\n                }\n            } catch (e) {}\n        }\n    }\n    return null;\n}\n\nfunction isFakeBullet(fakeBullet: string): boolean {\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\n}\n\n/** Given a fake bullet text, returns the type of list that should be used for it */\nfunction getFakeBulletTagName(fakeBullet: string): string {\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\n}\n\n/**\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\n * a bullet string. If not found, it returns null...\n */\nfunction getFakeBulletText(node: Node, levels: number): string {\n    // Word uses the following format for their bullets:\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\n    // &lt;span style=\"...\"&gt;\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\n    // &lt;/span&gt;\n    // Content here...\n    // &lt;/p&gt;\n    //\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\n    // text or image node will be the fake bullet we are looking for\n    let result: string = '';\n    let child: Node | null = node.firstChild;\n    while (!result && child) {\n        // First, check if we need to convert the Word list comments into real elements\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\n        if (isIgnoreNode(child)) {\n            // Yes... this is the node that holds either the text or image data\n            result = child.textContent?.trim() ?? '';\n\n            // This is the case for image case\n            if (result.length == 0) {\n                result = 'o';\n            }\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\n            // If this is an element and we are not in the last level, try to get the fake bullet\n            // out of the child\n            result = getFakeBulletText(child, levels - 1);\n        }\n\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * If the specified element is a Word List comments, this code verifies and fixes\n * the markup when needed to ensure that Chrome bullet conversions work as expected\n * -----\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\n * styles of the span, but we'll use these comments to recreate them out\n */\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\n    if (child.nodeType == NodeType.Comment) {\n        let value = (child as Comment).data;\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\n            // We have a list ignore start, find the end.. We know is not more than\n            // 3 nodes away, so we'll optimize our checks\n            let nextElement: Node | null = child;\n            let endComment: Node | null = null;\n            for (let j = 0; j < 4; j++) {\n                nextElement = getRealNextSibling(nextElement);\n                if (!nextElement) {\n                    break;\n                }\n                if (nextElement.nodeType == NodeType.Comment) {\n                    value = (nextElement as Comment).data;\n                    if (value && value.trim().toLowerCase() == '[endif]') {\n                        endComment = nextElement;\n                        break;\n                    }\n                }\n            }\n\n            // if we found the end node, wrap everything out\n            if (endComment) {\n                const newSpan = child.ownerDocument?.createElement('span');\n                newSpan?.setAttribute('style', 'mso-list: ignore');\n\n                nextElement = getRealNextSibling(child);\n                while (nextElement != endComment) {\n                    nextElement = nextElement?.nextSibling as HTMLElement;\n                    if (nextElement.previousSibling) {\n                        newSpan?.appendChild(nextElement.previousSibling);\n                    }\n                }\n\n                // Insert the element out and use that one as the current child\n                if (newSpan) {\n                    endComment.parentNode?.insertBefore(newSpan, endComment);\n                }\n\n                // Remove the comments out if the call specified it out\n                if (removeComments) {\n                    child.parentNode?.removeChild(child);\n                    endComment.parentNode?.removeChild(endComment);\n                }\n\n                // Last, make sure we return the new element out instead of the comment\n                if (newSpan) {\n                    child = newSpan;\n                }\n            }\n        }\n    }\n\n    return child;\n}\n\n/** Finds the real previous sibling, ignoring empty text nodes */\nfunction getRealPreviousSibling(node: Node): Node | null {\n    let prevSibling: Node | null = node;\n    do {\n        prevSibling = prevSibling.previousSibling;\n    } while (prevSibling && isEmptyTextNode(prevSibling));\n    return prevSibling;\n}\n\n/** Finds the real next sibling, ignoring empty text nodes */\nfunction getRealNextSibling(node: Node): Node | null {\n    let nextSibling: Node | null = node;\n    do {\n        nextSibling = nextSibling.nextSibling;\n    } while (nextSibling && isEmptyTextNode(nextSibling));\n\n    return nextSibling;\n}\n\n/**\n * Checks if the specified node is marked as a mso-list: Ignore. These\n * nodes need to be ignored when a list item is converted into standard\n * HTML lists\n */\nfunction isIgnoreNode(node: Node): boolean {\n    if (node.nodeType == NodeType.Element) {\n        const listAttribute = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\n        if (\n            listAttribute &&\n            listAttribute.length > 0 &&\n            listAttribute.trim().toLowerCase() == 'ignore'\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/** Checks if the specified node is an empty span. */\nfunction isEmptySpan(node: Node): boolean {\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\n}\n\n/** Reads the specified style value from the node */\nfunction getStyleValue(node: HTMLElement, styleName: string): string | null {\n    // Word uses non-standard names for the metadata that puts in the style of the element...\n    // Most browsers will not provide the information for those nonstandard values through the node.style\n    // property, so the only reliable way to read them is to get the attribute directly and do\n    // the required parsing..\n    return getStyles(node)[styleName] || null;\n}\n\n/** Checks if the node is an empty text node that can be ignored */\nfunction isEmptyTextNode(node: Node): boolean {\n    // No node is empty\n    if (!node) {\n        return true;\n    }\n\n    // Empty text node is empty\n    if (node.nodeType == NodeType.Text) {\n        let value = node.nodeValue;\n        value = value?.replace(LINE_BREAKS, '') ?? '';\n        return value?.trim().length == 0;\n    }\n\n    // Span or Font with an empty child node is empty\n    const tagName = getTagOfNode(node);\n    if (\n        node.firstChild &&\n        node.firstChild == node.lastChild &&\n        (tagName == 'SPAN' || tagName == 'FONT')\n    ) {\n        return isEmptyTextNode(node.firstChild);\n    }\n\n    // If not found, then this is not empty\n    return false;\n}\n\n/** Resets the list */\nfunction resetCurrentLists(args: WordConverterArguments) {\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\n        const ll = args.currentListIdsByLevels[i];\n        if (ll) {\n            ll.currentUniqueListId = -1;\n        }\n    }\n}\n"]}