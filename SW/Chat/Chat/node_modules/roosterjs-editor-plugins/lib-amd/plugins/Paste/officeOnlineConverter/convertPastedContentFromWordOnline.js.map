{"version":3,"file":"convertPastedContentFromWordOnline.js","sourceRoot":"","sources":["../../../../../../packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.ts"],"names":[],"mappings":"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","sourcesContent":["import { createListItemBlock } from './ListItemBlock';\nimport type ListItemBlock from './ListItemBlock';\n\nimport {\n    splitParentNode,\n    getNextLeafSibling,\n    getFirstLeafNode,\n    getTagOfNode,\n    collapseNodes,\n    unwrap,\n    toArray,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\nconst WORD_ONLINE_IDENTIFYING_SELECTOR =\n    'div.ListContainerWrapper>ul[class^=\"BulletListStyle\"],div.ListContainerWrapper>ol[class^=\"NumberListStyle\"],span.WACImageContainer > img';\nconst LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';\nconst IMAGE_CONTAINER_ELEMENT_CLASS_NAME = 'WACImageContainer';\n\n//When the list style is a symbol and the value is not in the clipboard, WordOnline\nconst VALID_LIST_STYLE_CHAR_CODES = [\n    '111', //'o'\n    '9643', //'▫'\n    '9830', //'♦'\n];\n\n/**\n * @internal\n */\nexport function isWordOnlineWithList(fragment: DocumentFragment): boolean {\n    return !!(fragment && fragment.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));\n}\n\n// Word Online pasted content DOM structure as of July 12th 2019\n//<html>\n//  <body>\n//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste\n//          <div class=\"OutlineElement\">  ----------> text content\n//              <p></p>\n//          </div>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper\n//              <ul>                                       list items in the same list can be divided into different ListItemWrapper\n//                  <li></li>                              list items in the same list can also be divided into different Outline Group;\n//                  <li></li>\n//              </ul>\n//          </div>\n//      </div>\n//      <div class='OutlineGroup'>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for ordered list, each items has it's own wrapper\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//          <div class=\"ListItemWrapper\">\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//      </div>\n//  </body>\n//</html>\n//\n\n/**\n * @internal\n * Convert text copied from word online into text that's workable with rooster editor\n * @param fragment Document fragment that is being pasted into editor.\n */\nexport default function convertPastedContentFromWordOnline(fragment: DocumentFragment) {\n    sanitizeListItemContainer(fragment);\n    const listItemBlocks: ListItemBlock[] = getListItemBlocks(fragment);\n\n    listItemBlocks.forEach(itemBlock => {\n        // There are cases where consecutive List Elements are separated into different nodes:\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // in the above case we want to collapse the two root level div into one and unwrap the list item nodes.\n        // after the following flattening the list will become following:\n        //\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // Then we are start processing.\n        flattenListBlock(fragment, itemBlock);\n\n        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.\n        itemBlock.insertPositionNode = itemBlock.endElement?.nextSibling ?? null;\n\n        let convertedListElement: Element | undefined = undefined;\n        const doc = fragment.ownerDocument;\n\n        itemBlock.listItemContainers.forEach(listItemContainer => {\n            const listType: 'OL' | 'UL' | null = getContainerListType(listItemContainer); // list type that is contained by iterator.\n            if (listType) {\n                // Initialize processed element with proper listType if this is the first element\n                if (!convertedListElement) {\n                    convertedListElement = createNewList(listItemContainer, doc, listType);\n                }\n\n                // Get all list items(<li>) in the current iterator element.\n                const currentListItems = toArray(listItemContainer.querySelectorAll('li'));\n                currentListItems.forEach(item => {\n                    // If item is in root level and the type of list changes then\n                    // insert the current list into body and then reinitialize the convertedListElement\n                    // Word Online is using data-aria-level to determine the the depth of the list item.\n                    const itemLevel = parseInt(item.getAttribute('data-aria-level') ?? '');\n                    // In first level list, there are cases where a consecutive list item DIV may have different list type\n                    // When that happens we need to insert the processed elements into the document, then change the list type\n                    // and keep the processing going.\n                    if (\n                        convertedListElement &&\n                        getTagOfNode(convertedListElement) != listType &&\n                        itemLevel == 1 &&\n                        listType\n                    ) {\n                        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n                        convertedListElement = createNewList(listItemContainer, doc, listType);\n                    }\n                    if (convertedListElement && listType) {\n                        insertListItem(convertedListElement, item, listType, doc);\n                    }\n                });\n            }\n        });\n        if (convertedListElement) {\n            insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n        }\n\n        // Once we finish the process the list items and put them into a list.\n        // After inserting the processed element,\n        // we need to remove all the non processed node from the parent node.\n        const parentContainer = itemBlock.startElement?.parentNode;\n        if (parentContainer) {\n            itemBlock.listItemContainers.forEach(listItemContainer => {\n                parentContainer.removeChild(listItemContainer);\n            });\n        }\n    });\n\n    const imageNodes = getImageNodes(fragment);\n    imageNodes.forEach(node => {\n        //   Structure when pasting Word Wac Image as of 10/22/2021\n        //   <span class='WACImageContainer'>\n        //        <img class=\"WACImage\" >\n        //        <span style=\"display:block\">\n        //        </span>\n        //   </span>\n        //\n        //   Since the second span inside of WACImageContainer have style display block it displays an additional space at the bottom of the image.\n        //   Removing the nodes that are not img will resolve the additional space\n        if (safeInstanceOf(node, 'HTMLSpanElement')) {\n            node.childNodes.forEach(childNode => {\n                if (getTagOfNode(childNode) != 'IMG') {\n                    childNode.parentElement?.removeChild(childNode);\n                }\n            });\n        }\n    });\n}\n\nfunction createNewList(listItemContainer: Element, doc: Document, tag: 'OL' | 'UL') {\n    const newList = doc.createElement(tag);\n    const startAttribute = listItemContainer.firstElementChild?.getAttribute('start');\n    if (startAttribute) {\n        newList.setAttribute('start', startAttribute);\n    }\n    return newList;\n}\n\n/**\n * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class\n * However the html might be malformed, this function is to split all the other elements out of ListContainerWrapper\n * @param fragment pasted document that contains all the list element.\n */\nfunction sanitizeListItemContainer(fragment: DocumentFragment) {\n    const listItemContainerListEl = toArray(\n        fragment.querySelectorAll(WORD_ONLINE_IDENTIFYING_SELECTOR)\n    );\n    listItemContainerListEl.forEach(el => {\n        const replaceRegex = new RegExp(`\\\\b${LIST_CONTAINER_ELEMENT_CLASS_NAME}\\\\b`, 'g');\n        if (el.previousSibling) {\n            const prevParent = splitParentNode(el, true) as HTMLElement;\n            prevParent.className = prevParent.className.replace(replaceRegex, '');\n        }\n        if (el.nextSibling) {\n            const nextParent = splitParentNode(el, false) as HTMLElement;\n            nextParent.className = nextParent.className.replace(replaceRegex, '');\n        }\n    });\n}\n\n/**\n * Take all the list items in the document, and group the consecutive list times in a list block;\n * @param fragment pasted document that contains all the list element.\n */\nfunction getListItemBlocks(fragment: DocumentFragment): ListItemBlock[] {\n    const listElements = fragment.querySelectorAll('.' + LIST_CONTAINER_ELEMENT_CLASS_NAME);\n    const result: ListItemBlock[] = [];\n    let curListItemBlock: ListItemBlock | null = null;\n    for (let i = 0; i < listElements.length; i++) {\n        const curItem = listElements[i];\n        if (!curListItemBlock) {\n            curListItemBlock = createListItemBlock(curItem);\n        } else {\n            const { listItemContainers } = curListItemBlock;\n            const lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];\n            if (\n                curItem == lastItemInCurBlock.nextSibling ||\n                (lastItemInCurBlock.parentNode &&\n                    getFirstLeafNode(curItem) ==\n                        getNextLeafSibling(lastItemInCurBlock.parentNode, lastItemInCurBlock))\n            ) {\n                listItemContainers.push(curItem);\n                curListItemBlock.endElement = curItem;\n            } else {\n                curListItemBlock.endElement = lastItemInCurBlock;\n                result.push(curListItemBlock);\n                curListItemBlock = createListItemBlock(curItem);\n            }\n        }\n    }\n\n    if (curListItemBlock && curListItemBlock.listItemContainers.length > 0) {\n        result.push(curListItemBlock);\n    }\n\n    return result;\n}\n\n/**\n * Flatten the list items, so that all the consecutive list items are under the same parent.\n * @param fragment Root element of that contains the element.\n * @param listItemBlock The list item block needed to be flattened.\n */\nfunction flattenListBlock(fragment: DocumentFragment, listItemBlock: ListItemBlock) {\n    if (listItemBlock.startElement && listItemBlock.endElement) {\n        const collapsedListItemSections = collapseNodes(\n            fragment,\n            listItemBlock.startElement,\n            listItemBlock.endElement,\n            true\n        );\n        collapsedListItemSections.forEach(section => {\n            if (getTagOfNode(section.firstChild) == 'DIV') {\n                unwrap(section);\n            }\n        });\n    }\n}\n\n/**\n * Get the list type that the container contains. If there is no list in the container\n * return null;\n * @param listItemContainer Container that contains a list\n */\nfunction getContainerListType(listItemContainer: Element): 'OL' | 'UL' | null {\n    const tag = getTagOfNode(listItemContainer.firstChild);\n    return tag == 'UL' || tag == 'OL' ? tag : null;\n}\n\n/**\n * Insert list item into the correct position of a list\n * @param listRootElement Root element of the list that is accepting a coming element.\n * @param itemToInsert List item that needed to be inserted.\n * @param listType Type of list(ul/ol)\n */\nfunction insertListItem(\n    listRootElement: Element,\n    itemToInsert: HTMLElement,\n    listType: 'UL' | 'OL',\n    doc: HTMLDocument\n): void {\n    if (!listType) {\n        return;\n    }\n    // Get item level from 'data-aria-level' attribute\n    let itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level') ?? '');\n\n    // Try to reuse the List Marker\n    const style = itemToInsert.getAttribute('data-leveltext');\n    if (\n        listType == 'UL' &&\n        style &&\n        VALID_LIST_STYLE_CHAR_CODES.indexOf(style.charCodeAt(0).toString()) > -1\n    ) {\n        itemToInsert.style.listStyleType = `\"${style}  \"`;\n    }\n\n    let curListLevel = listRootElement; // Level iterator to find the correct place for the current element.\n    // if the itemLevel is 1 it means the level iterator is at the correct place.\n    while (itemLevel > 1) {\n        if (!curListLevel.firstChild) {\n            // If the current level is empty, create empty list within the current level\n            // then move the level iterator into the next level.\n            curListLevel.appendChild(doc.createElement(listType));\n            if (curListLevel.firstElementChild) {\n                curListLevel = curListLevel.firstElementChild;\n            }\n        } else {\n            // If the current level is not empty, the last item in the needs to be a UL or OL\n            // and the level iterator should move to the UL/OL at the last position.\n            const lastChild = curListLevel.lastElementChild;\n            const lastChildTag = getTagOfNode(lastChild);\n            if (lastChild && (lastChildTag == 'UL' || lastChildTag == 'OL')) {\n                // If the last child is a list(UL/OL), then move the level iterator to last child.\n                curListLevel = lastChild;\n            } else {\n                // If the last child is not a list, then append a new list to the level\n                // and move the level iterator to the new level.\n                curListLevel.appendChild(doc.createElement(listType));\n                if (curListLevel.lastElementChild) {\n                    curListLevel = curListLevel.lastElementChild;\n                }\n            }\n        }\n        itemLevel--;\n    }\n\n    // Once the level iterator is at the right place, then append the list item in the level.\n    curListLevel.appendChild(itemToInsert);\n}\n\n/**\n * Insert the converted list item into the correct place.\n * @param convertedListElement List element that is converted from list item block\n * @param fragment Root element of that contains the converted listItemBlock\n * @param listItemBlock List item block that was converted.\n */\nfunction insertConvertedListToDoc(\n    convertedListElement: Element,\n    fragment: DocumentFragment,\n    listItemBlock: ListItemBlock\n) {\n    if (!convertedListElement) {\n        return;\n    }\n\n    const { insertPositionNode } = listItemBlock;\n    if (insertPositionNode) {\n        const parentNode = insertPositionNode.parentNode;\n        if (parentNode) {\n            parentNode.insertBefore(convertedListElement, insertPositionNode);\n        }\n    } else {\n        const parentNode = listItemBlock.startElement?.parentNode;\n        if (parentNode) {\n            parentNode.appendChild(convertedListElement);\n        } else {\n            fragment.appendChild(convertedListElement);\n        }\n    }\n}\n\nfunction getImageNodes(fragment: DocumentFragment) {\n    return fragment.querySelectorAll('.' + IMAGE_CONTAINER_ELEMENT_CLASS_NAME);\n}\n"]}