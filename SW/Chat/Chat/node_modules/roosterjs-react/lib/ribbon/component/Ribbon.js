"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var getLocalizedString_1 = require("../../common/utils/getLocalizedString");
var CommandBar_1 = require("@fluentui/react/lib/CommandBar");
var FocusZone_1 = require("@fluentui/react/lib/FocusZone");
var roosterjs_editor_dom_1 = require("roosterjs-editor-dom");
var Styling_1 = require("@fluentui/react/lib/Styling");
var moreCommands_1 = require("./buttons/moreCommands");
var ribbonClassName = (0, Styling_1.mergeStyles)({
    '& .ms-CommandBar': {
        padding: '0px',
    },
});
var rtlIcon = (0, Styling_1.mergeStyles)({
    transform: 'scaleX(-1)',
});
/**
 * The format ribbon component of roosterjs-react
 * @param props Properties of format ribbon component
 * @returns The format ribbon component
 */
function Ribbon(props) {
    var plugin = props.plugin, buttons = props.buttons, strings = props.strings, dir = props.dir;
    var _a = (0, tslib_1.__read)(React.useState(null), 2), formatState = _a[0], setFormatState = _a[1];
    var isRtl = dir == 'rtl';
    var onClick = React.useCallback(function (_, item) {
        if (item) {
            plugin === null || plugin === void 0 ? void 0 : plugin.onButtonClick(item.data, item.key, strings);
        }
    }, [plugin, strings]);
    var onHover = React.useCallback(function (button, key) {
        plugin.startLivePreview(button, key, strings);
    }, [plugin, strings]);
    var onDismiss = React.useCallback(function () {
        plugin.stopLivePreview();
    }, [plugin]);
    var flipIcon = React.useCallback(function (props, defaultRender) {
        if (!defaultRender) {
            return null;
        }
        return React.createElement("span", { className: rtlIcon }, defaultRender(props));
    }, []);
    var commandBarItems = React.useMemo(function () {
        return buttons.map(function (button) {
            var _a, _b, _c, _d;
            var selectedItem = formatState && ((_b = (_a = button.dropDownMenu) === null || _a === void 0 ? void 0 : _a.getSelectedItemKey) === null || _b === void 0 ? void 0 : _b.call(_a, formatState));
            var dropDownMenu = button.dropDownMenu;
            var result = (0, tslib_1.__assign)({ key: button.key, data: button, iconProps: {
                    iconName: button.iconName,
                }, onRenderIcon: isRtl && button.flipWhenRtl ? flipIcon : undefined, iconOnly: true, text: (0, getLocalizedString_1.default)(strings, button.key, button.unlocalizedText), ariaLabel: (0, getLocalizedString_1.default)(strings, button.key, button.unlocalizedText), canCheck: true, checked: (formatState && ((_c = button.isChecked) === null || _c === void 0 ? void 0 : _c.call(button, formatState))) || false, disabled: (formatState && ((_d = button.isDisabled) === null || _d === void 0 ? void 0 : _d.call(button, formatState))) || false }, (button.commandBarProperties || {}));
            var contextMenuItemRenderer = function (props, defaultRenderer) {
                return props && defaultRenderer ? (React.createElement("div", { onMouseOver: function (e) { return onHover(button, props.key); } }, defaultRenderer(props))) : null;
            };
            if (dropDownMenu) {
                result.subMenuProps = (0, tslib_1.__assign)({ shouldFocusOnMount: true, focusZoneProps: { direction: FocusZone_1.FocusZoneDirection.bidirectional }, onMenuDismissed: onDismiss, onItemClick: onClick, onRenderContextualMenuItem: dropDownMenu.allowLivePreview
                        ? contextMenuItemRenderer
                        : undefined, items: (0, roosterjs_editor_dom_1.getObjectKeys)(dropDownMenu.items).map(function (key) { return ({
                        key: key,
                        text: (0, getLocalizedString_1.default)(strings, key, dropDownMenu.items[key]),
                        data: button,
                        canCheck: !!dropDownMenu.getSelectedItemKey,
                        checked: selectedItem == key || false,
                        className: dropDownMenu.itemClassName,
                        onRender: dropDownMenu.itemRender
                            ? function (item) { return dropDownMenu.itemRender(item, onClick); }
                            : undefined,
                    }); }) }, (dropDownMenu.commandBarSubMenuProperties || {}));
            }
            else {
                result.onClick = onClick;
            }
            return result;
        });
    }, [buttons, formatState, isRtl, strings, onClick, onDismiss, onHover]);
    React.useEffect(function () {
        var disposer = plugin === null || plugin === void 0 ? void 0 : plugin.registerFormatChangedCallback(setFormatState);
        return function () {
            disposer === null || disposer === void 0 ? void 0 : disposer();
        };
    }, [plugin]);
    var moreCommandsBtn = moreCommands_1.moreCommands;
    return (React.createElement(CommandBar_1.CommandBar, (0, tslib_1.__assign)({ items: commandBarItems }, props, { className: ribbonClassName + ' ' + ((props === null || props === void 0 ? void 0 : props.className) || ''), overflowButtonProps: (0, tslib_1.__assign)({ ariaLabel: (0, getLocalizedString_1.default)(strings, moreCommandsBtn.key, moreCommandsBtn.unlocalizedText) }, props === null || props === void 0 ? void 0 : props.overflowButtonProps) })));
}
exports.default = Ribbon;
//# sourceMappingURL=Ribbon.js.map