{"version":3,"file":"createRibbonPlugin.js","sourceRoot":"","sources":["../../../../../packages/roosterjs-react/lib/ribbon/plugin/createRibbonPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { getFormatState } from 'roosterjs-editor-api';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport { insertLink } from '../component/buttons/insertLink';\n\nimport { getObjectKeys, isCtrlOrMetaPressed } from 'roosterjs-editor-dom';\n\nimport type RibbonButton from '../type/RibbonButton';\nimport type RibbonPlugin from '../type/RibbonPlugin';\n\nimport type { FormatState, IEditor, PluginEvent } from 'roosterjs-editor-types';\nimport type { LocalizedStrings, UIUtilities, RibbonPluginOptions } from '../../common/index';\n\n/**\n * A plugin to connect format ribbon component and the editor\n */\nclass RibbonPluginImpl implements RibbonPlugin {\n    private editor: IEditor | null = null;\n    private onFormatChanged: ((formatState: FormatState) => void) | null = null;\n    private timer = 0;\n    private formatState: FormatState | null = null;\n    private uiUtilities: UIUtilities | null = null;\n    private options: RibbonPluginOptions | undefined;\n\n    /**\n     * Construct a new instance of RibbonPlugin object\n     * @param delayUpdateTime The time to wait before refresh the button when user do some editing operation in editor\n     * @param options The options for ribbon plugin to allow insert link on hot key press.\n     */\n    constructor(private delayUpdateTime: number = 200, options?: RibbonPluginOptions) {\n        this.options = options;\n    }\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'Ribbon';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n            case PluginEventType.ContentChanged:\n            case PluginEventType.ZoomChanged:\n                this.updateFormat();\n                break;\n\n            case PluginEventType.KeyDown:\n                if (\n                    event.rawEvent.key == 'k' &&\n                    isCtrlOrMetaPressed(event.rawEvent) &&\n                    !event.rawEvent.altKey &&\n                    this.options?.allowInsertLinkHotKey\n                ) {\n                    this.handleButtonClick(insertLink, 'insertLinkTitle', undefined);\n                    event.rawEvent.preventDefault();\n                }\n                break;\n            case PluginEventType.MouseUp:\n                this.delayUpdate();\n                break;\n        }\n    }\n\n    /**\n     * Set the UI utilities objects to this plugin to help render additional UI elements\n     * @param uiUtilities The UI utilities object to set\n     */\n    setUIUtilities(uiUtilities: UIUtilities) {\n        this.uiUtilities = uiUtilities;\n    }\n\n    /**\n     * Register a callback to be invoked when format state of editor is changed, returns a disposer function.\n     */\n    registerFormatChangedCallback(callback: (formatState: FormatState) => void) {\n        this.onFormatChanged = callback;\n\n        return () => {\n            this.onFormatChanged = null;\n        };\n    }\n\n    /**\n     * When user clicks on a button, call this method to let the plugin to handle this click event\n     * @param button The button that is clicked\n     * @param key Key of child menu item that is clicked if any\n     * @param strings The localized string map for this button\n     */\n    onButtonClick<T extends string>(\n        button: RibbonButton<T>,\n        key: T,\n        strings?: LocalizedStrings<T>\n    ) {\n        this.handleButtonClick(button, key, strings);\n    }\n\n    /**\n     * Common method to handle button clicks\n     * @param button The button that is clicked\n     * @param key Key of child menu item that is clicked if any\n     * @param strings The localized string map for this button\n     */\n    private handleButtonClick<T extends string>(\n        button: RibbonButton<T>,\n        key: T,\n        strings?: LocalizedStrings<T>\n    ) {\n        if (this.editor && this.uiUtilities) {\n            this.editor.stopShadowEdit();\n\n            button.onClick(this.editor, key, strings, this.uiUtilities);\n\n            if (button.isChecked || button.isDisabled || button.dropDownMenu?.getSelectedItemKey) {\n                this.updateFormat();\n            }\n        }\n    }\n\n    /**\n     * Enter live preview state (shadow edit) of editor if there is a non-collapsed selection\n     * @param button The button that triggered this action\n     * @param key Key of the hovered button sub item\n     * @param strings The localized string map for this button\n     */\n    startLivePreview<T extends string>(\n        button: RibbonButton<T>,\n        key: T,\n        strings?: LocalizedStrings<T>\n    ) {\n        if (this.editor && this.uiUtilities) {\n            const isInShadowEdit = this.editor.isInShadowEdit();\n\n            // If editor is already in shadow edit, no need to check again.\n            // And the check result may be incorrect because the content is changed from last shadow edit and the cached selection path won't apply\n            const range = !isInShadowEdit && this.editor.getSelectionRangeEx();\n\n            if (isInShadowEdit || (range && !range.areAllCollapsed)) {\n                this.editor.startShadowEdit();\n                button.onClick(this.editor, key, strings, this.uiUtilities);\n            }\n        }\n    }\n\n    /**\n     * Leave live preview state (shadow edit) of editor\n     */\n    stopLivePreview() {\n        this.editor?.stopShadowEdit();\n    }\n\n    private delayUpdate() {\n        const window = this.editor?.getDocument().defaultView;\n\n        if (!window) {\n            return;\n        }\n\n        if (this.timer) {\n            window.clearTimeout(this.timer);\n        }\n\n        this.timer = window.setTimeout(() => {\n            this.timer = 0;\n            this.updateFormat?.();\n        }, this.delayUpdateTime);\n    }\n\n    private updateFormat() {\n        if (this.editor && this.onFormatChanged) {\n            const newFormatState = getFormatState(this.editor);\n\n            if (\n                !this.formatState ||\n                getObjectKeys(newFormatState).some(\n                    key => newFormatState[key] != this.formatState?.[key]\n                )\n            ) {\n                this.formatState = newFormatState;\n                this.onFormatChanged(newFormatState);\n            }\n        }\n    }\n}\n\n/**\n * Create a new instance of RibbonPlugin object\n * @param delayUpdateTime The time to wait before refresh the button when user do some editing operation in editor\n * @param options The options for ribbon plugin to allow insert link on hot key press.\n */\nexport default function createRibbonPlugin(\n    delayUpdateTime?: number,\n    options?: RibbonPluginOptions\n): RibbonPlugin {\n    return new RibbonPluginImpl(delayUpdateTime, options);\n}\n"]}