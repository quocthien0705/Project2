import { getFormatState } from 'roosterjs-editor-api';
import { insertLink } from '../component/buttons/insertLink';
import { getObjectKeys, isCtrlOrMetaPressed } from 'roosterjs-editor-dom';
/**
 * A plugin to connect format ribbon component and the editor
 */
var RibbonPluginImpl = /** @class */ (function () {
    /**
     * Construct a new instance of RibbonPlugin object
     * @param delayUpdateTime The time to wait before refresh the button when user do some editing operation in editor
     * @param options The options for ribbon plugin to allow insert link on hot key press.
     */
    function RibbonPluginImpl(delayUpdateTime, options) {
        if (delayUpdateTime === void 0) { delayUpdateTime = 200; }
        this.delayUpdateTime = delayUpdateTime;
        this.editor = null;
        this.onFormatChanged = null;
        this.timer = 0;
        this.formatState = null;
        this.uiUtilities = null;
        this.options = options;
    }
    /**
     * Get a friendly name of this plugin
     */
    RibbonPluginImpl.prototype.getName = function () {
        return 'Ribbon';
    };
    /**
     * Initialize this plugin
     * @param editor The editor instance
     */
    RibbonPluginImpl.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    /**
     * Dispose this plugin
     */
    RibbonPluginImpl.prototype.dispose = function () {
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    RibbonPluginImpl.prototype.onPluginEvent = function (event) {
        var _a;
        switch (event.eventType) {
            case 11 /* EditorReady */:
            case 7 /* ContentChanged */:
            case 21 /* ZoomChanged */:
                this.updateFormat();
                break;
            case 0 /* KeyDown */:
                if (event.rawEvent.key == 'k' &&
                    isCtrlOrMetaPressed(event.rawEvent) &&
                    !event.rawEvent.altKey &&
                    ((_a = this.options) === null || _a === void 0 ? void 0 : _a.allowInsertLinkHotKey)) {
                    this.handleButtonClick(insertLink, 'insertLinkTitle', undefined);
                    event.rawEvent.preventDefault();
                }
                break;
            case 6 /* MouseUp */:
                this.delayUpdate();
                break;
        }
    };
    /**
     * Set the UI utilities objects to this plugin to help render additional UI elements
     * @param uiUtilities The UI utilities object to set
     */
    RibbonPluginImpl.prototype.setUIUtilities = function (uiUtilities) {
        this.uiUtilities = uiUtilities;
    };
    /**
     * Register a callback to be invoked when format state of editor is changed, returns a disposer function.
     */
    RibbonPluginImpl.prototype.registerFormatChangedCallback = function (callback) {
        var _this = this;
        this.onFormatChanged = callback;
        return function () {
            _this.onFormatChanged = null;
        };
    };
    /**
     * When user clicks on a button, call this method to let the plugin to handle this click event
     * @param button The button that is clicked
     * @param key Key of child menu item that is clicked if any
     * @param strings The localized string map for this button
     */
    RibbonPluginImpl.prototype.onButtonClick = function (button, key, strings) {
        this.handleButtonClick(button, key, strings);
    };
    /**
     * Common method to handle button clicks
     * @param button The button that is clicked
     * @param key Key of child menu item that is clicked if any
     * @param strings The localized string map for this button
     */
    RibbonPluginImpl.prototype.handleButtonClick = function (button, key, strings) {
        var _a;
        if (this.editor && this.uiUtilities) {
            this.editor.stopShadowEdit();
            button.onClick(this.editor, key, strings, this.uiUtilities);
            if (button.isChecked || button.isDisabled || ((_a = button.dropDownMenu) === null || _a === void 0 ? void 0 : _a.getSelectedItemKey)) {
                this.updateFormat();
            }
        }
    };
    /**
     * Enter live preview state (shadow edit) of editor if there is a non-collapsed selection
     * @param button The button that triggered this action
     * @param key Key of the hovered button sub item
     * @param strings The localized string map for this button
     */
    RibbonPluginImpl.prototype.startLivePreview = function (button, key, strings) {
        if (this.editor && this.uiUtilities) {
            var isInShadowEdit = this.editor.isInShadowEdit();
            // If editor is already in shadow edit, no need to check again.
            // And the check result may be incorrect because the content is changed from last shadow edit and the cached selection path won't apply
            var range = !isInShadowEdit && this.editor.getSelectionRangeEx();
            if (isInShadowEdit || (range && !range.areAllCollapsed)) {
                this.editor.startShadowEdit();
                button.onClick(this.editor, key, strings, this.uiUtilities);
            }
        }
    };
    /**
     * Leave live preview state (shadow edit) of editor
     */
    RibbonPluginImpl.prototype.stopLivePreview = function () {
        var _a;
        (_a = this.editor) === null || _a === void 0 ? void 0 : _a.stopShadowEdit();
    };
    RibbonPluginImpl.prototype.delayUpdate = function () {
        var _this = this;
        var _a;
        var window = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getDocument().defaultView;
        if (!window) {
            return;
        }
        if (this.timer) {
            window.clearTimeout(this.timer);
        }
        this.timer = window.setTimeout(function () {
            var _a;
            _this.timer = 0;
            (_a = _this.updateFormat) === null || _a === void 0 ? void 0 : _a.call(_this);
        }, this.delayUpdateTime);
    };
    RibbonPluginImpl.prototype.updateFormat = function () {
        var _this = this;
        if (this.editor && this.onFormatChanged) {
            var newFormatState_1 = getFormatState(this.editor);
            if (!this.formatState ||
                getObjectKeys(newFormatState_1).some(function (key) { var _a; return newFormatState_1[key] != ((_a = _this.formatState) === null || _a === void 0 ? void 0 : _a[key]); })) {
                this.formatState = newFormatState_1;
                this.onFormatChanged(newFormatState_1);
            }
        }
    };
    return RibbonPluginImpl;
}());
/**
 * Create a new instance of RibbonPlugin object
 * @param delayUpdateTime The time to wait before refresh the button when user do some editing operation in editor
 * @param options The options for ribbon plugin to allow insert link on hot key press.
 */
export default function createRibbonPlugin(delayUpdateTime, options) {
    return new RibbonPluginImpl(delayUpdateTime, options);
}
//# sourceMappingURL=createRibbonPlugin.js.map