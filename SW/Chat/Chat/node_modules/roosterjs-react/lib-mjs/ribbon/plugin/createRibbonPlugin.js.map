{"version":3,"file":"createRibbonPlugin.js","sourceRoot":"","sources":["../../../../../packages/roosterjs-react/lib/ribbon/plugin/createRibbonPlugin.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,sBAAsB,CAAC;AAEtD,OAAO,EAAE,UAAU,EAAE,MAAM,iCAAiC,CAAC;AAE7D,OAAO,EAAE,aAAa,EAAE,mBAAmB,EAAE,MAAM,sBAAsB,CAAC;AAQ1E;;GAEG;AACH;IAQI;;;;OAIG;IACH,0BAAoB,eAA6B,EAAE,OAA6B;QAA5D,gCAAA,EAAA,qBAA6B;QAA7B,oBAAe,GAAf,eAAe,CAAc;QAZzC,WAAM,GAAmB,IAAI,CAAC;QAC9B,oBAAe,GAAgD,IAAI,CAAC;QACpE,UAAK,GAAG,CAAC,CAAC;QACV,gBAAW,GAAuB,IAAI,CAAC;QACvC,gBAAW,GAAuB,IAAI,CAAC;QAS3C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,kCAAO,GAAP;QACI,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED;;;OAGG;IACH,qCAAU,GAAV,UAAW,MAAe;QACtB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACzB,CAAC;IAED;;OAEG;IACH,kCAAO,GAAP;QACI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;IACvB,CAAC;IAED;;;OAGG;IACH,wCAAa,GAAb,UAAc,KAAkB;;QAC5B,QAAQ,KAAK,CAAC,SAAS,EAAE;YACrB,0BAAiC;YACjC,4BAAoC;YACpC;gBACI,IAAI,CAAC,YAAY,EAAE,CAAC;gBACpB,MAAM;YAEV;gBACI,IACI,KAAK,CAAC,QAAQ,CAAC,GAAG,IAAI,GAAG;oBACzB,mBAAmB,CAAC,KAAK,CAAC,QAAQ,CAAC;oBACnC,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM;qBACtB,MAAA,IAAI,CAAC,OAAO,0CAAE,qBAAqB,CAAA,EACrC;oBACE,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,iBAAiB,EAAE,SAAS,CAAC,CAAC;oBACjE,KAAK,CAAC,QAAQ,CAAC,cAAc,EAAE,CAAC;iBACnC;gBACD,MAAM;YACV;gBACI,IAAI,CAAC,WAAW,EAAE,CAAC;gBACnB,MAAM;SACb;IACL,CAAC;IAED;;;OAGG;IACH,yCAAc,GAAd,UAAe,WAAwB;QACnC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;IACnC,CAAC;IAED;;OAEG;IACH,wDAA6B,GAA7B,UAA8B,QAA4C;QAA1E,iBAMC;QALG,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC;QAEhC,OAAO;YACH,KAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAChC,CAAC,CAAC;IACN,CAAC;IAED;;;;;OAKG;IACH,wCAAa,GAAb,UACI,MAAuB,EACvB,GAAM,EACN,OAA6B;QAE7B,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;IACjD,CAAC;IAED;;;;;OAKG;IACK,4CAAiB,GAAzB,UACI,MAAuB,EACvB,GAAM,EACN,OAA6B;;QAE7B,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,WAAW,EAAE;YACjC,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC;YAE7B,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;YAE5D,IAAI,MAAM,CAAC,SAAS,IAAI,MAAM,CAAC,UAAU,KAAI,MAAA,MAAM,CAAC,YAAY,0CAAE,kBAAkB,CAAA,EAAE;gBAClF,IAAI,CAAC,YAAY,EAAE,CAAC;aACvB;SACJ;IACL,CAAC;IAED;;;;;OAKG;IACH,2CAAgB,GAAhB,UACI,MAAuB,EACvB,GAAM,EACN,OAA6B;QAE7B,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,WAAW,EAAE;YACjC,IAAM,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC;YAEpD,+DAA+D;YAC/D,uIAAuI;YACvI,IAAM,KAAK,GAAG,CAAC,cAAc,IAAI,IAAI,CAAC,MAAM,CAAC,mBAAmB,EAAE,CAAC;YAEnE,IAAI,cAAc,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,EAAE;gBACrD,IAAI,CAAC,MAAM,CAAC,eAAe,EAAE,CAAC;gBAC9B,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;aAC/D;SACJ;IACL,CAAC;IAED;;OAEG;IACH,0CAAe,GAAf;;QACI,MAAA,IAAI,CAAC,MAAM,0CAAE,cAAc,EAAE,CAAC;IAClC,CAAC;IAEO,sCAAW,GAAnB;QAAA,iBAeC;;QAdG,IAAM,MAAM,GAAG,MAAA,IAAI,CAAC,MAAM,0CAAE,WAAW,GAAG,WAAW,CAAC;QAEtD,IAAI,CAAC,MAAM,EAAE;YACT,OAAO;SACV;QAED,IAAI,IAAI,CAAC,KAAK,EAAE;YACZ,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACnC;QAED,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC;;YAC3B,KAAI,CAAC,KAAK,GAAG,CAAC,CAAC;YACf,MAAA,KAAI,CAAC,YAAY,+CAAjB,KAAI,CAAiB,CAAC;QAC1B,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;IAC7B,CAAC;IAEO,uCAAY,GAApB;QAAA,iBAcC;QAbG,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,eAAe,EAAE;YACrC,IAAM,gBAAc,GAAG,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAEnD,IACI,CAAC,IAAI,CAAC,WAAW;gBACjB,aAAa,CAAC,gBAAc,CAAC,CAAC,IAAI,CAC9B,UAAA,GAAG,YAAI,OAAA,gBAAc,CAAC,GAAG,CAAC,KAAI,MAAA,KAAI,CAAC,WAAW,0CAAG,GAAG,CAAC,CAAA,CAAA,EAAA,CACxD,EACH;gBACE,IAAI,CAAC,WAAW,GAAG,gBAAc,CAAC;gBAClC,IAAI,CAAC,eAAe,CAAC,gBAAc,CAAC,CAAC;aACxC;SACJ;IACL,CAAC;IACL,uBAAC;AAAD,CAAC,AA3LD,IA2LC;AAED;;;;GAIG;AACH,MAAM,CAAC,OAAO,UAAU,kBAAkB,CACtC,eAAwB,EACxB,OAA6B;IAE7B,OAAO,IAAI,gBAAgB,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;AAC1D,CAAC","sourcesContent":["import { getFormatState } from 'roosterjs-editor-api';\nimport { PluginEventType } from 'roosterjs-editor-types';\nimport { insertLink } from '../component/buttons/insertLink';\n\nimport { getObjectKeys, isCtrlOrMetaPressed } from 'roosterjs-editor-dom';\n\nimport type RibbonButton from '../type/RibbonButton';\nimport type RibbonPlugin from '../type/RibbonPlugin';\n\nimport type { FormatState, IEditor, PluginEvent } from 'roosterjs-editor-types';\nimport type { LocalizedStrings, UIUtilities, RibbonPluginOptions } from '../../common/index';\n\n/**\n * A plugin to connect format ribbon component and the editor\n */\nclass RibbonPluginImpl implements RibbonPlugin {\n    private editor: IEditor | null = null;\n    private onFormatChanged: ((formatState: FormatState) => void) | null = null;\n    private timer = 0;\n    private formatState: FormatState | null = null;\n    private uiUtilities: UIUtilities | null = null;\n    private options: RibbonPluginOptions | undefined;\n\n    /**\n     * Construct a new instance of RibbonPlugin object\n     * @param delayUpdateTime The time to wait before refresh the button when user do some editing operation in editor\n     * @param options The options for ribbon plugin to allow insert link on hot key press.\n     */\n    constructor(private delayUpdateTime: number = 200, options?: RibbonPluginOptions) {\n        this.options = options;\n    }\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'Ribbon';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n            case PluginEventType.ContentChanged:\n            case PluginEventType.ZoomChanged:\n                this.updateFormat();\n                break;\n\n            case PluginEventType.KeyDown:\n                if (\n                    event.rawEvent.key == 'k' &&\n                    isCtrlOrMetaPressed(event.rawEvent) &&\n                    !event.rawEvent.altKey &&\n                    this.options?.allowInsertLinkHotKey\n                ) {\n                    this.handleButtonClick(insertLink, 'insertLinkTitle', undefined);\n                    event.rawEvent.preventDefault();\n                }\n                break;\n            case PluginEventType.MouseUp:\n                this.delayUpdate();\n                break;\n        }\n    }\n\n    /**\n     * Set the UI utilities objects to this plugin to help render additional UI elements\n     * @param uiUtilities The UI utilities object to set\n     */\n    setUIUtilities(uiUtilities: UIUtilities) {\n        this.uiUtilities = uiUtilities;\n    }\n\n    /**\n     * Register a callback to be invoked when format state of editor is changed, returns a disposer function.\n     */\n    registerFormatChangedCallback(callback: (formatState: FormatState) => void) {\n        this.onFormatChanged = callback;\n\n        return () => {\n            this.onFormatChanged = null;\n        };\n    }\n\n    /**\n     * When user clicks on a button, call this method to let the plugin to handle this click event\n     * @param button The button that is clicked\n     * @param key Key of child menu item that is clicked if any\n     * @param strings The localized string map for this button\n     */\n    onButtonClick<T extends string>(\n        button: RibbonButton<T>,\n        key: T,\n        strings?: LocalizedStrings<T>\n    ) {\n        this.handleButtonClick(button, key, strings);\n    }\n\n    /**\n     * Common method to handle button clicks\n     * @param button The button that is clicked\n     * @param key Key of child menu item that is clicked if any\n     * @param strings The localized string map for this button\n     */\n    private handleButtonClick<T extends string>(\n        button: RibbonButton<T>,\n        key: T,\n        strings?: LocalizedStrings<T>\n    ) {\n        if (this.editor && this.uiUtilities) {\n            this.editor.stopShadowEdit();\n\n            button.onClick(this.editor, key, strings, this.uiUtilities);\n\n            if (button.isChecked || button.isDisabled || button.dropDownMenu?.getSelectedItemKey) {\n                this.updateFormat();\n            }\n        }\n    }\n\n    /**\n     * Enter live preview state (shadow edit) of editor if there is a non-collapsed selection\n     * @param button The button that triggered this action\n     * @param key Key of the hovered button sub item\n     * @param strings The localized string map for this button\n     */\n    startLivePreview<T extends string>(\n        button: RibbonButton<T>,\n        key: T,\n        strings?: LocalizedStrings<T>\n    ) {\n        if (this.editor && this.uiUtilities) {\n            const isInShadowEdit = this.editor.isInShadowEdit();\n\n            // If editor is already in shadow edit, no need to check again.\n            // And the check result may be incorrect because the content is changed from last shadow edit and the cached selection path won't apply\n            const range = !isInShadowEdit && this.editor.getSelectionRangeEx();\n\n            if (isInShadowEdit || (range && !range.areAllCollapsed)) {\n                this.editor.startShadowEdit();\n                button.onClick(this.editor, key, strings, this.uiUtilities);\n            }\n        }\n    }\n\n    /**\n     * Leave live preview state (shadow edit) of editor\n     */\n    stopLivePreview() {\n        this.editor?.stopShadowEdit();\n    }\n\n    private delayUpdate() {\n        const window = this.editor?.getDocument().defaultView;\n\n        if (!window) {\n            return;\n        }\n\n        if (this.timer) {\n            window.clearTimeout(this.timer);\n        }\n\n        this.timer = window.setTimeout(() => {\n            this.timer = 0;\n            this.updateFormat?.();\n        }, this.delayUpdateTime);\n    }\n\n    private updateFormat() {\n        if (this.editor && this.onFormatChanged) {\n            const newFormatState = getFormatState(this.editor);\n\n            if (\n                !this.formatState ||\n                getObjectKeys(newFormatState).some(\n                    key => newFormatState[key] != this.formatState?.[key]\n                )\n            ) {\n                this.formatState = newFormatState;\n                this.onFormatChanged(newFormatState);\n            }\n        }\n    }\n}\n\n/**\n * Create a new instance of RibbonPlugin object\n * @param delayUpdateTime The time to wait before refresh the button when user do some editing operation in editor\n * @param options The options for ribbon plugin to allow insert link on hot key press.\n */\nexport default function createRibbonPlugin(\n    delayUpdateTime?: number,\n    options?: RibbonPluginOptions\n): RibbonPlugin {\n    return new RibbonPluginImpl(delayUpdateTime, options);\n}\n"]}