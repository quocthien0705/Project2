import { __assign, __read } from "tslib";
import * as React from 'react';
import getLocalizedString from '../../common/utils/getLocalizedString';
import { CommandBar } from '@fluentui/react/lib/CommandBar';
import { FocusZoneDirection } from '@fluentui/react/lib/FocusZone';
import { getObjectKeys } from 'roosterjs-editor-dom';
import { mergeStyles } from '@fluentui/react/lib/Styling';
import { moreCommands } from './buttons/moreCommands';
var ribbonClassName = mergeStyles({
    '& .ms-CommandBar': {
        padding: '0px',
    },
});
var rtlIcon = mergeStyles({
    transform: 'scaleX(-1)',
});
/**
 * The format ribbon component of roosterjs-react
 * @param props Properties of format ribbon component
 * @returns The format ribbon component
 */
export default function Ribbon(props) {
    var plugin = props.plugin, buttons = props.buttons, strings = props.strings, dir = props.dir;
    var _a = __read(React.useState(null), 2), formatState = _a[0], setFormatState = _a[1];
    var isRtl = dir == 'rtl';
    var onClick = React.useCallback(function (_, item) {
        if (item) {
            plugin === null || plugin === void 0 ? void 0 : plugin.onButtonClick(item.data, item.key, strings);
        }
    }, [plugin, strings]);
    var onHover = React.useCallback(function (button, key) {
        plugin.startLivePreview(button, key, strings);
    }, [plugin, strings]);
    var onDismiss = React.useCallback(function () {
        plugin.stopLivePreview();
    }, [plugin]);
    var flipIcon = React.useCallback(function (props, defaultRender) {
        if (!defaultRender) {
            return null;
        }
        return React.createElement("span", { className: rtlIcon }, defaultRender(props));
    }, []);
    var commandBarItems = React.useMemo(function () {
        return buttons.map(function (button) {
            var _a, _b, _c, _d;
            var selectedItem = formatState && ((_b = (_a = button.dropDownMenu) === null || _a === void 0 ? void 0 : _a.getSelectedItemKey) === null || _b === void 0 ? void 0 : _b.call(_a, formatState));
            var dropDownMenu = button.dropDownMenu;
            var result = __assign({ key: button.key, data: button, iconProps: {
                    iconName: button.iconName,
                }, onRenderIcon: isRtl && button.flipWhenRtl ? flipIcon : undefined, iconOnly: true, text: getLocalizedString(strings, button.key, button.unlocalizedText), ariaLabel: getLocalizedString(strings, button.key, button.unlocalizedText), canCheck: true, checked: (formatState && ((_c = button.isChecked) === null || _c === void 0 ? void 0 : _c.call(button, formatState))) || false, disabled: (formatState && ((_d = button.isDisabled) === null || _d === void 0 ? void 0 : _d.call(button, formatState))) || false }, (button.commandBarProperties || {}));
            var contextMenuItemRenderer = function (props, defaultRenderer) {
                return props && defaultRenderer ? (React.createElement("div", { onMouseOver: function (e) { return onHover(button, props.key); } }, defaultRenderer(props))) : null;
            };
            if (dropDownMenu) {
                result.subMenuProps = __assign({ shouldFocusOnMount: true, focusZoneProps: { direction: FocusZoneDirection.bidirectional }, onMenuDismissed: onDismiss, onItemClick: onClick, onRenderContextualMenuItem: dropDownMenu.allowLivePreview
                        ? contextMenuItemRenderer
                        : undefined, items: getObjectKeys(dropDownMenu.items).map(function (key) { return ({
                        key: key,
                        text: getLocalizedString(strings, key, dropDownMenu.items[key]),
                        data: button,
                        canCheck: !!dropDownMenu.getSelectedItemKey,
                        checked: selectedItem == key || false,
                        className: dropDownMenu.itemClassName,
                        onRender: dropDownMenu.itemRender
                            ? function (item) { return dropDownMenu.itemRender(item, onClick); }
                            : undefined,
                    }); }) }, (dropDownMenu.commandBarSubMenuProperties || {}));
            }
            else {
                result.onClick = onClick;
            }
            return result;
        });
    }, [buttons, formatState, isRtl, strings, onClick, onDismiss, onHover]);
    React.useEffect(function () {
        var disposer = plugin === null || plugin === void 0 ? void 0 : plugin.registerFormatChangedCallback(setFormatState);
        return function () {
            disposer === null || disposer === void 0 ? void 0 : disposer();
        };
    }, [plugin]);
    var moreCommandsBtn = moreCommands;
    return (React.createElement(CommandBar, __assign({ items: commandBarItems }, props, { className: ribbonClassName + ' ' + ((props === null || props === void 0 ? void 0 : props.className) || ''), overflowButtonProps: __assign({ ariaLabel: getLocalizedString(strings, moreCommandsBtn.key, moreCommandsBtn.unlocalizedText) }, props === null || props === void 0 ? void 0 : props.overflowButtonProps) })));
}
//# sourceMappingURL=Ribbon.js.map