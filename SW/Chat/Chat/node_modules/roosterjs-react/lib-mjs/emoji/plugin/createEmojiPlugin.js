import { __assign } from "tslib";
import * as React from 'react';
import showEmojiCallout from '../components/showEmojiCallout';
import { isModifierKey } from 'roosterjs-editor-dom';
import { KeyCodes } from '@fluentui/react/lib/Utilities';
import { MoreEmoji } from '../utils/emojiList';
import { replaceWithNode } from 'roosterjs-editor-api';
import { EmojiDescriptionStrings, EmojiFamilyStrings, EmojiKeywordStrings, } from '../type/EmojiStrings';
var KEYCODE_COLON = 186;
var KEYCODE_COLON_FIREFOX = 59;
// Regex looks for an emoji right before the : to allow contextual search immediately following an emoji
// MATCHES: 0: ðŸ˜ƒ:r
//          1: ðŸ˜ƒ
//          2: :r
var EMOJI_BEFORE_COLON_REGEX = /([\u0023-\u0039][\u20e3]|[\ud800-\udbff][\udc00-\udfff]|[\u00a9-\u00ae]|[\u2122-\u3299])*([:;][^:]*)/;
var EmojiPlugin = /** @class */ (function () {
    function EmojiPlugin(searchBoxStrings) {
        var _this = this;
        this.searchBoxStrings = searchBoxStrings;
        this.editor = null;
        this.eventHandledOnKeyDown = false;
        this.canUndoEmoji = false;
        this.isSuggesting = false;
        this.paneRef = React.createRef();
        this.timer = null;
        this.uiUtilities = null;
        this.emojiCalloutRef = React.createRef();
        this.baseId = 0;
        this.onHideCallout = function () { return _this.setIsSuggesting(false); };
        this.onSelectFromPane = function (emoji, wordBeforeCursor) {
            var _a;
            if (emoji === MoreEmoji) {
                (_a = _this.paneRef.current) === null || _a === void 0 ? void 0 : _a.showFullPicker(wordBeforeCursor);
                return;
            }
            _this.insertEmoji(emoji, wordBeforeCursor);
        };
        this.strings = __assign(__assign(__assign({}, EmojiDescriptionStrings), EmojiKeywordStrings), EmojiFamilyStrings);
    }
    EmojiPlugin.prototype.setUIUtilities = function (uiUtilities) {
        this.uiUtilities = uiUtilities;
    };
    EmojiPlugin.prototype.getName = function () {
        return 'Emoji';
    };
    EmojiPlugin.prototype.dispose = function () {
        var _a;
        this.setIsSuggesting(false);
        (_a = this.emojiCalloutRef.current) === null || _a === void 0 ? void 0 : _a.dismiss();
        this.editor = null;
        this.baseId = 0;
    };
    EmojiPlugin.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    EmojiPlugin.prototype.onPluginEvent = function (event) {
        if (event.eventType === 0 /* KeyDown */) {
            this.eventHandledOnKeyDown = false;
            if (this.isSuggesting) {
                this.onKeyDownSuggestingDomEvent(event);
            }
            else if (event.rawEvent.which === KeyCodes.backspace && this.canUndoEmoji) {
                //TODO: 1051
                // If KeyDown is backspace and canUndoEmoji, call editor undo
                this.editor.undo();
                this.handleEventOnKeyDown(event);
                this.canUndoEmoji = false;
            }
        }
        else if (event.eventType === 2 /* KeyUp */ && !isModifierKey(event.rawEvent)) {
            if (this.isSuggesting) {
                this.onKeyUpSuggestingDomEvent(event);
            }
            else {
                this.onKeyUpDomEvent(event);
            }
        }
        else if (event.eventType === 6 /* MouseUp */) {
            //TODO: 1052
            // If MouseUp, the emoji cannot be undone
            this.canUndoEmoji = false;
            this.setIsSuggesting(false);
        }
    };
    /**
     * On KeyDown suggesting DOM event
     * Try to insert emoji is possible
     * Intercept arrow keys to move selection if popup is shown
     */
    EmojiPlugin.prototype.onKeyDownSuggestingDomEvent = function (event) {
        // If key is enter, try insert emoji at selection
        // If key is space and selection is shortcut, try insert emoji
        var _a, _b;
        var wordBeforeCursor = this.getWordBeforeCursor(event);
        switch (event.rawEvent.which) {
            case KeyCodes.enter:
                var selectedEmoji = (_a = this.paneRef.current) === null || _a === void 0 ? void 0 : _a.getSelectedEmoji();
                // check if selection is on the "..." and show full picker if so, otherwise try to apply emoji
                if (!selectedEmoji ||
                    !wordBeforeCursor ||
                    this.tryShowFullPicker(event, selectedEmoji, wordBeforeCursor)) {
                    break;
                }
                else {
                    this.insertEmoji(selectedEmoji, wordBeforeCursor);
                    this.handleEventOnKeyDown(event);
                }
                break;
            case KeyCodes.left:
            case KeyCodes.right:
                (_b = this.paneRef.current) === null || _b === void 0 ? void 0 : _b.navigate(event.rawEvent.which === KeyCodes.left ? -1 : 1);
                this.handleEventOnKeyDown(event);
                break;
            case KeyCodes.escape:
                this.setIsSuggesting(false);
                this.handleEventOnKeyDown(event);
        }
    };
    EmojiPlugin.prototype.tryShowFullPicker = function (event, selectedEmoji, wordBeforeCursor) {
        var _a;
        if (selectedEmoji !== MoreEmoji) {
            return false;
        }
        this.handleEventOnKeyDown(event);
        (_a = this.paneRef.current) === null || _a === void 0 ? void 0 : _a.showFullPicker(wordBeforeCursor);
        return true;
    };
    /**
     * On KeyUp suggesting DOM event
     * If key is character, update search term
     * Otherwise set isSuggesting to false
     */
    EmojiPlugin.prototype.onKeyUpSuggestingDomEvent = function (event) {
        var _a, _b, _c, _d;
        if (this.eventHandledOnKeyDown) {
            return;
        }
        // If this is a character key or backspace
        // Clear the timer as we will either queue a new timer or stop suggesting
        if (this.timer &&
            ((event.rawEvent.key.length === 1 && event.rawEvent.which !== KeyCodes.space) ||
                event.rawEvent.which === KeyCodes.backspace)) {
            (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getDocument().defaultView) === null || _b === void 0 ? void 0 : _b.clearTimeout(this.timer);
            this.timer = null;
            (_c = this.emojiCalloutRef.current) === null || _c === void 0 ? void 0 : _c.dismiss();
        }
        var wordBeforeCursor = this.getWordBeforeCursor(event);
        if (wordBeforeCursor) {
            if (this.paneRef) {
                (_d = this.paneRef.current) === null || _d === void 0 ? void 0 : _d.setSearch(wordBeforeCursor);
            }
            else {
                this.setIsSuggesting(false);
            }
        }
        else {
            this.setIsSuggesting(false);
        }
    };
    EmojiPlugin.prototype.onKeyUpDomEvent = function (event) {
        if (this.eventHandledOnKeyDown) {
            return;
        }
        var wordBeforeCursor = this.getWordBeforeCursor(event);
        if ((event.rawEvent.which === KEYCODE_COLON ||
            event.rawEvent.which === KEYCODE_COLON_FIREFOX) &&
            wordBeforeCursor === ':') {
            this.setIsSuggesting(true);
        }
    };
    EmojiPlugin.prototype.getCallout = function () {
        var _a;
        var rangeNode = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getElementAtCursor();
        var rect = rangeNode === null || rangeNode === void 0 ? void 0 : rangeNode.getBoundingClientRect();
        if (this.uiUtilities && rect) {
            this.baseId++;
            showEmojiCallout(this.uiUtilities, rect, this.strings, this.onSelectFromPane, this.paneRef, this.emojiCalloutRef, this.onHideCallout, this.baseId, this.searchBoxStrings);
        }
    };
    EmojiPlugin.prototype.setIsSuggesting = function (isSuggesting) {
        var _a;
        if (this.isSuggesting === isSuggesting) {
            return;
        }
        this.isSuggesting = isSuggesting;
        if (this.isSuggesting) {
            this.getCallout();
        }
        else if (this.emojiCalloutRef) {
            (_a = this.emojiCalloutRef.current) === null || _a === void 0 ? void 0 : _a.dismiss();
        }
    };
    EmojiPlugin.prototype.insertEmoji = function (emoji, wordBeforeCursor) {
        var _this = this;
        var _a;
        if (!wordBeforeCursor || !this.editor || !emoji.codePoint) {
            return;
        }
        var node = this.editor.getDocument().createElement('span');
        node.innerText = emoji.codePoint;
        this.editor.addUndoSnapshot(function () {
            if (_this.editor) {
                replaceWithNode(_this.editor, wordBeforeCursor, node, true /*exactMatch*/);
                _this.editor.select(node, -3 /* After */);
            }
        }, undefined /*changeSource*/, true /*canUndoByBackspace*/);
        (_a = this.emojiCalloutRef.current) === null || _a === void 0 ? void 0 : _a.dismiss();
    };
    EmojiPlugin.prototype.getWordBeforeCursor = function (event) {
        var _a;
        var cursorData = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getContentSearcherOfCursor(event);
        var wordBeforeCursor = cursorData ? cursorData.getWordBefore() : null;
        var matches = wordBeforeCursor ? EMOJI_BEFORE_COLON_REGEX.exec(wordBeforeCursor) : null;
        return matches && matches.length > 2 && matches[0] === wordBeforeCursor ? matches[2] : null;
    };
    EmojiPlugin.prototype.handleEventOnKeyDown = function (event) {
        this.eventHandledOnKeyDown = true;
        event.rawEvent.preventDefault();
        event.rawEvent.stopImmediatePropagation();
    };
    return EmojiPlugin;
}());
/**
 * Create a new instance of Emoji plugin with FluentUI components.
 */
export default function createEmojiPlugin(searchBoxStrings) {
    return new EmojiPlugin(searchBoxStrings);
}
//# sourceMappingURL=createEmojiPlugin.js.map