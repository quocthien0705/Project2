import { __assign, __read } from "tslib";
import * as React from 'react';
import EmojiIcon from './EmojiIcon';
import EmojiNavBar from './EmojiNavBar';
import EmojiStatusBar from './EmojiStatusBar';
import { Callout, DirectionalHint } from '@fluentui/react/lib/Callout';
import { CommonEmojis, EmojiList, MoreEmoji } from '../utils/emojiList';
import { css, KeyCodes, memoizeFunction } from '@fluentui/react/lib/Utilities';
import { FocusZone } from '@fluentui/react/lib/FocusZone';
import { getLocalizedString } from '../../common/index';
import { mergeStyleSets } from '@fluentui/react/lib/Styling';
import { searchEmojis } from '../utils/searchEmojis';
import { TextField } from '@fluentui/react/lib/TextField';
import { useTheme } from '@fluentui/react/lib/Theme';
// "When a div contains an element that is bigger (either taller or wider) than the parent and has the property
// overflow-x or overflow-y set to any value, then it can receive the focus."
// https://bugzilla.mozilla.org/show_bug.cgi?id=1069739
var TabIndexForFirefoxBug = -1;
var EmojisPerRow = 7;
var EmojiVisibleRowCount = 5;
var EmojiVisibleWithoutNavBarRowCount = 6;
var EmojiHeightPx = 40;
var VerticalDirectionKeys = [KeyCodes.up, KeyCodes.down];
var DirectionKeys = [
    KeyCodes.left,
    KeyCodes.right,
    KeyCodes.up,
    KeyCodes.down,
    KeyCodes.home,
    KeyCodes.end,
];
var TooltipCalloutProps = {
    isBeakVisible: true,
    beakWidth: 16,
    gapSpace: 0,
    setInitialFocus: true,
    doNotLayer: false,
    directionalHint: DirectionalHint.bottomCenter,
};
/**
 * @internal
 * Types of emoji pane size
 */
// eslint-disable-next-line etc/no-const-enum
export var EmojiPaneMode;
(function (EmojiPaneMode) {
    EmojiPaneMode[EmojiPaneMode["Quick"] = 0] = "Quick";
    EmojiPaneMode[EmojiPaneMode["Partial"] = 1] = "Partial";
    EmojiPaneMode[EmojiPaneMode["Full"] = 2] = "Full";
})(EmojiPaneMode || (EmojiPaneMode = {}));
/**
 * @internal
 * Types of emoji Navigation direction
 */
// eslint-disable-next-line etc/no-const-enum
export var EmojiPaneNavigateDirection;
(function (EmojiPaneNavigateDirection) {
    EmojiPaneNavigateDirection[EmojiPaneNavigateDirection["Horizontal"] = 0] = "Horizontal";
    EmojiPaneNavigateDirection[EmojiPaneNavigateDirection["Vertical"] = 1] = "Vertical";
})(EmojiPaneNavigateDirection || (EmojiPaneNavigateDirection = {}));
var AriaAttributes = {
    ActiveDescendant: 'aria-activedescendant',
    AutoComplete: 'aria-autocomplete',
    Controls: 'aria-controls',
    Expanded: 'aria-expanded',
    HasPopup: 'aria-haspopup',
    Owns: 'aria-owns',
    Pressed: 'aria-pressed',
};
var EmojiPane = React.forwardRef(function EmojiPaneFunc(props, ref) {
    var searchBox;
    var emojiBody;
    var input;
    var _a = __read(React.useState(0), 2), index = _a[0], setIndex = _a[1];
    var _b = __read(React.useState(0 /* Quick */), 2), mode = _b[0], setMode = _b[1];
    var _c = __read(React.useState(CommonEmojis), 2), currentEmojiList = _c[0], setCurrentEmojiList = _c[1];
    var _d = __read(React.useState("People" /* People */), 2), currentFamily = _d[0], setCurrentFamily = _d[1];
    var _e = __read(React.useState(':'), 2), search = _e[0], setSearchString = _e[1];
    var _f = __read(React.useState(''), 2), searchInBox = _f[0], setSearchInBox = _f[1];
    var theme = useTheme();
    var classNames = getEmojiPaneClassName(theme);
    var listId = "EmojiPane" + props.baseId;
    var navigate = React.useCallback(function (change, direction) {
        if (!direction) {
            direction = 0 /* Horizontal */;
        }
        if (direction === 1 /* Vertical */ && index !== -1) {
            change *= EmojisPerRow;
        }
        var newIndex = index + change;
        var length = currentEmojiList.length;
        if (newIndex >= 0 && newIndex < length) {
            setIndex(newIndex);
            return newIndex;
        }
        return -1;
    }, [index]);
    var normalizeSearchText = React.useCallback(function (text, colonIncluded) {
        if (text == null) {
            return '';
        }
        if (colonIncluded) {
            text = text.substr(1);
        }
        return text.trim();
    }, []);
    var getEmojiElementIdByIndex = React.useCallback(function (index) {
        var emoji = currentEmojiList[index];
        if (emoji) {
            return getEmojiIconId(emoji);
        }
        return null;
    }, [currentEmojiList]);
    var getSelectedEmoji = React.useCallback(function () {
        return currentEmojiList[index];
    }, [currentEmojiList, index]);
    var showFullPicker = React.useCallback(function (fullSearchText) {
        var normalizedSearchValue = normalizeSearchText(fullSearchText, true);
        var newMode = normalizedSearchValue.length === 0 ? 2 /* Full */ : 1 /* Partial */;
        setIndex(newMode === 2 /* Full */ ? -1 : 0);
        setMode(newMode);
        setCurrentEmojiList(getSearchResult(normalizedSearchValue, newMode));
        setSearchString(fullSearchText);
        setSearchInBox(normalizedSearchValue);
    }, [mode]);
    var setSearch = React.useCallback(function (value) {
        var normalizedSearchValue = normalizeSearchText(value, false);
        setIndex(0);
        setCurrentEmojiList(getSearchResult(normalizedSearchValue, mode));
        setSearchString(value);
    }, [index, search, currentEmojiList]);
    var getSearchResult = React.useCallback(function (searchValue, mode) {
        var isQuickMode = mode === 0 /* Quick */;
        if (!searchValue) {
            return isQuickMode ? currentEmojiList : EmojiList[currentFamily];
        }
        var emojiList = searchEmojis(searchValue, props.strings);
        return isQuickMode ? emojiList.slice(0, 5).concat([MoreEmoji]) : emojiList;
    }, [mode, currentFamily, currentEmojiList]);
    var getEmojiIconId = React.useCallback(function (emoji) { return (emoji ? listId + "-" + emoji.key : ''); }, [listId]);
    React.useImperativeHandle(ref, function () { return ({
        navigate: navigate,
        getEmojiElementIdByIndex: getEmojiElementIdByIndex,
        showFullPicker: showFullPicker,
        getSearchResult: getSearchResult,
        setSearch: setSearch,
        getSelectedEmoji: getSelectedEmoji,
        normalizeSearchText: normalizeSearchText,
        getEmojiIconId: getEmojiIconId,
    }); }, [
        navigate,
        getEmojiElementIdByIndex,
        showFullPicker,
        getSearchResult,
        setSearch,
        getEmojiIconId,
        getSelectedEmoji,
        normalizeSearchText,
    ]);
    var renderQuickPicker = function (props, index, currentEmojiList) {
        var strings = props.strings;
        var selectedEmoji = getSelectedEmoji();
        var target = selectedEmoji ? "#" + getEmojiIconId(selectedEmoji) : undefined;
        var content = (selectedEmoji === null || selectedEmoji === void 0 ? void 0 : selectedEmoji.description) ? strings[selectedEmoji.description] : undefined;
        var emojiList = renderCurrentEmojiIcons(index, currentEmojiList);
        // note: we're using a callout since TooltipHost does not support manual trigger, and we need to show the tooltip since quick picker is shown
        // as an autocomplete menu (false focus based on transferring navigation keyboard event)
        return (React.createElement("div", { id: listId, role: "listbox" },
            emojiList,
            React.createElement("div", { id: listId, role: "listbox", className: css(classNames.quickPicker, classNames.roosterEmojiPane) },
                React.createElement(Callout, __assign({}, TooltipCalloutProps, { role: "tooltip", target: target, hidden: !content || !emojiList, className: classNames.tooltip }), content))));
    };
    var renderFullPicker = function (props, index, searchInBox, currentFamily, currentEmojiList) {
        var _a;
        var searchDisabled = props.searchDisabled, searchBoxString = props.searchBoxString;
        var emojiId = getEmojiIconId(getSelectedEmoji());
        var autoCompleteAttributes = (_a = {},
            _a[AriaAttributes.AutoComplete] = 'list',
            _a[AriaAttributes.Expanded] = 'true',
            _a[AriaAttributes.HasPopup] = 'listbox',
            _a[AriaAttributes.Owns] = listId,
            _a);
        if (emojiId) {
            autoCompleteAttributes[AriaAttributes.ActiveDescendant] = emojiId;
        }
        return (React.createElement("div", { className: classNames.roosterEmojiPane },
            !searchDisabled && (React.createElement(TextField, __assign({ role: "combobox", componentRef: function (ref) { return searchRefCallback(ref); }, value: searchInBox, onChange: onSearchChange, inputClassName: classNames.emojiTextInput, onKeyPress: onSearchKeyPress, onKeyDown: onSearchKeyDown, onFocus: onSearchFocus, placeholder: getLocalizedString(searchBoxString, 'emojiSearchPlaceholder', 'Search...'), ariaLabel: getLocalizedString(searchBoxString, 'emojiSearchInputAriaLabel', 'Search...') }, autoCompleteAttributes))),
            mode === 2 /* Full */
                ? renderFullList(props, index, currentFamily, currentEmojiList)
                : renderPartialList(props, index, currentEmojiList)));
    };
    var onSearchFocus = function (e) {
        input = e.target;
    };
    var onSearchKeyPress = function (e) {
        if (!e || e.which !== KeyCodes.enter) {
            return;
        }
        if (index >= 0 && currentEmojiList && currentEmojiList.length > 0) {
            onSelect(e, currentEmojiList[index]);
        }
    };
    var onSearchKeyDown = function (e) {
        if (!e || DirectionKeys.indexOf(e.which) < 0) {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        if (e.which === KeyCodes.home) {
            setIndex(0);
            emojiBody.scrollTop = 0;
            return;
        }
        if (e.which === KeyCodes.end) {
            setIndex(currentEmojiList.length - 1);
            emojiBody.scrollTop = emojiBody.scrollHeight; // scrollHeight will be larger than max
            return;
        }
        var direction = VerticalDirectionKeys.indexOf(e.which) < 0
            ? 0 /* Horizontal */
            : 1 /* Vertical */;
        var newIndex = navigate(e.which === KeyCodes.left || e.which === KeyCodes.up ? -1 : 1, direction);
        if (newIndex > -1) {
            var visibleRowCount = mode === 2 /* Full */
                ? EmojiVisibleRowCount
                : EmojiVisibleWithoutNavBarRowCount;
            var currentRow = Math.floor(newIndex / EmojisPerRow);
            var visibleTop = emojiBody.scrollTop;
            var visibleBottom = visibleTop + visibleRowCount * EmojiHeightPx;
            var currentRowTop = currentRow * EmojiHeightPx;
            var currentRowBottom = currentRowTop + EmojiHeightPx;
            if (visibleTop <= currentRowTop && visibleBottom >= currentRowBottom) {
                return; // row is visible, so exit
            }
            emojiBody.scrollTop = currentRow * EmojiHeightPx;
        }
    };
    var renderCurrentEmojiIcons = function (index, currentEmojiList) {
        var strings = props.strings;
        return currentEmojiList.map(function (emoji, emojiIndex) { return (React.createElement(EmojiIcon, { strings: strings, id: getEmojiIconId(emoji), key: emoji.key, onMouseOver: function () { return setIndex(emojiIndex); }, onFocus: function () { return setIndex(emojiIndex); }, emoji: emoji, classNames: classNames, isSelected: index === emojiIndex, onClick: function (e) { return onSelect(e, emoji); }, "aria-posinset": index + 1, "aria-setsize": currentEmojiList.length })); });
    };
    var renderPartialList = function (props, index, currentEmojiList) {
        var strings = props.strings, hideStatusBar = props.hideStatusBar, statusBarProps = props.statusBarProps;
        var hasResult = currentEmojiList && currentEmojiList.length > 0;
        return (React.createElement("div", null,
            React.createElement("div", { className: classNames.partialList, "data-is-scrollable": true, tabIndex: TabIndexForFirefoxBug, ref: onEmojiBodyRef },
                React.createElement(FocusZone, { id: listId, role: "listbox", className: classNames.fullListContent, ref: focusZoneRefCallback }, renderCurrentEmojiIcons(index, currentEmojiList))),
            !hideStatusBar && (React.createElement(EmojiStatusBar, __assign({ classNames: classNames, strings: strings }, statusBarProps, { hasResult: hasResult, emoji: getSelectedEmoji() })))));
    };
    var renderFullList = function (props, index, currentFamily, currentEmojiList) {
        var strings = props.strings, hideStatusBar = props.hideStatusBar, navBarProps = props.navBarProps, statusBarProps = props.statusBarProps;
        var hasResult = currentEmojiList && currentEmojiList.length > 0;
        return (React.createElement("div", { className: classNames.fullList },
            React.createElement("div", { className: classNames.fullListBody, "data-is-scrollable": true, tabIndex: TabIndexForFirefoxBug, ref: onEmojiBodyRef },
                React.createElement(EmojiNavBar, __assign({ strings: strings }, navBarProps, { onClick: pivotClick, currentSelected: currentFamily, getTabId: getTabId, classNames: classNames })),
                React.createElement("div", { role: "tabpanel", "aria-labelledby": getTabId(currentFamily) },
                    React.createElement("div", null,
                        React.createElement(FocusZone, { id: listId, role: "listbox", className: classNames.fullListContent, ref: focusZoneRefCallback }, renderCurrentEmojiIcons(index, currentEmojiList))))),
            !hideStatusBar && (React.createElement(EmojiStatusBar, __assign({ classNames: classNames, strings: strings }, statusBarProps, { hasResult: hasResult, emoji: getSelectedEmoji() })))));
    };
    var onEmojiBodyRef = function (ref) {
        emojiBody = ref;
    };
    var pivotClick = function (selected) {
        var currentFamily = selected;
        setCurrentEmojiList(EmojiList[currentFamily]);
        setCurrentFamily(currentFamily);
    };
    var getTabId = function (itemKey) {
        return "family_" + itemKey + "_" + props.baseId;
    };
    var searchRefCallback = function (ref) {
        if (ref) {
            searchBox = ref;
            if (searchBox === null || searchBox === void 0 ? void 0 : searchBox.value) {
                searchBox.focus();
                searchBox.setSelectionStart(searchBox.value.length);
            }
        }
    };
    var focusZoneRefCallback = function (ref) {
        if (props.searchDisabled && ref) {
            ref.focus();
        }
        if (input) {
            // make sure to announce the active descending after the focus zone containing the emojis is ready
            input.removeAttribute(AriaAttributes.ActiveDescendant);
            var emojiId_1 = getEmojiIconId(getSelectedEmoji());
            // we need to delay so NVDA will announce the first selection
            if (emojiId_1) {
                setTimeout(function () { return input.setAttribute(AriaAttributes.ActiveDescendant, emojiId_1); }, 0);
            }
        }
    };
    var onSearchChange = function (_, newValue) {
        if (typeof newValue === 'string') {
            var normalizedSearchValue = normalizeSearchText(newValue, false);
            var newMode = normalizedSearchValue.length === 0 ? 2 /* Full */ : 1 /* Partial */;
            setIndex(newMode === 2 /* Full */ ? -1 : 0);
            setCurrentEmojiList(getSearchResult(normalizedSearchValue, mode));
            setSearchInBox(newValue);
            setMode(newMode);
        }
    };
    var onSelect = function (e, emoji) {
        e.stopPropagation();
        e.preventDefault();
        if (props.onSelect) {
            props.onSelect(emoji, search);
        }
    };
    var renderPane = function (props, index, searchInBox, currentFamily, currentEmojiList) {
        return mode === 0 /* Quick */
            ? renderQuickPicker(props, index, currentEmojiList)
            : renderFullPicker(props, index, searchInBox, currentFamily, currentEmojiList);
    };
    return React.createElement(React.Fragment, null, renderPane(props, index, searchInBox, currentFamily, currentEmojiList));
});
/**
 * @internal
 * Emoji pane component
 */
export function showEmojiPane(onSelect, strings, paneRef, baseId, searchBoxString) {
    return (React.createElement(EmojiPane, { ref: paneRef, baseId: baseId, searchBoxString: searchBoxString, strings: strings, onSelect: onSelect }));
}
var calcMaxHeight = function () {
    var buttonHeight = 40;
    var rowsOfIcons = 6; // including family bar if shown
    var bottomPaddingForContent = 5;
    var maxHeightForContent = rowsOfIcons * buttonHeight + bottomPaddingForContent;
    return maxHeightForContent.toString() + 'px';
};
var calcPaneWidth = function () {
    var buttonWidth = 40;
    var pivotItemCount = 7;
    var paneHorizontalPadding = 1;
    var paneWidth = buttonWidth * pivotItemCount + 2 * paneHorizontalPadding;
    return paneWidth.toString() + 'px';
};
var getEmojiPaneClassName = memoizeFunction(function (theme) {
    var palette = theme.palette;
    return mergeStyleSets({
        quickPicker: {
            overflowY: 'hidden',
            ':after': {
                content: '',
                position: 'absolute',
                left: '0px',
                top: '0px',
                bottom: '0px',
                right: '0px',
                zIndex: 1,
                borderWidth: '1px',
                borderStyle: 'solid',
                borderColor: 'rgb(255, 255, 255)',
                borderImage: 'initial',
                outline: 'rgb(102, 102, 102) solid 1px',
            },
        },
        tooltip: {
            padding: '8px',
        },
        emojiTextInput: {
            padding: '6px',
        },
        partialList: {
            maxHeight: calcMaxHeight(),
            overflow: 'hidden',
            overflowY: 'scroll',
        },
        fullListContent: {
            width: calcPaneWidth(),
        },
        fullListBody: {
            maxHeight: calcMaxHeight(),
            overflow: 'hidden',
            overflowY: 'scroll',
            height: calcMaxHeight(),
        },
        fullList: {
            position: 'relative',
        },
        roosterEmojiPane: {
            padding: '1px',
            background: palette.white,
        },
        emoji: {
            fontSize: '18px',
            width: '40px',
            height: '40px',
            border: '0',
            position: 'relative',
            background: palette.white,
            transition: 'backgorund 0.5s ease-in-out',
        },
        emojiSelected: {
            background: palette.neutralLight,
        },
        navBar: {
            top: '-1px',
            zIndex: 10,
            position: 'sticky',
        },
        navBarTooltip: {
            display: 'inline-block',
        },
        navBarButton: {
            height: '40px',
            width: '40px',
            border: '0',
            borderBottom: 'solid 1px',
            padding: 0,
            marginBottom: 0,
            display: 'inline-block',
            color: palette.themeDark,
            background: palette.white,
            '&:hover': {
                cursor: 'default',
            },
        },
        selected: {
            borderBottom: '2px solid',
            borderBottomColor: palette.themeDark,
        },
        statusBar: {
            borderTop: 'solid 1px',
            height: '50px',
            overflow: 'hidden',
            position: 'relative',
            background: palette.white,
        },
        statusBarIcon: {
            padding: '4px',
            fontSize: '25px',
            display: 'inline-block',
            fontStyle: 'normal',
            fontWeight: 'normal',
            lineHeight: '40px',
        },
        statusBarDetailsContainer: {
            padding: '0 4px',
            lineHeight: '50px',
            position: 'absolute',
            display: 'inline-block',
            left: '40px',
            right: '0',
            top: '0',
        },
        statusBarDetails: {
            fontWeight: 'bold',
            whiteSpace: 'nowrap',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
        },
        statusBarNoResultDetailsContainer: {
            lineHeight: '50px',
            position: 'absolute',
            display: 'inline-block',
            top: '0',
            whiteSpace: 'nowrap',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            left: '0',
            padding: '0 8px',
        },
    });
});
//# sourceMappingURL=EmojiPane.js.map