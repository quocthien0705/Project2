"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addDelimiterBefore = exports.addDelimiterAfter = void 0;
var tslib_1 = require("tslib");
var createElement_1 = require("../utils/createElement");
var getDelimiterFromElement_1 = require("./getDelimiterFromElement");
var ZERO_WIDTH_SPACE = '\u200B';
/**
 * Adds delimiters to the element provided. If the delimiters already exists, will not be added
 * @param node the node to add the delimiters
 */
function addDelimiters(node) {
    var _a = (0, tslib_1.__read)(getDelimiters(node), 2), delimiterAfter = _a[0], delimiterBefore = _a[1];
    if (!delimiterAfter) {
        delimiterAfter = addDelimiterAfter(node);
    }
    if (!delimiterBefore) {
        delimiterBefore = addDelimiterBefore(node);
    }
    return [delimiterAfter, delimiterBefore];
}
exports.default = addDelimiters;
/**
 * Adds delimiter after the element provided.
 * @param element element to use
 */
function addDelimiterAfter(element) {
    return insertDelimiter(element, "entityDelimiterAfter" /* DELIMITER_AFTER */);
}
exports.addDelimiterAfter = addDelimiterAfter;
/**
 * Adds delimiter before the element provided.
 * @param element element to use
 */
function addDelimiterBefore(element) {
    return insertDelimiter(element, "entityDelimiterBefore" /* DELIMITER_BEFORE */);
}
exports.addDelimiterBefore = addDelimiterBefore;
function getDelimiters(entityWrapper) {
    var result = [];
    var nextElementSibling = entityWrapper.nextElementSibling, previousElementSibling = entityWrapper.previousElementSibling;
    result.push(isDelimiter(nextElementSibling, "entityDelimiterAfter" /* DELIMITER_AFTER */), isDelimiter(previousElementSibling, "entityDelimiterBefore" /* DELIMITER_BEFORE */));
    return result;
}
function isDelimiter(el, className) {
    return el && (0, getDelimiterFromElement_1.default)(el) && el.classList.contains(className) ? el : undefined;
}
function insertDelimiter(element, delimiterClass) {
    var span = (0, createElement_1.default)({
        tag: 'span',
        className: delimiterClass,
        children: [ZERO_WIDTH_SPACE],
    }, element.ownerDocument);
    if (span) {
        var insertPosition = delimiterClass == "entityDelimiterAfter" /* DELIMITER_AFTER */ ? 'afterend' : 'beforebegin';
        element.insertAdjacentElement(insertPosition, span);
    }
    return span;
}
//# sourceMappingURL=addDelimiters.js.map