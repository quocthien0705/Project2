"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInlineElementBeforeAfter = exports.getInlineElementAfter = exports.getInlineElementBefore = void 0;
var getInlineElementAtNode_1 = require("./getInlineElementAtNode");
var PartialInlineElement_1 = require("./PartialInlineElement");
var shouldSkipNode_1 = require("../utils/shouldSkipNode");
var getLeafSibling_1 = require("../utils/getLeafSibling");
/**
 * @internal
 * Get inline element before a position
 * This is mostly used when we want to get the inline element before selection/cursor
 * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)
 * in this case, we only want to return what is before cursor (a partial of an inline) to indicate
 * that we're in middle.
 * @param root Root node of current scope, use for create InlineElement
 * @param position The position to get InlineElement before
 */
function getInlineElementBefore(root, position) {
    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);
}
exports.getInlineElementBefore = getInlineElementBefore;
/**
 * @internal
 * Get inline element after a position
 * This is mostly used when we want to get the inline element after selection/cursor
 * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)
 * in this case, we only want to return what is before cursor (a partial of an inline) to indicate
 * that we're in middle.
 * @param root Root node of current scope, use for create InlineElement
 * @param position The position to get InlineElement after
 */
function getInlineElementAfter(root, position) {
    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);
}
exports.getInlineElementAfter = getInlineElementAfter;
/**
 * @internal
 */
function getInlineElementBeforeAfter(root, position, isAfter) {
    if (!root || !position || !position.node) {
        return null;
    }
    position = position.normalize();
    var offset = position.offset, isAtEnd = position.isAtEnd;
    var node = position.node;
    var isPartial = false;
    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {
        node = (0, getLeafSibling_1.getLeafSibling)(root, node, isAfter);
    }
    else if (node.nodeType == 3 /* Text */ &&
        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))) {
        isPartial = true;
    }
    if (node && (0, shouldSkipNode_1.default)(node)) {
        node = (0, getLeafSibling_1.getLeafSibling)(root, node, isAfter);
    }
    var inlineElement = (0, getInlineElementAtNode_1.default)(root, node);
    if (inlineElement && (isPartial || inlineElement.contains(position))) {
        inlineElement = isAfter
            ? new PartialInlineElement_1.default(inlineElement, position, undefined)
            : new PartialInlineElement_1.default(inlineElement, undefined, position);
    }
    return inlineElement;
}
exports.getInlineElementBeforeAfter = getInlineElementBeforeAfter;
//# sourceMappingURL=getInlineElementBeforeAfter.js.map