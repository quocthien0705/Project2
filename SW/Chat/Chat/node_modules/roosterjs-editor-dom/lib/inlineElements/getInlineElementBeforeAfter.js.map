{"version":3,"file":"getInlineElementBeforeAfter.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts"],"names":[],"mappings":";;;AAAA,mEAA8D;AAC9D,+DAA0D;AAC1D,0DAAqD;AACrD,0DAAyD;AAIzD;;;;;;;;;GASG;AACH,SAAgB,sBAAsB,CAAC,IAAU,EAAE,QAAsB;IACrE,OAAO,2BAA2B,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;AAC1E,CAAC;AAFD,wDAEC;AAED;;;;;;;;;GASG;AACH,SAAgB,qBAAqB,CAAC,IAAU,EAAE,QAAsB;IACpE,OAAO,2BAA2B,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;AACzE,CAAC;AAFD,sDAEC;AAED;;GAEG;AACH,SAAgB,2BAA2B,CAAC,IAAU,EAAE,QAAsB,EAAE,OAAgB;IAC5F,IAAI,CAAC,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE;QACtC,OAAO,IAAI,CAAC;KACf;IAED,QAAQ,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;IACxB,IAAA,MAAM,GAAc,QAAQ,OAAtB,EAAE,OAAO,GAAK,QAAQ,QAAb,CAAc;IACrC,IAAI,IAAI,GAAgB,QAAQ,CAAC,IAAI,CAAC;IACtC,IAAI,SAAS,GAAG,KAAK,CAAC;IAEtB,IAAI,CAAC,CAAC,OAAO,IAAI,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,EAAE;QAC/D,IAAI,GAAG,IAAA,+BAAc,EAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;KAC9C;SAAM,IACH,IAAI,CAAC,QAAQ,gBAAiB;QAC9B,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,IAAI,MAAM,GAAG,CAAC,CAAC,CAAC,EACrD;QACE,SAAS,GAAG,IAAI,CAAC;KACpB;IAED,IAAI,IAAI,IAAI,IAAA,wBAAc,EAAC,IAAI,CAAC,EAAE;QAC9B,IAAI,GAAG,IAAA,+BAAc,EAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;KAC9C;IAED,IAAI,aAAa,GAAG,IAAA,gCAAsB,EAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAEvD,IAAI,aAAa,IAAI,CAAC,SAAS,IAAI,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,EAAE;QAClE,aAAa,GAAG,OAAO;YACnB,CAAC,CAAC,IAAI,8BAAoB,CAAC,aAAa,EAAE,QAAQ,EAAE,SAAS,CAAC;YAC9D,CAAC,CAAC,IAAI,8BAAoB,CAAC,aAAa,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC;KACtE;IAED,OAAO,aAAa,CAAC;AACzB,CAAC;AAhCD,kEAgCC","sourcesContent":["import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\nimport type { InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement | null {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement | null {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    const { offset, isAtEnd } = position;\r\n    let node: Node | null = position.node;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, undefined)\r\n            : new PartialInlineElement(inlineElement, undefined, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n"]}