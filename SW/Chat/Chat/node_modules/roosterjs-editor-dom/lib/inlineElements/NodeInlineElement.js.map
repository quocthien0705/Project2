{"version":3,"file":"NodeInlineElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts"],"names":[],"mappings":";;AAAA,mDAA8C;AAC9C,oDAA+C;AAC/C,kDAA6C;AAI7C;;;;;GAKG;AACH;IACI,2BAAoB,aAAmB,EAAU,WAAyB;QAAtD,kBAAa,GAAb,aAAa,CAAM;QAAU,gBAAW,GAAX,WAAW,CAAc;IAAG,CAAC;IAE9E;;OAEG;IACI,0CAAc,GAArB;QACI,uFAAuF;QACvF,OAAO,CACH,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,gBAAiB;YACzC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS;YAC9B,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,IAAI,EAAE,CAC9C,CAAC;IACN,CAAC;IAED;;OAEG;IACI,4CAAgB,GAAvB;QACI,OAAO,IAAI,CAAC,aAAa,CAAC;IAC9B,CAAC;IAED,uBAAuB;IAChB,0CAAc,GAArB;QACI,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED;;OAEG;IACI,4CAAgB,GAAvB;QACI,4DAA4D;QAC5D,yEAAyE;QACzE,OAAO,IAAI,kBAAQ,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC;IAC3D,CAAC;IAED;;OAEG;IACI,0CAAc,GAArB;QACI,4DAA4D;QAC5D,wEAAwE;QACxE,OAAO,IAAI,kBAAQ,CAAC,IAAI,CAAC,aAAa,eAAmB,CAAC,SAAS,EAAE,CAAC;IAC1E,CAAC;IAED;;OAEG;IACI,kDAAsB,GAA7B;QACI,OAAO,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,gBAAiB,CAAC;IAC9E,CAAC;IAED;;OAEG;IACI,mCAAO,GAAd,UAAe,aAA4B;QACvC,OAAO,aAAa,IAAI,IAAA,qBAAW,EAAC,IAAI,CAAC,aAAa,EAAE,aAAa,CAAC,gBAAgB,EAAE,CAAC,CAAC;IAC9F,CAAC;IAED;;OAEG;IACI,oCAAQ,GAAf,UAAgB,GAAiB;QAC7B,IAAM,KAAK,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACtC,IAAM,GAAG,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QAClC,OAAO,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACzD,CAAC;IAED;;OAEG;IACI,sCAAU,GAAjB,UAAkB,MAA4D;QAC1E,IAAA,wBAAc,EAAC,IAAI,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;IAC/C,CAAC;IACL,wBAAC;AAAD,CAAC,AA1ED,IA0EC","sourcesContent":["import applyTextStyle from './applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport { NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be represented by a single html node.\r\n * This serves as base for most inline element as it contains most implementation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themselves for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return (\r\n            (this.containerNode.nodeType == NodeType.Text\r\n                ? this.containerNode.nodeValue\r\n                : this.containerNode.textContent) || ''\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        const start = this.getStartPosition();\r\n        const end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n"]}