"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var changeElementTag_1 = require("../utils/changeElementTag");
var contains_1 = require("../utils/contains");
var ContentTraverser_1 = require("../contentTraverser/ContentTraverser");
var createRange_1 = require("../selection/createRange");
var findClosestElementAncestor_1 = require("../utils/findClosestElementAncestor");
var getBlockElementAtNode_1 = require("../blockElements/getBlockElementAtNode");
var getTagOfNode_1 = require("../utils/getTagOfNode");
var isNodeEmpty_1 = require("../utils/isNodeEmpty");
var isPositionAtBeginningOf_1 = require("../selection/isPositionAtBeginningOf");
var isVoidHtmlElement_1 = require("../utils/isVoidHtmlElement");
var LinkInlineElement_1 = require("../inlineElements/LinkInlineElement");
var moveChildNodes_1 = require("../utils/moveChildNodes");
var pasteTable_1 = require("../table/pasteTable");
var Position_1 = require("../selection/Position");
var PositionContentSearcher_1 = require("../contentTraverser/PositionContentSearcher");
var queryElements_1 = require("../utils/queryElements");
var splitTextNode_1 = require("../utils/splitTextNode");
var toArray_1 = require("../jsUtils/toArray");
var unwrap_1 = require("../utils/unwrap");
var wrap_1 = require("../utils/wrap");
var splitParentNode_1 = require("../utils/splitParentNode");
var NOT_EDITABLE_SELECTOR = '[contenteditable=false]';
var adjustSteps = [
    adjustInsertPositionForHyperLink,
    adjustInsertPositionForStructuredNode,
    adjustInsertPositionForParagraph,
    adjustInsertPositionForVoidElement,
    adjustInsertPositionForMoveCursorOutOfALink,
    adjustInsertPositionForNotEditableNode,
    adjustInsertPositionForTable,
];
/**
 * Adjust position for A tag don't be nested inside another A tag.
 */
function adjustInsertPositionForHyperLink(root, nodeToInsert, position, range) {
    var _a, _b;
    var blockElement = (0, getBlockElementAtNode_1.default)(root, position.node);
    if (blockElement) {
        // Find the first <A> tag within current block which covers current selection
        // If there are more than one nested, let's handle the first one only since that is not a common scenario.
        var anchor = (0, queryElements_1.default)(root, 'a[href]', null /*forEachCallback*/, 1 /* OnSelection */, (0, createRange_1.default)(position)).filter(function (a) { return blockElement.contains(a); })[0];
        // If this is about to insert node to an empty A tag, clear the A tag and reset position
        if (anchor && (0, isNodeEmpty_1.default)(anchor)) {
            position = new Position_1.default(anchor, -2 /* Before */);
            safeRemove(anchor);
            anchor = null;
        }
        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag
        // otherwise we will have nested A tags which is a wrong HTML structure
        if (anchor &&
            ((_a = nodeToInsert) === null || _a === void 0 ? void 0 : _a.querySelector) &&
            ((_b = nodeToInsert) === null || _b === void 0 ? void 0 : _b.querySelector('a[href]'))) {
            var normalizedPosition = position.normalize();
            var parentNode = normalizedPosition.node.parentNode;
            var nextNode = normalizedPosition.node.nodeType == 3 /* Text */
                ? (0, splitTextNode_1.default)(normalizedPosition.node, normalizedPosition.offset, false /*returnFirstPart*/)
                : normalizedPosition.isAtEnd
                    ? normalizedPosition.node.nextSibling
                    : normalizedPosition.node;
            var splitter = root.ownerDocument.createTextNode('');
            parentNode.insertBefore(splitter, nextNode);
            while (splitter && (0, contains_1.default)(anchor, splitter)) {
                splitter = (0, splitParentNode_1.splitBalancedNodeRange)(splitter);
            }
            if (splitter) {
                position = new Position_1.default(splitter, -2 /* Before */);
                safeRemove(splitter);
            }
        }
    }
    return position;
}
/**
 * Adjust position for a node don't be nested inside tags like BR, LI, TD.
 */
function adjustInsertPositionForStructuredNode(root, nodeToInsert, position, range) {
    var rootNodeToInsert = nodeToInsert;
    var isFragment = false;
    if (rootNodeToInsert.nodeType == 11 /* DocumentFragment */) {
        isFragment = true;
        var rootNodes = (0, toArray_1.default)(rootNodeToInsert.childNodes).filter(function (n) { return (0, getTagOfNode_1.default)(n) != 'BR'; });
        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;
    }
    var tag = (0, getTagOfNode_1.default)(rootNodeToInsert);
    var hasBrNextToRoot = tag && rootNodeToInsert && (0, getTagOfNode_1.default)(rootNodeToInsert.nextSibling) == 'BR';
    var listItem = (0, findClosestElementAncestor_1.default)(position.node, root, 'LI');
    var listNode = listItem && (0, findClosestElementAncestor_1.default)(listItem, root, 'OL,UL');
    var tdNode = (0, findClosestElementAncestor_1.default)(position.node, root, 'TD,TH');
    if (tag == 'LI') {
        tag = listNode ? (0, getTagOfNode_1.default)(listNode) : 'UL';
        rootNodeToInsert = (0, wrap_1.default)(rootNodeToInsert, tag);
    }
    if ((tag == 'OL' || tag == 'UL') &&
        rootNodeToInsert &&
        (0, getTagOfNode_1.default)(rootNodeToInsert.firstChild) == 'LI') {
        var shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;
        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {
            safeRemove(rootNodeToInsert.nextSibling);
        }
        if (shouldInsertListAsText) {
            (0, unwrap_1.default)(rootNodeToInsert.firstChild);
            (0, unwrap_1.default)(rootNodeToInsert);
        }
        else if ((0, getTagOfNode_1.default)(listNode) == tag) {
            (0, unwrap_1.default)(rootNodeToInsert);
            position = new Position_1.default(listItem, (0, isPositionAtBeginningOf_1.default)(position, listItem)
                ? -2 /* Before */
                : -3 /* After */);
        }
    }
    if (isFragment && tag == 'TABLE' && tdNode) {
        (0, pasteTable_1.default)(tdNode, rootNodeToInsert, position, range);
        position = new Position_1.default(rootNodeToInsert, 0);
        (0, moveChildNodes_1.default)(nodeToInsert);
    }
    return position;
}
/**
 * Change P tag to DIV, when a new node when insert node.
 */
function adjustInsertPositionForParagraph(root, nodeToInsert, position, range) {
    if ((0, getTagOfNode_1.default)(position.node) == 'P') {
        // Insert into a P tag may cause issues when the inserted content contains any block element.
        // Change P tag to DIV to make sure it works well
        var pos = position.normalize();
        var div = (0, changeElementTag_1.default)(position.node, 'div');
        if (pos.node != div) {
            position = pos;
        }
    }
    return position;
}
/**
 * Adjust position for a node that can have children.
 */
function adjustInsertPositionForVoidElement(root, nodeToInsert, position, range) {
    if ((0, isVoidHtmlElement_1.default)(position.node)) {
        position = new Position_1.default(position.node, position.isAtEnd ? -3 /* After */ : -2 /* Before */);
    }
    return position;
}
/**
 * Adjust the position cursor out of link when a new node is inserted.
 */
function adjustInsertPositionForMoveCursorOutOfALink(root, nodeToInsert, position, range) {
    if (range && range.collapsed) {
        var searcher = new PositionContentSearcher_1.default(root, Position_1.default.getStart(range));
        var inlineElementBefore = searcher.getInlineElementBefore();
        var inlineElementAfter = searcher.getInlineElementAfter();
        if (inlineElementBefore instanceof LinkInlineElement_1.default) {
            position = new Position_1.default(inlineElementBefore.getContainerNode(), -3 /* After */);
        }
        else if (inlineElementAfter instanceof LinkInlineElement_1.default) {
            position = new Position_1.default(inlineElementAfter.getContainerNode(), -2 /* Before */);
        }
    }
    return position;
}
/**
 * Adjust the position cursor out of a not contenteditable element.
 */
function adjustInsertPositionForNotEditableNode(root, nodeToInsert, position, range) {
    var _a;
    if (!((_a = position.element) === null || _a === void 0 ? void 0 : _a.isContentEditable)) {
        var nonEditableElement = void 0;
        var lastNonEditableElement = (0, findClosestElementAncestor_1.default)(position.node, root, NOT_EDITABLE_SELECTOR);
        while (lastNonEditableElement) {
            nonEditableElement = lastNonEditableElement;
            lastNonEditableElement = (nonEditableElement === null || nonEditableElement === void 0 ? void 0 : nonEditableElement.parentElement)
                ? (0, findClosestElementAncestor_1.default)(nonEditableElement.parentElement, root, NOT_EDITABLE_SELECTOR)
                : null;
        }
        if (nonEditableElement) {
            position = new Position_1.default(nonEditableElement, -3 /* After */);
            return adjustInsertPositionForNotEditableNode(root, nodeToInsert, position, range);
        }
    }
    return position;
}
/**
 * Adjust the position of a table to be one line after another table.
 */
function adjustInsertPositionForTable(root, nodeToInsert, position, range) {
    if ((nodeToInsert.childNodes.length == 1 &&
        (0, getTagOfNode_1.default)(nodeToInsert.childNodes[0]) == 'TABLE') ||
        (0, getTagOfNode_1.default)(nodeToInsert) == 'TABLE') {
        var element = position.element;
        var posBefore = new Position_1.default(element, -2 /* Before */);
        var rangeToTraverse = (0, createRange_1.default)(posBefore, position);
        var contentTraverser = ContentTraverser_1.default.createSelectionTraverser(root, rangeToTraverse);
        var blockElement = contentTraverser && contentTraverser.currentBlockElement;
        if (blockElement) {
            var nextBlockElement = blockElement;
            while (!nextBlockElement) {
                nextBlockElement = contentTraverser.getNextBlockElement();
                if (nextBlockElement) {
                    blockElement = nextBlockElement;
                }
            }
            var prevElement = blockElement === null || blockElement === void 0 ? void 0 : blockElement.getEndNode();
            if (prevElement && (0, findClosestElementAncestor_1.default)(prevElement, root, 'TABLE')) {
                var tempRange = (0, createRange_1.default)(position);
                tempRange.collapse(false /* toStart */);
                var br = root.ownerDocument.createElement('br');
                tempRange.insertNode(br);
                tempRange = (0, createRange_1.default)(br);
                position = Position_1.default.getEnd(tempRange);
            }
        }
    }
    return position;
}
/**
 *
 * @param root the contentDiv of the ditor
 * @param nodeToInsert the node to be inserted
 * @param position the position of the node to be inserted
 * @param range the range current or cached range of the editor
 * @returns the adjusted position of the inserted node
 */
function adjustInsertPositionBySteps(root, nodeToInsert, position, range) {
    adjustSteps.forEach(function (handler) {
        position = handler(root, nodeToInsert, position, range);
    });
    return position;
}
exports.default = adjustInsertPositionBySteps;
function safeRemove(node) {
    var _a;
    (_a = node === null || node === void 0 ? void 0 : node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);
}
//# sourceMappingURL=adjustInsertPosition.js.map