{"version":3,"file":"adjustInsertPosition.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/edit/adjustInsertPosition.ts"],"names":[],"mappings":"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","sourcesContent":["import changeElementTag from '../utils/changeElementTag';\nimport contains from '../utils/contains';\nimport ContentTraverser from '../contentTraverser/ContentTraverser';\nimport createRange from '../selection/createRange';\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isNodeEmpty from '../utils/isNodeEmpty';\nimport isPositionAtBeginningOf from '../selection/isPositionAtBeginningOf';\nimport isVoidHtmlElement from '../utils/isVoidHtmlElement';\nimport LinkInlineElement from '../inlineElements/LinkInlineElement';\nimport moveChildNodes from '../utils/moveChildNodes';\nimport pasteTable from '../table/pasteTable';\nimport Position from '../selection/Position';\nimport PositionContentSearcher from '../contentTraverser/PositionContentSearcher';\nimport queryElements from '../utils/queryElements';\nimport splitTextNode from '../utils/splitTextNode';\nimport toArray from '../jsUtils/toArray';\nimport unwrap from '../utils/unwrap';\nimport wrap from '../utils/wrap';\nimport { NodeType, PositionType, QueryScope } from 'roosterjs-editor-types';\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\nimport type { BlockElement, NodePosition } from 'roosterjs-editor-types';\n\nconst NOT_EDITABLE_SELECTOR = '[contenteditable=false]';\n\nconst adjustSteps: ((\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n) => NodePosition)[] = [\n    adjustInsertPositionForHyperLink,\n    adjustInsertPositionForStructuredNode,\n    adjustInsertPositionForParagraph,\n    adjustInsertPositionForVoidElement,\n    adjustInsertPositionForMoveCursorOutOfALink,\n    adjustInsertPositionForNotEditableNode,\n    adjustInsertPositionForTable,\n];\n\n/**\n * Adjust position for A tag don't be nested inside another A tag.\n */\nfunction adjustInsertPositionForHyperLink(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    const blockElement = getBlockElementAtNode(root, position.node);\n\n    if (blockElement) {\n        // Find the first <A> tag within current block which covers current selection\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\n        let anchor: HTMLElement | null = queryElements(\n            root,\n            'a[href]',\n            null /*forEachCallback*/,\n            QueryScope.OnSelection,\n            createRange(position)\n        ).filter((a: HTMLElement) => blockElement!.contains(a))[0];\n\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\n        if (anchor && isNodeEmpty(anchor)) {\n            position = new Position(anchor, PositionType.Before);\n            safeRemove(anchor);\n            anchor = null;\n        }\n\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\n        // otherwise we will have nested A tags which is a wrong HTML structure\n        if (\n            anchor &&\n            (<ParentNode>(nodeToInsert as HTMLElement))?.querySelector &&\n            (<ParentNode>(nodeToInsert as HTMLElement))?.querySelector('a[href]')\n        ) {\n            const normalizedPosition = position.normalize();\n            const parentNode = normalizedPosition.node.parentNode!;\n            const nextNode =\n                normalizedPosition.node.nodeType == NodeType.Text\n                    ? splitTextNode(\n                          <Text>normalizedPosition.node,\n                          normalizedPosition.offset,\n                          false /*returnFirstPart*/\n                      )\n                    : normalizedPosition.isAtEnd\n                    ? normalizedPosition.node.nextSibling\n                    : normalizedPosition.node;\n            let splitter: Node | null = root.ownerDocument.createTextNode('');\n            parentNode.insertBefore(splitter, nextNode);\n\n            while (splitter && contains(anchor, splitter)) {\n                splitter = splitBalancedNodeRange(splitter);\n            }\n\n            if (splitter) {\n                position = new Position(splitter, PositionType.Before);\n                safeRemove(splitter);\n            }\n        }\n    }\n\n    return position;\n}\n\n/**\n * Adjust position for a node don't be nested inside tags like BR, LI, TD.\n */\nfunction adjustInsertPositionForStructuredNode(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    let rootNodeToInsert: Node | null = nodeToInsert;\n    let isFragment: boolean = false;\n\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\n        isFragment = true;\n        const rootNodes = toArray(rootNodeToInsert.childNodes).filter(\n            (n: ChildNode) => getTagOfNode(n) != 'BR'\n        );\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\n    }\n\n    let tag = getTagOfNode(rootNodeToInsert);\n    const hasBrNextToRoot =\n        tag && rootNodeToInsert && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\n    const listItem = findClosestElementAncestor(position.node, root, 'LI');\n    const listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\n    const tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\n\n    if (tag == 'LI') {\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\n        rootNodeToInsert = wrap(rootNodeToInsert!, tag);\n    }\n\n    if (\n        (tag == 'OL' || tag == 'UL') &&\n        rootNodeToInsert &&\n        getTagOfNode(rootNodeToInsert.firstChild) == 'LI'\n    ) {\n        const shouldInsertListAsText =\n            !rootNodeToInsert.firstChild!.nextSibling && !hasBrNextToRoot;\n\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\n            safeRemove(rootNodeToInsert.nextSibling!);\n        }\n\n        if (shouldInsertListAsText) {\n            unwrap(rootNodeToInsert.firstChild!);\n            unwrap(rootNodeToInsert);\n        } else if (getTagOfNode(listNode) == tag) {\n            unwrap(rootNodeToInsert);\n            position = new Position(\n                listItem!,\n                isPositionAtBeginningOf(position, listItem!)\n                    ? PositionType.Before\n                    : PositionType.After\n            );\n        }\n    }\n\n    if (isFragment && tag == 'TABLE' && tdNode) {\n        pasteTable(\n            <HTMLTableCellElement>tdNode,\n            <HTMLTableElement>rootNodeToInsert,\n            position,\n            range\n        );\n        position = new Position(rootNodeToInsert!, 0);\n        moveChildNodes(nodeToInsert);\n    }\n\n    return position;\n}\n\n/**\n * Change P tag to DIV, when a new node when insert node.\n */\n\nfunction adjustInsertPositionForParagraph(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    if (getTagOfNode(position.node) == 'P') {\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\n        // Change P tag to DIV to make sure it works well\n        const pos = position.normalize();\n        const div = changeElementTag(<HTMLElement>position.node, 'div');\n        if (pos.node != div) {\n            position = pos;\n        }\n    }\n\n    return position;\n}\n\n/**\n * Adjust position for a node that can have children.\n */\n\nfunction adjustInsertPositionForVoidElement(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    if (isVoidHtmlElement(position.node)) {\n        position = new Position(\n            position.node,\n            position.isAtEnd ? PositionType.After : PositionType.Before\n        );\n    }\n    return position;\n}\n\n/**\n * Adjust the position cursor out of link when a new node is inserted.\n */\n\nfunction adjustInsertPositionForMoveCursorOutOfALink(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    if (range && range.collapsed) {\n        const searcher = new PositionContentSearcher(root, Position.getStart(range));\n        const inlineElementBefore = searcher.getInlineElementBefore();\n        const inlineElementAfter = searcher.getInlineElementAfter();\n        if (inlineElementBefore instanceof LinkInlineElement) {\n            position = new Position(inlineElementBefore.getContainerNode(), PositionType.After);\n        } else if (inlineElementAfter instanceof LinkInlineElement) {\n            position = new Position(inlineElementAfter.getContainerNode(), PositionType.Before);\n        }\n    }\n    return position;\n}\n\n/**\n * Adjust the position cursor out of a not contenteditable element.\n */\nfunction adjustInsertPositionForNotEditableNode(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    if (!position.element?.isContentEditable) {\n        let nonEditableElement: HTMLElement | undefined;\n        let lastNonEditableElement: HTMLElement | null = findClosestElementAncestor(\n            position.node,\n            root,\n            NOT_EDITABLE_SELECTOR\n        );\n\n        while (lastNonEditableElement) {\n            nonEditableElement = lastNonEditableElement;\n            lastNonEditableElement = nonEditableElement?.parentElement\n                ? findClosestElementAncestor(\n                      nonEditableElement.parentElement,\n                      root,\n                      NOT_EDITABLE_SELECTOR\n                  )\n                : null;\n        }\n\n        if (nonEditableElement) {\n            position = new Position(nonEditableElement, PositionType.After);\n            return adjustInsertPositionForNotEditableNode(root, nodeToInsert, position, range);\n        }\n    }\n\n    return position;\n}\n\n/**\n * Adjust the position of a table to be one line after another table.\n */\nfunction adjustInsertPositionForTable(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    if (\n        (nodeToInsert.childNodes.length == 1 &&\n            getTagOfNode(nodeToInsert.childNodes[0]) == 'TABLE') ||\n        getTagOfNode(nodeToInsert) == 'TABLE'\n    ) {\n        const { element } = position;\n\n        const posBefore = new Position(element, PositionType.Before);\n        const rangeToTraverse = createRange(posBefore, position);\n        const contentTraverser = ContentTraverser.createSelectionTraverser(root, rangeToTraverse);\n\n        let blockElement = contentTraverser && contentTraverser.currentBlockElement;\n\n        if (blockElement) {\n            let nextBlockElement: BlockElement | null = blockElement;\n\n            while (!nextBlockElement) {\n                nextBlockElement = contentTraverser.getNextBlockElement();\n                if (nextBlockElement) {\n                    blockElement = nextBlockElement;\n                }\n            }\n\n            const prevElement = blockElement?.getEndNode();\n\n            if (prevElement && findClosestElementAncestor(prevElement, root, 'TABLE')) {\n                let tempRange = createRange(position);\n                tempRange.collapse(false /* toStart */);\n                const br = root.ownerDocument.createElement('br');\n                tempRange.insertNode(br);\n\n                tempRange = createRange(br);\n                position = Position.getEnd(tempRange);\n            }\n        }\n    }\n    return position;\n}\n\n/**\n *\n * @param root the contentDiv of the ditor\n * @param nodeToInsert the node to be inserted\n * @param position the position of the node to be inserted\n * @param range the range current or cached range of the editor\n * @returns the adjusted position of the inserted node\n */\n\nexport default function adjustInsertPositionBySteps(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    adjustSteps.forEach(handler => {\n        position = handler(root, nodeToInsert, position, range);\n    });\n    return position;\n}\n\nfunction safeRemove(node: Node) {\n    node?.parentNode?.removeChild(node);\n}\n"]}