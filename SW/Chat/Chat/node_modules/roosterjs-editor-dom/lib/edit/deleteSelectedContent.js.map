{"version":3,"file":"deleteSelectedContent.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/edit/deleteSelectedContent.ts"],"names":[],"mappings":"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","sourcesContent":["import arrayPush from '../jsUtils/arrayPush';\nimport collapseNodesInRegion from '../region/collapseNodesInRegion';\nimport getRegionsFromRange from '../region/getRegionsFromRange';\nimport getSelectionRangeInRegion from '../region/getSelectionRangeInRegion';\nimport mergeBlocksInRegion from '../region/mergeBlocksInRegion';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitTextNode from '../utils/splitTextNode';\nimport { PositionType, QueryScope, RegionType } from 'roosterjs-editor-types';\nimport type { NodePosition } from 'roosterjs-editor-types';\n\n/**\n * Delete selected content, and return the new position to select\n * @param core The EditorCore object.\n * @param range The range to delete\n */\nexport default function deleteSelectedContent(\n    root: HTMLElement,\n    range: Range\n): NodePosition | null {\n    let nodeBefore: Node | null = null;\n\n    // 1. TABLE and TR node in selected should be deleted. It is possible we don't detect them from step 2\n    // since table cells will fall in to different regions\n    const nodesToDelete: Node[] = queryElements(\n        root,\n        'table,tr',\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // 2. Loop all selected regions, find out those nodes need to be deleted and merged.\n    // We don't delete them directly here because delete node from one region may cause selection range\n    // another region becomes invalid. So we delay the process of deletion.\n    const regions = getRegionsFromRange(root, range, RegionType.Table);\n    const nodesPairToMerge = regions\n        .map(region => {\n            const regionRange = getSelectionRangeInRegion(region);\n            if (!regionRange) {\n                return null;\n            }\n\n            const {\n                startContainer,\n                endContainer,\n                startOffset,\n                endOffset,\n                commonAncestorContainer,\n            } = regionRange;\n\n            // Disallow merging of readonly elements\n            if (\n                safeInstanceOf(commonAncestorContainer, 'HTMLElement') &&\n                !commonAncestorContainer.isContentEditable\n            ) {\n                return null;\n            }\n\n            // Make sure there are node before and after the merging point.\n            // This is required by mergeBlocksInRegion API.\n            // This may create some empty text node as anchor\n            const [beforeEnd, afterEnd] = ensureBeforeAndAfter(\n                endContainer,\n                endOffset,\n                false /*isStart*/\n            );\n            const [beforeStart, afterStart] = ensureBeforeAndAfter(\n                startContainer,\n                startOffset,\n                true /*isStart*/\n            );\n            nodeBefore = nodeBefore || beforeStart;\n\n            // Find out all nodes to be deleted\n            const nodes = collapseNodesInRegion(region, [afterStart, beforeEnd]);\n            arrayPush(nodesToDelete, nodes);\n            return { region, beforeStart, afterEnd };\n        })\n        .filter(x => !!x);\n\n    // 3. Delete all nodes that we found, whose parent is editable\n    nodesToDelete.forEach(\n        node => node.parentElement?.isContentEditable && node.parentElement.removeChild(node)\n    );\n\n    // 4. Merge lines for each region, so that after we don't see extra line breaks\n    nodesPairToMerge.forEach(nodes => {\n        if (nodes) {\n            mergeBlocksInRegion(nodes.region, nodes.beforeStart, nodes.afterEnd);\n        }\n    });\n\n    return nodeBefore && new Position(nodeBefore, PositionType.End);\n}\n\nfunction ensureBeforeAndAfter(node: Node, offset: number, isStart: boolean) {\n    if (safeInstanceOf(node, 'Text')) {\n        const newNode = splitTextNode(node, offset, isStart);\n        return isStart ? [newNode, node] : [node, newNode];\n    } else {\n        let nodeBefore: Node | null = node.childNodes[offset - 1];\n        let nodeAfter: Node | null = node.childNodes[offset];\n\n        // Condition 1: node child nodes\n        // (\"I\" means cursor; \"o\" means a DOM node, \"[ ]\" means a parent node)\n        // [ I ]\n        // need to use parent node instead to convert to condition 2\n        if (!nodeBefore && !nodeAfter) {\n            if (isStart) {\n                nodeAfter = node;\n                nodeBefore = nodeAfter.previousSibling;\n            } else {\n                nodeBefore = node;\n                nodeAfter = nodeBefore.nextSibling;\n            }\n        }\n\n        // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)\n        // [ o I ]  or [ I o]\n        // need to add empty text node to convert to condition 3\n        if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {\n            const emptyNode = node.ownerDocument!.createTextNode('');\n            (nodeBefore || nodeAfter)?.parentNode?.insertBefore(emptyNode, nodeAfter);\n            if (nodeBefore) {\n                nodeAfter = emptyNode;\n            } else {\n                nodeBefore = emptyNode;\n            }\n        }\n\n        // Condition 3: Both nodeBefore and nodeAfter are not null\n        // [o I o]\n        // return the nodes\n        return [nodeBefore!, nodeAfter!];\n    }\n}\n"]}