{"version":3,"file":"PositionContentSearcher.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts"],"names":[],"mappings":";;AAAA,uDAAkD;AAClD,wDAAmD;AAQnD,0DAA0D;AAC1D,kBAAkB;AAClB,kCAAkC;AAClC,2BAA2B;AAC3B,yDAAyD;AACzD,IAAM,gBAAgB,GAAG,qDAAqD,CAAC;AAE/E;;GAEG;AACH;IAyBI;;;;OAIG;IACH,iCAAoB,QAAc,EAAU,QAAsB;QAA9C,aAAQ,GAAR,QAAQ,CAAM;QAAU,aAAQ,GAAR,QAAQ,CAAc;QA7BlE,4DAA4D;QACpD,SAAI,GAAG,EAAE,CAAC;QAElB,kCAAkC;QAC1B,SAAI,GAAW,EAAE,CAAC;QAE1B,qCAAqC;QAC7B,iBAAY,GAAyB,IAAI,CAAC;QAElD,oCAAoC;QAC5B,gBAAW,GAAyB,IAAI,CAAC;QAEjD,mDAAmD;QAC3C,cAAS,GAA6B,IAAI,CAAC;QAEnD,iCAAiC;QACzB,uBAAkB,GAAY,KAAK,CAAC;QAE5C,iEAAiE;QACzD,mBAAc,GAAoB,EAAE,CAAC;QAE7C,wCAAwC;QAChC,gCAA2B,GAAyB,IAAI,CAAC;IAOI,CAAC;IAEtE;;;;OAIG;IACI,+CAAa,GAApB;QAAA,iBAMC;QALG,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACZ,IAAI,CAAC,QAAQ,CAAC,cAAM,OAAA,KAAI,CAAC,IAAI,EAAT,CAAS,CAAC,CAAC;SAClC;QAED,OAAO,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC;IAC3B,CAAC;IAED;;;OAGG;IACI,wDAAsB,GAA7B;QACI,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;YACpB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACvB;QAED,OAAO,IAAI,CAAC,YAAY,CAAC;IAC7B,CAAC;IAED;;;OAGG;IACI,uDAAqB,GAA5B;QACI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACnB,IAAI,CAAC,WAAW,GAAG,0BAAgB,CAAC,oBAAoB,CACpD,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,QAAQ,CAChB,CAAC,oBAAoB,CAAC;SAC1B;QAED,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED;;;;;;;OAOG;IACI,oDAAkB,GAAzB,UAA0B,MAAc;QAAxC,iBAMC;QALG,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,MAAM,EAAE;YAC3B,IAAI,CAAC,QAAQ,CAAC,cAAM,OAAA,KAAI,CAAC,IAAI,CAAC,MAAM,IAAI,MAAM,EAA1B,CAA0B,CAAC,CAAC;SACnD;QAED,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC;IACpE,CAAC;IAED;;;;;OAKG;IACI,kDAAgB,GAAvB,UAAwB,IAAY,EAAE,UAAmB;QACrD,IAAI,CAAC,IAAI,EAAE;YACP,OAAO,IAAI,CAAC;SACf;QAED,IAAI,aAAa,GAAwB,IAAI,CAAC;QAC9C,IAAI,WAAW,GAAwB,IAAI,CAAC;QAC5C,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAEhC,IAAI,CAAC,wBAAwB,CAAC,UAAA,UAAU;YACpC,IAAM,WAAW,GAAG,UAAU,CAAC,cAAc,EAAE,IAAI,EAAE,CAAC;YACtD,IAAI,SAAS,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;YACvC,OAAO,SAAS,IAAI,CAAC,IAAI,SAAS,IAAI,CAAC,EAAE,SAAS,EAAE,EAAE;gBAClD,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,WAAW,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;oBACjE,SAAS,EAAE,CAAC;oBAEZ,0DAA0D;oBAC1D,IAAI,CAAC,WAAW,EAAE;wBACd,WAAW,GAAG,UAAU,CAAC,gBAAgB,EAAE,CAAC,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;qBACnE;iBACJ;qBAAM,IAAI,UAAU,IAAI,WAAW,EAAE;oBAClC,wFAAwF;oBACxF,OAAO,IAAI,CAAC;iBACf;aACJ;YAED,4DAA4D;YAC5D,IAAI,SAAS,IAAI,CAAC,CAAC,EAAE;gBACjB,aAAa,GAAG,UAAU,CAAC,gBAAgB,EAAE,CAAC,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;gBAClE,OAAO,IAAI,CAAC;aACf;YAED,OAAO,KAAK,CAAC;QACjB,CAAC,CAAC,CAAC;QAEH,OAAO,aAAa,IAAI,WAAW,IAAI,IAAA,qBAAW,EAAC,aAAa,EAAE,WAAW,CAAC,CAAC;IACnF,CAAC;IAED;;;;;;;OAOG;IACI,0DAAwB,GAA/B,UAAgC,QAAmD;QAC/E,yCAAyC;QACzC,0EAA0E;QAC1E,iEAAiE;QACjE,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACrC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;SAC3B;IACL,CAAC;IAED;;;OAGG;IACI,gEAA8B,GAArC;QAAA,iBAMC;QALG,IAAI,CAAC,IAAI,CAAC,2BAA2B,EAAE;YACnC,IAAI,CAAC,QAAQ,CAAC,cAAM,OAAA,KAAI,CAAC,2BAA2B,EAAhC,CAAgC,CAAC,CAAC;SACzD;QAED,OAAO,IAAI,CAAC,2BAA2B,CAAC;IAC5C,CAAC;IAED;;OAEG;IACK,0CAAQ,GAAhB,UAAiB,QAAwD;QACrE,IAAI,CAAC,SAAS;YACV,IAAI,CAAC,SAAS,IAAI,0BAAgB,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAE1F,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC5C,OAAO;SACV;QAED,IAAI,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,wBAAwB,EAAE,CAAC;QAC/D,OAAO,CAAC,IAAI,CAAC,kBAAkB,EAAE;YAC7B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,IAAI,cAAc,CAAC;YAExD,IAAI,cAAc,IAAI,cAAc,CAAC,sBAAsB,EAAE,EAAE;gBAC3D,IAAM,WAAW,GAAG,cAAc,CAAC,cAAc,EAAE,CAAC;gBAEpD,wDAAwD;gBACxD,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;oBACZ,+FAA+F;oBAC/F,6DAA6D;oBAC7D,IAAM,OAAO,GAAG,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;oBACnD,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,IAAI,CAAC,EAAE;wBAChC,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;qBACtC;iBACJ;gBAED,IAAI,CAAC,IAAI,GAAG,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC;gBACpC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;gBAEzC,iCAAiC;gBACjC,IAAI,QAAQ,IAAI,QAAQ,CAAC,cAAc,CAAC,EAAE;oBACtC,MAAM;iBACT;aACJ;iBAAM;gBACH,IAAI,CAAC,2BAA2B,GAAG,cAAc,CAAC;gBAClD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;gBAC/B,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;oBACZ,8GAA8G;oBAC9G,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;iBACzB;gBAED,mFAAmF;gBACnF,wFAAwF;gBACxF,mFAAmF;gBACnF,MAAM;aACT;YAED,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,wBAAwB,EAAE,CAAC;SAC9D;IACL,CAAC;IACL,8BAAC;AAAD,CAAC,AArND,IAqNC","sourcesContent":["import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport type {\r\n    IContentTraverser,\r\n    InlineElement,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher implements IPositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string = '';\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement | null = null;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement | null = null;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: IContentTraverser | null = null;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean = false;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement | null = null;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word || '';\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement | null {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement | null {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determines the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range | null {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition | null = null;\r\n        let endPosition: NodePosition | null = null;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            const nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textual inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement | null {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: null | ((inlineElement: InlineElement) => any)) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                const textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    const matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n"]}