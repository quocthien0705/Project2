import { ContentPosition } from 'roosterjs-editor-types';
import type TraversingScoper from './TraversingScoper';
import type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';
import type { CompatibleContentPosition } from 'roosterjs-editor-types/lib/compatibleTypes';
/**
 * @internal
 * This provides traversing content in a selection start block
 * This is commonly used for those cursor context sensitive plugin,
 * they want to know text being typed at cursor
 * This provides a scope for parsing from cursor position up to begin of the selection block
 */
export default class SelectionBlockScoper implements TraversingScoper {
    rootNode: Node;
    private startFrom;
    private block;
    private position;
    /**
     * Create a new instance of SelectionBlockScoper class
     * @param rootNode The root node of the whole scope
     * @param position Position of the selection start
     * @param startFrom Where to start, can be Begin, End, SelectionStart
     */
    constructor(rootNode: Node, position: NodePosition | Range, startFrom: ContentPosition | CompatibleContentPosition);
    /**
     * Get the start block element
     */
    getStartBlockElement(): BlockElement | null;
    /**
     * Get the start inline element
     * The start inline refers to inline before the selection start
     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragraph,
     * the one after likely will point to inline in next paragraph which may be null if the cursor is at bottom of editor
     */
    getStartInlineElement(): InlineElement | null;
    /**
     * Check if the given block element is in current scope
     * @param blockElement The block element to check
     */
    isBlockInScope(blockElement: BlockElement): boolean;
    /**
     * Trim the incoming inline element, and return an inline element
     * This just tests and return the inline element if it is in block
     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half
     * A block scoper does not cut an inline in half
     */
    trimInlineElement(inlineElement: InlineElement): InlineElement | null;
}
