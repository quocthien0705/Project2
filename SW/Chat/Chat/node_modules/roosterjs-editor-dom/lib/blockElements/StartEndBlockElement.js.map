{"version":3,"file":"StartEndBlockElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts"],"names":[],"mappings":"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","sourcesContent":["import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport createRange from '../selection/createRange';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\nimport type { BlockElement } from 'roosterjs-editor-types';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * @internal\r\n * This represents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) {}\r\n\r\n    static getBlockContext(node: Node): HTMLElement | null {\r\n        let currentNode: Node | null = node;\r\n        while (currentNode && !isBlockElement(currentNode)) {\r\n            currentNode = currentNode.parentNode;\r\n        }\r\n        return currentNode as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        const nodeContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        let nodes = nodeContext\r\n            ? collapseNodes(nodeContext, this.startNode, this.endNode, true /*canSplitParent*/)\r\n            : [];\r\n        const blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            const newNode = splitBalancedNodeRange(nodes);\r\n            if (newNode) {\r\n                nodes = [newNode];\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartNode(), this.getEndNode());\r\n        return range ? range.toString() : '';\r\n    }\r\n}\r\n"]}