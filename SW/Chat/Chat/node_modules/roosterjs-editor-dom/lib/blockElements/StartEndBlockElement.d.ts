import type { BlockElement } from 'roosterjs-editor-types';
/**
 * @internal
 * This represents a block that is identified by a start and end node
 * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;
 * in that case, Hello&lt;BR&gt; is a block, World is another block
 * Such block cannot be represented by a NodeBlockElement since they don't chained up
 * to a single parent node, instead they have a start and end
 * This start and end must be in same sibling level and have same parent in DOM tree
 */
export default class StartEndBlockElement implements BlockElement {
    private rootNode;
    private startNode;
    private endNode;
    constructor(rootNode: Node, startNode: Node, endNode: Node);
    static getBlockContext(node: Node): HTMLElement | null;
    /**
     * Collapse this element to a single DOM element.
     * If the content nodes are separated in different root nodes, wrap them to a single node
     * If the content nodes are included in root node with other nodes, split root node
     */
    collapseToSingleElement(): HTMLElement;
    /**
     * Gets the start node
     */
    getStartNode(): Node;
    /**
     * Gets the end node
     */
    getEndNode(): Node;
    /**
     * Checks equals of two blocks
     */
    equals(blockElement: BlockElement): boolean;
    /**
     * Checks if another block is after this current
     */
    isAfter(blockElement: BlockElement): boolean;
    /**
     * Checks if an Html node is contained within the block
     */
    contains(node: Node): boolean;
    /**
     * Get the text content of this block element
     */
    getTextContent(): string;
}
