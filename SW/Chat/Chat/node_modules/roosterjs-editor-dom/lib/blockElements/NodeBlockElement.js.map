{"version":3,"file":"NodeBlockElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts"],"names":[],"mappings":";;AAAA,8CAAyC;AACzC,oDAA+C;AAG/C;;;;GAIG;AACH;IACI,0BAAoB,OAAoB;QAApB,YAAO,GAAP,OAAO,CAAa;IAAG,CAAC;IAE5C;;;;OAIG;IACI,kDAAuB,GAA9B;QACI,OAAO,IAAI,CAAC,OAAO,CAAC;IACxB,CAAC;IAED;;;OAGG;IACI,uCAAY,GAAnB;QACI,OAAO,IAAI,CAAC,OAAO,CAAC;IACxB,CAAC;IAED;;;OAGG;IACI,qCAAU,GAAjB;QACI,OAAO,IAAI,CAAC,OAAO,CAAC;IACxB,CAAC;IAED;;OAEG;IACI,iCAAM,GAAb,UAAc,YAA0B;QACpC,oGAAoG;QACpG,OAAO,IAAI,CAAC,OAAO,IAAI,YAAY,CAAC,YAAY,EAAE,CAAC;IACvD,CAAC;IAED;;OAEG;IACI,kCAAO,GAAd,UAAe,YAA0B;QACrC,4EAA4E;QAC5E,OAAO,IAAA,qBAAW,EAAC,IAAI,CAAC,OAAO,EAAE,YAAY,CAAC,UAAU,EAAE,CAAC,CAAC;IAChE,CAAC;IAED;;OAEG;IACI,mCAAQ,GAAf,UAAgB,IAAU;QACtB,OAAO,IAAA,kBAAQ,EAAC,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,0BAA0B,CAAC,CAAC;IACzE,CAAC;IAED;;OAEG;IACI,yCAAc,GAArB;;QACI,OAAO,CAAA,MAAA,IAAI,CAAC,OAAO,0CAAE,WAAW,KAAI,EAAE,CAAC;IAC3C,CAAC;IACL,uBAAC;AAAD,CAAC,AAzDD,IAyDC","sourcesContent":["import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport type { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * This presents a content block that can be represented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) {}\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element?.textContent || '';\r\n    }\r\n}\r\n"]}