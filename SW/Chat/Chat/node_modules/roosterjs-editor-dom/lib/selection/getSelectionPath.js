"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = require("../utils/contains");
var Position_1 = require("./Position");
/**
 * Get path of the given selection range related to the given rootNode
 * @param rootNode The root node where the path start from
 * @param range The range of selection
 */
function getSelectionPath(rootNode, range) {
    if (!range) {
        return null;
    }
    var selectionPath = {
        start: getPositionPath(Position_1.default.getStart(range), rootNode),
        end: getPositionPath(Position_1.default.getEnd(range), rootNode),
    };
    return selectionPath;
}
exports.default = getSelectionPath;
/**
 * Get the path of the node relative to rootNode.
 * The path of the node is an array of integer indices into the childNodes of the given node.
 *
 * The node path will be what the node path will be on a _normalized_ dom
 * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)
 *
 * @param rootNode the node the path will be relative to
 * @param position the position to get indexes from. Follows the same semantics
 * as selectionRange (if node is of type Text, it is an offset into the text of that node.
 * If node is of type Element, it is the index of a child in that Element node.)
 */
function getPositionPath(position, rootNode) {
    var _a, _b;
    if (!position || !rootNode) {
        return [];
    }
    var node = position.node;
    var offset = position.offset;
    var result = [];
    var parent;
    if (!(0, contains_1.default)(rootNode, node, true)) {
        return [];
    }
    if (node.nodeType == 3 /* Text */) {
        parent = node.parentNode;
        while (node.previousSibling && node.previousSibling.nodeType == 3 /* Text */) {
            offset += ((_a = node.previousSibling.nodeValue) === null || _a === void 0 ? void 0 : _a.length) || 0;
            node = node.previousSibling;
        }
        result.unshift(offset);
    }
    else {
        parent = node;
        node = node.childNodes[offset];
    }
    do {
        offset = 0;
        var isPreviousText = false;
        for (var c = (parent === null || parent === void 0 ? void 0 : parent.firstChild) || null; c && c != node; c = c.nextSibling) {
            if (c.nodeType == 3 /* Text */) {
                if (((_b = c.nodeValue) === null || _b === void 0 ? void 0 : _b.length) === 0 || isPreviousText) {
                    continue;
                }
                isPreviousText = true;
            }
            else {
                isPreviousText = false;
            }
            offset++;
        }
        result.unshift(offset);
        node = parent;
        parent = (parent === null || parent === void 0 ? void 0 : parent.parentNode) || null;
    } while (node && node != rootNode);
    return result;
}
//# sourceMappingURL=getSelectionPath.js.map