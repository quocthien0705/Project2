{"version":3,"file":"Position.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/selection/Position.ts"],"names":[],"mappings":"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","sourcesContent":["import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport type { NodePosition } from 'roosterjs-editor-types';\r\nimport type { CompatiblePositionType } from 'roosterjs-editor-types/lib/compatibleTypes';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     * @param isFromEndOfRange Whether this position is created from end of a range. An position\r\n     * created from end of range has different behavior when normalize, it will use the child node\r\n     * before current position if any as a deeper level node and set isAtEnd to true.\r\n     */\r\n    constructor(node: Node, offset: number, isFromEndOfRange?: boolean);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the position, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType | CompatiblePositionType);\r\n\r\n    constructor(\r\n        nodeOrPosition: Node | NodePosition,\r\n        offsetOrPosType: number = 0,\r\n        private readonly isFromEndOfRange?: boolean\r\n    ) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode!; // TODO: how to handle parentNode is null?\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode!; // TODO: how to handle parentNode is null?\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                const endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node)!; // TODO: how to handle parent element is null?\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element || node.nodeType == NodeType.DocumentFragment) {\r\n            const nextNode = this.isFromEndOfRange\r\n                ? newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset - 1]\r\n                : newOffset == PositionType.Begin\r\n                ? node.firstChild\r\n                : newOffset == PositionType.End\r\n                ? node.lastChild\r\n                : node.childNodes[<number>newOffset];\r\n\r\n            if (nextNode) {\r\n                node = nextNode;\r\n                newOffset =\r\n                    this.isAtEnd || this.isFromEndOfRange ? PositionType.End : PositionType.Begin;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return new Position(node, newOffset, this.isFromEndOfRange);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        // For collapsed range, always return the same value of start container to make sure\r\n        // end position is not before start position\r\n        return range.collapsed\r\n            ? Position.getStart(range)\r\n            : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node | null): number {\r\n    let i = 0;\r\n    while ((node = node?.previousSibling || null)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue?.length || 0;\r\n    } else if (node.nodeType == NodeType.Element || node.nodeType == NodeType.DocumentFragment) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n"]}