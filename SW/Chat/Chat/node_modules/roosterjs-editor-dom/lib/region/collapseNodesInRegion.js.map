{"version":3,"file":"collapseNodesInRegion.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/region/collapseNodesInRegion.ts"],"names":[],"mappings":";;AAAA,wDAAkD;AAClD,mDAA8C;AAC9C,0DAAqD;AAGrD;;;;;;GAMG;AACH,SAAwB,qBAAqB,CACzC,MAAkB,EAClB,oBAA6C;IAE7C,IAAI,CAAC,oBAAoB,IAAI,oBAAoB,CAAC,MAAM,IAAI,CAAC,EAAE;QAC3D,OAAO,EAAE,CAAC;KACb;IAED,IAAI,KAAK,GAAG,IAAA,wBAAc,EAAC,oBAAoB,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC;QACvD,CAAC,CAAS,oBAAoB;QAC9B,CAAC,CAAC;YACI,oBAAoB,CAAC,CAAC,CAAC,CAAC,YAAY,EAAE;YACvB,oBAAoB,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAE,CAAC,UAAU,EAAE;SACrF,CAAC;IAER,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,IAAA,wBAAc,EAAC,MAAM,EAAE,IAAI,CAAC,EAA5B,CAA4B,CAAC,CAAC;IAEpE,IAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3B,IAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAEzC,IAAI,IAAA,wBAAc,EAAC,MAAM,EAAE,SAAS,CAAC,IAAI,IAAA,wBAAc,EAAC,MAAM,EAAE,QAAQ,CAAC,EAAE;QACvE,OAAO,IAAA,uBAAY,EAAC,MAAM,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC;KACtF;SAAM;QACH,OAAO,EAAE,CAAC;KACb;AACL,CAAC;AAzBD,wCAyBC","sourcesContent":["import collapseNode from '../utils/collapseNodes';\nimport isNodeInRegion from './isNodeInRegion';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport type { BlockElement, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Collapse nodes within this region to their common ancestor node under this region\n * @param region The region to collapse nodes in.\n * @param nodesOrBlockElements Nodes or block elements to collapse. When take BlockElement[] as input,\n * start node of the first BlockElement and end node of the last BlockElement will be used as the nodes.\n * All nodes not contained by the given region will be ignored.\n */\nexport default function collapseNodesInRegion(\n    region: RegionBase,\n    nodesOrBlockElements: Node[] | BlockElement[]\n): Node[] {\n    if (!nodesOrBlockElements || nodesOrBlockElements.length == 0) {\n        return [];\n    }\n\n    let nodes = safeInstanceOf(nodesOrBlockElements[0], 'Node')\n        ? <Node[]>nodesOrBlockElements\n        : [\n              nodesOrBlockElements[0].getStartNode(),\n              (<BlockElement>nodesOrBlockElements[nodesOrBlockElements.length - 1]).getEndNode(),\n          ];\n\n    nodes = nodes && nodes.filter(node => isNodeInRegion(region, node));\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n\n    if (isNodeInRegion(region, firstNode) && isNodeInRegion(region, lastNode)) {\n        return collapseNode(region.rootNode, firstNode, lastNode, true /*canSplitParent*/);\n    } else {\n        return [];\n    }\n}\n"]}