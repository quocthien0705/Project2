"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var changeElementTag_1 = require("../utils/changeElementTag");
var contains_1 = require("../utils/contains");
var getBlockElementAtNode_1 = require("../blockElements/getBlockElementAtNode");
var getPredefinedCssForElement_1 = require("../htmlSanitizer/getPredefinedCssForElement");
var getStyles_1 = require("../style/getStyles");
var isNodeInRegion_1 = require("./isNodeInRegion");
var safeInstanceOf_1 = require("../utils/safeInstanceOf");
var setStyles_1 = require("../style/setStyles");
var collapseNodes_1 = require("../utils/collapseNodes");
/**
 * Merge a BlockElement of given node after another node
 * @param region Region to operate in
 * @param refNode The node to merge after
 * @param targetNode The node of target block element
 */
function mergeBlocksInRegion(region, refNode, targetNode) {
    var _a, _b, _c;
    var block;
    if (!(0, isNodeInRegion_1.default)(region, refNode) ||
        !(0, isNodeInRegion_1.default)(region, targetNode) ||
        !(block = (0, getBlockElementAtNode_1.default)(region.rootNode, targetNode)) ||
        block.contains(refNode)) {
        return;
    }
    var blockRoot = block.collapseToSingleElement();
    var commonContainer = (0, collapseNodes_1.collapse)(region.rootNode, blockRoot, refNode, false /*isStart*/, true /*canSplitParent*/);
    // Copy styles of parent nodes into blockRoot
    for (var node = blockRoot; (0, contains_1.default)(commonContainer, node);) {
        var parent_1 = node.parentNode;
        if ((0, safeInstanceOf_1.default)(parent_1, 'HTMLElement')) {
            var styles = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, ((0, getPredefinedCssForElement_1.default)(parent_1) || {})), (0, getStyles_1.default)(parent_1)), (0, getStyles_1.default)(blockRoot));
            (0, setStyles_1.default)(blockRoot, styles);
        }
        node = parent_1;
    }
    var nodeToRemove = null;
    var nodeToMerge = blockRoot.childNodes.length == 1 && blockRoot.attributes.length == 0
        ? blockRoot.firstChild
        : (0, changeElementTag_1.default)(blockRoot, 'SPAN');
    // Remove empty node
    for (var node = nodeToMerge; (0, contains_1.default)(commonContainer, node) && ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes.length) == 1; node = node.parentNode) {
        // If the only child is the one which is about to be removed, this node should also be removed
        nodeToRemove = node.parentNode;
    }
    // Finally, merge blocks, and remove empty nodes
    (_b = refNode.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(nodeToMerge, refNode.nextSibling);
    (_c = nodeToRemove === null || nodeToRemove === void 0 ? void 0 : nodeToRemove.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(nodeToRemove);
}
exports.default = mergeBlocksInRegion;
//# sourceMappingURL=mergeBlocksInRegion.js.map