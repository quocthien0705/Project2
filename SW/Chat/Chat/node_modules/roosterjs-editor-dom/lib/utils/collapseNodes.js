"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collapse = void 0;
var contains_1 = require("./contains");
var splitParentNode_1 = require("./splitParentNode");
var toArray_1 = require("../jsUtils/toArray");
/**
 * Collapse nodes within the given start and end nodes to their common ancestor node,
 * split parent nodes if necessary
 * @param root The root node of the scope
 * @param start The start node
 * @param end The end node
 * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent
 * and the returned nodes will be all nodes from start through end after splitting
 * False to disallow split parent
 * @returns When canSplitParent is true, returns all node from start through end after splitting,
 * otherwise just return start and end
 */
function collapseNodes(root, start, end, canSplitParent) {
    var _a;
    if (!(0, contains_1.default)(root, start) || !(0, contains_1.default)(root, end)) {
        return [];
    }
    start = collapse(root, start, end, true /*isStart*/, canSplitParent);
    end = collapse(root, end, start, false /*isStart*/, canSplitParent);
    if ((0, contains_1.default)(start, end, true /*treatSameNodeAsContain*/)) {
        return [start];
    }
    else if ((0, contains_1.default)(end, start)) {
        return [end];
    }
    else if (start.parentNode == end.parentNode) {
        var nodes = start.parentNode ? (0, toArray_1.default)((_a = start.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes) : [];
        var startIndex = nodes.indexOf(start);
        var endIndex = nodes.indexOf(end);
        return nodes.slice(startIndex, endIndex + 1);
    }
    else {
        return [start, end];
    }
}
exports.default = collapseNodes;
/**
 * @internal
 * Collapse a node by traversing its parent nodes until we get the common ancestor node of node and ref node
 * @param root Root node, traversing will be limited under this scope
 * @param node The node to collapse
 * @param ref Ref node. The result will be the nearest common ancestor node of the given node and this ref node
 * @param isStart Whether the given node is start of the sequence of nodes to collapse
 * @param canSplitParent Whether splitting parent node is allowed
 * @returns The common ancestor node of the given node ref node
 */
function collapse(root, node, ref, isStart, canSplitParent) {
    while (node.parentNode != root && !(0, contains_1.default)(node.parentNode, ref)) {
        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {
            if (!canSplitParent) {
                break;
            }
            (0, splitParentNode_1.default)(node, isStart);
        }
        if (!node.parentNode) {
            break;
        }
        node = node.parentNode;
    }
    return node;
}
exports.collapse = collapse;
//# sourceMappingURL=collapseNodes.js.map