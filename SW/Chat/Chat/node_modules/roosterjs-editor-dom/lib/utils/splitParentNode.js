"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitBalancedNodeRange = void 0;
var isNodeAfter_1 = require("./isNodeAfter");
/**
 * Split parent node of the given node before/after the given node.
 * When a parent node contains [A,B,C] and pass B as the given node,
 * If split before, the new nodes will be [A][B,C] and returns [A];
 * otherwise, it will be [A,B][C] and returns [C].
 * @param node The node to split before/after
 * @param splitBefore Whether split before or after
 * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),
 * we remove it. @default false
 * @returns The new parent node
 */
function splitParentNode(node, splitBefore) {
    var _a;
    if (!node || !node.parentNode) {
        return null;
    }
    var parentNode = node.parentNode;
    var newParent = parentNode.cloneNode(false /*deep*/);
    newParent.removeAttribute('id');
    if (splitBefore) {
        while (parentNode.firstChild && parentNode.firstChild != node) {
            newParent.appendChild(parentNode.firstChild);
        }
    }
    else {
        while (node.nextSibling) {
            newParent.appendChild(node.nextSibling);
        }
    }
    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true
    if (newParent.firstChild && newParent.innerHTML != '') {
        (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newParent, splitBefore ? parentNode : parentNode.nextSibling);
    }
    else {
        newParent = null;
    }
    return newParent;
}
exports.default = splitParentNode;
/**
 * Split parent node by a balanced node range
 * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.
 * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored
 * @returns The parent node of the given node range if the given nodes are balanced, otherwise null
 */
function splitBalancedNodeRange(nodes) {
    var start = Array.isArray(nodes) ? nodes[0] : nodes;
    var end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;
    var parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;
    if (parentNode) {
        if ((0, isNodeAfter_1.default)(start, end)) {
            var temp = end;
            end = start;
            start = temp;
        }
        splitParentNode(start, true /*splitBefore*/);
        splitParentNode(end, false /*splitBefore*/);
    }
    return parentNode;
}
exports.splitBalancedNodeRange = splitBalancedNodeRange;
//# sourceMappingURL=splitParentNode.js.map