{"version":3,"file":"getIntersectedRect.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/utils/getIntersectedRect.ts"],"names":[],"mappings":";;;AAAA,iDAA4C;AAG5C;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,SAAwB,kBAAkB,CACtC,QAAuB,EACvB,eAA4B;IAA5B,gCAAA,EAAA,oBAA4B;IAE5B,IAAM,KAAK,GAAG,QAAQ;SACjB,GAAG,CAAC,UAAA,OAAO,IAAI,OAAA,IAAA,uBAAa,EAAC,OAAO,CAAC,qBAAqB,EAAE,CAAC,EAA9C,CAA8C,CAAC;SAC9D,MAAM,CAAC,eAAe,CAAC;SACvB,MAAM,CAAC,UAAA,OAAO,IAAI,OAAA,CAAC,CAAC,OAAO,EAAT,CAAS,CAAW,CAAC;IAE5C,IAAM,MAAM,GAAS;QACjB,GAAG,EAAE,IAAI,CAAC,GAAG,OAAR,IAAI,qDAAQ,KAAK,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,GAAG,EAAL,CAAK,CAAC,UAAC;QACvC,MAAM,EAAE,IAAI,CAAC,GAAG,OAAR,IAAI,qDAAQ,KAAK,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,MAAM,EAAR,CAAQ,CAAC,UAAC;QAC7C,IAAI,EAAE,IAAI,CAAC,GAAG,OAAR,IAAI,qDAAQ,KAAK,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,EAAN,CAAM,CAAC,UAAC;QACzC,KAAK,EAAE,IAAI,CAAC,GAAG,OAAR,IAAI,qDAAQ,KAAK,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,KAAK,EAAP,CAAO,CAAC,UAAC;KAC9C,CAAC;IAEF,OAAO,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;AACpF,CAAC;AAjBD,qCAiBC","sourcesContent":["import normalizeRect from './normalizeRect';\nimport type { Rect } from 'roosterjs-editor-types';\n\n/**\n * Get the intersected Rect of elements provided\n *\n * @example\n * The result of the following Elements Rects would be:\n    {\n        top: Element2.top,\n        bottom: Element1.bottom,\n        left: Element2.left,\n        right: Element2.right\n    }\n    +-------------------------+\n    | Element 1               |\n    |   +-----------------+   |\n    |   | Element2        |   |\n    |   |                 |   |\n    |   |                 |   |\n    +-------------------------+\n        |                 |\n        +-----------------+\n\n * @param elements Elements to use.\n * @param additionalRects additional rects to use\n * @returns If the Rect is valid return the rect, if not, return null.\n */\nexport default function getIntersectedRect(\n    elements: HTMLElement[],\n    additionalRects: Rect[] = []\n): Rect | null {\n    const rects = elements\n        .map(element => normalizeRect(element.getBoundingClientRect()))\n        .concat(additionalRects)\n        .filter(element => !!element) as Rect[];\n\n    const result: Rect = {\n        top: Math.max(...rects.map(r => r.top)),\n        bottom: Math.min(...rects.map(r => r.bottom)),\n        left: Math.max(...rects.map(r => r.left)),\n        right: Math.min(...rects.map(r => r.right)),\n    };\n\n    return result.top < result.bottom && result.left < result.right ? result : null;\n}\n"]}