"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.KnownCreateElementData = void 0;
var getObjectKeys_1 = require("../jsUtils/getObjectKeys");
var safeInstanceOf_1 = require("./safeInstanceOf");
var Browser_1 = require("./Browser");
/**
 * All known CreateElementData used by roosterjs to create elements
 */
exports.KnownCreateElementData = (_a = {},
    _a[0 /* None */] = { tag: '' },
    // Edge can sometimes lose current format when Enter to new line.
    // So here we add an extra SPAN for Edge to workaround this bug
    _a[1 /* EmptyLine */] = Browser_1.Browser.isEdge
        ? { tag: 'div', children: [{ tag: 'span', children: [{ tag: 'br' }] }] }
        : { tag: 'div', children: [{ tag: 'br' }] },
    _a[2 /* BlockquoteWrapper */] = {
        tag: 'blockquote',
        style: 'margin-top:0;margin-bottom:0',
    },
    _a[3 /* CopyPasteTempDiv */] = {
        tag: 'div',
        style: 'width: 600px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text',
        attributes: {
            contenteditable: 'true',
        },
    },
    _a[4 /* BlockListItem */] = { tag: 'li', style: 'display:block' },
    _a[5 /* ContextMenuWrapper */] = {
        tag: 'div',
        style: 'position: fixed; width: 0; height: 0',
    },
    _a[6 /* ImageEditWrapper */] = {
        tag: 'span',
        style: 'max-width:100%;position:relative',
        children: [
            {
                tag: 'div',
                style: 'width:100%;height:100%;position:relative;overflow:hidden',
            },
        ],
    },
    _a[7 /* TableHorizontalResizer */] = {
        tag: 'div',
        style: 'position: fixed; cursor: row-resize; user-select: none',
    },
    _a[8 /* TableVerticalResizer */] = {
        tag: 'div',
        style: 'position: fixed; cursor: col-resize; user-select: none',
    },
    _a[9 /* TableResizerLTR */] = {
        tag: 'div',
        style: 'position: fixed; cursor: nw-resize; user-select: none; border: 1px solid #808080',
    },
    _a[10 /* TableResizerRTL */] = {
        tag: 'div',
        style: 'position: fixed; cursor: ne-resize; user-select: none; border: 1px solid #808080',
    },
    _a[11 /* TableSelector */] = {
        tag: 'div',
        style: 'position: fixed; cursor: all-scroll; user-select: none; border: 1px solid #808080',
    },
    _a[12 /* EmptyLineFormatInSpan */] = {
        tag: 'div',
        children: [{ tag: 'span', children: [{ tag: 'br' }] }],
    },
    _a);
/**
 * Create DOM element from the given CreateElementData
 * @param elementData The CreateElementData or an index of a known CreateElementData used for creating this element
 * @param document The document to create the element from
 * @returns The root DOM element just created
 */
function createElement(elementData, document) {
    if (typeof elementData == 'number') {
        elementData = exports.KnownCreateElementData[elementData];
    }
    if (!elementData || !elementData.tag) {
        return null;
    }
    var tag = elementData.tag, namespace = elementData.namespace, className = elementData.className, style = elementData.style, dataset = elementData.dataset, attributes = elementData.attributes, children = elementData.children;
    var result = namespace
        ? document.createElementNS(namespace, tag)
        : document.createElement(tag);
    if (style) {
        result.setAttribute('style', style);
    }
    if (className) {
        result.className = className;
    }
    if (dataset && (0, safeInstanceOf_1.default)(result, 'HTMLElement')) {
        (0, getObjectKeys_1.default)(dataset).forEach(function (datasetName) {
            result.dataset[datasetName] = dataset[datasetName];
        });
    }
    if (attributes) {
        (0, getObjectKeys_1.default)(attributes).forEach(function (attrName) {
            result.setAttribute(attrName, attributes[attrName]);
        });
    }
    if (children) {
        children.forEach(function (child) {
            if (typeof child === 'string') {
                result.appendChild(document.createTextNode(child));
            }
            else if (child) {
                var childElement = createElement(child, document);
                if (childElement) {
                    result.appendChild(childElement);
                }
            }
        });
    }
    return result;
}
exports.default = createElement;
//# sourceMappingURL=createElement.js.map