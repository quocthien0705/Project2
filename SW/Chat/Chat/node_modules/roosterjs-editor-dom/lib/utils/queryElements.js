"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var toArray_1 = require("../jsUtils/toArray");
/**
 * Query HTML elements in the container by a selector string
 * @param container Container element to query from
 * @param selector Selector string to query
 * @param forEachCallback An optional callback to be invoked on each node in query result
 * @param scope The scope of the query, default value is QueryScope.Body
 * @param range The selection range to query with. This is required when scope is not Body
 * @returns HTML Element array of the query result
 */
function queryElements(container, selector, forEachCallback, scope, range) {
    if (scope === void 0) { scope = 0 /* Body */; }
    if (!container || !selector) {
        return [];
    }
    var elements = (0, toArray_1.default)(container.querySelectorAll(selector));
    if (scope != 0 /* Body */ && range) {
        var startOffset = range.startOffset, endOffset = range.endOffset;
        var startContainer_1 = range.startContainer, endContainer_1 = range.endContainer;
        if (startContainer_1.nodeType == 1 /* Element */ && startContainer_1.firstChild) {
            var child = startContainer_1.childNodes[startOffset];
            // range.startOffset can give a value of child.length+1 when selection is after the last child
            // In that case we will use the last child instead
            startContainer_1 = child || startContainer_1.lastChild;
        }
        endContainer_1 =
            endContainer_1.nodeType == 1 /* Element */ && endContainer_1.firstChild && endOffset > 0
                ? endContainer_1.childNodes[endOffset - 1]
                : endContainer_1;
        elements = elements.filter(function (element) {
            return isIntersectWithNodeRange(element, startContainer_1, endContainer_1, scope == 2 /* InSelection */);
        });
    }
    if (forEachCallback) {
        elements.forEach(forEachCallback);
    }
    return elements;
}
exports.default = queryElements;
function isIntersectWithNodeRange(node, startNode, endNode, nodeContainedByRangeOnly) {
    var startPosition = node.compareDocumentPosition(startNode);
    var endPosition = node.compareDocumentPosition(endNode);
    var targetPositions = [0 /* Same */, 8 /* Contains */];
    if (!nodeContainedByRangeOnly) {
        targetPositions.push(16 /* ContainedBy */);
    }
    return (checkPosition(startPosition, targetPositions) || // intersectStart
        checkPosition(endPosition, targetPositions) || // intersectEnd
        (checkPosition(startPosition, [2 /* Preceding */]) && // Contains
            checkPosition(endPosition, [4 /* Following */]) &&
            !checkPosition(endPosition, [16 /* ContainedBy */])));
}
function checkPosition(position, targets) {
    return targets.some(function (target) {
        return target == 0 /* Same */
            ? position == 0 /* Same */
            : (position & target) == target;
    });
}
//# sourceMappingURL=queryElements.js.map