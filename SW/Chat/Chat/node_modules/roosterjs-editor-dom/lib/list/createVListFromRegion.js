"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var createElement_1 = require("../utils/createElement");
var getRootListNode_1 = require("./getRootListNode");
var getSelectedBlockElementsInRegion_1 = require("../region/getSelectedBlockElementsInRegion");
var isNodeInRegion_1 = require("../region/isNodeInRegion");
var Position_1 = require("../selection/Position");
var safeInstanceOf_1 = require("../utils/safeInstanceOf");
var shouldSkipNode_1 = require("../utils/shouldSkipNode");
var toArray_1 = require("../jsUtils/toArray");
var VList_1 = require("./VList");
var wrap_1 = require("../utils/wrap");
var getLeafSibling_1 = require("../utils/getLeafSibling");
var getListTypeFromNode_1 = require("./getListTypeFromNode");
var ListSelector = 'ol,ul';
/**
 * Create a VList object from the given region.
 * @param region The region to get VList from
 * @param includeSiblingLists True to also try get lists before and after the selection and merge them together,
 * false to only include the list for the selected blocks
 * @param startNode (Optional) When specified, try get VList which will contain this node.
 * If not specified, get VList from selection of this region
 */
function createVListFromRegion(region, includeSiblingLists, startNode) {
    if (!region) {
        return null;
    }
    var nodes = [];
    if (startNode) {
        var list = (0, getRootListNode_1.default)(region, ListSelector, startNode);
        if (list) {
            nodes.push(list);
        }
    }
    else {
        var blocks = (0, getSelectedBlockElementsInRegion_1.default)(region, undefined, true /* shouldApplyFormatToSpan */);
        blocks.forEach(function (block) {
            var list = (0, getRootListNode_1.default)(region, ListSelector, block.getStartNode());
            if (list) {
                if (nodes[nodes.length - 1] != list) {
                    nodes.push(list);
                }
                if (nodes.length == 1 &&
                    (0, safeInstanceOf_1.default)(list, 'HTMLOListElement') &&
                    list.start > 1) {
                    // Do not include sibling lists if this list is not start from 1
                    includeSiblingLists = false;
                }
            }
            else {
                nodes.push(block.collapseToSingleElement());
            }
        });
        if (nodes.length == 0 && !region.rootNode.firstChild) {
            var newNode = (0, createElement_1.default)(1 /* EmptyLine */, region.rootNode.ownerDocument);
            region.rootNode.appendChild(newNode);
            nodes.push(newNode);
            region.fullSelectionStart = new Position_1.default(newNode, 0 /* Begin */);
            region.fullSelectionEnd = new Position_1.default(newNode, -1 /* End */);
        }
        if (includeSiblingLists) {
            tryIncludeSiblingNode(region, nodes, false /*isNext*/);
            tryIncludeSiblingNode(region, nodes, true /*isNext*/);
        }
        nodes = nodes.filter(function (node) { return !(0, shouldSkipNode_1.default)(node, true /*ignoreSpace*/); });
    }
    var vList = null;
    if (nodes.length > 0) {
        var firstNode = nodes.shift() || null;
        vList = (0, getListTypeFromNode_1.isListElement)(firstNode)
            ? new VList_1.default(firstNode)
            : firstNode
                ? createVListFromItemNode(firstNode)
                : null;
        if (vList) {
            nodes.forEach(function (node) {
                if ((0, getListTypeFromNode_1.isListElement)(node)) {
                    vList.mergeVList(new VList_1.default(node));
                }
                else {
                    vList.appendItem(node, 0 /* None */);
                }
            });
        }
    }
    return vList;
}
exports.default = createVListFromRegion;
function tryIncludeSiblingNode(region, nodes, isNext) {
    var node = nodes[isNext ? nodes.length - 1 : 0];
    node = (0, getLeafSibling_1.getLeafSibling)(region.rootNode, node, isNext, region.skipTags, true /*ignoreSpace*/);
    node = (0, getRootListNode_1.default)(region, ListSelector, node);
    if ((0, isNodeInRegion_1.default)(region, node) && (0, getListTypeFromNode_1.isListElement)(node)) {
        if (isNext) {
            if (!(0, safeInstanceOf_1.default)(node, 'HTMLOListElement') || node.start == 1) {
                // Only include sibling list when
                // 1. This is a unordered list, OR
                // 2. This list starts from 1
                nodes.push(node);
            }
        }
        else {
            nodes.unshift(node);
        }
    }
}
function createVListFromItemNode(node) {
    // Wrap all child nodes under a single one, and put the new list under original root node
    // so that the list can carry over styles under the root node.
    var childNodes = (0, toArray_1.default)(node.childNodes);
    var nodeForItem = childNodes.length == 1 ? childNodes[0] : (0, wrap_1.default)(childNodes, 'SPAN');
    // Create a temporary OL root element for this list.
    var listNode = node.ownerDocument.createElement('ol'); // Either OL or UL is ok here
    node.appendChild(listNode);
    // Create the VList and append items
    var vList = new VList_1.default(listNode);
    vList.appendItem(nodeForItem, 0 /* None */);
    return vList;
}
//# sourceMappingURL=createVListFromRegion.js.map