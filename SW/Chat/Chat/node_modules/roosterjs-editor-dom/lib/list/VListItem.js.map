{"version":3,"file":"VListItem.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/list/VListItem.ts"],"names":[],"mappings":"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","sourcesContent":["import contains from '../utils/contains';\nimport getListTypeFromNode from './getListTypeFromNode';\nimport getStyles from '../style/getStyles';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport moveChildNodes from '../utils/moveChildNodes';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport setBulletListMarkers from './setBulletListMarkers';\nimport setListItemStyle from './setListItemStyle';\nimport setNumberingListMarkers from './setNumberingListMarkers';\nimport setStyles from '../style/setStyles';\nimport toArray from '../jsUtils/toArray';\nimport unwrap from '../utils/unwrap';\nimport wrap from '../utils/wrap';\nimport { createNumberDefinition, createObjectDefinition } from '../metadata/definitionCreators';\nimport { getMetadata, setMetadata } from '../metadata/metadata';\nimport {\n    BulletListType,\n    KnownCreateElementDataIndex,\n    ListType,\n    NumberingListType,\n} from 'roosterjs-editor-types';\nimport type {\n    CompatibleBulletListType,\n    CompatibleListType,\n    CompatibleNumberingListType,\n} from 'roosterjs-editor-types/lib/compatibleTypes';\n\nconst orderListStyles = [null, 'lower-alpha', 'lower-roman'];\nconst unorderedListStyles = ['disc', 'circle', 'square'];\n\nconst MARGIN_BASE = '0in 0in 0in 0.5in';\nconst NEGATIVE_MARGIN = '-.25in';\n\nconst stylesToInherit = ['font-size', 'font-family', 'color'];\nconst attrsToInherit = ['data-ogsc', 'data-ogsb', 'data-ogac', 'data-ogab'];\n\n/**\n * @internal\n * The definition for the number of BulletListType or NumberingListType\n */\nexport const ListStyleDefinitionMetadata = createObjectDefinition<ListStyleMetadata>(\n    {\n        orderedStyleType: createNumberDefinition(\n            true /** isOptional */,\n            undefined /** value **/,\n            NumberingListType.Min,\n            NumberingListType.Max\n        ),\n        unorderedStyleType: createNumberDefinition(\n            true /** isOptional */,\n            undefined /** value **/,\n            BulletListType.Min,\n            BulletListType.Max\n        ),\n    },\n    true /** isOptional */,\n    true /** allowNull */\n);\n\n/**\n * @internal\n * Represents the metadata of the style of a list element\n */\nexport interface ListStyleMetadata {\n    orderedStyleType?: NumberingListType | CompatibleNumberingListType;\n    unorderedStyleType?: BulletListType | CompatibleBulletListType;\n}\n\n/**\n * !!! Never directly create instance of this class. It should be created within VList class !!!\n *\n * Represent a list item.\n *\n * A list item is normally wrapped using a LI tag. But this class is only a logical item,\n * it can be a LI tag, or another other type of node which means it is actually not a list item.\n * That can happen after we do \"outdent\" on a 1-level list item, then it becomes not a list item.\n */\nexport default class VListItem {\n    private listTypes: (ListType | CompatibleListType)[];\n    private node: HTMLLIElement;\n    private dummy: boolean;\n    private newListStart: number | undefined = undefined;\n\n    /**\n     * Construct a new instance of VListItem class\n     * @param node The DOM node for this item\n     * @param listTypes An array represents list types of all parent and current level.\n     * Skip this parameter for a non-list item.\n     */\n    constructor(\n        node: Node,\n        ...listTypes: (\n            | ListType.Ordered\n            | ListType.Unordered\n            | CompatibleListType.Ordered\n            | CompatibleListType.Unordered\n        )[]\n    ) {\n        if (!node) {\n            throw new Error('node must not be null');\n        }\n\n        this.node = safeInstanceOf(node, 'HTMLLIElement')\n            ? node\n            : (wrap(node, KnownCreateElementDataIndex.BlockListItem) as HTMLLIElement);\n        const display = this.node.style.display;\n\n        this.dummy = display != 'list-item' && display != '';\n\n        // Always add a None list type in front of all other types to represent non-list scenario.\n        this.listTypes = [ListType.None, ...listTypes];\n    }\n\n    /**\n     * Get type of current list item\n     */\n    getListType(): ListType | CompatibleListType {\n        return this.listTypes[this.listTypes.length - 1];\n    }\n\n    /**\n     * Get the levels of this list item.\n     */\n    getLevel(): number {\n        return this.listTypes.length - 1;\n    }\n\n    /**\n     * Get DOM node of this list item\n     */\n    getNode(): HTMLLIElement {\n        return this.node;\n    }\n\n    /**\n     * Get the Start Number of the new List\n     */\n    getNewListStart(): number | undefined {\n        return this.newListStart;\n    }\n\n    /**\n     * Check if a given node is contained by this list item\n     * @param node The node to check\n     */\n    contains(node: Node): boolean {\n        return contains(this.node, node, true /*treatSameNodeAsContain*/);\n    }\n\n    /**\n     * Check if this item is a dummy item.\n     * A dummy item is also represented by LI tag, but it won't render a bullet (for Unordered list) or a number (for Ordered list)\n     * normally it has CSS style display set to a value other than \"list-item\"\n     */\n    isDummy() {\n        return this.dummy;\n    }\n\n    /**\n     * @deprecated Always return false\n     */\n    isOrphanItem(): boolean {\n        return false;\n    }\n\n    /**\n     * @deprecated\n     */\n    canMerge(item: VListItem): boolean {\n        if (!item?.isOrphanItem() || this.listTypes.length != item.listTypes.length) {\n            return false;\n        }\n\n        return this.listTypes.every((type, index) => item.listTypes[index] == type);\n    }\n\n    /**\n     * @deprecated\n     */\n    mergeItems(items: VListItem[]) {\n        const nodesToWrap = items?.map(item => item.node) || [];\n        const targetNodes = wrapIfNotBlockNode(\n            nodesToWrap,\n            true /*checkFirst*/,\n            false /*checkLast*/\n        );\n        targetNodes.forEach(node => this.node.appendChild(node));\n    }\n\n    /**\n     * Indent this item\n     * If this is not an list item, it will be no op\n     */\n    indent() {\n        if (this.node.style.marginLeft == NEGATIVE_MARGIN) {\n            this.node.style.margin = '';\n            this.node.style.marginLeft = '';\n            return;\n        }\n\n        const listType = this.getListType();\n        if (listType != ListType.None) {\n            this.listTypes.push(listType);\n        }\n    }\n\n    /**\n     * Outdent this item\n     * If this item is already not an list item, it will be no op\n     * @param preventItemRemoval Whether prevent the list item to be removed for the listItem by default false\n     */\n    outdent(preventItemRemoval: boolean = false) {\n        const expectedLength = preventItemRemoval ? 2 : 1;\n        if (this.listTypes.length > expectedLength) {\n            this.listTypes.pop();\n        }\n    }\n\n    /**\n     * Add negative margin to the List item\n     */\n    addNegativeMargins() {\n        this.node.style.margin = MARGIN_BASE;\n        this.node.style.marginLeft = NEGATIVE_MARGIN;\n    }\n\n    /**\n     * Change list type of this item\n     * @param targetType The target list type to change to\n     */\n    changeListType(targetType: ListType | CompatibleListType) {\n        if (targetType == ListType.None) {\n            this.listTypes = [targetType];\n        } else {\n            this.outdent();\n            this.listTypes.push(targetType);\n        }\n    }\n\n    /**\n     * Set whether the item is a dummy item\n     * @param isDummy Whether the item is a dummy item\n     */\n    setIsDummy(isDummy: boolean) {\n        this.dummy = isDummy;\n    }\n\n    /**\n     * Set the start Number of the new list\n     * @param isDummy Whether the item is a dummy item\n     */\n    setNewListStart(startNumber: number) {\n        this.newListStart = startNumber;\n    }\n\n    /**\n     * Apply the list style type\n     * @param rootList the vList that receives the style\n     * @param index the list item index\n     */\n    applyListStyle(rootList: HTMLOListElement | HTMLUListElement, index: number) {\n        const style = getMetadata<ListStyleMetadata>(rootList, ListStyleDefinitionMetadata);\n        // The list just need to be styled if it is at top level, so the listType length for this Vlist must be 2.\n        const isFirstLevel = this.listTypes.length < 3;\n        if (style) {\n            if (\n                isFirstLevel &&\n                this.listTypes[1] === ListType.Unordered &&\n                style.unorderedStyleType\n            ) {\n                setBulletListMarkers(this.node, style.unorderedStyleType);\n            } else if (\n                isFirstLevel &&\n                this.listTypes[1] === ListType.Ordered &&\n                style.orderedStyleType\n            ) {\n                setNumberingListMarkers(this.node, style.orderedStyleType, index);\n            } else {\n                this.node.style.removeProperty('list-style-type');\n            }\n        }\n    }\n\n    /**\n     * Write the change result back into DOM\n     * @param listStack current stack of list elements\n     * @param originalRoot Original list root element. It will be reused when write back if possible\n     * @param shouldReuseAllAncestorListElements Optional - defaults to false. If true, only make\n     *              sure the direct parent of this list matches the list types when writing back.\n     */\n    writeBack(\n        listStack: Node[],\n        originalRoot?: HTMLOListElement | HTMLUListElement,\n        shouldReuseAllAncestorListElements: boolean = false\n    ) {\n        let nextLevel = 1;\n\n        if (shouldReuseAllAncestorListElements) {\n            // Remove any un-needed lists from the stack.\n            if (listStack.length > this.listTypes.length) {\n                listStack.splice(this.listTypes.length);\n            }\n\n            // 1. If the listStack is the same length as the listTypes for this item, check\n            // if the last item needs to change, and remove it if needed. We can always re-use\n            // the other lists even if the type doesn't match - since the display is the same\n            // as long as the list immediately surrounding the item is correct.\n            const listStackEndIndex = listStack.length - 1;\n            if (\n                listStackEndIndex === this.listTypes.length - 1 && // they are the same length\n                getListTypeFromNode(listStack[listStackEndIndex]) !==\n                    this.listTypes[listStackEndIndex]\n            ) {\n                listStack.splice(listStackEndIndex);\n            }\n\n            nextLevel = listStack.length;\n        } else {\n            // 1. Determine list elements that we can reuse\n            // e.g.:\n            //    passed in listStack: Fragment > OL > UL > OL\n            //    local listTypes:     null     > OL > UL > UL > OL\n            //    then Fragment > OL > UL can be reused\n            for (; nextLevel < listStack.length; nextLevel++) {\n                if (getListTypeFromNode(listStack[nextLevel]) !== this.listTypes[nextLevel]) {\n                    listStack.splice(nextLevel);\n                    break;\n                }\n            }\n        }\n\n        // 2. Add new list elements\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then we need to create a UL and a OL tag\n        for (; nextLevel < this.listTypes.length; nextLevel++) {\n            const stackLength = listStack.length - 1;\n            const newList = createListElement(\n                listStack[0],\n                this.listTypes[nextLevel],\n                nextLevel,\n                originalRoot\n            );\n\n            listStack[stackLength].appendChild(newList);\n            listStack.push(newList);\n\n            //If the current node parent is in the same deep child index,\n            //apply the styles of the current parent list to the new list\n            if (this.getDeepChildIndex(originalRoot) == stackLength) {\n                const listStyleType = this.node.parentElement?.style.listStyleType;\n                if (\n                    listStyleType &&\n                    getTagOfNode(this.node.parentElement) === getTagOfNode(newList)\n                ) {\n                    newList.style.listStyleType = listStyleType;\n                }\n            }\n        }\n        // 3. Add current node into deepest list element\n        listStack[listStack.length - 1].appendChild(this.node);\n        this.node.style.setProperty('display', this.dummy ? 'block' : null);\n\n        // 4. Inherit styles of the child element to the li, so we are able to apply the styles to the ::marker\n        if (this.listTypes.length > 1) {\n            setListItemStyle(this.node, stylesToInherit, true /*isCssStyle*/);\n            setListItemStyle(this.node, attrsToInherit, false /*isCssStyle*/);\n        }\n\n        // 5. If this is not a list item now, need to unwrap the LI node and do proper handling\n        if (this.listTypes.length <= 1) {\n            // If original <LI> node has styles for font and color, we need to apply it to new parent\n            const isLi = getTagOfNode(this.node) == 'LI';\n            const stylesToApply = isLi\n                ? {\n                      'font-family': this.node.style.fontFamily,\n                      'font-size': this.node.style.fontSize,\n                      color: this.node.style.color,\n                  }\n                : undefined;\n\n            const childNodes = isLi ? getChildrenAndUnwrap(this.node) : [this.node];\n\n            if (stylesToApply) {\n                for (let i = 0; i < childNodes.length; i++) {\n                    if (safeInstanceOf(childNodes[i], 'Text')) {\n                        childNodes[i] = wrap(childNodes[i], 'span');\n                    }\n\n                    const node = childNodes[i];\n\n                    if (safeInstanceOf(node, 'HTMLElement')) {\n                        const styles = {\n                            ...stylesToApply,\n                            ...getStyles(node),\n                        };\n                        setStyles(node, styles);\n\n                        attrsToInherit.forEach(attr => {\n                            const attrValue = this.node.getAttribute(attr);\n\n                            if (attrValue) {\n                                node.setAttribute(attr, attrValue);\n                            }\n                        });\n                    }\n                }\n            }\n\n            wrapIfNotBlockNode(childNodes, true /*checkFirst*/, true /*checkLast*/);\n        }\n    }\n\n    /**\n     * Get the index of how deep is the current node parent list inside of the original root list.\n     * @example In the following structure this function would return 2\n     * ```html\n     *  <ol> <!-- original Root -->\n     *      <ol>\n     *          <ol>\n     *              <li></li> <!-- this.node  -->\n     *          </ol>\n     *      </ol>\n     *  </ol>\n     * ```\n     * @param originalRoot The root list\n     * @returns -1  if the node does not have parent element or if original root was not provided,\n     *              else, how deep is the parent element inside of the original root.\n     */\n    private getDeepChildIndex(originalRoot: HTMLOListElement | HTMLUListElement | undefined) {\n        let parentElement = this.node.parentElement;\n        if (originalRoot && parentElement) {\n            let deepIndex = 0;\n            while (parentElement && parentElement != originalRoot) {\n                deepIndex++;\n                parentElement = parentElement?.parentElement || null;\n            }\n            return deepIndex;\n        }\n        return -1;\n    }\n}\n\nfunction createListElement(\n    newRoot: Node,\n    listType: ListType | CompatibleListType,\n    nextLevel: number,\n    originalRoot?: HTMLOListElement | HTMLUListElement\n): HTMLOListElement | HTMLUListElement {\n    const doc = newRoot.ownerDocument!;\n    let result: HTMLOListElement | HTMLUListElement;\n\n    // Try to reuse the existing root element\n    // It can be reused when\n    // 1. Current list item is level 1 (top level), AND\n    // 2. Original root exists, AND\n    // 3. They have the same list type AND\n    // 4. The original root is not used yet\n    if (nextLevel == 1 && originalRoot && listType == getListTypeFromNode(originalRoot)) {\n        if (contains(newRoot, originalRoot)) {\n            // If it is already used, let's clone one and remove ID to avoid duplicating ID\n            result = originalRoot.cloneNode(false /*deep*/) as HTMLOListElement | HTMLUListElement;\n            (<HTMLOListElement>result).removeAttribute('id');\n        } else {\n            // Remove all child nodes, they will be added back later when write back other items\n            moveChildNodes(originalRoot);\n            result = originalRoot;\n        }\n    } else {\n        // Can't be reused, can't clone, let's create a new one\n        result = doc.createElement(listType == ListType.Ordered ? 'ol' : 'ul');\n    }\n\n    if (originalRoot?.style.marginTop == '0px' && originalRoot?.style.marginBottom == '0px') {\n        result.style.marginTop = '0px';\n        result.style.marginBottom = '0px';\n    }\n\n    // Always maintain the metadata saved in the list\n    if (originalRoot && nextLevel == 1 && listType != getListTypeFromNode(originalRoot)) {\n        const style = getMetadata<ListStyleMetadata>(originalRoot, ListStyleDefinitionMetadata);\n        if (style) {\n            setMetadata(result, style, ListStyleDefinitionMetadata);\n        }\n    }\n\n    if (listType == ListType.Ordered && nextLevel > 1) {\n        result.style.setProperty(\n            'list-style-type',\n            orderListStyles[(nextLevel - 1) % orderListStyles.length]\n        );\n    }\n\n    if (listType == ListType.Unordered && nextLevel > 1) {\n        result.style.setProperty(\n            'list-style-type',\n            unorderedListStyles[(nextLevel - 1) % unorderedListStyles.length]\n        );\n    }\n\n    return result;\n}\n\nfunction wrapIfNotBlockNode(nodes: Node[], checkFirst: boolean, checkLast: boolean): Node[] {\n    if (\n        nodes.length > 0 &&\n        (!checkFirst || !isBlockElement(nodes[0])) &&\n        (!checkLast || !isBlockElement(nodes[nodes.length]))\n    ) {\n        nodes = [wrap(nodes)];\n    }\n\n    return nodes;\n}\n\nfunction getChildrenAndUnwrap(node: Node): Node[] {\n    const result = toArray(node.childNodes);\n    unwrap(node);\n    return result;\n}\n"]}