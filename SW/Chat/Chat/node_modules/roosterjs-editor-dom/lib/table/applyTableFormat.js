"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var changeElementTag_1 = require("../utils/changeElementTag");
var setColor_1 = require("../utils/setColor");
var tableCellInfo_1 = require("./tableCellInfo");
var TRANSPARENT = 'transparent';
var TABLE_CELL_TAG_NAME = 'TD';
var TABLE_HEADER_TAG_NAME = 'TH';
/**
 * @internal
 * Apply the given table format to this virtual table
 * @param format Table format to apply
 * @param darkColorHandler An object to handle dark background colors, if not passed the cell background color will not be set
 */
function applyTableFormat(table, cells, format, darkColorHandler) {
    if (!format) {
        return;
    }
    table.style.borderCollapse = 'collapse';
    setBordersType(cells, format);
    setCellFormat(cells, format, darkColorHandler);
    setFirstColumnFormat(cells, format);
    setHeaderRowFormat(cells, format, darkColorHandler);
}
exports.default = applyTableFormat;
/**
 * Check if the cell has shade meta override
 * @param cell
 * @returns
 */
function hasCellShadeOverride(cell) {
    var _a;
    if (!cell.td) {
        return false;
    }
    return !!((_a = (0, tableCellInfo_1.getTableCellMetadata)(cell.td)) === null || _a === void 0 ? void 0 : _a.bgColorOverride);
}
/**
 * Check if the cell has vertical align meta override
 * @param cell
 * @returns
 */
function hasValignOverride(cell) {
    var _a;
    if (!cell.td) {
        return false;
    }
    return !!((_a = (0, tableCellInfo_1.getTableCellMetadata)(cell.td)) === null || _a === void 0 ? void 0 : _a.vAlignOverride);
}
/**
 * Check if the cell has any modified border meta override
 * @param cell
 * @returns
 */
function hasBorderOverride(cell) {
    var _a;
    if (!cell.td) {
        return false;
    }
    return !!((_a = (0, tableCellInfo_1.getTableCellMetadata)(cell.td)) === null || _a === void 0 ? void 0 : _a.borderOverride);
}
/**
 * Set color and vertical align to the table
 * @param format the format that must be applied
 * @param darkColorHandler An object to handle dark background colors, if not passed the cell background color will not be set
 */
function setCellFormat(cells, format, darkColorHandler) {
    var color = function (index) { return (index % 2 === 0 ? format.bgColorEven : format.bgColorOdd); };
    var hasBandedRows = format.hasBandedRows, hasBandedColumns = format.hasBandedColumns, bgColorOdd = format.bgColorOdd, bgColorEven = format.bgColorEven;
    var shouldColorWholeTable = !hasBandedRows && bgColorOdd === bgColorEven ? true : false;
    cells.forEach(function (row, index) {
        row.forEach(function (cell) {
            if (cell.td) {
                // Set cell color
                if (!hasCellShadeOverride(cell)) {
                    if (hasBandedRows) {
                        var backgroundColor = color(index);
                        (0, setColor_1.default)(cell.td, backgroundColor || TRANSPARENT, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */, darkColorHandler);
                    }
                    else if (shouldColorWholeTable) {
                        (0, setColor_1.default)(cell.td, format.bgColorOdd || TRANSPARENT, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */, darkColorHandler);
                    }
                    else {
                        (0, setColor_1.default)(cell.td, TRANSPARENT, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */, darkColorHandler);
                    }
                }
                // Set cell vertical align
                if (format.verticalAlign && !hasValignOverride(cell)) {
                    cell.td.style.verticalAlign = format.verticalAlign;
                }
            }
        });
    });
    if (hasBandedColumns) {
        cells.forEach(function (row) {
            row.forEach(function (cell, index) {
                var backgroundColor = color(index);
                if (cell.td && backgroundColor && !hasCellShadeOverride(cell)) {
                    (0, setColor_1.default)(cell.td, backgroundColor, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */, darkColorHandler);
                }
            });
        });
    }
}
/**
 * Set color to borders of an table
 * @param format
 * @returns
 */
function setBorderColors(td, format) {
    td.style.borderTop = getBorderStyle(format.topBorderColor);
    td.style.borderLeft = getBorderStyle(format.verticalBorderColor);
    td.style.borderRight = getBorderStyle(format.verticalBorderColor);
    td.style.borderBottom = getBorderStyle(format.bottomBorderColor);
}
/**
 * Format the border type
 * @returns
 */
function formatBorders(format, td, isFirstRow, isLastRow, isFirstColumn, isLastColumn) {
    setBorderColors(td, format);
    switch (format.tableBorderFormat) {
        case 0 /* DEFAULT */:
            return;
        case 1 /* LIST_WITH_SIDE_BORDERS */:
            if (!isFirstColumn) {
                td.style.borderLeftColor = TRANSPARENT;
            }
            if (!isLastColumn) {
                td.style.borderRightColor = TRANSPARENT;
            }
            break;
        case 4 /* FIRST_COLUMN_HEADER_EXTERNAL */:
            if (!isFirstRow) {
                td.style.borderTopColor = TRANSPARENT;
            }
            if (!isLastRow && !isFirstRow) {
                td.style.borderBottomColor = TRANSPARENT;
            }
            if (!isFirstColumn) {
                td.style.borderLeftColor = TRANSPARENT;
            }
            if (!isLastColumn && !isFirstColumn) {
                td.style.borderRightColor = TRANSPARENT;
            }
            if (isFirstColumn && isFirstRow) {
                td.style.borderRightColor = TRANSPARENT;
            }
            break;
        case 2 /* NO_HEADER_BORDERS */:
            if (isFirstRow) {
                td.style.borderTopColor = TRANSPARENT;
                td.style.borderRightColor = TRANSPARENT;
                td.style.borderLeftColor = TRANSPARENT;
            }
            if (isFirstColumn) {
                td.style.borderLeftColor = TRANSPARENT;
            }
            if (isLastColumn) {
                td.style.borderRightColor = TRANSPARENT;
            }
            break;
        case 3 /* NO_SIDE_BORDERS */:
            if (isFirstColumn) {
                td.style.borderLeftColor = TRANSPARENT;
            }
            if (isLastColumn) {
                td.style.borderRightColor = TRANSPARENT;
            }
            break;
        case 5 /* ESPECIAL_TYPE_1 */:
            if (isFirstRow) {
                td.style.borderRightColor = TRANSPARENT;
                td.style.borderLeftColor = TRANSPARENT;
            }
            if (isFirstColumn) {
                td.style.borderBottomColor = TRANSPARENT;
                td.style.borderTopColor = TRANSPARENT;
            }
            if (isFirstRow && isFirstColumn) {
                td.style.borderLeftColor = format.verticalBorderColor || TRANSPARENT;
                td.style.borderBottomColor = format.bottomBorderColor || TRANSPARENT;
                td.style.borderTopColor = format.topBorderColor || TRANSPARENT;
            }
            break;
        case 6 /* ESPECIAL_TYPE_2 */:
            if (isFirstRow) {
                td.style.borderRightColor = TRANSPARENT;
                td.style.borderLeftColor = TRANSPARENT;
            }
            if (isFirstColumn) {
                td.style.borderBottomColor = TRANSPARENT;
                td.style.borderTopColor = TRANSPARENT;
            }
            if (isFirstRow && isFirstColumn) {
                td.style.borderLeftColor = format.verticalBorderColor || TRANSPARENT;
                td.style.borderBottomColor = format.bottomBorderColor || TRANSPARENT;
                td.style.borderTopColor = format.topBorderColor || TRANSPARENT;
            }
            if (!isFirstRow && !isFirstColumn) {
                td.style.borderLeftColor = TRANSPARENT;
                td.style.borderBottomColor = TRANSPARENT;
                td.style.borderTopColor = TRANSPARENT;
                td.style.borderRightColor = TRANSPARENT;
            }
            break;
        case 7 /* ESPECIAL_TYPE_3 */:
            if (isFirstRow) {
                td.style.borderLeftColor = TRANSPARENT;
                td.style.borderTopColor = TRANSPARENT;
                td.style.borderRightColor = TRANSPARENT;
            }
            if (isFirstColumn) {
                td.style.borderLeftColor = TRANSPARENT;
                td.style.borderTopColor = TRANSPARENT;
                td.style.borderBottomColor = TRANSPARENT;
            }
            if (!isFirstRow && !isFirstColumn) {
                td.style.borderLeftColor = TRANSPARENT;
                td.style.borderBottomColor = TRANSPARENT;
                td.style.borderTopColor = TRANSPARENT;
                td.style.borderRightColor = TRANSPARENT;
            }
            if (isFirstRow && isFirstColumn) {
                td.style.borderBottomColor = format.bottomBorderColor || TRANSPARENT;
            }
            break;
    }
}
/**
 * Organize the borders of table according to a border type
 * @param format
 * @returns
 */
function setBordersType(cells, format) {
    cells.forEach(function (row, rowIndex) {
        row.forEach(function (cell, cellIndex) {
            if (cell.td && !hasBorderOverride(cell)) {
                formatBorders(format, cell.td, rowIndex === 0, rowIndex === cells.length - 1, cellIndex === 0, cellIndex === row.length - 1);
            }
        });
    });
}
/**
 * Apply custom design to the first table column
 * @param format
 * @returns
 */
function setFirstColumnFormat(cells, format) {
    if (!format.hasFirstColumn) {
        cells.forEach(function (row) {
            row.forEach(function (cell, cellIndex) {
                if (cell.td && cellIndex === 0) {
                    cell.td = (0, changeElementTag_1.default)(cell.td, TABLE_CELL_TAG_NAME);
                    cell.td.scope = '';
                }
            });
        });
        return;
    }
    cells.forEach(function (row, rowIndex) {
        row.forEach(function (cell, cellIndex) {
            if (cell.td && cellIndex === 0) {
                if (rowIndex !== 0 && !hasCellShadeOverride(cell)) {
                    cell.td.style.borderTopColor = TRANSPARENT;
                    (0, setColor_1.default)(cell.td, TRANSPARENT, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */);
                }
                if (rowIndex !== cells.length - 1 && rowIndex !== 0) {
                    cell.td.style.borderBottomColor = TRANSPARENT;
                }
                cell.td = (0, changeElementTag_1.default)(cell.td, TABLE_HEADER_TAG_NAME);
                cell.td.scope = 'col';
            }
        });
    });
}
/**
 * Apply custom design to the Header Row
 * @param format
 * @param darkColorHandler An object to handle dark background colors, if not passed the cell background color will not be set
 * @returns
 */
function setHeaderRowFormat(cells, format, darkColorHandler) {
    var _a, _b;
    if (!format.hasHeaderRow) {
        (_a = cells[0]) === null || _a === void 0 ? void 0 : _a.forEach(function (cell) {
            if (cell.td) {
                cell.td = (0, changeElementTag_1.default)(cell.td, TABLE_CELL_TAG_NAME);
                cell.td.scope = '';
            }
        });
        return;
    }
    (_b = cells[0]) === null || _b === void 0 ? void 0 : _b.forEach(function (cell) {
        if (cell.td && format.headerRowColor) {
            if (!hasCellShadeOverride(cell)) {
                (0, setColor_1.default)(cell.td, format.headerRowColor, true /** isBackgroundColor*/, undefined /** isDarkMode **/, true /** shouldAdaptFontColor */, darkColorHandler);
            }
            cell.td.style.borderRightColor = format.headerRowColor;
            cell.td.style.borderLeftColor = format.headerRowColor;
            cell.td.style.borderTopColor = format.headerRowColor;
            cell.td = (0, changeElementTag_1.default)(cell.td, TABLE_HEADER_TAG_NAME);
            cell.td.scope = 'row';
        }
    });
}
function getBorderStyle(style) {
    var color = style ? style : 'transparent';
    return 'solid 1px ' + color;
}
//# sourceMappingURL=applyTableFormat.js.map