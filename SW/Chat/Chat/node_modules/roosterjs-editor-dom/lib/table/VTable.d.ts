import { TableOperation } from 'roosterjs-editor-types';
import type { SizeTransformer, TableFormat, TableSelection, VCell, DarkColorHandler } from 'roosterjs-editor-types';
import type { CompatibleTableOperation } from 'roosterjs-editor-types/lib/compatibleTypes';
/**
 * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells
 */
export default class VTable {
    /**
     * The HTML table object
     */
    table: HTMLTableElement;
    /**
     * Virtual cells
     */
    cells: VCell[][] | null;
    /**
     * Current row index
     */
    row: number | undefined;
    /**
     * Current column index
     */
    col: number | undefined;
    /**
     * Current format of the table
     */
    formatInfo: Required<TableFormat> | null;
    private trs;
    private tableSelection;
    /**
     * Create a new instance of VTable object using HTML TABLE or TD node
     * @param node The HTML Table or TD node
     * @param normalizeSize Whether table size needs to be normalized
     * @param zoomScale When the table is under a zoomed container, pass in the zoom scale here
     */
    constructor(node: HTMLTableElement | HTMLTableCellElement, normalizeSize?: boolean, zoomScale?: number | SizeTransformer);
    /**
     * Selected range of cells with the coordinates of the first and last cell selected.
     */
    get selection(): TableSelection | null;
    set selection(value: TableSelection | null);
    /**
     * Write the virtual table back to DOM tree to represent the change of VTable
     * @param skipApplyFormat Do not reapply table format when write back. Only use this parameter when you are pretty sure there is no format or table structure change during the process.
     * @param darkColorHandler An object to handle dark background colors, if not passed the cell background color will not be set
     */
    writeBack(skipApplyFormat?: boolean, darkColorHandler?: DarkColorHandler | null): void;
    private recalculateCellHeight;
    /**
     * Apply the given table format to this virtual table
     * @param format Table format to apply
     */
    applyFormat(format: Partial<TableFormat>): void;
    /**
     * Remove the cellShade dataset to apply a new style format at the cell.
     * @param cells
     */
    private deleteCellShadeDataset;
    /**
     * Edit table with given operation.
     * @param operation Table operation
     */
    edit(operation: TableOperation | CompatibleTableOperation): void;
    setAlignmentToSelectedCells(firstRow: number, lastRow: number, firstColumn: number, lastColumn: number, alignmentType: string, isVertical?: boolean): void;
    private mergeCells;
    private isEmptyCell;
    private mergeCellContents;
    /**
     * Loop each cell of current column and invoke a callback function
     * @param callback The callback function to invoke
     */
    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any): void;
    /**
     * Loop each table cell and get all the cells that share the same border from one side
     * The result is an array of table cell elements
     * @param borderPos The position of the border
     * @param getLeftCells Get left-hand-side or right-hand-side cells of the border
     *
     * Example, consider having a 3 by 4 table as below with merged and split cells
     *
     *     | 1 | 4 | 7 | 8 |
     *     |   5   |   9   |
     *     |   3   |   10  |
     *
     *  input => borderPos: the 3rd border, getLeftCells: true
     *  output => [4, 5, 3]
     *
     *  input => borderPos: the 3rd border, getLeftCells: false
     *  output => [7, 9, 10]
     *
     *  input => borderPos: the 2nd border, getLeftCells: true
     *  output => [1]
     *
     *  input => borderPos: the 2nd border, getLeftCells: false
     *  output => [4]
     */
    getCellsWithBorder(borderPos: number, getLeftCells: boolean): HTMLTableCellElement[];
    /**
     * Loop each cell of current row and invoke a callback function
     * @param callback The callback function to invoke
     */
    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any): void;
    /**
     * Get a table cell using its row and column index. This function will always return an object
     * even if the given indexes don't exist in table.
     * @param row The row index
     * @param col The column index
     */
    getCell(row: number, col: number): VCell;
    /**
     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell
     */
    getCurrentTd(): HTMLTableCellElement | null;
    /**
     * Get the Table Cell in a provided coordinate
     * @param row row of the cell
     * @param col column of the cell
     */
    getTd(row: number | undefined, col: number | undefined): HTMLTableCellElement | null;
    private forEachCellOfColumn;
    private forEachCellOfRow;
    private recalculateSpans;
    private countSpanLeft;
    private countSpanAbove;
    private normalizeEmptyTableCells;
    normalizeTableCellSize(zoomScale?: number | SizeTransformer): void;
    private normalizeSize;
}
