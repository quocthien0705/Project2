{"version":3,"file":"shouldSkipNode.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts"],"names":[],"mappings":"AAAA,OAAO,YAAY,MAAM,gBAAgB,CAAC;AAC1C,OAAO,EAAE,gBAAgB,EAAE,MAAM,qBAAqB,CAAC;AAGvD,IAAM,IAAI,GAAG,YAAY,CAAC;AAC1B,IAAM,UAAU,GAAG,wBAAwB,CAAC,CAAC,wFAAwF;AAErI;;;;;;;;;;;;GAYG;AACH,MAAM,CAAC,OAAO,UAAU,cAAc,CAAC,IAAU,EAAE,WAAqB;IACpE,IAAI,IAAI,CAAC,QAAQ,gBAAiB,EAAE;QAChC,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,WAAW,IAAI,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;YACxE,OAAO,IAAI,CAAC;SACf;aAAM,IAAI,WAAW,IAAI,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE;YACpE,OAAO,IAAI,CAAC;SACf;aAAM;YACH,OAAO,KAAK,CAAC;SAChB;KACJ;SAAM,IAAI,IAAI,CAAC,QAAQ,mBAAoB,EAAE;QAC1C,IAAI,gBAAgB,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI,MAAM,EAAE;YAC7C,OAAO,IAAI,CAAC;SACf;QAED,IAAM,GAAG,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QAE/B,IAAI,GAAG,IAAI,KAAK,IAAI,GAAG,IAAI,MAAM,EAAE;YAC/B,4EAA4E;YAC5E,+EAA+E;YAC/E,iDAAiD;YACjD,KAAK,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC,KAAK,EAAE,KAAK,GAAG,KAAK,CAAC,WAAW,EAAE;gBAClE,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,WAAW,CAAC,EAAE;oBACrC,OAAO,KAAK,CAAC;iBAChB;aACJ;YACD,OAAO,IAAI,CAAC;SACf;aAAM;YACH,kEAAkE;YAClE,gDAAgD;YAChD,OAAO,KAAK,CAAC;SAChB;KACJ;SAAM;QACH,OAAO,IAAI,CAAC;KACf;AACL,CAAC","sourcesContent":["import getTagOfNode from './getTagOfNode';\r\nimport { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/g;\r\nconst CRLF_SPACE = /[\\t\\r\\n\\u0020\\u200B]/gm; // We should only find new line, real space or ZeroWidthSpace (TAB, %20, but not &nbsp;)\r\n\r\n/**\r\n * @internal\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n * - it is just <div></div>\r\n * @param node The node to check\r\n * @param ignoreSpace (Optional) True to ignore pure space text node of the node when check.\r\n * If the value of a node value is only space, set this to true will treat this node can be skipped.\r\n * Default value is false\r\n */\r\nexport default function shouldSkipNode(node: Node, ignoreSpace?: boolean): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        if (!node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue)) {\r\n            return true;\r\n        } else if (ignoreSpace && node.nodeValue.replace(CRLF_SPACE, '') == '') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        if (getComputedStyle(node, 'display') == 'none') {\r\n            return true;\r\n        }\r\n\r\n        const tag = getTagOfNode(node);\r\n\r\n        if (tag == 'DIV' || tag == 'SPAN') {\r\n            // Empty SPAN/DIV or SPAN/DIV with only meaningless children is meaningless,\r\n            // because it can render nothing. If we keep them here, there may be unexpected\r\n            // LI elements added for those meaningless nodes.\r\n            for (let child = node.firstChild; !!child; child = child.nextSibling) {\r\n                if (!shouldSkipNode(child, ignoreSpace)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            // There may still be other cases that the node is not meaningful.\r\n            // We can add those cases here once we hit them.\r\n            return false;\r\n        }\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n"]}