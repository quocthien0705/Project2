{"version":3,"file":"getLeafSibling.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts"],"names":[],"mappings":"AAAA,OAAO,QAAQ,MAAM,YAAY,CAAC;AAClC,OAAO,YAAY,MAAM,gBAAgB,CAAC;AAC1C,OAAO,cAAc,MAAM,kBAAkB,CAAC;AAE9C;;;;;;;;GAQG;AACH,MAAM,UAAU,cAAc,CAC1B,QAAc,EACd,SAAe,EACf,MAAe,EACf,QAAmB,EACnB,WAAqB;IAErB,IAAI,MAAM,GAAG,IAAI,CAAC;IAClB,IAAM,UAAU,GAAG,MAAM;QACrB,CAAC,CAAC,UAAC,IAAiB,IAAK,OAAA,CAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,WAAW,KAAI,IAAI,EAAzB,CAAyB;QAClD,CAAC,CAAC,UAAC,IAAiB,IAAK,OAAA,CAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,eAAe,KAAI,IAAI,EAA7B,CAA6B,CAAC;IAC3D,IAAM,QAAQ,GAAG,MAAM,CAAC,CAAC,CAAC,UAAC,IAAU,IAAK,OAAA,IAAI,CAAC,UAAU,EAAf,CAAe,CAAC,CAAC,CAAC,UAAC,IAAU,IAAK,OAAA,IAAI,CAAC,SAAS,EAAd,CAAc,CAAC;IAC3F,IAAI,QAAQ,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE;QAC/B,IAAI,OAAO,GAAgB,SAAS,CAAC;QACrC,IAAI,cAAc,GAAY,IAAI,CAAC;QAEnC,OAAO,cAAc,EAAE;YACnB,4HAA4H;YAC5H,gGAAgG;YAChG,IAAI,UAAU,GAAG,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,UAAU,KAAI,IAAI,CAAC;YAC7C,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;YAC9B,OAAO,CAAC,OAAO,IAAI,UAAU,IAAI,QAAQ,EAAE;gBACvC,OAAO,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC;gBACjC,UAAU,GAAG,CAAA,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,UAAU,KAAI,IAAI,CAAC;aAC/C;YAED,4CAA4C;YAC5C,OACI,OAAO;gBACP,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,OAAO,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;gBAC1D,QAAQ,CAAC,OAAO,CAAC,EACnB;gBACE,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;aAC/B;YAED,0FAA0F;YAC1F,cAAc,GAAG,CAAC,CAAC,OAAO,IAAI,cAAc,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YACnE,IAAI,CAAC,cAAc,EAAE;gBACjB,0CAA0C;gBAC1C,MAAM,GAAG,OAAO,CAAC;gBACjB,MAAM;aACT;SACJ;KACJ;IAED,OAAO,MAAM,CAAC;AAClB,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,kBAAkB,CAC9B,QAAc,EACd,SAAe,EACf,QAAmB;IAEnB,OAAO,cAAc,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;AAC1E,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,sBAAsB,CAClC,QAAc,EACd,SAAe,EACf,QAAmB;IAEnB,OAAO,cAAc,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;AAC3E,CAAC","sourcesContent":["import contains from './contains';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * @internal\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped\r\n */\r\nexport function getLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    isNext: boolean,\r\n    skipTags?: string[],\r\n    ignoreSpace?: boolean\r\n): Node | null {\r\n    let result = null;\r\n    const getSibling = isNext\r\n        ? (node: Node | null) => node?.nextSibling || null\r\n        : (node: Node | null) => node?.previousSibling || null;\r\n    const getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode: Node | null = startNode;\r\n        let shouldContinue: boolean = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode?.parentNode || null;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode?.parentNode || null;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (\r\n                curNode &&\r\n                (!skipTags || skipTags.indexOf(getTagOfNode(curNode)) < 0) &&\r\n                getChild(curNode)\r\n            ) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = !!curNode && shouldSkipNode(curNode, ignoreSpace);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getNextLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    skipTags?: string[]\r\n): Node | null {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getPreviousLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    skipTags?: string[]\r\n): Node | null {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);\r\n}\r\n"]}