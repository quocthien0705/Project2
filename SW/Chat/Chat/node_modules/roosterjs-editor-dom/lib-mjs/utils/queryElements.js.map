{"version":3,"file":"queryElements.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/utils/queryElements.ts"],"names":[],"mappings":"AAAA,OAAO,OAAO,MAAM,oBAAoB,CAAC;AAIzC;;;;;;;;GAQG;AACH,MAAM,CAAC,OAAO,UAAU,aAAa,CACjC,SAAqB,EACrB,QAAgB,EAChB,eAAqD,EACrD,KAA0D,EAC1D,KAAa;IADb,sBAAA,EAAA,oBAA0D;IAG1D,IAAI,CAAC,SAAS,IAAI,CAAC,QAAQ,EAAE;QACzB,OAAO,EAAE,CAAC;KACb;IAED,IAAI,QAAQ,GAAG,OAAO,CAAC,SAAS,CAAC,gBAAgB,CAAc,QAAQ,CAAC,CAAC,CAAC;IAE1E,IAAI,KAAK,gBAAmB,IAAI,KAAK,EAAE;QAC3B,IAAA,WAAW,GAAgB,KAAK,YAArB,EAAE,SAAS,GAAK,KAAK,UAAV,CAAW;QACnC,IAAA,gBAAc,GAAmB,KAAK,eAAxB,EAAE,cAAY,GAAK,KAAK,aAAV,CAAW;QAC7C,IAAI,gBAAc,CAAC,QAAQ,mBAAoB,IAAI,gBAAc,CAAC,UAAU,EAAE;YAC1E,IAAM,KAAK,GAAG,gBAAc,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YAErD,8FAA8F;YAC9F,kDAAkD;YAClD,gBAAc,GAAG,KAAK,IAAI,gBAAc,CAAC,SAAS,CAAC;SACtD;QAED,cAAY;YACR,cAAY,CAAC,QAAQ,mBAAoB,IAAI,cAAY,CAAC,UAAU,IAAI,SAAS,GAAG,CAAC;gBACjF,CAAC,CAAC,cAAY,CAAC,UAAU,CAAC,SAAS,GAAG,CAAC,CAAC;gBACxC,CAAC,CAAC,cAAY,CAAC;QAEvB,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAA,OAAO;YAC9B,OAAA,wBAAwB,CACpB,OAAO,EACP,gBAAc,EACd,cAAY,EACZ,KAAK,uBAA0B,CAClC;QALD,CAKC,CACJ,CAAC;KACL;IAED,IAAI,eAAe,EAAE;QACjB,QAAQ,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;KACrC;IACD,OAAO,QAAQ,CAAC;AACpB,CAAC;AAED,SAAS,wBAAwB,CAC7B,IAAU,EACV,SAAe,EACf,OAAa,EACb,wBAAiC;IAEjC,IAAM,aAAa,GAAG,IAAI,CAAC,uBAAuB,CAAC,SAAS,CAAC,CAAC;IAC9D,IAAM,WAAW,GAAG,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC;IAC1D,IAAM,eAAe,GAAG,gCAAkD,CAAC;IAE3E,IAAI,CAAC,wBAAwB,EAAE;QAC3B,eAAe,CAAC,IAAI,sBAA8B,CAAC;KACtD;IAED,OAAO,CACH,aAAa,CAAC,aAAa,EAAE,eAAe,CAAC,IAAI,iBAAiB;QAClE,aAAa,CAAC,WAAW,EAAE,eAAe,CAAC,IAAI,eAAe;QAC9D,CAAC,aAAa,CAAC,aAAa,EAAE,mBAA4B,CAAC,IAAI,WAAW;YACtE,aAAa,CAAC,WAAW,EAAE,mBAA4B,CAAC;YACxD,CAAC,aAAa,CAAC,WAAW,EAAE,sBAA8B,CAAC,CAAC,CACnE,CAAC;AACN,CAAC;AAED,SAAS,aAAa,CAAC,QAA0B,EAAE,OAA2B;IAC1E,OAAO,OAAO,CAAC,IAAI,CAAC,UAAA,MAAM;QACtB,OAAA,MAAM,gBAAyB;YAC3B,CAAC,CAAC,QAAQ,gBAAyB;YACnC,CAAC,CAAC,CAAC,QAAQ,GAAG,MAAM,CAAC,IAAI,MAAM;IAFnC,CAEmC,CACtC,CAAC;AACN,CAAC","sourcesContent":["import toArray from '../jsUtils/toArray';\r\nimport { DocumentPosition, NodeType, QueryScope } from 'roosterjs-editor-types';\r\nimport type { CompatibleQueryScope } from 'roosterjs-editor-types/lib/compatibleTypes';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: ParentNode,\r\n    selector: string,\r\n    forEachCallback?: ((node: HTMLElement) => any) | null,\r\n    scope: QueryScope | CompatibleQueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = toArray(container.querySelectorAll<HTMLElement>(selector));\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        const { startOffset, endOffset } = range;\r\n        let { startContainer, endContainer } = range;\r\n        if (startContainer.nodeType == NodeType.Element && startContainer.firstChild) {\r\n            const child = startContainer.childNodes[startOffset];\r\n\r\n            // range.startOffset can give a value of child.length+1 when selection is after the last child\r\n            // In that case we will use the last child instead\r\n            startContainer = child || startContainer.lastChild;\r\n        }\r\n\r\n        endContainer =\r\n            endContainer.nodeType == NodeType.Element && endContainer.firstChild && endOffset > 0\r\n                ? endContainer.childNodes[endOffset - 1]\r\n                : endContainer;\r\n\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(\r\n                element,\r\n                startContainer,\r\n                endContainer,\r\n                scope == QueryScope.InSelection\r\n            )\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    startNode: Node,\r\n    endNode: Node,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    const startPosition = node.compareDocumentPosition(startNode);\r\n    const endPosition = node.compareDocumentPosition(endNode);\r\n    const targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n"]}