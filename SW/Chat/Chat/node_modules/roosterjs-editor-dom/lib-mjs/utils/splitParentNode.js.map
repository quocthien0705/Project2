{"version":3,"file":"splitParentNode.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts"],"names":[],"mappings":"AAAA,OAAO,WAAW,MAAM,eAAe,CAAC;AAExC;;;;;;;;;;GAUG;AACH,MAAM,CAAC,OAAO,UAAU,eAAe,CAAC,IAAU,EAAE,WAAoB;;IACpE,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;QAC3B,OAAO,IAAI,CAAC;KACf;IAED,IAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;IACnC,IAAI,SAAS,GAAuB,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAgB,CAAC;IACxF,SAAS,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IAChC,IAAI,WAAW,EAAE;QACb,OAAO,UAAU,CAAC,UAAU,IAAI,UAAU,CAAC,UAAU,IAAI,IAAI,EAAE;YAC3D,SAAS,CAAC,WAAW,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;SAChD;KACJ;SAAM;QACH,OAAO,IAAI,CAAC,WAAW,EAAE;YACrB,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SAC3C;KACJ;IAED,2HAA2H;IAC3H,IAAI,SAAS,CAAC,UAAU,IAAI,SAAS,CAAC,SAAS,IAAI,EAAE,EAAE;QACnD,MAAA,UAAU,CAAC,UAAU,0CAAE,YAAY,CAC/B,SAAS,EACT,WAAW,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,WAAW,CACpD,CAAC;KACL;SAAM;QACH,SAAS,GAAG,IAAI,CAAC;KACpB;IAED,OAAO,SAAS,CAAC;AACrB,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,sBAAsB,CAAC,KAAoB;IACvD,IAAI,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IACpD,IAAI,GAAG,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IACjE,IAAM,UAAU,GAAG,KAAK,IAAI,GAAG,IAAI,KAAK,CAAC,UAAU,IAAI,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC;IAChG,IAAI,UAAU,EAAE;QACZ,IAAI,WAAW,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;YACzB,IAAM,IAAI,GAAG,GAAG,CAAC;YACjB,GAAG,GAAG,KAAK,CAAC;YACZ,KAAK,GAAG,IAAI,CAAC;SAChB;QACD,eAAe,CAAC,KAAK,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;QAC7C,eAAe,CAAC,GAAG,EAAE,KAAK,CAAC,eAAe,CAAC,CAAC;KAC/C;IAED,OAAO,UAAU,CAAC;AACtB,CAAC","sourcesContent":["import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node | null {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    const parentNode = node.parentNode;\r\n    let newParent: HTMLElement | null = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode?.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): Node | null {\r\n    let start = Array.isArray(nodes) ? nodes[0] : nodes;\r\n    let end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;\r\n    const parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            const temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode;\r\n}\r\n"]}