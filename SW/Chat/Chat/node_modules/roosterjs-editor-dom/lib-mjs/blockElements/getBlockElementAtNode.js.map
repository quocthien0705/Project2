{"version":3,"file":"getBlockElementAtNode.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts"],"names":[],"mappings":"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","sourcesContent":["import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport type { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitrary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(\r\n    rootNode: Node,\r\n    node: Node | null\r\n): BlockElement | null {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    const containerBlockNode = StartEndBlockElement.getBlockContext(node!);\r\n    if (!containerBlockNode) {\r\n        return null;\r\n    } else if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node!, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node!, containerBlockNode, true /*isTail*/);\r\n\r\n    if (!headNode || !tailNode) {\r\n        return null;\r\n    }\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancestor\r\n    const nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n\r\n    if (nodes.length === 0) {\r\n        return null;\r\n    }\r\n\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            const parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else if (parentNode && parentNode != rootNode) {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling: Node | null = node;\r\n        while (node.parentNode && !(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n"]}