import collapseNodes from '../utils/collapseNodes';
import contains from '../utils/contains';
import createRange from '../selection/createRange';
import getTagOfNode from '../utils/getTagOfNode';
import isBlockElement from '../utils/isBlockElement';
import isNodeAfter from '../utils/isNodeAfter';
import wrap from '../utils/wrap';
import { splitBalancedNodeRange } from '../utils/splitParentNode';
var STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];
/**
 * @internal
 * This represents a block that is identified by a start and end node
 * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;
 * in that case, Hello&lt;BR&gt; is a block, World is another block
 * Such block cannot be represented by a NodeBlockElement since they don't chained up
 * to a single parent node, instead they have a start and end
 * This start and end must be in same sibling level and have same parent in DOM tree
 */
var StartEndBlockElement = /** @class */ (function () {
    function StartEndBlockElement(rootNode, startNode, endNode) {
        this.rootNode = rootNode;
        this.startNode = startNode;
        this.endNode = endNode;
    }
    StartEndBlockElement.getBlockContext = function (node) {
        var currentNode = node;
        while (currentNode && !isBlockElement(currentNode)) {
            currentNode = currentNode.parentNode;
        }
        return currentNode;
    };
    /**
     * Collapse this element to a single DOM element.
     * If the content nodes are separated in different root nodes, wrap them to a single node
     * If the content nodes are included in root node with other nodes, split root node
     */
    StartEndBlockElement.prototype.collapseToSingleElement = function () {
        var nodeContext = StartEndBlockElement.getBlockContext(this.startNode);
        var nodes = nodeContext
            ? collapseNodes(nodeContext, this.startNode, this.endNode, true /*canSplitParent*/)
            : [];
        var blockContext = StartEndBlockElement.getBlockContext(this.startNode);
        while (nodes[0] &&
            nodes[0] != blockContext &&
            nodes[0].parentNode != this.rootNode &&
            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0) {
            var newNode = splitBalancedNodeRange(nodes);
            if (newNode) {
                nodes = [newNode];
            }
            else {
                break;
            }
        }
        return nodes.length == 1 && isBlockElement(nodes[0])
            ? nodes[0]
            : wrap(nodes);
    };
    /**
     * Gets the start node
     */
    StartEndBlockElement.prototype.getStartNode = function () {
        return this.startNode;
    };
    /**
     * Gets the end node
     */
    StartEndBlockElement.prototype.getEndNode = function () {
        return this.endNode;
    };
    /**
     * Checks equals of two blocks
     */
    StartEndBlockElement.prototype.equals = function (blockElement) {
        return (this.startNode == blockElement.getStartNode() &&
            this.endNode == blockElement.getEndNode());
    };
    /**
     * Checks if another block is after this current
     */
    StartEndBlockElement.prototype.isAfter = function (blockElement) {
        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());
    };
    /**
     * Checks if an Html node is contained within the block
     */
    StartEndBlockElement.prototype.contains = function (node) {
        return (contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||
            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||
            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node)));
    };
    /**
     * Get the text content of this block element
     */
    StartEndBlockElement.prototype.getTextContent = function () {
        var range = createRange(this.getStartNode(), this.getEndNode());
        return range ? range.toString() : '';
    };
    return StartEndBlockElement;
}());
export default StartEndBlockElement;
//# sourceMappingURL=StartEndBlockElement.js.map