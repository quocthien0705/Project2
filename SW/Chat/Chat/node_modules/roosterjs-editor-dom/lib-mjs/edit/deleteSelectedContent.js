import { __read } from "tslib";
import arrayPush from '../jsUtils/arrayPush';
import collapseNodesInRegion from '../region/collapseNodesInRegion';
import getRegionsFromRange from '../region/getRegionsFromRange';
import getSelectionRangeInRegion from '../region/getSelectionRangeInRegion';
import mergeBlocksInRegion from '../region/mergeBlocksInRegion';
import Position from '../selection/Position';
import queryElements from '../utils/queryElements';
import safeInstanceOf from '../utils/safeInstanceOf';
import splitTextNode from '../utils/splitTextNode';
/**
 * Delete selected content, and return the new position to select
 * @param core The EditorCore object.
 * @param range The range to delete
 */
export default function deleteSelectedContent(root, range) {
    var nodeBefore = null;
    // 1. TABLE and TR node in selected should be deleted. It is possible we don't detect them from step 2
    // since table cells will fall in to different regions
    var nodesToDelete = queryElements(root, 'table,tr', null /*callback*/, 2 /* InSelection */, range);
    // 2. Loop all selected regions, find out those nodes need to be deleted and merged.
    // We don't delete them directly here because delete node from one region may cause selection range
    // another region becomes invalid. So we delay the process of deletion.
    var regions = getRegionsFromRange(root, range, 0 /* Table */);
    var nodesPairToMerge = regions
        .map(function (region) {
        var regionRange = getSelectionRangeInRegion(region);
        if (!regionRange) {
            return null;
        }
        var startContainer = regionRange.startContainer, endContainer = regionRange.endContainer, startOffset = regionRange.startOffset, endOffset = regionRange.endOffset, commonAncestorContainer = regionRange.commonAncestorContainer;
        // Disallow merging of readonly elements
        if (safeInstanceOf(commonAncestorContainer, 'HTMLElement') &&
            !commonAncestorContainer.isContentEditable) {
            return null;
        }
        // Make sure there are node before and after the merging point.
        // This is required by mergeBlocksInRegion API.
        // This may create some empty text node as anchor
        var _a = __read(ensureBeforeAndAfter(endContainer, endOffset, false /*isStart*/), 2), beforeEnd = _a[0], afterEnd = _a[1];
        var _b = __read(ensureBeforeAndAfter(startContainer, startOffset, true /*isStart*/), 2), beforeStart = _b[0], afterStart = _b[1];
        nodeBefore = nodeBefore || beforeStart;
        // Find out all nodes to be deleted
        var nodes = collapseNodesInRegion(region, [afterStart, beforeEnd]);
        arrayPush(nodesToDelete, nodes);
        return { region: region, beforeStart: beforeStart, afterEnd: afterEnd };
    })
        .filter(function (x) { return !!x; });
    // 3. Delete all nodes that we found, whose parent is editable
    nodesToDelete.forEach(function (node) { var _a; return ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.isContentEditable) && node.parentElement.removeChild(node); });
    // 4. Merge lines for each region, so that after we don't see extra line breaks
    nodesPairToMerge.forEach(function (nodes) {
        if (nodes) {
            mergeBlocksInRegion(nodes.region, nodes.beforeStart, nodes.afterEnd);
        }
    });
    return nodeBefore && new Position(nodeBefore, -1 /* End */);
}
function ensureBeforeAndAfter(node, offset, isStart) {
    var _a, _b;
    if (safeInstanceOf(node, 'Text')) {
        var newNode = splitTextNode(node, offset, isStart);
        return isStart ? [newNode, node] : [node, newNode];
    }
    else {
        var nodeBefore = node.childNodes[offset - 1];
        var nodeAfter = node.childNodes[offset];
        // Condition 1: node child nodes
        // ("I" means cursor; "o" means a DOM node, "[ ]" means a parent node)
        // [ I ]
        // need to use parent node instead to convert to condition 2
        if (!nodeBefore && !nodeAfter) {
            if (isStart) {
                nodeAfter = node;
                nodeBefore = nodeAfter.previousSibling;
            }
            else {
                nodeBefore = node;
                nodeAfter = nodeBefore.nextSibling;
            }
        }
        // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)
        // [ o I ]  or [ I o]
        // need to add empty text node to convert to condition 3
        if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {
            var emptyNode = node.ownerDocument.createTextNode('');
            (_b = (_a = (nodeBefore || nodeAfter)) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(emptyNode, nodeAfter);
            if (nodeBefore) {
                nodeAfter = emptyNode;
            }
            else {
                nodeBefore = emptyNode;
            }
        }
        // Condition 3: Both nodeBefore and nodeAfter are not null
        // [o I o]
        // return the nodes
        return [nodeBefore, nodeAfter];
    }
}
//# sourceMappingURL=deleteSelectedContent.js.map