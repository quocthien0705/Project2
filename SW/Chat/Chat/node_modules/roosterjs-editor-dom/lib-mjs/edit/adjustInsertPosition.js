import changeElementTag from '../utils/changeElementTag';
import contains from '../utils/contains';
import ContentTraverser from '../contentTraverser/ContentTraverser';
import createRange from '../selection/createRange';
import findClosestElementAncestor from '../utils/findClosestElementAncestor';
import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';
import getTagOfNode from '../utils/getTagOfNode';
import isNodeEmpty from '../utils/isNodeEmpty';
import isPositionAtBeginningOf from '../selection/isPositionAtBeginningOf';
import isVoidHtmlElement from '../utils/isVoidHtmlElement';
import LinkInlineElement from '../inlineElements/LinkInlineElement';
import moveChildNodes from '../utils/moveChildNodes';
import pasteTable from '../table/pasteTable';
import Position from '../selection/Position';
import PositionContentSearcher from '../contentTraverser/PositionContentSearcher';
import queryElements from '../utils/queryElements';
import splitTextNode from '../utils/splitTextNode';
import toArray from '../jsUtils/toArray';
import unwrap from '../utils/unwrap';
import wrap from '../utils/wrap';
import { splitBalancedNodeRange } from '../utils/splitParentNode';
var NOT_EDITABLE_SELECTOR = '[contenteditable=false]';
var adjustSteps = [
    adjustInsertPositionForHyperLink,
    adjustInsertPositionForStructuredNode,
    adjustInsertPositionForParagraph,
    adjustInsertPositionForVoidElement,
    adjustInsertPositionForMoveCursorOutOfALink,
    adjustInsertPositionForNotEditableNode,
    adjustInsertPositionForTable,
];
/**
 * Adjust position for A tag don't be nested inside another A tag.
 */
function adjustInsertPositionForHyperLink(root, nodeToInsert, position, range) {
    var _a, _b;
    var blockElement = getBlockElementAtNode(root, position.node);
    if (blockElement) {
        // Find the first <A> tag within current block which covers current selection
        // If there are more than one nested, let's handle the first one only since that is not a common scenario.
        var anchor = queryElements(root, 'a[href]', null /*forEachCallback*/, 1 /* OnSelection */, createRange(position)).filter(function (a) { return blockElement.contains(a); })[0];
        // If this is about to insert node to an empty A tag, clear the A tag and reset position
        if (anchor && isNodeEmpty(anchor)) {
            position = new Position(anchor, -2 /* Before */);
            safeRemove(anchor);
            anchor = null;
        }
        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag
        // otherwise we will have nested A tags which is a wrong HTML structure
        if (anchor &&
            ((_a = nodeToInsert) === null || _a === void 0 ? void 0 : _a.querySelector) &&
            ((_b = nodeToInsert) === null || _b === void 0 ? void 0 : _b.querySelector('a[href]'))) {
            var normalizedPosition = position.normalize();
            var parentNode = normalizedPosition.node.parentNode;
            var nextNode = normalizedPosition.node.nodeType == 3 /* Text */
                ? splitTextNode(normalizedPosition.node, normalizedPosition.offset, false /*returnFirstPart*/)
                : normalizedPosition.isAtEnd
                    ? normalizedPosition.node.nextSibling
                    : normalizedPosition.node;
            var splitter = root.ownerDocument.createTextNode('');
            parentNode.insertBefore(splitter, nextNode);
            while (splitter && contains(anchor, splitter)) {
                splitter = splitBalancedNodeRange(splitter);
            }
            if (splitter) {
                position = new Position(splitter, -2 /* Before */);
                safeRemove(splitter);
            }
        }
    }
    return position;
}
/**
 * Adjust position for a node don't be nested inside tags like BR, LI, TD.
 */
function adjustInsertPositionForStructuredNode(root, nodeToInsert, position, range) {
    var rootNodeToInsert = nodeToInsert;
    var isFragment = false;
    if (rootNodeToInsert.nodeType == 11 /* DocumentFragment */) {
        isFragment = true;
        var rootNodes = toArray(rootNodeToInsert.childNodes).filter(function (n) { return getTagOfNode(n) != 'BR'; });
        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;
    }
    var tag = getTagOfNode(rootNodeToInsert);
    var hasBrNextToRoot = tag && rootNodeToInsert && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';
    var listItem = findClosestElementAncestor(position.node, root, 'LI');
    var listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');
    var tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');
    if (tag == 'LI') {
        tag = listNode ? getTagOfNode(listNode) : 'UL';
        rootNodeToInsert = wrap(rootNodeToInsert, tag);
    }
    if ((tag == 'OL' || tag == 'UL') &&
        rootNodeToInsert &&
        getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {
        var shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;
        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {
            safeRemove(rootNodeToInsert.nextSibling);
        }
        if (shouldInsertListAsText) {
            unwrap(rootNodeToInsert.firstChild);
            unwrap(rootNodeToInsert);
        }
        else if (getTagOfNode(listNode) == tag) {
            unwrap(rootNodeToInsert);
            position = new Position(listItem, isPositionAtBeginningOf(position, listItem)
                ? -2 /* Before */
                : -3 /* After */);
        }
    }
    if (isFragment && tag == 'TABLE' && tdNode) {
        pasteTable(tdNode, rootNodeToInsert, position, range);
        position = new Position(rootNodeToInsert, 0);
        moveChildNodes(nodeToInsert);
    }
    return position;
}
/**
 * Change P tag to DIV, when a new node when insert node.
 */
function adjustInsertPositionForParagraph(root, nodeToInsert, position, range) {
    if (getTagOfNode(position.node) == 'P') {
        // Insert into a P tag may cause issues when the inserted content contains any block element.
        // Change P tag to DIV to make sure it works well
        var pos = position.normalize();
        var div = changeElementTag(position.node, 'div');
        if (pos.node != div) {
            position = pos;
        }
    }
    return position;
}
/**
 * Adjust position for a node that can have children.
 */
function adjustInsertPositionForVoidElement(root, nodeToInsert, position, range) {
    if (isVoidHtmlElement(position.node)) {
        position = new Position(position.node, position.isAtEnd ? -3 /* After */ : -2 /* Before */);
    }
    return position;
}
/**
 * Adjust the position cursor out of link when a new node is inserted.
 */
function adjustInsertPositionForMoveCursorOutOfALink(root, nodeToInsert, position, range) {
    if (range && range.collapsed) {
        var searcher = new PositionContentSearcher(root, Position.getStart(range));
        var inlineElementBefore = searcher.getInlineElementBefore();
        var inlineElementAfter = searcher.getInlineElementAfter();
        if (inlineElementBefore instanceof LinkInlineElement) {
            position = new Position(inlineElementBefore.getContainerNode(), -3 /* After */);
        }
        else if (inlineElementAfter instanceof LinkInlineElement) {
            position = new Position(inlineElementAfter.getContainerNode(), -2 /* Before */);
        }
    }
    return position;
}
/**
 * Adjust the position cursor out of a not contenteditable element.
 */
function adjustInsertPositionForNotEditableNode(root, nodeToInsert, position, range) {
    var _a;
    if (!((_a = position.element) === null || _a === void 0 ? void 0 : _a.isContentEditable)) {
        var nonEditableElement = void 0;
        var lastNonEditableElement = findClosestElementAncestor(position.node, root, NOT_EDITABLE_SELECTOR);
        while (lastNonEditableElement) {
            nonEditableElement = lastNonEditableElement;
            lastNonEditableElement = (nonEditableElement === null || nonEditableElement === void 0 ? void 0 : nonEditableElement.parentElement)
                ? findClosestElementAncestor(nonEditableElement.parentElement, root, NOT_EDITABLE_SELECTOR)
                : null;
        }
        if (nonEditableElement) {
            position = new Position(nonEditableElement, -3 /* After */);
            return adjustInsertPositionForNotEditableNode(root, nodeToInsert, position, range);
        }
    }
    return position;
}
/**
 * Adjust the position of a table to be one line after another table.
 */
function adjustInsertPositionForTable(root, nodeToInsert, position, range) {
    if ((nodeToInsert.childNodes.length == 1 &&
        getTagOfNode(nodeToInsert.childNodes[0]) == 'TABLE') ||
        getTagOfNode(nodeToInsert) == 'TABLE') {
        var element = position.element;
        var posBefore = new Position(element, -2 /* Before */);
        var rangeToTraverse = createRange(posBefore, position);
        var contentTraverser = ContentTraverser.createSelectionTraverser(root, rangeToTraverse);
        var blockElement = contentTraverser && contentTraverser.currentBlockElement;
        if (blockElement) {
            var nextBlockElement = blockElement;
            while (!nextBlockElement) {
                nextBlockElement = contentTraverser.getNextBlockElement();
                if (nextBlockElement) {
                    blockElement = nextBlockElement;
                }
            }
            var prevElement = blockElement === null || blockElement === void 0 ? void 0 : blockElement.getEndNode();
            if (prevElement && findClosestElementAncestor(prevElement, root, 'TABLE')) {
                var tempRange = createRange(position);
                tempRange.collapse(false /* toStart */);
                var br = root.ownerDocument.createElement('br');
                tempRange.insertNode(br);
                tempRange = createRange(br);
                position = Position.getEnd(tempRange);
            }
        }
    }
    return position;
}
/**
 *
 * @param root the contentDiv of the ditor
 * @param nodeToInsert the node to be inserted
 * @param position the position of the node to be inserted
 * @param range the range current or cached range of the editor
 * @returns the adjusted position of the inserted node
 */
export default function adjustInsertPositionBySteps(root, nodeToInsert, position, range) {
    adjustSteps.forEach(function (handler) {
        position = handler(root, nodeToInsert, position, range);
    });
    return position;
}
function safeRemove(node) {
    var _a;
    (_a = node === null || node === void 0 ? void 0 : node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);
}
//# sourceMappingURL=adjustInsertPosition.js.map