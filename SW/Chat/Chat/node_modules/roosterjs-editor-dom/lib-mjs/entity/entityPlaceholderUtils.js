import getEntityFromElement from './getEntityFromElement';
import getEntitySelector from './getEntitySelector';
import safeInstanceOf from '../utils/safeInstanceOf';
var EntityPlaceHolderTagName = 'ENTITY-PLACEHOLDER';
/**
 * @deprecated
 * Create a placeholder comment node for entity
 * @param entity The entity to create placeholder from
 * @returns A placeholder comment node as
 */
export function createEntityPlaceholder(entity) {
    var placeholder = entity.wrapper.ownerDocument.createElement(EntityPlaceHolderTagName);
    placeholder.id = entity.id;
    return placeholder;
}
/**
 * Move content from a container into a new Document fragment, and try keep entities to be reusable by creating placeholder
 * for them in the document fragment.
 * If an entity is directly under root container, the whole entity can be reused and no need to move it at all.
 * If an entity is not directly under root container, it is still reusable, but it may need some movement.
 * In any case, entities will be replaced with a placeholder in the target document fragment.
 * We will use an entity map (the "entities" parameter) to save the map from entity id to its wrapper element.
 * @param root The root element
 * @param entities A map from entity id to entity wrapper element
 * @returns A new document fragment contains all the content and entity placeholders
 */
export function moveContentWithEntityPlaceholders(root, entities) {
    var entitySelector = getEntitySelector();
    var fragment = root.ownerDocument.createDocumentFragment();
    var next = null;
    var _loop_1 = function (child) {
        var entity;
        var nodeToAppend = child;
        next = child.nextSibling;
        if (safeInstanceOf(child, 'HTMLElement')) {
            if ((entity = getEntityFromElement(child))) {
                nodeToAppend = getPlaceholder(entity, entities);
            }
            else {
                child.querySelectorAll(entitySelector).forEach(function (wrapper) {
                    var _a;
                    if ((entity = getEntityFromElement(wrapper))) {
                        var placeholder = getPlaceholder(entity, entities);
                        (_a = wrapper.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(placeholder, wrapper);
                    }
                });
            }
        }
        fragment.appendChild(nodeToAppend);
    };
    for (var child = root.firstChild; child; child = next) {
        _loop_1(child);
    }
    fragment.normalize();
    return fragment;
}
/**
 * Restore HTML content from a document fragment that may contain entity placeholders.
 * @param source Source document fragment that contains HTML content and entity placeholders
 * @param target Target container, usually to be editor root container
 * @param entities A map from entity id to entity wrapper, used for reusing existing DOM structure for entity
 * @param insertClonedNode When pass true, merge with a cloned copy of the nodes from source fragment rather than the nodes themselves @default false
 */
export function restoreContentWithEntityPlaceholder(source, target, entities, insertClonedNode) {
    var anchor = target.firstChild;
    var entitySelector = getEntitySelector();
    for (var current = source.firstChild; current;) {
        var next = current.nextSibling;
        var wrapper = tryGetWrapperFromEntityPlaceholder(entities, current);
        if (wrapper) {
            anchor = removeUntil(anchor, wrapper);
            if (anchor) {
                anchor = anchor.nextSibling;
            }
            else {
                target.appendChild(wrapper);
            }
        }
        else {
            var nodeToInsert = insertClonedNode ? current.cloneNode(true /*deep*/) : current;
            target.insertBefore(nodeToInsert, anchor);
            if (safeInstanceOf(nodeToInsert, 'HTMLElement')) {
                nodeToInsert.querySelectorAll(entitySelector).forEach(function (placeholder) {
                    var _a;
                    var wrapper = tryGetWrapperFromEntityPlaceholder(entities, placeholder);
                    if (wrapper) {
                        (_a = placeholder.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(wrapper, placeholder);
                    }
                });
            }
        }
        current = next;
    }
    removeUntil(anchor);
}
function removeUntil(anchor, nodeToStop) {
    var _a;
    while (anchor && (!nodeToStop || anchor != nodeToStop)) {
        var nodeToRemove = anchor;
        anchor = anchor.nextSibling;
        (_a = nodeToRemove.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(nodeToRemove);
    }
    return anchor;
}
function tryGetWrapperFromEntityPlaceholder(entities, node) {
    var _a;
    var id = safeInstanceOf(node, 'HTMLElement') &&
        node.classList.contains("_Entity" /* ENTITY_INFO_NAME */) &&
        ((_a = getEntityFromElement(node)) === null || _a === void 0 ? void 0 : _a.id);
    var item = id ? entities === null || entities === void 0 ? void 0 : entities[id] : null;
    return !item
        ? null
        : safeInstanceOf(item, 'HTMLElement')
            ? item
            : (item === null || item === void 0 ? void 0 : item.canPersist)
                ? item.element
                : null;
}
function getPlaceholder(entity, entities) {
    entities[entity.id] = entity.wrapper;
    return entity.wrapper.cloneNode(true /*deep*/);
}
//# sourceMappingURL=entityPlaceholderUtils.js.map