import applyTextStyle from './applyTextStyle';
import isNodeAfter from '../utils/isNodeAfter';
import Position from '../selection/Position';
/**
 * This presents an inline element that can be represented by a single html node.
 * This serves as base for most inline element as it contains most implementation
 * of all operations that can happen on an inline element. Other sub inline elements mostly
 * just identify themselves for a certain type
 */
var NodeInlineElement = /** @class */ (function () {
    function NodeInlineElement(containerNode, parentBlock) {
        this.containerNode = containerNode;
        this.parentBlock = parentBlock;
    }
    /**
     * The text content for this inline element
     */
    NodeInlineElement.prototype.getTextContent = function () {
        // nodeValue is better way to retrieve content for a text. Others, just use textContent
        return ((this.containerNode.nodeType == 3 /* Text */
            ? this.containerNode.nodeValue
            : this.containerNode.textContent) || '');
    };
    /**
     * Get the container node
     */
    NodeInlineElement.prototype.getContainerNode = function () {
        return this.containerNode;
    };
    // Get the parent block
    NodeInlineElement.prototype.getParentBlock = function () {
        return this.parentBlock;
    };
    /**
     * Get the start position of the inline element
     */
    NodeInlineElement.prototype.getStartPosition = function () {
        // For a position, we always want it to point to a leaf node
        // We should try to go get the lowest first child node from the container
        return new Position(this.containerNode, 0).normalize();
    };
    /**
     * Get the end position of the inline element
     */
    NodeInlineElement.prototype.getEndPosition = function () {
        // For a position, we always want it to point to a leaf node
        // We should try to go get the lowest last child node from the container
        return new Position(this.containerNode, -1 /* End */).normalize();
    };
    /**
     * Checks if this inline element is a textual inline element
     */
    NodeInlineElement.prototype.isTextualInlineElement = function () {
        return this.containerNode && this.containerNode.nodeType == 3 /* Text */;
    };
    /**
     * Checks if an inline element is after the current inline element
     */
    NodeInlineElement.prototype.isAfter = function (inlineElement) {
        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());
    };
    /**
     * Checks if the given position is contained in the inline element
     */
    NodeInlineElement.prototype.contains = function (pos) {
        var start = this.getStartPosition();
        var end = this.getEndPosition();
        return pos && pos.isAfter(start) && end.isAfter(pos);
    };
    /**
     * Apply inline style to an inline element
     */
    NodeInlineElement.prototype.applyStyle = function (styler) {
        applyTextStyle(this.containerNode, styler);
    };
    return NodeInlineElement;
}());
export default NodeInlineElement;
//# sourceMappingURL=NodeInlineElement.js.map