import getTagOfNode from '../utils/getTagOfNode';
import Position from '../selection/Position';
import safeInstanceOf from '../utils/safeInstanceOf';
import splitTextNode from '../utils/splitTextNode';
import wrap from '../utils/wrap';
import { getNextLeafSibling } from '../utils/getLeafSibling';
import { splitBalancedNodeRange } from '../utils/splitParentNode';
var STYLET_AGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL,SUP,SUB'.split(',');
/**
 * Apply style using a styler function to the given container node in the given range
 * @param container The container node to apply style to
 * @param styler The styler function
 * @param fromPosition From position
 * @param toPosition To position
 */
export default function applyTextStyle(container, styler, from, to) {
    if (from === void 0) { from = new Position(container, 0 /* Begin */).normalize(); }
    if (to === void 0) { to = new Position(container, -1 /* End */).normalize(); }
    var formatNodes = [];
    var fromPosition = from;
    var toPosition = to;
    while (fromPosition && toPosition && toPosition.isAfter(fromPosition)) {
        var formatNode = fromPosition.node;
        var parentTag = getTagOfNode(formatNode.parentNode);
        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node
        var nextNode = getNextLeafSibling(container, formatNode);
        if (formatNode.nodeType == 3 /* Text */ && ['TR', 'TABLE'].indexOf(parentTag) < 0) {
            if (formatNode == toPosition.node && !toPosition.isAtEnd) {
                formatNode = splitTextNode(formatNode, toPosition.offset, true /*returnFirstPart*/);
            }
            if (fromPosition.offset > 0) {
                formatNode = splitTextNode(formatNode, fromPosition.offset, false /*returnFirstPart*/);
            }
            formatNodes.push(formatNode);
        }
        fromPosition = nextNode && new Position(nextNode, 0 /* Begin */);
    }
    if (formatNodes.length > 0) {
        if (formatNodes.every(function (node) { return node.parentNode == formatNodes[0].parentNode; })) {
            var newNode_1 = formatNodes.shift();
            formatNodes.forEach(function (node) {
                var _a;
                var newNodeValue = (newNode_1.nodeValue || '') + (node.nodeValue || '');
                newNode_1.nodeValue = newNodeValue;
                (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);
            });
            formatNodes = [newNode_1];
        }
        formatNodes.forEach(function (startingNode) {
            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them
            // So that the inner style tag such as U, STRIKE can inherit the style we added
            var node = startingNode;
            while (node &&
                getTagOfNode(node) != 'SPAN' &&
                STYLET_AGS.indexOf(getTagOfNode(node.parentNode)) >= 0) {
                callStylerWithInnerNode(node, styler);
                node = splitBalancedNodeRange(node);
            }
            if (node && getTagOfNode(node) != 'SPAN') {
                callStylerWithInnerNode(node, styler);
                node = wrap(node, 'SPAN');
            }
            if (safeInstanceOf(node, 'HTMLElement')) {
                styler(node);
            }
        });
    }
}
function callStylerWithInnerNode(node, styler) {
    if (node && node.nodeType == 1 /* Element */) {
        styler(node, true /*isInnerNode*/);
    }
}
//# sourceMappingURL=applyTextStyle.js.map