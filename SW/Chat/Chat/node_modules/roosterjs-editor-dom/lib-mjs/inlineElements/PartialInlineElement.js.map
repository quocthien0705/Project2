{"version":3,"file":"PartialInlineElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts"],"names":[],"mappings":"AAAA,OAAO,cAAc,MAAM,kBAAkB,CAAC;AAC9C,OAAO,WAAW,MAAM,0BAA0B,CAAC;AACnD,OAAO,QAAQ,MAAM,uBAAuB,CAAC;AAC7C,OAAO,EAAE,kBAAkB,EAAE,sBAAsB,EAAE,MAAM,yBAAyB,CAAC;AAIrF;;;;;;GAMG;AACH;IACI,8BACY,aAA4B,EAC5B,KAAiC,EACjC,GAA+B;QAD/B,sBAAA,EAAA,YAAiC;QACjC,oBAAA,EAAA,UAA+B;QAF/B,kBAAa,GAAb,aAAa,CAAe;QAC5B,UAAK,GAAL,KAAK,CAA4B;QACjC,QAAG,GAAH,GAAG,CAA4B;IACxC,CAAC;IAEJ;;OAEG;IACI,iDAAkB,GAAzB;QACI,OAAO,IAAI,CAAC,aAAa,CAAC;IAC9B,CAAC;IAED;;OAEG;IACI,+CAAgB,GAAvB;QACI,OAAO,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;IACjD,CAAC;IAED;;OAEG;IACI,6CAAc,GAArB;QACI,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC;IAC/C,CAAC;IAED;;OAEG;IACI,6CAAc,GAArB;QACI,IAAM,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC,gBAAgB,EAAE,EAAE,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC;QAE1E,OAAO,KAAK,CAAC,QAAQ,EAAE,CAAC;IAC5B,CAAC;IAED;;OAEG;IACI,+CAAgB,GAAvB;QACI,OAAO,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;IAC/D,CAAC;IAED;;OAEG;IACI,6CAAc,GAArB;QACI,OAAO,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC;IAC3D,CAAC;IAKD,sBAAW,mDAAiB;QAH5B;;WAEG;aACH;YACI,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,oBAAoB,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QACpF,CAAC;;;OAAA;IAKD,sBAAW,uDAAqB;QAHhC;;WAEG;aACH;YACI,OAAO,IAAI,CAAC,KAAK;gBACb,CAAC,CAAC,IAAI,oBAAoB,CAAC,IAAI,CAAC,aAAa,EAAE,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC;gBACrE,CAAC,CAAC,IAAI,CAAC;QACf,CAAC;;;OAAA;IAED;;OAEG;IACI,uCAAQ,GAAf,UAAgB,GAAiB;QAC7B,OAAO,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IAC7F,CAAC;IAED;;OAEG;IACI,qDAAsB,GAA7B;QACI,OAAO,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,sBAAsB,EAAE,CAAC;IAC7E,CAAC;IAED;;OAEG;IACI,sCAAO,GAAd,UAAe,aAA4B;QACvC,IAAM,SAAS,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAC1C,IAAM,QAAQ,GAAG,aAAa,IAAI,aAAa,CAAC,cAAc,EAAE,CAAC;QACjE,OAAO,QAAQ,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;IACpF,CAAC;IAED;;OAEG;IACI,yCAAU,GAAjB,UAAkB,MAA4D;QAC1E,IAAI,IAAI,GAAwB,IAAI,CAAC,gBAAgB,EAAE,CAAC,SAAS,EAAE,CAAC;QACpE,IAAI,EAAE,GAAwB,IAAI,CAAC,cAAc,EAAE,CAAC,SAAS,EAAE,CAAC;QAChE,IAAM,SAAS,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAE1C,IAAI,IAAI,CAAC,OAAO,EAAE;YACd,IAAM,QAAQ,GAAG,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YAC1D,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,QAAQ,gBAAqB,CAAC,CAAC,CAAC,IAAI,CAAC;SACvE;QACD,IAAI,EAAE,CAAC,MAAM,IAAI,CAAC,EAAE;YAChB,IAAM,YAAY,GAAG,sBAAsB,CAAC,SAAS,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC;YAChE,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,YAAY,eAAmB,CAAC,CAAC,CAAC,IAAI,CAAC;SAC3E;QAED,cAAc,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,IAAI,SAAS,EAAE,EAAE,IAAI,SAAS,CAAC,CAAC;IAC1E,CAAC;IACL,2BAAC;AAAD,CAAC,AA7GD,IA6GC","sourcesContent":["import applyTextStyle from './applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\nimport { PositionType } from 'roosterjs-editor-types';\r\nimport type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start: NodePosition | null = null,\r\n        private end: NodePosition | null = null\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement | null {\r\n        return this.end ? new PartialInlineElement(this.inlineElement, this.end) : null;\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement | null {\r\n        return this.start\r\n            ? new PartialInlineElement(this.inlineElement, undefined, this.start)\r\n            : null;\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        const thisStart = this.getStartPosition();\r\n        const otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from: NodePosition | null = this.getStartPosition().normalize();\r\n        let to: NodePosition | null = this.getEndPosition().normalize();\r\n        const container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            const nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            const previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from || undefined, to || undefined);\r\n    }\r\n}\r\n"]}