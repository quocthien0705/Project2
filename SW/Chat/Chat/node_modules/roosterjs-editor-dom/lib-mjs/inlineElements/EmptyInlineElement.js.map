{"version":3,"file":"EmptyInlineElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts"],"names":[],"mappings":"AAEA;;;;;GAKG;AACH;IACI,4BAAoB,QAAsB,EAAU,WAAyB;QAAzD,aAAQ,GAAR,QAAQ,CAAc;QAAU,gBAAW,GAAX,WAAW,CAAc;IAAG,CAAC;IAEjF;;OAEG;IACH,2CAAc,GAAd;QACI,OAAO,EAAE,CAAC;IACd,CAAC;IAED;;OAEG;IACH,6CAAgB,GAAhB;QACI,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,2CAAc,GAAd;QACI,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED;;OAEG;IACH,6CAAgB,GAAhB;QACI,OAAO,IAAI,CAAC,QAAQ,CAAC;IACzB,CAAC;IAED;;OAEG;IACH,2CAAc,GAAd;QACI,OAAO,IAAI,CAAC,QAAQ,CAAC;IACzB,CAAC;IAED;;OAEG;IACH,oCAAO,GAAP,UAAQ,aAA4B;QAChC,OAAO,aAAa,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC,CAAC;IAClF,CAAC;IAED;;OAEG;IACH,mDAAsB,GAAtB;QACI,OAAO,KAAK,CAAC;IACjB,CAAC;IAED;;OAEG;IACH,qCAAQ,GAAR,UAAS,QAAsB;QAC3B,OAAO,KAAK,CAAC;IACjB,CAAC;IAED;;OAEG;IACH,uCAAU,GAAV,UAAW,MAAqC,IAAS,CAAC;IAC9D,yBAAC;AAAD,CAAC,AA/DD,IA+DC","sourcesContent":["import type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n"]}