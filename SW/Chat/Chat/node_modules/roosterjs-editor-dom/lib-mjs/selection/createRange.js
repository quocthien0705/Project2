import isVoidHtmlElement from '../utils/isVoidHtmlElement';
import Position from './Position';
import safeInstanceOf from '../utils/safeInstanceOf';
export default function createRange(arg1, arg2, arg3, arg4) {
    var _a;
    var start = null;
    var end = null;
    if (isNodePosition(arg1)) {
        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;
        start = arg1;
        end = isNodePosition(arg2) ? arg2 : null;
    }
    else if (safeInstanceOf(arg1, 'Node')) {
        if (Array.isArray(arg2)) {
            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;
            start = getPositionFromPath(arg1, arg2);
            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;
        }
        else if (typeof arg2 == 'number') {
            // function createRange(node: Node, offset: number | PositionType): Range;
            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;
            start = new Position(arg1, arg2);
            end = safeInstanceOf(arg3, 'Node') ? new Position(arg3, arg4) : null;
        }
        else if (safeInstanceOf(arg2, 'Node') || !arg2) {
            // function createRange(startNode: Node, endNode?: Node): Range;
            start = new Position(arg1, -2 /* Before */);
            end = new Position(arg2 || arg1, -3 /* After */);
        }
    }
    if ((_a = start === null || start === void 0 ? void 0 : start.node) === null || _a === void 0 ? void 0 : _a.ownerDocument) {
        var range = start.node.ownerDocument.createRange();
        start = getFocusablePosition(start);
        end = getFocusablePosition(end || start);
        range.setStart(start.node, start.offset);
        range.setEnd(end.node, end.offset);
        return range;
    }
    else {
        return null;
    }
}
/**
 * Convert to focusable position
 * If current node is a void element, we need to move up one level to put cursor outside void element
 */
function getFocusablePosition(position) {
    return position.node.nodeType == 1 /* Element */ && isVoidHtmlElement(position.node)
        ? new Position(position.node, position.isAtEnd ? -3 /* After */ : -2 /* Before */)
        : position;
}
function isNodePosition(arg) {
    return arg && arg.node;
}
function getPositionFromPath(node, path) {
    if (!node || !path) {
        return null;
    }
    // Iterate with a for loop to avoid mutating the passed in element path stack
    // or needing to copy it.
    var offset = 0;
    for (var i = 0; i < path.length; i++) {
        offset = path[i];
        if (i < path.length - 1 &&
            node &&
            node.nodeType == 1 /* Element */ &&
            node.childNodes.length > offset) {
            node = node.childNodes[offset];
        }
        else {
            break;
        }
    }
    return new Position(node, offset);
}
//# sourceMappingURL=createRange.js.map