import createRange from './createRange';
import safeInstanceOf from '../utils/safeInstanceOf';
import validate from '../metadata/validate';
import { createArrayDefinition, createBooleanDefinition, createNumberDefinition, createObjectDefinition, createStringDefinition, } from '../metadata/definitionCreators';
var NumberArrayDefinition = createArrayDefinition(createNumberDefinition());
var CoordinatesDefinition = createObjectDefinition({
    x: createNumberDefinition(),
    y: createNumberDefinition(),
});
var IsDarkModeDefinition = createBooleanDefinition(true /*isOptional*/);
var NormalContentMetadataDefinition = createObjectDefinition({
    type: createNumberDefinition(true /*isOptional*/, 0 /* Normal */),
    isDarkMode: IsDarkModeDefinition,
    start: NumberArrayDefinition,
    end: NumberArrayDefinition,
});
var TableContentMetadataDefinition = createObjectDefinition({
    type: createNumberDefinition(false /*isOptional*/, 1 /* TableSelection */),
    isDarkMode: IsDarkModeDefinition,
    tableId: createStringDefinition(),
    firstCell: CoordinatesDefinition,
    lastCell: CoordinatesDefinition,
});
var ImageContentMetadataDefinition = createObjectDefinition({
    type: createNumberDefinition(false /*isOptional*/, 2 /* ImageSelection */),
    isDarkMode: IsDarkModeDefinition,
    imageId: createStringDefinition(),
});
/**
 * @deprecated Use setHtmlWithMetadata instead
 * Restore inner HTML of a root element from given html string. If the string contains selection path,
 * remove the selection path and return a range represented by the path
 * @param root The root element
 * @param html The HTML to restore
 * @param trustedHTMLHandler An optional trusted HTML handler to convert HTML string to security string
 * @returns A selection range if the html contains a valid selection path, otherwise null
 */
export default function setHtmlWithSelectionPath(rootNode, html, trustedHTMLHandler) {
    var metadata = setHtmlWithMetadata(rootNode, html, trustedHTMLHandler);
    return (metadata === null || metadata === void 0 ? void 0 : metadata.type) == 0 /* Normal */
        ? createRange(rootNode, metadata.start, metadata.end)
        : null;
}
/**
 * Restore inner HTML of a root element from given html string. If the string contains metadata,
 * remove it from DOM tree and return the metadata
 * @param root The root element
 * @param html The HTML to restore
 * @param trustedHTMLHandler An optional trusted HTML handler to convert HTML string to security string
 * @returns Content metadata if any, or undefined
 */
export function setHtmlWithMetadata(rootNode, html, trustedHTMLHandler) {
    if (!rootNode) {
        return undefined;
    }
    html = html || '';
    rootNode.innerHTML = (trustedHTMLHandler === null || trustedHTMLHandler === void 0 ? void 0 : trustedHTMLHandler(html)) || html;
    return extractContentMetadata(rootNode);
}
/**
 * Extract content metadata from DOM tree
 * @param rootNode Root of the DOM tree
 * @returns If there is a valid content metadata node in the give DOM tree, return this metadata object, otherwise undefined
 */
export function extractContentMetadata(rootNode) {
    var potentialMetadataComment = rootNode.lastChild;
    if (safeInstanceOf(potentialMetadataComment, 'Comment')) {
        try {
            var obj = JSON.parse(potentialMetadataComment.nodeValue || '');
            if (validate(obj, NormalContentMetadataDefinition) ||
                validate(obj, TableContentMetadataDefinition) ||
                validate(obj, ImageContentMetadataDefinition)) {
                rootNode.removeChild(potentialMetadataComment);
                obj.type = typeof obj.type === 'undefined' ? 0 /* Normal */ : obj.type;
                obj.isDarkMode = obj.isDarkMode || false;
                return obj;
            }
        }
        catch (_a) { }
    }
    return undefined;
}
//# sourceMappingURL=setHtmlWithSelectionPath.js.map