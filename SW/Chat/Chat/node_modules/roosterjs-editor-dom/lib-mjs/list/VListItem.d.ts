import { BulletListType, ListType, NumberingListType } from 'roosterjs-editor-types';
import type { CompatibleBulletListType, CompatibleListType, CompatibleNumberingListType } from 'roosterjs-editor-types/lib/compatibleTypes';
/**
 * @internal
 * The definition for the number of BulletListType or NumberingListType
 */
export declare const ListStyleDefinitionMetadata: import("roosterjs-editor-types").ObjectDefinition<ListStyleMetadata>;
/**
 * @internal
 * Represents the metadata of the style of a list element
 */
export interface ListStyleMetadata {
    orderedStyleType?: NumberingListType | CompatibleNumberingListType;
    unorderedStyleType?: BulletListType | CompatibleBulletListType;
}
/**
 * !!! Never directly create instance of this class. It should be created within VList class !!!
 *
 * Represent a list item.
 *
 * A list item is normally wrapped using a LI tag. But this class is only a logical item,
 * it can be a LI tag, or another other type of node which means it is actually not a list item.
 * That can happen after we do "outdent" on a 1-level list item, then it becomes not a list item.
 */
export default class VListItem {
    private listTypes;
    private node;
    private dummy;
    private newListStart;
    /**
     * Construct a new instance of VListItem class
     * @param node The DOM node for this item
     * @param listTypes An array represents list types of all parent and current level.
     * Skip this parameter for a non-list item.
     */
    constructor(node: Node, ...listTypes: (ListType.Ordered | ListType.Unordered | CompatibleListType.Ordered | CompatibleListType.Unordered)[]);
    /**
     * Get type of current list item
     */
    getListType(): ListType | CompatibleListType;
    /**
     * Get the levels of this list item.
     */
    getLevel(): number;
    /**
     * Get DOM node of this list item
     */
    getNode(): HTMLLIElement;
    /**
     * Get the Start Number of the new List
     */
    getNewListStart(): number | undefined;
    /**
     * Check if a given node is contained by this list item
     * @param node The node to check
     */
    contains(node: Node): boolean;
    /**
     * Check if this item is a dummy item.
     * A dummy item is also represented by LI tag, but it won't render a bullet (for Unordered list) or a number (for Ordered list)
     * normally it has CSS style display set to a value other than "list-item"
     */
    isDummy(): boolean;
    /**
     * @deprecated Always return false
     */
    isOrphanItem(): boolean;
    /**
     * @deprecated
     */
    canMerge(item: VListItem): boolean;
    /**
     * @deprecated
     */
    mergeItems(items: VListItem[]): void;
    /**
     * Indent this item
     * If this is not an list item, it will be no op
     */
    indent(): void;
    /**
     * Outdent this item
     * If this item is already not an list item, it will be no op
     * @param preventItemRemoval Whether prevent the list item to be removed for the listItem by default false
     */
    outdent(preventItemRemoval?: boolean): void;
    /**
     * Add negative margin to the List item
     */
    addNegativeMargins(): void;
    /**
     * Change list type of this item
     * @param targetType The target list type to change to
     */
    changeListType(targetType: ListType | CompatibleListType): void;
    /**
     * Set whether the item is a dummy item
     * @param isDummy Whether the item is a dummy item
     */
    setIsDummy(isDummy: boolean): void;
    /**
     * Set the start Number of the new list
     * @param isDummy Whether the item is a dummy item
     */
    setNewListStart(startNumber: number): void;
    /**
     * Apply the list style type
     * @param rootList the vList that receives the style
     * @param index the list item index
     */
    applyListStyle(rootList: HTMLOListElement | HTMLUListElement, index: number): void;
    /**
     * Write the change result back into DOM
     * @param listStack current stack of list elements
     * @param originalRoot Original list root element. It will be reused when write back if possible
     * @param shouldReuseAllAncestorListElements Optional - defaults to false. If true, only make
     *              sure the direct parent of this list matches the list types when writing back.
     */
    writeBack(listStack: Node[], originalRoot?: HTMLOListElement | HTMLUListElement, shouldReuseAllAncestorListElements?: boolean): void;
    /**
     * Get the index of how deep is the current node parent list inside of the original root list.
     * @example In the following structure this function would return 2
     * ```html
     *  <ol> <!-- original Root -->
     *      <ol>
     *          <ol>
     *              <li></li> <!-- this.node  -->
     *          </ol>
     *      </ol>
     *  </ol>
     * ```
     * @param originalRoot The root list
     * @returns -1  if the node does not have parent element or if original root was not provided,
     *              else, how deep is the parent element inside of the original root.
     */
    private getDeepChildIndex;
}
