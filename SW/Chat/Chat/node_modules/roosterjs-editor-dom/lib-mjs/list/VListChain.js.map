{"version":3,"file":"VListChain.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/list/VListChain.ts"],"names":[],"mappings":"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","sourcesContent":["import arrayPush from '../jsUtils/arrayPush';\nimport getRootListNode from './getRootListNode';\nimport isNodeAfter from '../utils/isNodeAfter';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport queryElements from '../utils/queryElements';\nimport VList from './VList';\nimport { ListType } from 'roosterjs-editor-types';\nimport type { RegionBase } from 'roosterjs-editor-types';\n\nconst CHAIN_NAME_PREFIX = '__List_Chain_';\nconst CHAIN_DATASET_NAME = 'listchain';\nconst AFTER_CURSOR_DATASET_NAME = 'listchainafter';\nlet lastChainIndex = 0;\n\n/**\n * Represent a chain of list nodes.\n * A chain of lists is a virtual link of lists that have continuous numbers, when editor one of them,\n * all others should also be updated in order to main the list number to be continuous.\n */\nexport default class VListChain {\n    private lastNumber = 0;\n    private lastNumberBeforeCursor = 0;\n\n    /**\n     * Create an array of VListChain from current region in editor\n     * @param region The region to create VListChain from\n     * @param currentNode Optional current node, used for mark lists that are after this node\n     * @param nameGenerator Used by test code only\n     */\n    static createListChains(\n        region: RegionBase | RegionBase[],\n        currentNode?: Node,\n        nameGenerator?: () => string\n    ): VListChain[] {\n        const regions = Array.isArray(region) ? region : region ? [region] : [];\n        const result: VListChain[] = [];\n        regions.forEach(region => {\n            const chains: VListChain[] = [];\n            let lastList: HTMLOListElement;\n\n            queryElements(region.rootNode, 'ol', ol => {\n                const list = getRootListNode(region, 'ol', ol);\n\n                if (lastList != list) {\n                    const chain =\n                        chains.filter(c => c.canAppendToTail(list))[0] ||\n                        new VListChain(region, (nameGenerator || createListChainName)());\n                    const index = chains.indexOf(chain);\n                    const afterCurrentNode = !!currentNode && isNodeAfter(list, currentNode);\n\n                    if (!afterCurrentNode) {\n                        // Make sure current one is at the front if current block has not been met, so that\n                        // the first chain is always the nearest one from current node\n                        if (index >= 0) {\n                            chains.splice(index, 1);\n                        }\n\n                        chains.unshift(chain);\n                    } else if (index < 0) {\n                        chains.push(chain);\n                    }\n\n                    chain.append(list, afterCurrentNode);\n                    lastList = list;\n                }\n            });\n\n            arrayPush(result, chains);\n        });\n\n        return result;\n    }\n\n    /**\n     * Check if a list with the given start number can be appended next to the last list before cursor\n     * @param startNumber The start number of the new list\n     */\n    canAppendAtCursor(startNumber: number): boolean {\n        return startNumber > 1 && this.lastNumberBeforeCursor + 1 == startNumber;\n    }\n\n    /**\n     * Create a VList to wrap the block of the given node, and append to current chain\n     * @param container The container node to create list at\n     * @param startNumber Start number of the new list\n     */\n    createVListAtBlock(container: Node, startNumber: number): VList | null {\n        if (container && container.parentNode) {\n            const list = container.ownerDocument!.createElement('ol');\n\n            list.start = startNumber;\n            this.applyChainName(list);\n            container.parentNode.insertBefore(list, container);\n\n            const vList = new VList(list);\n\n            vList.appendItem(container, ListType.None);\n            return vList;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * After change the lists, commit the change to all lists in this chain to update the list number,\n     * and clear the temporary dataset values added to list node\n     * @param shouldReuseAllAncestorListElements Whether we can parent list item (OL/UL) even if its list type does not match the previous one. @default false\n     * @param disableListChain Whether we want to disable list chain functionality, so splitted list will always restart its number from 1 @default false\n     */\n    commit(shouldReuseAllAncestorListElements?: boolean, disableListChain?: boolean) {\n        const lists = this.getLists();\n        let lastNumber = 0;\n\n        for (let i = 0; i < lists.length; i++) {\n            const list = lists[i];\n\n            if (!disableListChain) {\n                //If there is a list chain sequence, ensure the list chain keep increasing correctly\n                if (list.start > 1) {\n                    list.start = list.start === lastNumber ? lastNumber + 1 : list.start;\n                } else {\n                    list.start = lastNumber + 1;\n                }\n            }\n\n            const vlist = new VList(list);\n            lastNumber = vlist.getLastItemNumber() || 0;\n\n            delete list.dataset[CHAIN_DATASET_NAME];\n            delete list.dataset[AFTER_CURSOR_DATASET_NAME];\n\n            vlist.writeBack(shouldReuseAllAncestorListElements);\n        }\n    }\n\n    /**\n     * Construct a new instance of VListChain class\n     * @param editor Editor object\n     */\n    private constructor(private region: RegionBase, private name: string) {}\n\n    /**\n     * Check if the given list node is can be appended into current list chain\n     * @param list The list node to check\n     */\n    private canAppendToTail(list: HTMLOListElement) {\n        return this.lastNumber + 1 == list.start;\n    }\n\n    /**\n     * Append the given list node into this VListChain\n     * @param list The list node to append\n     * @param isAfterCurrentNode Whether this list is after current node\n     */\n    private append(list: HTMLOListElement, isAfterCurrentNode: boolean) {\n        this.applyChainName(list);\n        this.lastNumber = new VList(list).getLastItemNumber() || 0;\n\n        if (isAfterCurrentNode) {\n            list.dataset[AFTER_CURSOR_DATASET_NAME] = 'true';\n        } else {\n            this.lastNumberBeforeCursor = this.lastNumber;\n        }\n    }\n\n    private applyChainName(list: HTMLOListElement) {\n        list.dataset[CHAIN_DATASET_NAME] = this.name;\n    }\n\n    private getLists() {\n        return queryElements(\n            this.region.rootNode,\n            `ol[data-${CHAIN_DATASET_NAME}=${this.name}]`\n        ).filter(node => isNodeInRegion(this.region, node)) as HTMLOListElement[];\n    }\n}\n\nfunction createListChainName() {\n    return CHAIN_NAME_PREFIX + lastChainIndex++;\n}\n"]}