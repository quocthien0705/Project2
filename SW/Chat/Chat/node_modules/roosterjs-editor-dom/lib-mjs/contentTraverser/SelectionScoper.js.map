{"version":3,"file":"SelectionScoper.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts"],"names":[],"mappings":"AAAA,OAAO,qBAAqB,MAAM,wCAAwC,CAAC;AAC3E,OAAO,oBAAoB,MAAM,wCAAwC,CAAC;AAC1E,OAAO,QAAQ,MAAM,uBAAuB,CAAC;AAC7C,OAAO,EAAE,qBAAqB,EAAE,MAAM,+CAA+C,CAAC;AAItF;;;;;GAKG;AACH;IAMI;;;;OAIG;IACH,yBAAmB,QAAc,EAAE,KAAY;QAA5B,aAAQ,GAAR,QAAQ,CAAM;QARzB,eAAU,GAAwB,IAAI,CAAC;QACvC,gBAAW,GAAyB,IAAI,CAAC;QAQ7C,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,SAAS,EAAE,CAAC;QAClD,IAAI,CAAC,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,SAAS,EAAE,CAAC;IAClD,CAAC;IAED;;OAEG;IACI,8CAAoB,GAA3B;QACI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAClB,IAAI,CAAC,UAAU,GAAG,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SAC3E;QAED,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAC;IAED;;OAEG;IACI,+CAAqB,GAA5B;QACI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACnB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,iBAAiB,CACrC,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,CACnD,CAAC;SACL;QAED,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED;;;OAGG;IACI,wCAAc,GAArB,UAAsB,KAAmB;QACrC,IAAI,CAAC,KAAK,EAAE;YACR,OAAO,KAAK,CAAC;SAChB;QACD,IAAI,OAAO,GAAG,KAAK,CAAC;QACpB,IAAM,aAAa,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAClD,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YAC9B,OAAO,GAAG,CAAC,CAAC,aAAa,IAAI,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SAC5D;aAAM;YACH,IAAM,WAAW,GAAG,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAExE,gEAAgE;YAChE,+CAA+C;YAC/C,6CAA6C;YAC7C,wDAAwD;YACxD,OAAO;gBACH,CAAC,CAAC,aAAa;oBACf,CAAC,CAAC,WAAW;oBACb,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC;wBACxB,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC;wBACzB,CAAC,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;SACzE;QAED,OAAO,OAAO,CAAC;IACnB,CAAC;IAED;;;;OAIG;IACI,2CAAiB,GAAxB,UAAyB,MAA4B;QACjD,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YACzC,OAAO,IAAI,CAAC;SACf;QAED,gFAAgF;QAChF,IAAI,KAAK,GAAG,MAAM,CAAC,gBAAgB,EAAE,CAAC;QACtC,IAAI,GAAG,GAAG,MAAM,CAAC,cAAc,EAAE,CAAC;QAElC,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YACpD,OAAO,IAAI,CAAC;SACf;QAED,IAAI,YAAY,GAAG,KAAK,CAAC;QACzB,IAAI,UAAU,GAAG,KAAK,CAAC;QAEvB,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YAC3B,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YACnB,YAAY,GAAG,IAAI,CAAC;SACvB;QAED,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YACvB,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;YACf,UAAU,GAAG,IAAI,CAAC;SACrB;QAED,OAAO,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC;YAC3C,CAAC,CAAC,IAAI;YACN,CAAC,CAAC,YAAY,IAAI,UAAU;gBAC5B,CAAC,CAAC,IAAI,oBAAoB,CACpB,MAAM,EACN,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,EAChC,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS,CAC/B;gBACH,CAAC,CAAC,MAAM,CAAC;IACjB,CAAC;IACL,sBAAC;AAAD,CAAC,AA/GD,IA+GC","sourcesContent":["import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport type TraversingScoper from './TraversingScoper';\r\nimport type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement | null = null;\r\n    private startInline: InlineElement | null = null;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement | null {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement | null {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        const selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = !!selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            const selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                !!selStartBlock &&\r\n                !!selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement | null): InlineElement | null {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(\r\n                  inline,\r\n                  startPartial ? start : undefined,\r\n                  endPartial ? end : undefined\r\n              )\r\n            : inline;\r\n    }\r\n}\r\n"]}