{"version":3,"file":"ContentTraverser.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts"],"names":[],"mappings":"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","sourcesContent":["import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport { ContentPosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport type TraversingScoper from './TraversingScoper';\r\nimport type { CompatibleContentPosition } from 'roosterjs-editor-types/lib/compatibleTypes';\r\nimport type {\r\n    BlockElement,\r\n    IContentTraverser,\r\n    InlineElement,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meaning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser implements IContentTraverser {\r\n    private currentInline: InlineElement | null = null;\r\n    private currentBlock: BlockElement | null = null;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    private constructor(private scoper: TraversingScoper, private skipTags?: string[]) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBodyTraverser(\r\n        rootNode: Node,\r\n        startNode?: Node,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createSelectionTraverser(\r\n        rootNode: Node,\r\n        range: Range,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range), skipTags);\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition | CompatibleContentPosition = ContentPosition.SelectionStart,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement | null {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement | null {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement | null {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement | null {\r\n        const current = this.currentBlockElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        const leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext,\r\n            this.skipTags\r\n        );\r\n        const newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement | null {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement | null {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement | null {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement | null {\r\n        const current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement | null;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the trimming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement | null {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the other half of the inline unless it is no more\r\n        const result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode: Node | null = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n"]}