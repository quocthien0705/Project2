{"version":3,"file":"SelectionBlockScoper.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts"],"names":[],"mappings":"AAAA,OAAO,kBAAkB,MAAM,sCAAsC,CAAC;AACtE,OAAO,qBAAqB,MAAM,wCAAwC,CAAC;AAC3E,OAAO,sBAAsB,MAAM,0CAA0C,CAAC;AAC9E,OAAO,gBAAgB,MAAM,mCAAmC,CAAC;AACjE,OAAO,QAAQ,MAAM,uBAAuB,CAAC;AAC7C,OAAO,cAAc,MAAM,yBAAyB,CAAC;AAErD,OAAO,EAAE,qBAAqB,EAAE,MAAM,+CAA+C,CAAC;AAGtF,OAAO,EACH,qBAAqB,EACrB,oBAAoB,GACvB,MAAM,6CAA6C,CAAC;AAGrD;;;;;;GAMG;AACH;IAII;;;;;OAKG;IACH,8BACW,QAAc,EACrB,QAA8B,EACtB,SAAsD;QAFvD,aAAQ,GAAR,QAAQ,CAAM;QAEb,cAAS,GAAT,SAAS,CAA6C;QAE9D,IAAI,cAAc,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE;YACnC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;SAC1C;QAED,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;QACrC,IAAI,CAAC,KAAK,GAAG,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;IAC1E,CAAC;IAED;;OAEG;IACI,mDAAoB,GAA3B;QACI,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAED;;;;;OAKG;IACI,oDAAqB,GAA5B;QACI,IAAI,IAAI,CAAC,KAAK,EAAE;YACZ,QAAQ,IAAI,CAAC,SAAS,EAAE;gBACpB,mBAA2B;gBAC3B,iBAAyB;gBACzB;oBACI,OAAO,yCAAyC,CAC5C,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,SAAS,iBAAyB,CAC1C,CAAC;gBACN;oBACI,0FAA0F;oBAC1F,IAAM,WAAW,GAAG,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;oBACxE,OAAO,WAAW,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC;wBACrE,CAAC,CAAC,WAAW;wBACb,CAAC,CAAC,IAAI,kBAAkB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;aAC/D;SACJ;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACI,6CAAc,GAArB,UAAsB,YAA0B;QAC5C,OAAO,IAAI,CAAC,KAAK,IAAI,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IAChF,CAAC;IAED;;;;;OAKG;IACI,gDAAiB,GAAxB,UAAyB,aAA4B;QACjD,OAAO,IAAI,CAAC,KAAK,IAAI,aAAa,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;YACvF,CAAC,CAAC,aAAa;YACf,CAAC,CAAC,IAAI,CAAC;IACf,CAAC;IACL,2BAAC;AAAD,CAAC,AA7ED,IA6EC;;AAED;;;;GAIG;AACH,SAAS,yCAAyC,CAC9C,KAAmB,EACnB,OAAgB;IAEhB,IAAI,KAAK,YAAY,gBAAgB,EAAE;QACnC,IAAM,SAAS,GAAG,KAAK,CAAC,YAAY,EAAE,CAAC;QACvC,OAAO,OAAO,CAAC,CAAC,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;KACvF;SAAM;QACH,OAAO,sBAAsB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC,CAAC;KAC7F;AACL,CAAC","sourcesContent":["import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { ContentPosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport type TraversingScoper from './TraversingScoper';\r\nimport type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\nimport type { CompatibleContentPosition } from 'roosterjs-editor-types/lib/compatibleTypes';\r\n\r\n/**\r\n * @internal\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement | null;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition | CompatibleContentPosition\r\n    ) {\r\n        if (safeInstanceOf(position, 'Range')) {\r\n            position = Position.getStart(position);\r\n        }\r\n\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement | null {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragraph,\r\n     * the one after likely will point to inline in next paragraph which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement | null {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                case ContentPosition.DomEnd:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    const startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement | null {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement | null {\r\n    if (block instanceof NodeBlockElement) {\r\n        const blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n"]}