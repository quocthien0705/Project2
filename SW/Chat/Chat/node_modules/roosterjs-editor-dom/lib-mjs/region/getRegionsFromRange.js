var _a;
import { __read } from "tslib";
import contains from '../utils/contains';
import findClosestElementAncestor from '../utils/findClosestElementAncestor';
import Position from '../selection/Position';
import queryElements from '../utils/queryElements';
import { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';
var regionTypeData = (_a = {},
    _a[0 /* Table */] = {
        skipTags: ['TABLE'],
        outerSelector: 'table',
        innerSelector: 'td,th',
    },
    _a);
/**
 * Get regions impacted by the given range under the root node
 * @param root Root node to get regions from
 * @param range A selection range. Regions will be created according to this range. Each region will be
 * fully or partially covered by this range.
 * @param type Type of region. Currently we only support TABLE region.
 */
export default function getRegionsFromRange(root, range, type) {
    var _a;
    var regions = [];
    if (root && range) {
        var _b = regionTypeData[type], innerSelector = _b.innerSelector, skipTags = _b.skipTags;
        var boundaryTree = buildBoundaryTree(root, range, type);
        var start = findClosestElementAncestor(range.startContainer, root, innerSelector) || root;
        var end = findClosestElementAncestor(range.endContainer, root, innerSelector) || root;
        var creator = getRegionCreator(range, skipTags);
        _a = __read(iterateNodes(creator, boundaryTree, start, end), 1), regions = _a[0];
    }
    return regions.filter(function (r) { return !!r; });
}
/**
 * @internal export for test only
 */
export function getRegionCreator(fullRange, skipTags) {
    var fullSelectionStart = Position.getStart(fullRange).normalize();
    var fullSelectionEnd = Position.getEnd(fullRange).normalize();
    return function (rootNode, nodeBefore, nodeAfter) {
        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)
            ? {
                rootNode: rootNode,
                nodeBefore: nodeBefore,
                nodeAfter: nodeAfter,
                skipTags: skipTags,
                fullSelectionStart: fullSelectionStart,
                fullSelectionEnd: fullSelectionEnd,
            }
            : null;
    };
}
/**
 * Step 1: Build boundary tree
 * @param root Root node of the whole scope, normally this will be the root of editable scope
 * @param range Existing selected full range
 * @param type Type of region to create
 */
function buildBoundaryTree(root, range, type) {
    var allBoundaries = [{ innerNode: root, children: [] }];
    var _a = regionTypeData[type], outerSelector = _a.outerSelector, innerSelector = _a.innerSelector;
    var inSelectionOuterNode = queryElements(root, outerSelector, null /*callback*/, 2 /* InSelection */, range);
    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll
    // is in document order, which is what we expect. So we don't need to sort the result here.
    queryElements(root, innerSelector, function (thisInnerNode) {
        var thisOuterNode = findClosestElementAncestor(thisInnerNode, root, outerSelector);
        if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {
            var boundary = { innerNode: thisInnerNode, children: [] };
            for (var i = allBoundaries.length - 1; i >= 0; i--) {
                var _a = allBoundaries[i], innerNode = _a.innerNode, children = _a.children;
                if (contains(innerNode, thisOuterNode)) {
                    var child = children.filter(function (c) { return c.outerNode == thisOuterNode; })[0];
                    if (!child) {
                        child = { outerNode: thisOuterNode, boundaries: [] };
                        children.push(child);
                    }
                    child.boundaries.push(boundary);
                    break;
                }
            }
            allBoundaries.push(boundary);
        }
    }, 1 /* OnSelection */, range);
    return allBoundaries[0];
}
/**
 * Step 2: Recursively iterate all boundaries and create regions
 * @param creator A region creator function to help create region
 * @param boundary Current root boundary
 * @param start A node where full range start from. This may not be the direct node container of range.startContainer.
 * It is the nearest ancestor which satisfies the InnerSelector of the given region type
 * @param end A node where full range end from. This may not be the direct node container of range.endContainer.
 * It is the nearest ancestor which satisfies the InnerSelector of the given region type
 * @param started Whether we have already hit the start node
 */
function iterateNodes(creator, boundary, start, end, started) {
    var _a;
    started = started || boundary.innerNode == start;
    var ended = false;
    var children = boundary.children, innerNode = boundary.innerNode;
    var regions = [];
    if (children.length == 0) {
        var region = creator(innerNode);
        if (region) {
            regions.push(region);
        }
    }
    else {
        // Need to run one more time to add region after all children
        for (var i = 0; i <= children.length && !ended; i++) {
            var _b = children[i] || {}, outerNode = _b.outerNode, boundaries = _b.boundaries;
            var previousOuterNode = (_a = children[i - 1]) === null || _a === void 0 ? void 0 : _a.outerNode;
            if (started) {
                var region = creator(innerNode, previousOuterNode, outerNode);
                if (region) {
                    regions.push(region);
                }
            }
            boundaries === null || boundaries === void 0 ? void 0 : boundaries.forEach(function (child) {
                var _a;
                var newRegions;
                _a = __read(iterateNodes(creator, child, start, end, started), 3), newRegions = _a[0], started = _a[1], ended = _a[2];
                regions = regions.concat(newRegions);
            });
        }
    }
    return [regions, started, ended || innerNode == end];
}
/**
 * Check if the given nodes combination is valid to create a region.
 * A combination is valid when:
 * 1. Root node is not null and is not empty. And
 * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And
 * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be
 * node between them.
 * @param root Root node of region
 * @param nodeBefore The boundary node before the region under root
 * @param nodeAfter The boundary node after the region under root
 * @param skipTags Tags to skip
 */
function areNodesValid(root, nodeBefore, nodeAfter, skipTags) {
    if (!root) {
        return false;
    }
    else {
        var firstNodeOfRegion = nodeBefore && getNextLeafSibling(root, nodeBefore, skipTags);
        var lastNodeOfRegion = nodeAfter && getPreviousLeafSibling(root, nodeAfter, skipTags);
        var firstNodeValid = !nodeBefore || (contains(root, nodeBefore) && contains(root, firstNodeOfRegion));
        var lastNodeValid = !nodeAfter || (contains(root, nodeAfter) && contains(root, lastNodeOfRegion));
        var bothValid = !nodeBefore ||
            !nodeAfter ||
            (!contains(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&
                !contains(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&
                !contains(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&
                !contains(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));
        return firstNodeValid && lastNodeValid && bothValid;
    }
}
//# sourceMappingURL=getRegionsFromRange.js.map