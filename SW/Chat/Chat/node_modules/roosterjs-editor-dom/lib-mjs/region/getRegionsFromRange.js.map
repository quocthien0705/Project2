{"version":3,"file":"getRegionsFromRange.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/region/getRegionsFromRange.ts"],"names":[],"mappings":"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","sourcesContent":["import contains from '../utils/contains';\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { QueryScope, RegionType } from 'roosterjs-editor-types';\nimport type { Region } from 'roosterjs-editor-types';\nimport type { CompatibleRegionType } from 'roosterjs-editor-types/lib/compatibleTypes';\n\ninterface RegionTypeData {\n    /**\n     * Tags that child elements will be skipped\n     */\n    skipTags: string[];\n\n    /**\n     * Selector of outer node of a region\n     */\n    outerSelector: string;\n\n    /**\n     * Selector of inner node of a region\n     */\n    innerSelector: string;\n}\n\nconst regionTypeData: Record<RegionType, RegionTypeData> = {\n    [RegionType.Table]: {\n        skipTags: ['TABLE'],\n        outerSelector: 'table',\n        innerSelector: 'td,th',\n    },\n};\n\n/**\n * Get regions impacted by the given range under the root node\n * @param root Root node to get regions from\n * @param range A selection range. Regions will be created according to this range. Each region will be\n * fully or partially covered by this range.\n * @param type Type of region. Currently we only support TABLE region.\n */\nexport default function getRegionsFromRange(\n    root: HTMLElement,\n    range: Range,\n    type: RegionType | CompatibleRegionType\n): Region[] {\n    let regions: Region[] = [];\n    if (root && range) {\n        const { innerSelector, skipTags } = regionTypeData[type];\n        const boundaryTree = buildBoundaryTree(root, range, type);\n        const start = findClosestElementAncestor(range.startContainer, root, innerSelector) || root;\n        const end = findClosestElementAncestor(range.endContainer, root, innerSelector) || root;\n        const creator = getRegionCreator(range, skipTags);\n        [regions] = iterateNodes(creator, boundaryTree, start, end);\n    }\n\n    return regions.filter(r => !!r);\n}\n\n/**\n * @internal export for test only\n */\nexport function getRegionCreator(\n    fullRange: Range,\n    skipTags: string[]\n): (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region | null {\n    const fullSelectionStart = Position.getStart(fullRange).normalize();\n    const fullSelectionEnd = Position.getEnd(fullRange).normalize();\n    return (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => {\n        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)\n            ? {\n                  rootNode,\n                  nodeBefore,\n                  nodeAfter,\n                  skipTags,\n                  fullSelectionStart,\n                  fullSelectionEnd,\n              }\n            : null;\n    };\n}\n\n/**\n * This is a internal data structure used for build regions.\n * We firstly split the selection by some boundaries, then we can build region from these boundaries.\n */\ninterface Boundary {\n    /**\n     * inner node of this boundary\n     */\n    innerNode: HTMLElement;\n\n    /**\n     * Children of this boundary\n     */\n    children: {\n        /**\n         * Outer node of a boundary child\n         */\n        outerNode: Node;\n\n        /**\n         * Child boundaries\n         */\n        boundaries: Boundary[];\n    }[];\n}\n\n/**\n * Step 1: Build boundary tree\n * @param root Root node of the whole scope, normally this will be the root of editable scope\n * @param range Existing selected full range\n * @param type Type of region to create\n */\nfunction buildBoundaryTree(\n    root: HTMLElement,\n    range: Range,\n    type: RegionType | CompatibleRegionType\n): Boundary {\n    const allBoundaries: Boundary[] = [{ innerNode: root, children: [] }];\n    const { outerSelector, innerSelector } = regionTypeData[type];\n    const inSelectionOuterNode = queryElements(\n        root,\n        outerSelector,\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll\n    // is in document order, which is what we expect. So we don't need to sort the result here.\n    queryElements(\n        root,\n        innerSelector,\n        thisInnerNode => {\n            const thisOuterNode = findClosestElementAncestor(thisInnerNode, root, outerSelector);\n            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {\n                const boundary: Boundary = { innerNode: thisInnerNode, children: [] };\n\n                for (let i = allBoundaries.length - 1; i >= 0; i--) {\n                    const { innerNode, children } = allBoundaries[i];\n                    if (contains(innerNode, thisOuterNode)) {\n                        let child = children.filter(c => c.outerNode == thisOuterNode)[0];\n\n                        if (!child) {\n                            child = { outerNode: thisOuterNode, boundaries: [] };\n                            children.push(child);\n                        }\n\n                        child.boundaries.push(boundary);\n                        break;\n                    }\n                }\n                allBoundaries.push(boundary);\n            }\n        },\n        QueryScope.OnSelection,\n        range\n    );\n\n    return allBoundaries[0];\n}\n\n/**\n * Step 2: Recursively iterate all boundaries and create regions\n * @param creator A region creator function to help create region\n * @param boundary Current root boundary\n * @param start A node where full range start from. This may not be the direct node container of range.startContainer.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param end A node where full range end from. This may not be the direct node container of range.endContainer.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param started Whether we have already hit the start node\n */\nfunction iterateNodes(\n    creator: (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region | null,\n    boundary: Boundary,\n    start: Node,\n    end: Node,\n    started?: boolean\n): [Region[], boolean, boolean] {\n    started = started || boundary.innerNode == start;\n    let ended = false;\n    const { children, innerNode } = boundary;\n    let regions: Region[] = [];\n\n    if (children.length == 0) {\n        const region = creator(innerNode);\n        if (region) {\n            regions.push(region);\n        }\n    } else {\n        // Need to run one more time to add region after all children\n        for (let i = 0; i <= children.length && !ended; i++) {\n            const { outerNode, boundaries } = children[i] || {};\n            const previousOuterNode = children[i - 1]?.outerNode;\n            if (started) {\n                const region = creator(innerNode, previousOuterNode, outerNode);\n                if (region) {\n                    regions.push(region);\n                }\n            }\n\n            boundaries?.forEach(child => {\n                let newRegions: Region[];\n                [newRegions, started, ended] = iterateNodes(creator, child, start, end, started);\n                regions = regions.concat(newRegions);\n            });\n        }\n    }\n\n    return [regions, started, ended || innerNode == end];\n}\n\n/**\n * Check if the given nodes combination is valid to create a region.\n * A combination is valid when:\n * 1. Root node is not null and is not empty. And\n * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And\n * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be\n * node between them.\n * @param root Root node of region\n * @param nodeBefore The boundary node before the region under root\n * @param nodeAfter The boundary node after the region under root\n * @param skipTags Tags to skip\n */\nfunction areNodesValid(\n    root: Node,\n    nodeBefore: Node | undefined,\n    nodeAfter: Node | undefined,\n    skipTags: string[]\n) {\n    if (!root) {\n        return false;\n    } else {\n        const firstNodeOfRegion = nodeBefore && getNextLeafSibling(root, nodeBefore, skipTags);\n        const lastNodeOfRegion = nodeAfter && getPreviousLeafSibling(root, nodeAfter, skipTags);\n        const firstNodeValid =\n            !nodeBefore || (contains(root, nodeBefore) && contains(root, firstNodeOfRegion));\n        const lastNodeValid =\n            !nodeAfter || (contains(root, nodeAfter) && contains(root, lastNodeOfRegion));\n        const bothValid =\n            !nodeBefore ||\n            !nodeAfter ||\n            (!contains(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&\n                !contains(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));\n        return firstNodeValid && lastNodeValid && bothValid;\n    }\n}\n"]}