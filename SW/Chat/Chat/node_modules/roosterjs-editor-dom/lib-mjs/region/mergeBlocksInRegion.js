import { __assign } from "tslib";
import changeElementTag from '../utils/changeElementTag';
import contains from '../utils/contains';
import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';
import getPredefinedCssForElement from '../htmlSanitizer/getPredefinedCssForElement';
import getStyles from '../style/getStyles';
import isNodeInRegion from './isNodeInRegion';
import safeInstanceOf from '../utils/safeInstanceOf';
import setStyles from '../style/setStyles';
import { collapse } from '../utils/collapseNodes';
/**
 * Merge a BlockElement of given node after another node
 * @param region Region to operate in
 * @param refNode The node to merge after
 * @param targetNode The node of target block element
 */
export default function mergeBlocksInRegion(region, refNode, targetNode) {
    var _a, _b, _c;
    var block;
    if (!isNodeInRegion(region, refNode) ||
        !isNodeInRegion(region, targetNode) ||
        !(block = getBlockElementAtNode(region.rootNode, targetNode)) ||
        block.contains(refNode)) {
        return;
    }
    var blockRoot = block.collapseToSingleElement();
    var commonContainer = collapse(region.rootNode, blockRoot, refNode, false /*isStart*/, true /*canSplitParent*/);
    // Copy styles of parent nodes into blockRoot
    for (var node = blockRoot; contains(commonContainer, node);) {
        var parent_1 = node.parentNode;
        if (safeInstanceOf(parent_1, 'HTMLElement')) {
            var styles = __assign(__assign(__assign({}, (getPredefinedCssForElement(parent_1) || {})), getStyles(parent_1)), getStyles(blockRoot));
            setStyles(blockRoot, styles);
        }
        node = parent_1;
    }
    var nodeToRemove = null;
    var nodeToMerge = blockRoot.childNodes.length == 1 && blockRoot.attributes.length == 0
        ? blockRoot.firstChild
        : changeElementTag(blockRoot, 'SPAN');
    // Remove empty node
    for (var node = nodeToMerge; contains(commonContainer, node) && ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes.length) == 1; node = node.parentNode) {
        // If the only child is the one which is about to be removed, this node should also be removed
        nodeToRemove = node.parentNode;
    }
    // Finally, merge blocks, and remove empty nodes
    (_b = refNode.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(nodeToMerge, refNode.nextSibling);
    (_c = nodeToRemove === null || nodeToRemove === void 0 ? void 0 : nodeToRemove.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(nodeToRemove);
}
//# sourceMappingURL=mergeBlocksInRegion.js.map