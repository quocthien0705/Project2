{"version":3,"file":"SelectionScoper.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts"],"names":[],"mappings":"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","sourcesContent":["import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport type TraversingScoper from './TraversingScoper';\r\nimport type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement | null = null;\r\n    private startInline: InlineElement | null = null;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement | null {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement | null {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        const selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = !!selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            const selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                !!selStartBlock &&\r\n                !!selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement | null): InlineElement | null {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(\r\n                  inline,\r\n                  startPartial ? start : undefined,\r\n                  endPartial ? end : undefined\r\n              )\r\n            : inline;\r\n    }\r\n}\r\n"]}