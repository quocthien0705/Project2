{"version":3,"file":"PositionContentSearcher.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts"],"names":[],"mappings":";;;IASA,0DAA0D;IAC1D,kBAAkB;IAClB,kCAAkC;IAClC,2BAA2B;IAC3B,yDAAyD;IACzD,IAAM,gBAAgB,GAAG,qDAAqD,CAAC;IAE/E;;OAEG;IACH;QAyBI;;;;WAIG;QACH,iCAAoB,QAAc,EAAU,QAAsB;YAA9C,aAAQ,GAAR,QAAQ,CAAM;YAAU,aAAQ,GAAR,QAAQ,CAAc;YA7BlE,4DAA4D;YACpD,SAAI,GAAG,EAAE,CAAC;YAElB,kCAAkC;YAC1B,SAAI,GAAW,EAAE,CAAC;YAE1B,qCAAqC;YAC7B,iBAAY,GAAyB,IAAI,CAAC;YAElD,oCAAoC;YAC5B,gBAAW,GAAyB,IAAI,CAAC;YAEjD,mDAAmD;YAC3C,cAAS,GAA6B,IAAI,CAAC;YAEnD,iCAAiC;YACzB,uBAAkB,GAAY,KAAK,CAAC;YAE5C,iEAAiE;YACzD,mBAAc,GAAoB,EAAE,CAAC;YAE7C,wCAAwC;YAChC,gCAA2B,GAAyB,IAAI,CAAC;QAOI,CAAC;QAEtE;;;;WAIG;QACI,+CAAa,GAApB;YAAA,iBAMC;YALG,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gBACZ,IAAI,CAAC,QAAQ,CAAC,cAAM,OAAA,KAAI,CAAC,IAAI,EAAT,CAAS,CAAC,CAAC;aAClC;YAED,OAAO,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC;QAC3B,CAAC;QAED;;;WAGG;QACI,wDAAsB,GAA7B;YACI,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;gBACpB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;aACvB;YAED,OAAO,IAAI,CAAC,YAAY,CAAC;QAC7B,CAAC;QAED;;;WAGG;QACI,uDAAqB,GAA5B;YACI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;gBACnB,IAAI,CAAC,WAAW,GAAG,0BAAgB,CAAC,oBAAoB,CACpD,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,QAAQ,CAChB,CAAC,oBAAoB,CAAC;aAC1B;YAED,OAAO,IAAI,CAAC,WAAW,CAAC;QAC5B,CAAC;QAED;;;;;;;WAOG;QACI,oDAAkB,GAAzB,UAA0B,MAAc;YAAxC,iBAMC;YALG,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,MAAM,EAAE;gBAC3B,IAAI,CAAC,QAAQ,CAAC,cAAM,OAAA,KAAI,CAAC,IAAI,CAAC,MAAM,IAAI,MAAM,EAA1B,CAA0B,CAAC,CAAC;aACnD;YAED,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC;QACpE,CAAC;QAED;;;;;WAKG;QACI,kDAAgB,GAAvB,UAAwB,IAAY,EAAE,UAAmB;YACrD,IAAI,CAAC,IAAI,EAAE;gBACP,OAAO,IAAI,CAAC;aACf;YAED,IAAI,aAAa,GAAwB,IAAI,CAAC;YAC9C,IAAI,WAAW,GAAwB,IAAI,CAAC;YAC5C,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YAEhC,IAAI,CAAC,wBAAwB,CAAC,UAAA,UAAU;gBACpC,IAAM,WAAW,GAAG,UAAU,CAAC,cAAc,EAAE,IAAI,EAAE,CAAC;gBACtD,IAAI,SAAS,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;gBACvC,OAAO,SAAS,IAAI,CAAC,IAAI,SAAS,IAAI,CAAC,EAAE,SAAS,EAAE,EAAE;oBAClD,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,WAAW,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;wBACjE,SAAS,EAAE,CAAC;wBAEZ,0DAA0D;wBAC1D,IAAI,CAAC,WAAW,EAAE;4BACd,WAAW,GAAG,UAAU,CAAC,gBAAgB,EAAE,CAAC,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;yBACnE;qBACJ;yBAAM,IAAI,UAAU,IAAI,WAAW,EAAE;wBAClC,wFAAwF;wBACxF,OAAO,IAAI,CAAC;qBACf;iBACJ;gBAED,4DAA4D;gBAC5D,IAAI,SAAS,IAAI,CAAC,CAAC,EAAE;oBACjB,aAAa,GAAG,UAAU,CAAC,gBAAgB,EAAE,CAAC,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;oBAClE,OAAO,IAAI,CAAC;iBACf;gBAED,OAAO,KAAK,CAAC;YACjB,CAAC,CAAC,CAAC;YAEH,OAAO,aAAa,IAAI,WAAW,IAAI,IAAA,qBAAW,EAAC,aAAa,EAAE,WAAW,CAAC,CAAC;QACnF,CAAC;QAED;;;;;;;WAOG;QACI,0DAAwB,GAA/B,UAAgC,QAAmD;YAC/E,yCAAyC;YACzC,0EAA0E;YAC1E,iEAAiE;YACjE,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBACrC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;aAC3B;QACL,CAAC;QAED;;;WAGG;QACI,gEAA8B,GAArC;YAAA,iBAMC;YALG,IAAI,CAAC,IAAI,CAAC,2BAA2B,EAAE;gBACnC,IAAI,CAAC,QAAQ,CAAC,cAAM,OAAA,KAAI,CAAC,2BAA2B,EAAhC,CAAgC,CAAC,CAAC;aACzD;YAED,OAAO,IAAI,CAAC,2BAA2B,CAAC;QAC5C,CAAC;QAED;;WAEG;QACK,0CAAQ,GAAhB,UAAiB,QAAwD;YACrE,IAAI,CAAC,SAAS;gBACV,IAAI,CAAC,SAAS,IAAI,0BAAgB,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YAE1F,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,kBAAkB,EAAE;gBAC5C,OAAO;aACV;YAED,IAAI,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,wBAAwB,EAAE,CAAC;YAC/D,OAAO,CAAC,IAAI,CAAC,kBAAkB,EAAE;gBAC7B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,IAAI,cAAc,CAAC;gBAExD,IAAI,cAAc,IAAI,cAAc,CAAC,sBAAsB,EAAE,EAAE;oBAC3D,IAAM,WAAW,GAAG,cAAc,CAAC,cAAc,EAAE,CAAC;oBAEpD,wDAAwD;oBACxD,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;wBACZ,+FAA+F;wBAC/F,6DAA6D;wBAC7D,IAAM,OAAO,GAAG,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;wBACnD,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,IAAI,CAAC,EAAE;4BAChC,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;yBACtC;qBACJ;oBAED,IAAI,CAAC,IAAI,GAAG,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC;oBACpC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;oBAEzC,iCAAiC;oBACjC,IAAI,QAAQ,IAAI,QAAQ,CAAC,cAAc,CAAC,EAAE;wBACtC,MAAM;qBACT;iBACJ;qBAAM;oBACH,IAAI,CAAC,2BAA2B,GAAG,cAAc,CAAC;oBAClD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;oBAC/B,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;wBACZ,8GAA8G;wBAC9G,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;qBACzB;oBAED,mFAAmF;oBACnF,wFAAwF;oBACxF,mFAAmF;oBACnF,MAAM;iBACT;gBAED,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,wBAAwB,EAAE,CAAC;aAC9D;QACL,CAAC;QACL,8BAAC;IAAD,CAAC,AArND,IAqNC","sourcesContent":["import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport type {\r\n    IContentTraverser,\r\n    InlineElement,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher implements IPositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string = '';\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement | null = null;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement | null = null;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: IContentTraverser | null = null;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean = false;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement | null = null;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word || '';\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement | null {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement | null {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determines the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range | null {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition | null = null;\r\n        let endPosition: NodePosition | null = null;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            const nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textual inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement | null {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: null | ((inlineElement: InlineElement) => any)) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                const textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    const matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n"]}