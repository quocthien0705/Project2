{"version":3,"file":"ContentTraverser.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts"],"names":[],"mappings":"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","sourcesContent":["import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport { ContentPosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport type TraversingScoper from './TraversingScoper';\r\nimport type { CompatibleContentPosition } from 'roosterjs-editor-types/lib/compatibleTypes';\r\nimport type {\r\n    BlockElement,\r\n    IContentTraverser,\r\n    InlineElement,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meaning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser implements IContentTraverser {\r\n    private currentInline: InlineElement | null = null;\r\n    private currentBlock: BlockElement | null = null;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    private constructor(private scoper: TraversingScoper, private skipTags?: string[]) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBodyTraverser(\r\n        rootNode: Node,\r\n        startNode?: Node,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createSelectionTraverser(\r\n        rootNode: Node,\r\n        range: Range,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range), skipTags);\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition | CompatibleContentPosition = ContentPosition.SelectionStart,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement | null {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement | null {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement | null {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement | null {\r\n        const current = this.currentBlockElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        const leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext,\r\n            this.skipTags\r\n        );\r\n        const newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement | null {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement | null {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement | null {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement | null {\r\n        const current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement | null;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the trimming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement | null {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the other half of the inline unless it is no more\r\n        const result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode: Node | null = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n"]}