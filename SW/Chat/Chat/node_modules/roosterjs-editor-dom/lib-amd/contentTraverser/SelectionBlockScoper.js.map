{"version":3,"file":"SelectionBlockScoper.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts"],"names":[],"mappings":";;;IAgBA;;;;;;OAMG;IACH;QAII;;;;;WAKG;QACH,8BACW,QAAc,EACrB,QAA8B,EACtB,SAAsD;YAFvD,aAAQ,GAAR,QAAQ,CAAM;YAEb,cAAS,GAAT,SAAS,CAA6C;YAE9D,IAAI,IAAA,wBAAc,EAAC,QAAQ,EAAE,OAAO,CAAC,EAAE;gBACnC,QAAQ,GAAG,kBAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;aAC1C;YAED,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;YACrC,IAAI,CAAC,KAAK,GAAG,IAAA,+BAAqB,EAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC1E,CAAC;QAED;;WAEG;QACI,mDAAoB,GAA3B;YACI,OAAO,IAAI,CAAC,KAAK,CAAC;QACtB,CAAC;QAED;;;;;WAKG;QACI,oDAAqB,GAA5B;YACI,IAAI,IAAI,CAAC,KAAK,EAAE;gBACZ,QAAQ,IAAI,CAAC,SAAS,EAAE;oBACpB,mBAA2B;oBAC3B,iBAAyB;oBACzB;wBACI,OAAO,yCAAyC,CAC5C,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,SAAS,iBAAyB,CAC1C,CAAC;oBACN;wBACI,0FAA0F;wBAC1F,IAAM,WAAW,GAAG,IAAA,mDAAqB,EAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;wBACxE,OAAO,WAAW,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC;4BACrE,CAAC,CAAC,WAAW;4BACb,CAAC,CAAC,IAAI,4BAAkB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;iBAC/D;aACJ;YAED,OAAO,IAAI,CAAC;QAChB,CAAC;QAED;;;WAGG;QACI,6CAAc,GAArB,UAAsB,YAA0B;YAC5C,OAAO,IAAI,CAAC,KAAK,IAAI,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QAChF,CAAC;QAED;;;;;WAKG;QACI,gDAAiB,GAAxB,UAAyB,aAA4B;YACjD,OAAO,IAAI,CAAC,KAAK,IAAI,aAAa,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;gBACvF,CAAC,CAAC,aAAa;gBACf,CAAC,CAAC,IAAI,CAAC;QACf,CAAC;QACL,2BAAC;IAAD,CAAC,AA7ED,IA6EC;;IAED;;;;OAIG;IACH,SAAS,yCAAyC,CAC9C,KAAmB,EACnB,OAAgB;QAEhB,IAAI,KAAK,YAAY,0BAAgB,EAAE;YACnC,IAAM,SAAS,GAAG,KAAK,CAAC,YAAY,EAAE,CAAC;YACvC,OAAO,OAAO,CAAC,CAAC,CAAC,IAAA,iDAAqB,EAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAA,gDAAoB,EAAC,SAAS,CAAC,CAAC;SACvF;aAAM;YACH,OAAO,IAAA,gCAAsB,EAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC,CAAC;SAC7F;IACL,CAAC","sourcesContent":["import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { ContentPosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport type TraversingScoper from './TraversingScoper';\r\nimport type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\nimport type { CompatibleContentPosition } from 'roosterjs-editor-types/lib/compatibleTypes';\r\n\r\n/**\r\n * @internal\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement | null;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition | CompatibleContentPosition\r\n    ) {\r\n        if (safeInstanceOf(position, 'Range')) {\r\n            position = Position.getStart(position);\r\n        }\r\n\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement | null {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragraph,\r\n     * the one after likely will point to inline in next paragraph which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement | null {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                case ContentPosition.DomEnd:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    const startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement | null {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement | null {\r\n    if (block instanceof NodeBlockElement) {\r\n        const blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n"]}