define(["require", "exports", "tslib", "./applyTableFormat", "../utils/getTagOfNode", "../utils/moveChildNodes", "../utils/normalizeRect", "../utils/safeInstanceOf", "../jsUtils/toArray", "./tableCellInfo", "./tableFormatInfo", "../metadata/metadata"], function (require, exports, tslib_1, applyTableFormat_1, getTagOfNode_1, moveChildNodes_1, normalizeRect_1, safeInstanceOf_1, toArray_1, tableCellInfo_1, tableFormatInfo_1, metadata_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEFAULT_FORMAT = {
        topBorderColor: '#ABABAB',
        bottomBorderColor: '#ABABAB',
        verticalBorderColor: '#ABABAB',
        hasHeaderRow: false,
        hasFirstColumn: false,
        hasBandedRows: false,
        hasBandedColumns: false,
        bgColorEven: null,
        bgColorOdd: '#ABABAB20',
        headerRowColor: '#ABABAB',
        tableBorderFormat: 0 /* DEFAULT */,
        keepCellShade: false,
        verticalAlign: null,
    };
    /**
     * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells
     */
    var VTable = /** @class */ (function () {
        /**
         * Create a new instance of VTable object using HTML TABLE or TD node
         * @param node The HTML Table or TD node
         * @param normalizeSize Whether table size needs to be normalized
         * @param zoomScale When the table is under a zoomed container, pass in the zoom scale here
         */
        function VTable(node, normalizeSize, zoomScale) {
            var _this = this;
            /**
             * Virtual cells
             */
            this.cells = null;
            /**
             * Current format of the table
             */
            this.formatInfo = null;
            this.trs = [];
            this.tableSelection = null;
            this.table = (0, safeInstanceOf_1.default)(node, 'HTMLTableElement') ? node : getTableFromTd(node);
            if (this.table) {
                var currentTd_1 = (0, safeInstanceOf_1.default)(node, 'HTMLTableElement') ? null : node;
                var trs = (0, toArray_1.default)(this.table.rows);
                this.cells = trs.map(function (row) { return []; });
                trs.forEach(function (tr, rowIndex) {
                    var _a;
                    _this.trs[rowIndex % 2] = tr;
                    for (var sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {
                        // Skip the cells which already initialized
                        for (; _this.cells[rowIndex][targetCol]; targetCol++) { }
                        var td = tr.cells[sourceCol];
                        if (td == currentTd_1) {
                            _this.col = targetCol;
                            _this.row = rowIndex;
                        }
                        for (var colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {
                            for (var rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {
                                var hasTd = colSpan + rowSpan == 0;
                                var rect = td.getBoundingClientRect();
                                if ((_a = _this.cells) === null || _a === void 0 ? void 0 : _a[rowIndex + rowSpan]) {
                                    _this.cells[rowIndex + rowSpan][targetCol] = {
                                        td: hasTd ? td : null,
                                        spanLeft: colSpan > 0,
                                        spanAbove: rowSpan > 0,
                                        width: hasTd ? rect.width : undefined,
                                        height: hasTd ? rect.height : undefined,
                                    };
                                }
                            }
                        }
                    }
                    for (var col = 0; col < _this.cells[rowIndex].length; col++) {
                        if (!_this.cells[rowIndex][col]) {
                            _this.cells[rowIndex][col] = {
                                td: null,
                                spanLeft: false,
                                spanAbove: false,
                                width: undefined,
                                height: undefined,
                            };
                        }
                    }
                });
                this.formatInfo = (0, tableFormatInfo_1.getTableFormatInfo)(this.table);
                if (normalizeSize) {
                    this.normalizeSize(typeof zoomScale == 'number' ? function (n) { return n / zoomScale; } : zoomScale);
                }
            }
        }
        Object.defineProperty(VTable.prototype, "selection", {
            /**
             * Selected range of cells with the coordinates of the first and last cell selected.
             */
            get: function () {
                return this.tableSelection || null;
            },
            set: function (value) {
                if (value) {
                    var firstCell = value.firstCell;
                    this.row = firstCell === null || firstCell === void 0 ? void 0 : firstCell.y;
                    this.col = firstCell === null || firstCell === void 0 ? void 0 : firstCell.x;
                }
                this.tableSelection = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Write the virtual table back to DOM tree to represent the change of VTable
         * @param skipApplyFormat Do not reapply table format when write back. Only use this parameter when you are pretty sure there is no format or table structure change during the process.
         * @param darkColorHandler An object to handle dark background colors, if not passed the cell background color will not be set
         */
        VTable.prototype.writeBack = function (skipApplyFormat, darkColorHandler) {
            var _this = this;
            var _a;
            if (this.cells) {
                (0, moveChildNodes_1.default)(this.table);
                this.cells.forEach(function (row, r) {
                    var tr = cloneNode(_this.trs[r % 2] || _this.trs[0]);
                    if (tr) {
                        _this.table.appendChild(tr);
                        row.forEach(function (cell, c) {
                            if (cell.td) {
                                _this.recalculateSpans(r, c);
                                _this.recalculateCellHeight(cell.td);
                                tr.appendChild(cell.td);
                            }
                        });
                    }
                });
                if (this.formatInfo && !skipApplyFormat) {
                    (0, tableFormatInfo_1.saveTableInfo)(this.table, this.formatInfo);
                    (0, applyTableFormat_1.default)(this.table, this.cells, this.formatInfo, darkColorHandler);
                }
            }
            else if (this.table) {
                (_a = this.table.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.table);
            }
        };
        VTable.prototype.recalculateCellHeight = function (td) {
            if (this.isEmptyCell(td) && td.rowSpan > 1) {
                for (var i = 1; i < td.rowSpan; i++) {
                    var br = document.createElement('br');
                    td.appendChild(br);
                }
            }
        };
        /**
         * Apply the given table format to this virtual table
         * @param format Table format to apply
         */
        VTable.prototype.applyFormat = function (format) {
            if (!this.table) {
                return;
            }
            this.formatInfo = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, DEFAULT_FORMAT), (this.formatInfo || {})), (format || {}));
            if (!this.formatInfo.keepCellShade) {
                this.deleteCellShadeDataset(this.cells);
            }
        };
        /**
         * Remove the cellShade dataset to apply a new style format at the cell.
         * @param cells
         */
        VTable.prototype.deleteCellShadeDataset = function (cells) {
            cells === null || cells === void 0 ? void 0 : cells.forEach(function (row) {
                row.forEach(function (cell) {
                    if (cell.td) {
                        (0, metadata_1.removeMetadata)(cell.td, 'bgColorOverride');
                    }
                });
            });
        };
        /**
         * Edit table with given operation.
         * @param operation Table operation
         */
        VTable.prototype.edit = function (operation) {
            var _this = this;
            var _a, _b;
            if (!this.table || !this.cells || this.row === undefined || this.col == undefined) {
                return;
            }
            var currentRow = this.cells[this.row];
            var currentCell = currentRow[this.col];
            var firstRow = this.selection ? this.selection.firstCell.y : this.row;
            var lastRow = this.selection ? this.selection.lastCell.y : this.row;
            var firstColumn = this.selection ? this.selection.firstCell.x : this.col;
            var lastColumn = this.selection ? this.selection.lastCell.x : this.col;
            switch (operation) {
                case 0 /* InsertAbove */:
                    for (var i = firstRow; i <= lastRow; i++) {
                        this.cells.splice(firstRow, 0, currentRow.map(cloneCell));
                    }
                    break;
                case 1 /* InsertBelow */:
                    var _loop_1 = function (i) {
                        var newRow = lastRow + this_1.countSpanAbove(lastRow, this_1.col);
                        this_1.cells.splice(newRow, 0, this_1.cells[newRow - 1].map(function (cell, colIndex) {
                            var nextCell = _this.getCell(newRow, colIndex);
                            if (nextCell.spanAbove) {
                                return cloneCell(nextCell);
                            }
                            else if (cell.spanLeft) {
                                var newCell = cloneCell(cell);
                                newCell.spanAbove = false;
                                return newCell;
                            }
                            else {
                                return {
                                    td: cloneNode(_this.getTd(_this.row, colIndex)),
                                };
                            }
                        }));
                    };
                    var this_1 = this;
                    for (var i = firstRow; i <= lastRow; i++) {
                        _loop_1(i);
                    }
                    break;
                case 2 /* InsertLeft */:
                    var _loop_2 = function (i) {
                        this_2.forEachCellOfCurrentColumn(function (cell, row) {
                            row.splice(i, 0, cloneCell(cell));
                        });
                    };
                    var this_2 = this;
                    for (var i = firstColumn; i <= lastColumn; i++) {
                        _loop_2(i);
                    }
                    break;
                case 3 /* InsertRight */:
                    var _loop_3 = function (i) {
                        var newCol = lastColumn + this_3.countSpanLeft(this_3.row, lastColumn);
                        this_3.forEachCellOfColumn(newCol - 1, function (cell, row, i) {
                            var nextCell = _this.getCell(i, newCol);
                            var newCell;
                            if (nextCell.spanLeft) {
                                newCell = cloneCell(nextCell);
                            }
                            else if (cell.spanAbove) {
                                newCell = cloneCell(cell);
                                newCell.spanLeft = false;
                            }
                            else {
                                newCell = {
                                    td: cloneNode(_this.getTd(i, _this.col)),
                                };
                            }
                            row.splice(newCol, 0, newCell);
                        });
                    };
                    var this_3 = this;
                    for (var i = firstColumn; i <= lastColumn; i++) {
                        _loop_3(i);
                    }
                    break;
                case 6 /* DeleteRow */:
                    var _loop_4 = function (rowIndex) {
                        this_4.forEachCellOfRow(rowIndex, function (cell, i) {
                            var nextCell = _this.getCell(rowIndex + 1, i);
                            if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {
                                nextCell.td = cell.td;
                            }
                        });
                    };
                    var this_4 = this;
                    for (var rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {
                        _loop_4(rowIndex);
                    }
                    var removedRows = this.selection
                        ? this.selection.lastCell.y - this.selection.firstCell.y
                        : 0;
                    this.cells.splice(firstRow, removedRows + 1);
                    if (this.cells.length === 0) {
                        this.cells = null;
                    }
                    break;
                case 5 /* DeleteColumn */:
                    var deletedColumns_1 = 0;
                    var _loop_5 = function (colIndex) {
                        this_5.forEachCellOfColumn(colIndex, function (cell, row, i) {
                            var nextCell = _this.getCell(i, colIndex + 1);
                            if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {
                                nextCell.td = cell.td;
                            }
                            var removedColumns = _this.selection
                                ? colIndex - deletedColumns_1
                                : _this.col;
                            row.splice(removedColumns, 1);
                        });
                        deletedColumns_1++;
                    };
                    var this_5 = this;
                    for (var colIndex = firstColumn; colIndex <= lastColumn; colIndex++) {
                        _loop_5(colIndex);
                    }
                    if (((_a = this.cells) === null || _a === void 0 ? void 0 : _a.length) === 0 || ((_b = this.cells) === null || _b === void 0 ? void 0 : _b.every(function (row) { return row.length === 0; }))) {
                        this.cells = null;
                    }
                    break;
                case 7 /* MergeAbove */:
                case 8 /* MergeBelow */:
                    var rowStep = operation == 7 /* MergeAbove */ ? -1 : 1;
                    for (var rowIndex = this.row + rowStep; rowIndex >= 0 && rowIndex < this.cells.length; rowIndex += rowStep) {
                        var cell = this.getCell(rowIndex, this.col);
                        if (cell.td && !cell.spanAbove) {
                            var aboveCell = rowIndex < this.row ? cell : currentCell;
                            var belowCell = rowIndex < this.row ? currentCell : cell;
                            this.mergeCells(aboveCell, belowCell);
                            break;
                        }
                    }
                    break;
                case 9 /* MergeLeft */:
                case 10 /* MergeRight */:
                    var colStep = operation == 9 /* MergeLeft */ ? -1 : 1;
                    for (var colIndex = this.col + colStep; colIndex >= 0 && colIndex < this.cells[this.row].length; colIndex += colStep) {
                        var cell = this.getCell(this.row, colIndex);
                        if (cell.td && !cell.spanLeft) {
                            var leftCell = colIndex < this.col ? cell : currentCell;
                            var rightCell = colIndex < this.col ? currentCell : cell;
                            this.mergeCells(leftCell, rightCell, true /** horizontally */);
                            break;
                        }
                    }
                    break;
                case 11 /* MergeCells */:
                    for (var colIndex = firstColumn; colIndex <= lastColumn; colIndex++) {
                        for (var rowIndex = firstRow + 1; rowIndex <= lastRow; rowIndex++) {
                            var cell = this.getCell(firstRow, colIndex);
                            var nextCellBelow = this.getCell(rowIndex, colIndex);
                            this.mergeCells(cell, nextCellBelow);
                        }
                    }
                    for (var colIndex = firstColumn + 1; colIndex <= lastColumn; colIndex++) {
                        var cell = this.getCell(firstRow, firstColumn);
                        var nextCellRight = this.getCell(firstRow, colIndex);
                        this.mergeCells(cell, nextCellRight, true /** horizontally */);
                    }
                    break;
                case 4 /* DeleteTable */:
                    this.cells = null;
                    break;
                case 13 /* SplitVertically */:
                    if (currentCell.td && currentCell.td.rowSpan > 1) {
                        this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);
                    }
                    else {
                        var splitRow = currentRow.map(function (cell) {
                            return {
                                td: cell == currentCell ? cloneNode(cell.td) : null,
                                spanAbove: cell != currentCell,
                                spanLeft: cell.spanLeft,
                            };
                        });
                        this.cells.splice(this.row + 1, 0, splitRow);
                    }
                    break;
                case 12 /* SplitHorizontally */:
                    if (currentCell.td && currentCell.td.colSpan > 1) {
                        this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);
                    }
                    else {
                        this.forEachCellOfCurrentColumn(function (cell, row) {
                            row.splice(_this.col + 1, 0, {
                                td: row == currentRow ? cloneNode(cell.td) : null,
                                spanAbove: cell.spanAbove,
                                spanLeft: row != currentRow,
                            });
                        });
                    }
                    break;
                case 14 /* AlignCenter */:
                    this.table.style.marginLeft = 'auto';
                    this.table.style.marginRight = 'auto';
                    break;
                case 15 /* AlignLeft */:
                    this.table.style.marginLeft = '';
                    this.table.style.marginRight = 'auto';
                    break;
                case 16 /* AlignRight */:
                    this.table.style.marginLeft = 'auto';
                    this.table.style.marginRight = '';
                    break;
                case 18 /* AlignCellCenter */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'center');
                    break;
                case 17 /* AlignCellLeft */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'left');
                    break;
                case 19 /* AlignCellRight */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'right');
                    break;
                case 20 /* AlignCellTop */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'top', true /** isVertical */);
                    break;
                case 21 /* AlignCellMiddle */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'middle', true /** isVertical */);
                    break;
                case 22 /* AlignCellBottom */:
                    this.setAlignmentToSelectedCells(firstRow, lastRow, firstColumn, lastColumn, 'bottom', true /** isVertical */);
                    break;
            }
        };
        VTable.prototype.setAlignmentToSelectedCells = function (firstRow, lastRow, firstColumn, lastColumn, alignmentType, isVertical) {
            var _a, _b;
            for (var i = firstRow; i <= lastRow; i++) {
                for (var j = firstColumn; j <= lastColumn; j++) {
                    if (this.cells) {
                        var cell = this.cells[i][j].td;
                        if (isVertical && cell) {
                            (_a = cell.style) === null || _a === void 0 ? void 0 : _a.setProperty('vertical-align', alignmentType);
                            var meta = (0, tableCellInfo_1.getTableCellMetadata)(cell);
                            (0, tableCellInfo_1.saveTableCellMetadata)(cell, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, meta), { vAlignOverride: true }));
                        }
                        else if (cell) {
                            (_b = cell.style) === null || _b === void 0 ? void 0 : _b.setProperty('text-align', alignmentType);
                        }
                    }
                }
            }
        };
        VTable.prototype.mergeCells = function (cell, nextCell, horizontally) {
            var _a, _b, _c, _d;
            var checkSpans = horizontally
                ? ((_a = cell.td) === null || _a === void 0 ? void 0 : _a.rowSpan) === ((_b = nextCell.td) === null || _b === void 0 ? void 0 : _b.rowSpan) && !cell.spanLeft
                : ((_c = cell.td) === null || _c === void 0 ? void 0 : _c.colSpan) === ((_d = nextCell.td) === null || _d === void 0 ? void 0 : _d.colSpan) && !cell.spanAbove;
            if (cell.td && nextCell.td && checkSpans) {
                this.mergeCellContents(cell.td, nextCell.td);
                nextCell.td = null;
                if (horizontally) {
                    nextCell.spanLeft = true;
                }
                else {
                    nextCell.spanAbove = true;
                }
            }
        };
        VTable.prototype.isEmptyCell = function (td) {
            return td.childElementCount === 1 && (0, getTagOfNode_1.default)(td.firstChild) === 'BR';
        };
        VTable.prototype.mergeCellContents = function (cellTd, nextCellTd) {
            if (this.isEmptyCell(nextCellTd)) {
                (0, moveChildNodes_1.default)(cellTd, nextCellTd, false /*keepExistingChildren*/);
            }
            else {
                var br = document.createElement('br');
                cellTd.appendChild(br);
                (0, moveChildNodes_1.default)(cellTd, nextCellTd, true /*keepExistingChildren*/);
            }
        };
        /**
         * Loop each cell of current column and invoke a callback function
         * @param callback The callback function to invoke
         */
        VTable.prototype.forEachCellOfCurrentColumn = function (callback) {
            this.forEachCellOfColumn(this.col, callback);
        };
        /**
         * Loop each table cell and get all the cells that share the same border from one side
         * The result is an array of table cell elements
         * @param borderPos The position of the border
         * @param getLeftCells Get left-hand-side or right-hand-side cells of the border
         *
         * Example, consider having a 3 by 4 table as below with merged and split cells
         *
         *     | 1 | 4 | 7 | 8 |
         *     |   5   |   9   |
         *     |   3   |   10  |
         *
         *  input => borderPos: the 3rd border, getLeftCells: true
         *  output => [4, 5, 3]
         *
         *  input => borderPos: the 3rd border, getLeftCells: false
         *  output => [7, 9, 10]
         *
         *  input => borderPos: the 2nd border, getLeftCells: true
         *  output => [1]
         *
         *  input => borderPos: the 2nd border, getLeftCells: false
         *  output => [4]
         */
        VTable.prototype.getCellsWithBorder = function (borderPos, getLeftCells) {
            var cells = [];
            for (var i = 0; this.cells && i < this.cells.length; i++) {
                for (var j = 0; j < this.cells[i].length; j++) {
                    var cell = this.getCell(i, j);
                    if (cell.td) {
                        var cellRect = (0, normalizeRect_1.default)(cell.td.getBoundingClientRect());
                        if (cellRect) {
                            var found = false;
                            if (getLeftCells) {
                                if (cellRect.right == borderPos) {
                                    found = true;
                                    cells.push(cell.td);
                                }
                                else if (found) {
                                    break;
                                }
                            }
                            else {
                                if (cellRect.left == borderPos) {
                                    found = true;
                                    cells.push(cell.td);
                                }
                                else if (found) {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            return cells;
        };
        /**
         * Loop each cell of current row and invoke a callback function
         * @param callback The callback function to invoke
         */
        VTable.prototype.forEachCellOfCurrentRow = function (callback) {
            this.forEachCellOfRow(this.row, callback);
        };
        /**
         * Get a table cell using its row and column index. This function will always return an object
         * even if the given indexes don't exist in table.
         * @param row The row index
         * @param col The column index
         */
        VTable.prototype.getCell = function (row, col) {
            return (this.cells && this.cells[row] && this.cells[row][col]) || {};
        };
        /**
         * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell
         */
        VTable.prototype.getCurrentTd = function () {
            return this.getTd(this.row, this.col);
        };
        /**
         * Get the Table Cell in a provided coordinate
         * @param row row of the cell
         * @param col column of the cell
         */
        VTable.prototype.getTd = function (row, col) {
            if (this.cells && row !== undefined && col !== undefined) {
                row = Math.min(this.cells.length - 1, row);
                col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;
                if (!isNaN(row) && !isNaN(col)) {
                    while (row >= 0 && col >= 0) {
                        var cell = this.getCell(row, col);
                        if (cell.td) {
                            return cell.td;
                        }
                        else if (cell.spanLeft) {
                            col--;
                        }
                        else if (cell.spanAbove) {
                            row--;
                        }
                        else {
                            break;
                        }
                    }
                }
            }
            return null;
        };
        VTable.prototype.forEachCellOfColumn = function (col, callback) {
            if (col !== undefined) {
                for (var i = 0; this.cells && i < this.cells.length; i++) {
                    callback(this.getCell(i, col), this.cells[i], i);
                }
            }
        };
        VTable.prototype.forEachCellOfRow = function (row, callback) {
            if (row !== undefined) {
                for (var i = 0; this.cells && i < this.cells[row].length; i++) {
                    callback(this.getCell(row, i), i);
                }
            }
        };
        VTable.prototype.recalculateSpans = function (row, col) {
            var td = this.getCell(row, col).td;
            if (td) {
                td.colSpan = this.countSpanLeft(row, col);
                td.rowSpan = this.countSpanAbove(row, col);
                if (td.colSpan == 1) {
                    td.removeAttribute('colSpan');
                }
                if (td.rowSpan == 1) {
                    td.removeAttribute('rowSpan');
                }
            }
        };
        VTable.prototype.countSpanLeft = function (row, col) {
            var result = 1;
            for (var i = col + 1; this.cells && i < this.cells[row].length; i++) {
                var cell = this.getCell(row, i);
                if (cell.td || !cell.spanLeft) {
                    break;
                }
                result++;
            }
            return result;
        };
        VTable.prototype.countSpanAbove = function (row, col) {
            var result = 1;
            for (var i = row + 1; this.cells && i < this.cells.length; i++) {
                var cell = this.getCell(i, col);
                if (cell.td || !cell.spanAbove) {
                    break;
                }
                result++;
            }
            return result;
        };
        VTable.prototype.normalizeEmptyTableCells = function () {
            for (var i = 0, row = void 0; (row = this.table.rows[i]); i++) {
                for (var j = 0, cell = void 0; (cell = row.cells[j]); j++) {
                    if (cell) {
                        if (!cell.innerHTML || !cell.innerHTML.trim()) {
                            cell.appendChild(document.createElement('br'));
                        }
                    }
                }
            }
        };
        /* normalize width/height for each cell in the table */
        VTable.prototype.normalizeTableCellSize = function (zoomScale) {
            // remove width/height for each row
            for (var i = 0, row = void 0; (row = this.table.rows[i]); i++) {
                row.removeAttribute('width');
                row.style.setProperty('width', null);
                row.removeAttribute('height');
                row.style.setProperty('height', null);
            }
            // set width/height for each cell
            for (var i = 0; this.cells && i < this.cells.length; i++) {
                for (var j = 0; j < this.cells[i].length; j++) {
                    var cell = this.cells[i][j];
                    if (cell) {
                        var func = typeof zoomScale == 'number' ? function (n) { return n / zoomScale; } : zoomScale;
                        var width = cell.width || 0;
                        var height = cell.height || 0;
                        setHTMLElementSizeInPx(cell.td, (func === null || func === void 0 ? void 0 : func(width)) || width, (func === null || func === void 0 ? void 0 : func(height)) || height);
                    }
                }
            }
        };
        VTable.prototype.normalizeSize = function (sizeTransformer) {
            this.normalizeEmptyTableCells();
            this.normalizeTableCellSize(sizeTransformer);
            var rect = this.table.getBoundingClientRect();
            // Make sure table width/height is fixed to avoid shifting effect
            setHTMLElementSizeInPx(this.table, (sizeTransformer === null || sizeTransformer === void 0 ? void 0 : sizeTransformer(rect.width)) || rect.width, (sizeTransformer === null || sizeTransformer === void 0 ? void 0 : sizeTransformer(rect.height)) || rect.height);
        };
        return VTable;
    }());
    exports.default = VTable;
    function setHTMLElementSizeInPx(element, newWidth, newHeight) {
        if (!!element) {
            element.removeAttribute('width');
            element.removeAttribute('height');
            element.style.boxSizing = 'border-box';
            element.style.width = newWidth + "px";
            element.style.height = newHeight + "px";
        }
    }
    function getTableFromTd(td) {
        var result = td;
        for (; result && result.tagName != 'TABLE'; result = result.parentElement) { }
        return result;
    }
    /**
     * Clone a table cell
     * @param cell The cell to clone
     */
    function cloneCell(cell) {
        return {
            td: cloneNode(cell.td),
            spanAbove: cell.spanAbove,
            spanLeft: cell.spanLeft,
        };
    }
    /**
     * Clone a node without its children.
     * @param node The node to clone
     */
    function cloneNode(node) {
        var newNode = node ? node.cloneNode(false /*deep*/) : null;
        if ((0, safeInstanceOf_1.default)(newNode, 'HTMLTableCellElement')) {
            newNode.removeAttribute('id');
            if (!newNode.firstChild) {
                newNode.appendChild(node.ownerDocument.createElement('br'));
            }
        }
        return newNode;
    }
});
//# sourceMappingURL=VTable.js.map