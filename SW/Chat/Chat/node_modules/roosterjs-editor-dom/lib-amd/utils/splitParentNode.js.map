{"version":3,"file":"splitParentNode.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts"],"names":[],"mappings":";;;;IAEA;;;;;;;;;;OAUG;IACH,SAAwB,eAAe,CAAC,IAAU,EAAE,WAAoB;;QACpE,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAC3B,OAAO,IAAI,CAAC;SACf;QAED,IAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;QACnC,IAAI,SAAS,GAAuB,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAgB,CAAC;QACxF,SAAS,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAChC,IAAI,WAAW,EAAE;YACb,OAAO,UAAU,CAAC,UAAU,IAAI,UAAU,CAAC,UAAU,IAAI,IAAI,EAAE;gBAC3D,SAAS,CAAC,WAAW,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;aAChD;SACJ;aAAM;YACH,OAAO,IAAI,CAAC,WAAW,EAAE;gBACrB,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;aAC3C;SACJ;QAED,2HAA2H;QAC3H,IAAI,SAAS,CAAC,UAAU,IAAI,SAAS,CAAC,SAAS,IAAI,EAAE,EAAE;YACnD,MAAA,UAAU,CAAC,UAAU,0CAAE,YAAY,CAC/B,SAAS,EACT,WAAW,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,WAAW,CACpD,CAAC;SACL;aAAM;YACH,SAAS,GAAG,IAAI,CAAC;SACpB;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;IA7BD,kCA6BC;IAED;;;;;OAKG;IACH,SAAgB,sBAAsB,CAAC,KAAoB;QACvD,IAAI,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QACpD,IAAI,GAAG,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QACjE,IAAM,UAAU,GAAG,KAAK,IAAI,GAAG,IAAI,KAAK,CAAC,UAAU,IAAI,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC;QAChG,IAAI,UAAU,EAAE;YACZ,IAAI,IAAA,qBAAW,EAAC,KAAK,EAAE,GAAG,CAAC,EAAE;gBACzB,IAAM,IAAI,GAAG,GAAG,CAAC;gBACjB,GAAG,GAAG,KAAK,CAAC;gBACZ,KAAK,GAAG,IAAI,CAAC;aAChB;YACD,eAAe,CAAC,KAAK,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;YAC7C,eAAe,CAAC,GAAG,EAAE,KAAK,CAAC,eAAe,CAAC,CAAC;SAC/C;QAED,OAAO,UAAU,CAAC;IACtB,CAAC;IAfD,wDAeC","sourcesContent":["import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node | null {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    const parentNode = node.parentNode;\r\n    let newParent: HTMLElement | null = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode?.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): Node | null {\r\n    let start = Array.isArray(nodes) ? nodes[0] : nodes;\r\n    let end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;\r\n    const parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            const temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode;\r\n}\r\n"]}