{"version":3,"file":"getLeafSibling.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts"],"names":[],"mappings":";;;;IAIA;;;;;;;;OAQG;IACH,SAAgB,cAAc,CAC1B,QAAc,EACd,SAAe,EACf,MAAe,EACf,QAAmB,EACnB,WAAqB;QAErB,IAAI,MAAM,GAAG,IAAI,CAAC;QAClB,IAAM,UAAU,GAAG,MAAM;YACrB,CAAC,CAAC,UAAC,IAAiB,IAAK,OAAA,CAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,WAAW,KAAI,IAAI,EAAzB,CAAyB;YAClD,CAAC,CAAC,UAAC,IAAiB,IAAK,OAAA,CAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,eAAe,KAAI,IAAI,EAA7B,CAA6B,CAAC;QAC3D,IAAM,QAAQ,GAAG,MAAM,CAAC,CAAC,CAAC,UAAC,IAAU,IAAK,OAAA,IAAI,CAAC,UAAU,EAAf,CAAe,CAAC,CAAC,CAAC,UAAC,IAAU,IAAK,OAAA,IAAI,CAAC,SAAS,EAAd,CAAc,CAAC;QAC3F,IAAI,IAAA,kBAAQ,EAAC,QAAQ,EAAE,SAAS,CAAC,EAAE;YAC/B,IAAI,OAAO,GAAgB,SAAS,CAAC;YACrC,IAAI,cAAc,GAAY,IAAI,CAAC;YAEnC,OAAO,cAAc,EAAE;gBACnB,4HAA4H;gBAC5H,gGAAgG;gBAChG,IAAI,UAAU,GAAG,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,UAAU,KAAI,IAAI,CAAC;gBAC7C,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;gBAC9B,OAAO,CAAC,OAAO,IAAI,UAAU,IAAI,QAAQ,EAAE;oBACvC,OAAO,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC;oBACjC,UAAU,GAAG,CAAA,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,UAAU,KAAI,IAAI,CAAC;iBAC/C;gBAED,4CAA4C;gBAC5C,OACI,OAAO;oBACP,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,OAAO,CAAC,IAAA,sBAAY,EAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;oBAC1D,QAAQ,CAAC,OAAO,CAAC,EACnB;oBACE,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;iBAC/B;gBAED,0FAA0F;gBAC1F,cAAc,GAAG,CAAC,CAAC,OAAO,IAAI,IAAA,wBAAc,EAAC,OAAO,EAAE,WAAW,CAAC,CAAC;gBACnE,IAAI,CAAC,cAAc,EAAE;oBACjB,0CAA0C;oBAC1C,MAAM,GAAG,OAAO,CAAC;oBACjB,MAAM;iBACT;aACJ;SACJ;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IA9CD,wCA8CC;IAED;;;;;OAKG;IACH,SAAgB,kBAAkB,CAC9B,QAAc,EACd,SAAe,EACf,QAAmB;QAEnB,OAAO,cAAc,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;IAC1E,CAAC;IAND,gDAMC;IAED;;;;;OAKG;IACH,SAAgB,sBAAsB,CAClC,QAAc,EACd,SAAe,EACf,QAAmB;QAEnB,OAAO,cAAc,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;IAC3E,CAAC;IAND,wDAMC","sourcesContent":["import contains from './contains';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * @internal\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped\r\n */\r\nexport function getLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    isNext: boolean,\r\n    skipTags?: string[],\r\n    ignoreSpace?: boolean\r\n): Node | null {\r\n    let result = null;\r\n    const getSibling = isNext\r\n        ? (node: Node | null) => node?.nextSibling || null\r\n        : (node: Node | null) => node?.previousSibling || null;\r\n    const getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode: Node | null = startNode;\r\n        let shouldContinue: boolean = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode?.parentNode || null;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode?.parentNode || null;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (\r\n                curNode &&\r\n                (!skipTags || skipTags.indexOf(getTagOfNode(curNode)) < 0) &&\r\n                getChild(curNode)\r\n            ) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = !!curNode && shouldSkipNode(curNode, ignoreSpace);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getNextLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    skipTags?: string[]\r\n): Node | null {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getPreviousLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    skipTags?: string[]\r\n): Node | null {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);\r\n}\r\n"]}