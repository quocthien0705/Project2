define(["require", "exports", "./contains", "./getTagOfNode", "./shouldSkipNode"], function (require, exports, contains_1, getTagOfNode_1, shouldSkipNode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPreviousLeafSibling = exports.getNextLeafSibling = exports.getLeafSibling = void 0;
    /**
     * @internal
     * This walks forwards/backwards DOM tree to get next meaningful node
     * @param rootNode Root node to scope the leaf sibling node
     * @param startNode current node to get sibling node from
     * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node
     * @param skipTags (Optional) tags that child elements will be skipped
     * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped
     */
    function getLeafSibling(rootNode, startNode, isNext, skipTags, ignoreSpace) {
        var result = null;
        var getSibling = isNext
            ? function (node) { return (node === null || node === void 0 ? void 0 : node.nextSibling) || null; }
            : function (node) { return (node === null || node === void 0 ? void 0 : node.previousSibling) || null; };
        var getChild = isNext ? function (node) { return node.firstChild; } : function (node) { return node.lastChild; };
        if ((0, contains_1.default)(rootNode, startNode)) {
            var curNode = startNode;
            var shouldContinue = true;
            while (shouldContinue) {
                // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent
                // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)
                var parentNode = (curNode === null || curNode === void 0 ? void 0 : curNode.parentNode) || null;
                curNode = getSibling(curNode);
                while (!curNode && parentNode != rootNode) {
                    curNode = getSibling(parentNode);
                    parentNode = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.parentNode) || null;
                }
                // Now traverse down to get first/last child
                while (curNode &&
                    (!skipTags || skipTags.indexOf((0, getTagOfNode_1.default)(curNode)) < 0) &&
                    getChild(curNode)) {
                    curNode = getChild(curNode);
                }
                // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so
                shouldContinue = !!curNode && (0, shouldSkipNode_1.default)(curNode, ignoreSpace);
                if (!shouldContinue) {
                    // Found a good leaf node, assign and exit
                    result = curNode;
                    break;
                }
            }
        }
        return result;
    }
    exports.getLeafSibling = getLeafSibling;
    /**
     * This walks forwards DOM tree to get next meaningful node
     * @param rootNode Root node to scope the leaf sibling node
     * @param startNode current node to get sibling node from
     * @param skipTags (Optional) tags that child elements will be skipped
     */
    function getNextLeafSibling(rootNode, startNode, skipTags) {
        return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);
    }
    exports.getNextLeafSibling = getNextLeafSibling;
    /**
     * This walks backwards DOM tree to get next meaningful node
     * @param rootNode Root node to scope the leaf sibling node
     * @param startNode current node to get sibling node from
     * @param skipTags (Optional) tags that child elements will be skipped
     */
    function getPreviousLeafSibling(rootNode, startNode, skipTags) {
        return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);
    }
    exports.getPreviousLeafSibling = getPreviousLeafSibling;
});
//# sourceMappingURL=getLeafSibling.js.map