{"version":3,"file":"collapseNodes.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts"],"names":[],"mappings":";;;;IAIA;;;;;;;;;;;OAWG;IACH,SAAwB,aAAa,CACjC,IAAU,EACV,KAAW,EACX,GAAS,EACT,cAAuB;;QAEvB,IAAI,CAAC,IAAA,kBAAQ,EAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAA,kBAAQ,EAAC,IAAI,EAAE,GAAG,CAAC,EAAE;YAChD,OAAO,EAAE,CAAC;SACb;QAED,KAAK,GAAG,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;QACrE,GAAG,GAAG,QAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;QAEpE,IAAI,IAAA,kBAAQ,EAAC,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,0BAA0B,CAAC,EAAE;YACvD,OAAO,CAAC,KAAK,CAAC,CAAC;SAClB;aAAM,IAAI,IAAA,kBAAQ,EAAC,GAAG,EAAE,KAAK,CAAC,EAAE;YAC7B,OAAO,CAAC,GAAG,CAAC,CAAC;SAChB;aAAM,IAAI,KAAK,CAAC,UAAU,IAAI,GAAG,CAAC,UAAU,EAAE;YAC3C,IAAM,KAAK,GAAW,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,IAAA,iBAAO,EAAC,MAAA,KAAK,CAAC,UAAU,0CAAE,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YACpF,IAAM,UAAU,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YACxC,IAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YACpC,OAAO,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,GAAG,CAAC,CAAC,CAAC;SAChD;aAAM;YACH,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;SACvB;IACL,CAAC;IAzBD,gCAyBC;IAED;;;;;;;;;OASG;IACH,SAAgB,QAAQ,CACpB,IAAU,EACV,IAAU,EACV,GAAS,EACT,OAAgB,EAChB,cAAuB;QAEvB,OAAO,IAAI,CAAC,UAAU,IAAI,IAAI,IAAI,CAAC,IAAA,kBAAQ,EAAC,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE;YAC/D,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,OAAO,IAAI,IAAI,CAAC,WAAW,CAAC,EAAE;gBACrE,IAAI,CAAC,cAAc,EAAE;oBACjB,MAAM;iBACT;gBACD,IAAA,yBAAe,EAAC,IAAI,EAAE,OAAO,CAAC,CAAC;aAClC;YAED,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;gBAClB,MAAM;aACT;YAED,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC;SAC1B;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;IAtBD,4BAsBC","sourcesContent":["import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\nimport toArray from '../jsUtils/toArray';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ancestor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start through end after splitting\r\n * False to disallow split parent\r\n * @returns When canSplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treatSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        const nodes: Node[] = start.parentNode ? toArray(start.parentNode?.childNodes) : [];\r\n        const startIndex = nodes.indexOf(start);\r\n        const endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * Collapse a node by traversing its parent nodes until we get the common ancestor node of node and ref node\r\n * @param root Root node, traversing will be limited under this scope\r\n * @param node The node to collapse\r\n * @param ref Ref node. The result will be the nearest common ancestor node of the given node and this ref node\r\n * @param isStart Whether the given node is start of the sequence of nodes to collapse\r\n * @param canSplitParent Whether splitting parent node is allowed\r\n * @returns The common ancestor node of the given node ref node\r\n */\r\nexport function collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n\r\n        if (!node.parentNode) {\r\n            break;\r\n        }\r\n\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n"]}