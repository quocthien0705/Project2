{"version":3,"file":"queryElements.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/utils/queryElements.ts"],"names":[],"mappings":";;;IAIA;;;;;;;;OAQG;IACH,SAAwB,aAAa,CACjC,SAAqB,EACrB,QAAgB,EAChB,eAAqD,EACrD,KAA0D,EAC1D,KAAa;QADb,sBAAA,EAAA,oBAA0D;QAG1D,IAAI,CAAC,SAAS,IAAI,CAAC,QAAQ,EAAE;YACzB,OAAO,EAAE,CAAC;SACb;QAED,IAAI,QAAQ,GAAG,IAAA,iBAAO,EAAC,SAAS,CAAC,gBAAgB,CAAc,QAAQ,CAAC,CAAC,CAAC;QAE1E,IAAI,KAAK,gBAAmB,IAAI,KAAK,EAAE;YAC3B,IAAA,WAAW,GAAgB,KAAK,YAArB,EAAE,SAAS,GAAK,KAAK,UAAV,CAAW;YACnC,IAAA,gBAAc,GAAmB,KAAK,eAAxB,EAAE,cAAY,GAAK,KAAK,aAAV,CAAW;YAC7C,IAAI,gBAAc,CAAC,QAAQ,mBAAoB,IAAI,gBAAc,CAAC,UAAU,EAAE;gBAC1E,IAAM,KAAK,GAAG,gBAAc,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;gBAErD,8FAA8F;gBAC9F,kDAAkD;gBAClD,gBAAc,GAAG,KAAK,IAAI,gBAAc,CAAC,SAAS,CAAC;aACtD;YAED,cAAY;gBACR,cAAY,CAAC,QAAQ,mBAAoB,IAAI,cAAY,CAAC,UAAU,IAAI,SAAS,GAAG,CAAC;oBACjF,CAAC,CAAC,cAAY,CAAC,UAAU,CAAC,SAAS,GAAG,CAAC,CAAC;oBACxC,CAAC,CAAC,cAAY,CAAC;YAEvB,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAA,OAAO;gBAC9B,OAAA,wBAAwB,CACpB,OAAO,EACP,gBAAc,EACd,cAAY,EACZ,KAAK,uBAA0B,CAClC;YALD,CAKC,CACJ,CAAC;SACL;QAED,IAAI,eAAe,EAAE;YACjB,QAAQ,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;SACrC;QACD,OAAO,QAAQ,CAAC;IACpB,CAAC;IA3CD,gCA2CC;IAED,SAAS,wBAAwB,CAC7B,IAAU,EACV,SAAe,EACf,OAAa,EACb,wBAAiC;QAEjC,IAAM,aAAa,GAAG,IAAI,CAAC,uBAAuB,CAAC,SAAS,CAAC,CAAC;QAC9D,IAAM,WAAW,GAAG,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC;QAC1D,IAAM,eAAe,GAAG,gCAAkD,CAAC;QAE3E,IAAI,CAAC,wBAAwB,EAAE;YAC3B,eAAe,CAAC,IAAI,sBAA8B,CAAC;SACtD;QAED,OAAO,CACH,aAAa,CAAC,aAAa,EAAE,eAAe,CAAC,IAAI,iBAAiB;YAClE,aAAa,CAAC,WAAW,EAAE,eAAe,CAAC,IAAI,eAAe;YAC9D,CAAC,aAAa,CAAC,aAAa,EAAE,mBAA4B,CAAC,IAAI,WAAW;gBACtE,aAAa,CAAC,WAAW,EAAE,mBAA4B,CAAC;gBACxD,CAAC,aAAa,CAAC,WAAW,EAAE,sBAA8B,CAAC,CAAC,CACnE,CAAC;IACN,CAAC;IAED,SAAS,aAAa,CAAC,QAA0B,EAAE,OAA2B;QAC1E,OAAO,OAAO,CAAC,IAAI,CAAC,UAAA,MAAM;YACtB,OAAA,MAAM,gBAAyB;gBAC3B,CAAC,CAAC,QAAQ,gBAAyB;gBACnC,CAAC,CAAC,CAAC,QAAQ,GAAG,MAAM,CAAC,IAAI,MAAM;QAFnC,CAEmC,CACtC,CAAC;IACN,CAAC","sourcesContent":["import toArray from '../jsUtils/toArray';\r\nimport { DocumentPosition, NodeType, QueryScope } from 'roosterjs-editor-types';\r\nimport type { CompatibleQueryScope } from 'roosterjs-editor-types/lib/compatibleTypes';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: ParentNode,\r\n    selector: string,\r\n    forEachCallback?: ((node: HTMLElement) => any) | null,\r\n    scope: QueryScope | CompatibleQueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = toArray(container.querySelectorAll<HTMLElement>(selector));\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        const { startOffset, endOffset } = range;\r\n        let { startContainer, endContainer } = range;\r\n        if (startContainer.nodeType == NodeType.Element && startContainer.firstChild) {\r\n            const child = startContainer.childNodes[startOffset];\r\n\r\n            // range.startOffset can give a value of child.length+1 when selection is after the last child\r\n            // In that case we will use the last child instead\r\n            startContainer = child || startContainer.lastChild;\r\n        }\r\n\r\n        endContainer =\r\n            endContainer.nodeType == NodeType.Element && endContainer.firstChild && endOffset > 0\r\n                ? endContainer.childNodes[endOffset - 1]\r\n                : endContainer;\r\n\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(\r\n                element,\r\n                startContainer,\r\n                endContainer,\r\n                scope == QueryScope.InSelection\r\n            )\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    startNode: Node,\r\n    endNode: Node,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    const startPosition = node.compareDocumentPosition(startNode);\r\n    const endPosition = node.compareDocumentPosition(endNode);\r\n    const targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n"]}