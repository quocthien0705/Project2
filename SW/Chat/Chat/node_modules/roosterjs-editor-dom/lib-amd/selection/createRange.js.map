{"version":3,"file":"createRange.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/selection/createRange.ts"],"names":[],"mappings":"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","sourcesContent":["import isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport type { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a range around the given node(s)\r\n * @param startNode The start node to create range from\r\n * @param endNode The end node to create range from. If specified, the range will start before startNode and\r\n * end after endNode, otherwise, the range will start before and end after the start node\r\n * @returns A range start before the given node and end after the given node\r\n */\r\nexport default function createRange(startNode: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a collapsed range at the given node and offset\r\n * @param node The container node of the range\r\n * @param offset The offset of the range, can be a number or value of PositionType\r\n * @returns A range at the given node and offset\r\n */\r\nexport default function createRange(node: Node, offset: number | PositionType): Range;\r\n\r\n/**\r\n * Create a range with the given start/end container node and offset\r\n * @param startNode The start container node of the range\r\n * @param startOffset The start offset of the range\r\n * @param endNode The end container node of the range\r\n * @param endOffset The end offset of the range\r\n * @returns A range at the given start/end container node and offset\r\n */\r\nexport default function createRange(\r\n    startNode: Node,\r\n    startOffset: number | PositionType,\r\n    endNode: Node,\r\n    endOffset: number | PositionType\r\n): Range;\r\n\r\n/**\r\n * Create a range under the given rootNode with start and end selection paths\r\n * @param rootNode The root node that the selection paths start from\r\n * @param startPath The selection path of the start position of the range\r\n * @param endPath The selection path of the end position of the range\r\n * @returns A range with the given start and end selection paths\r\n */\r\nexport default function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n\r\n/**\r\n * Create a range with the start and end position\r\n * @param startPosition The start position of the range\r\n * @param endPosition The end position of the range, if not specified, the range will be collapsed at start position\r\n * @returns A range start at startPosition, end at endPosition, or startPosition when endPosition is not specified\r\n */\r\nexport default function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n\r\nexport default function createRange(\r\n    arg1: Node | NodePosition,\r\n    arg2?: number | number[] | Node | NodePosition,\r\n    arg3?: Node | number[],\r\n    arg4?: number\r\n): Range | null {\r\n    let start: NodePosition | null = null;\r\n    let end: NodePosition | null = null;\r\n\r\n    if (isNodePosition(arg1)) {\r\n        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n        start = arg1;\r\n        end = isNodePosition(arg2) ? arg2 : null;\r\n    } else if (safeInstanceOf(arg1, 'Node')) {\r\n        if (Array.isArray(arg2)) {\r\n            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n            start = getPositionFromPath(arg1, arg2);\r\n            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;\r\n        } else if (typeof arg2 == 'number') {\r\n            // function createRange(node: Node, offset: number | PositionType): Range;\r\n            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;\r\n            start = new Position(arg1, arg2);\r\n            end = safeInstanceOf(arg3, 'Node') ? new Position(arg3, arg4!) : null;\r\n        } else if (safeInstanceOf(arg2, 'Node') || !arg2) {\r\n            // function createRange(startNode: Node, endNode?: Node): Range;\r\n            start = new Position(arg1, PositionType.Before);\r\n            end = new Position(<Node>arg2 || arg1, PositionType.After);\r\n        }\r\n    }\r\n\r\n    if (start?.node?.ownerDocument) {\r\n        const range = start.node.ownerDocument.createRange();\r\n        start = getFocusablePosition(start);\r\n        end = getFocusablePosition(end || start);\r\n        range.setStart(start.node, start.offset);\r\n        range.setEnd(end.node, end.offset);\r\n\r\n        return range;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n\r\nfunction isNodePosition(arg: any): arg is NodePosition {\r\n    return arg && arg.node;\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition | null {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number = 0;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n"]}