define(["require", "exports", "../utils/findClosestElementAncestor", "../utils/isNodeAfter"], function (require, exports, findClosestElementAncestor_1, isNodeAfter_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Represent a position in DOM tree by the node and its offset index
     */
    var Position = /** @class */ (function () {
        function Position(nodeOrPosition, offsetOrPosType, isFromEndOfRange) {
            if (offsetOrPosType === void 0) { offsetOrPosType = 0; }
            this.isFromEndOfRange = isFromEndOfRange;
            if (nodeOrPosition.node) {
                this.node = nodeOrPosition.node;
                offsetOrPosType = nodeOrPosition.offset;
            }
            else {
                this.node = nodeOrPosition;
            }
            switch (offsetOrPosType) {
                case -2 /* Before */:
                    this.offset = getIndexOfNode(this.node);
                    this.node = this.node.parentNode; // TODO: how to handle parentNode is null?
                    this.isAtEnd = false;
                    break;
                case -3 /* After */:
                    this.offset = getIndexOfNode(this.node) + 1;
                    this.isAtEnd = !this.node.nextSibling;
                    this.node = this.node.parentNode; // TODO: how to handle parentNode is null?
                    break;
                case -1 /* End */:
                    this.offset = getEndOffset(this.node);
                    this.isAtEnd = true;
                    break;
                default:
                    var endOffset = getEndOffset(this.node);
                    this.offset = Math.max(0, Math.min(offsetOrPosType, endOffset));
                    this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;
                    break;
            }
            this.element = (0, findClosestElementAncestor_1.default)(this.node); // TODO: how to handle parent element is null?
        }
        /**
         * Normalize this position to the leaf node, return the normalize result.
         * If current position is already using leaf node, return this position object itself
         */
        Position.prototype.normalize = function () {
            if (this.node.nodeType == 3 /* Text */ || !this.node.firstChild) {
                return this;
            }
            var node = this.node;
            var newOffset = this.isAtEnd
                ? -1 /* End */
                : this.offset;
            while (node.nodeType == 1 /* Element */ || node.nodeType == 11 /* DocumentFragment */) {
                var nextNode = this.isFromEndOfRange
                    ? newOffset == -1 /* End */
                        ? node.lastChild
                        : node.childNodes[newOffset - 1]
                    : newOffset == 0 /* Begin */
                        ? node.firstChild
                        : newOffset == -1 /* End */
                            ? node.lastChild
                            : node.childNodes[newOffset];
                if (nextNode) {
                    node = nextNode;
                    newOffset =
                        this.isAtEnd || this.isFromEndOfRange ? -1 /* End */ : 0 /* Begin */;
                }
                else {
                    break;
                }
            }
            return new Position(node, newOffset, this.isFromEndOfRange);
        };
        /**
         * Check if this position is equal to the given position
         * @param position The position to check
         */
        Position.prototype.equalTo = function (position) {
            return (position &&
                (this == position ||
                    (this.node == position.node &&
                        this.offset == position.offset &&
                        this.isAtEnd == position.isAtEnd)));
        };
        /**
         * Checks if this position is after the given position
         */
        Position.prototype.isAfter = function (position) {
            return this.node == position.node
                ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset
                : (0, isNodeAfter_1.default)(this.node, position.node);
        };
        /**
         * Move this position with offset, returns a new position with a valid offset in the same node
         * @param offset Offset to move with
         */
        Position.prototype.move = function (offset) {
            return new Position(this.node, Math.max(this.offset + offset, 0));
        };
        /**
         * Get start position of the given Range
         * @param range The range to get position from
         */
        Position.getStart = function (range) {
            return new Position(range.startContainer, range.startOffset);
        };
        /**
         * Get end position of the given Range
         * @param range The range to get position from
         */
        Position.getEnd = function (range) {
            // For collapsed range, always return the same value of start container to make sure
            // end position is not before start position
            return range.collapsed
                ? Position.getStart(range)
                : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);
        };
        return Position;
    }());
    exports.default = Position;
    function getIndexOfNode(node) {
        var i = 0;
        while ((node = (node === null || node === void 0 ? void 0 : node.previousSibling) || null)) {
            i++;
        }
        return i;
    }
    function getEndOffset(node) {
        var _a;
        if (node.nodeType == 3 /* Text */) {
            return ((_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) || 0;
        }
        else if (node.nodeType == 1 /* Element */ || node.nodeType == 11 /* DocumentFragment */) {
            return node.childNodes.length;
        }
        else {
            return 1;
        }
    }
});
//# sourceMappingURL=Position.js.map