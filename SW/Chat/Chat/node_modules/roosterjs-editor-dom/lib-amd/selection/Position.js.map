{"version":3,"file":"Position.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/selection/Position.ts"],"names":[],"mappings":"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","sourcesContent":["import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport type { NodePosition } from 'roosterjs-editor-types';\r\nimport type { CompatiblePositionType } from 'roosterjs-editor-types/lib/compatibleTypes';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     * @param isFromEndOfRange Whether this position is created from end of a range. An position\r\n     * created from end of range has different behavior when normalize, it will use the child node\r\n     * before current position if any as a deeper level node and set isAtEnd to true.\r\n     */\r\n    constructor(node: Node, offset: number, isFromEndOfRange?: boolean);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the position, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType | CompatiblePositionType);\r\n\r\n    constructor(\r\n        nodeOrPosition: Node | NodePosition,\r\n        offsetOrPosType: number = 0,\r\n        private readonly isFromEndOfRange?: boolean\r\n    ) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode!; // TODO: how to handle parentNode is null?\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode!; // TODO: how to handle parentNode is null?\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                const endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node)!; // TODO: how to handle parent element is null?\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element || node.nodeType == NodeType.DocumentFragment) {\r\n            const nextNode = this.isFromEndOfRange\r\n                ? newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset - 1]\r\n                : newOffset == PositionType.Begin\r\n                ? node.firstChild\r\n                : newOffset == PositionType.End\r\n                ? node.lastChild\r\n                : node.childNodes[<number>newOffset];\r\n\r\n            if (nextNode) {\r\n                node = nextNode;\r\n                newOffset =\r\n                    this.isAtEnd || this.isFromEndOfRange ? PositionType.End : PositionType.Begin;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return new Position(node, newOffset, this.isFromEndOfRange);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        // For collapsed range, always return the same value of start container to make sure\r\n        // end position is not before start position\r\n        return range.collapsed\r\n            ? Position.getStart(range)\r\n            : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node | null): number {\r\n    let i = 0;\r\n    while ((node = node?.previousSibling || null)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue?.length || 0;\r\n    } else if (node.nodeType == NodeType.Element || node.nodeType == NodeType.DocumentFragment) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n"]}