define(["require", "exports", "../utils/isVoidHtmlElement", "./Position", "../utils/safeInstanceOf"], function (require, exports, isVoidHtmlElement_1, Position_1, safeInstanceOf_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createRange(arg1, arg2, arg3, arg4) {
        var _a;
        var start = null;
        var end = null;
        if (isNodePosition(arg1)) {
            // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;
            start = arg1;
            end = isNodePosition(arg2) ? arg2 : null;
        }
        else if ((0, safeInstanceOf_1.default)(arg1, 'Node')) {
            if (Array.isArray(arg2)) {
                // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;
                start = getPositionFromPath(arg1, arg2);
                end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;
            }
            else if (typeof arg2 == 'number') {
                // function createRange(node: Node, offset: number | PositionType): Range;
                // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;
                start = new Position_1.default(arg1, arg2);
                end = (0, safeInstanceOf_1.default)(arg3, 'Node') ? new Position_1.default(arg3, arg4) : null;
            }
            else if ((0, safeInstanceOf_1.default)(arg2, 'Node') || !arg2) {
                // function createRange(startNode: Node, endNode?: Node): Range;
                start = new Position_1.default(arg1, -2 /* Before */);
                end = new Position_1.default(arg2 || arg1, -3 /* After */);
            }
        }
        if ((_a = start === null || start === void 0 ? void 0 : start.node) === null || _a === void 0 ? void 0 : _a.ownerDocument) {
            var range = start.node.ownerDocument.createRange();
            start = getFocusablePosition(start);
            end = getFocusablePosition(end || start);
            range.setStart(start.node, start.offset);
            range.setEnd(end.node, end.offset);
            return range;
        }
        else {
            return null;
        }
    }
    exports.default = createRange;
    /**
     * Convert to focusable position
     * If current node is a void element, we need to move up one level to put cursor outside void element
     */
    function getFocusablePosition(position) {
        return position.node.nodeType == 1 /* Element */ && (0, isVoidHtmlElement_1.default)(position.node)
            ? new Position_1.default(position.node, position.isAtEnd ? -3 /* After */ : -2 /* Before */)
            : position;
    }
    function isNodePosition(arg) {
        return arg && arg.node;
    }
    function getPositionFromPath(node, path) {
        if (!node || !path) {
            return null;
        }
        // Iterate with a for loop to avoid mutating the passed in element path stack
        // or needing to copy it.
        var offset = 0;
        for (var i = 0; i < path.length; i++) {
            offset = path[i];
            if (i < path.length - 1 &&
                node &&
                node.nodeType == 1 /* Element */ &&
                node.childNodes.length > offset) {
                node = node.childNodes[offset];
            }
            else {
                break;
            }
        }
        return new Position_1.default(node, offset);
    }
});
//# sourceMappingURL=createRange.js.map