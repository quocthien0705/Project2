define(["require", "exports", "../utils/contains", "../utils/isNodeAfter"], function (require, exports, contains_1, isNodeAfter_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @internal
     * This presents a content block that can be represented by a single html block type element.
     * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.
     */
    var NodeBlockElement = /** @class */ (function () {
        function NodeBlockElement(element) {
            this.element = element;
        }
        /**
         * Collapse this element to a single DOM element.
         * If the content nodes are separated in different root nodes, wrap them to a single node
         * If the content nodes are included in root node with other nodes, split root node
         */
        NodeBlockElement.prototype.collapseToSingleElement = function () {
            return this.element;
        };
        /**
         * Get the start node of the block
         * For NodeBlockElement, start and end essentially refers to same node
         */
        NodeBlockElement.prototype.getStartNode = function () {
            return this.element;
        };
        /**
         * Get the end node of the block
         * For NodeBlockElement, start and end essentially refers to same node
         */
        NodeBlockElement.prototype.getEndNode = function () {
            return this.element;
        };
        /**
         * Checks if it refers to same block
         */
        NodeBlockElement.prototype.equals = function (blockElement) {
            // Ideally there is only one unique way to generate a block so we only need to compare the startNode
            return this.element == blockElement.getStartNode();
        };
        /**
         * Checks if a block is after the current block
         */
        NodeBlockElement.prototype.isAfter = function (blockElement) {
            // if the block's startNode is after current node endEnd, we say it is after
            return (0, isNodeAfter_1.default)(this.element, blockElement.getEndNode());
        };
        /**
         * Checks if a certain html node is within the block
         */
        NodeBlockElement.prototype.contains = function (node) {
            return (0, contains_1.default)(this.element, node, true /*treatSameNodeAsContain*/);
        };
        /**
         * Get the text content of this block element
         */
        NodeBlockElement.prototype.getTextContent = function () {
            var _a;
            return ((_a = this.element) === null || _a === void 0 ? void 0 : _a.textContent) || '';
        };
        return NodeBlockElement;
    }());
    exports.default = NodeBlockElement;
});
//# sourceMappingURL=NodeBlockElement.js.map