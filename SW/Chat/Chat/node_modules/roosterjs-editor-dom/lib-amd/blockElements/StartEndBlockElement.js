define(["require", "exports", "../utils/collapseNodes", "../utils/contains", "../selection/createRange", "../utils/getTagOfNode", "../utils/isBlockElement", "../utils/isNodeAfter", "../utils/wrap", "../utils/splitParentNode"], function (require, exports, collapseNodes_1, contains_1, createRange_1, getTagOfNode_1, isBlockElement_1, isNodeAfter_1, wrap_1, splitParentNode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];
    /**
     * @internal
     * This represents a block that is identified by a start and end node
     * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;
     * in that case, Hello&lt;BR&gt; is a block, World is another block
     * Such block cannot be represented by a NodeBlockElement since they don't chained up
     * to a single parent node, instead they have a start and end
     * This start and end must be in same sibling level and have same parent in DOM tree
     */
    var StartEndBlockElement = /** @class */ (function () {
        function StartEndBlockElement(rootNode, startNode, endNode) {
            this.rootNode = rootNode;
            this.startNode = startNode;
            this.endNode = endNode;
        }
        StartEndBlockElement.getBlockContext = function (node) {
            var currentNode = node;
            while (currentNode && !(0, isBlockElement_1.default)(currentNode)) {
                currentNode = currentNode.parentNode;
            }
            return currentNode;
        };
        /**
         * Collapse this element to a single DOM element.
         * If the content nodes are separated in different root nodes, wrap them to a single node
         * If the content nodes are included in root node with other nodes, split root node
         */
        StartEndBlockElement.prototype.collapseToSingleElement = function () {
            var nodeContext = StartEndBlockElement.getBlockContext(this.startNode);
            var nodes = nodeContext
                ? (0, collapseNodes_1.default)(nodeContext, this.startNode, this.endNode, true /*canSplitParent*/)
                : [];
            var blockContext = StartEndBlockElement.getBlockContext(this.startNode);
            while (nodes[0] &&
                nodes[0] != blockContext &&
                nodes[0].parentNode != this.rootNode &&
                STRUCTURE_NODE_TAGS.indexOf((0, getTagOfNode_1.default)(nodes[0].parentNode)) < 0) {
                var newNode = (0, splitParentNode_1.splitBalancedNodeRange)(nodes);
                if (newNode) {
                    nodes = [newNode];
                }
                else {
                    break;
                }
            }
            return nodes.length == 1 && (0, isBlockElement_1.default)(nodes[0])
                ? nodes[0]
                : (0, wrap_1.default)(nodes);
        };
        /**
         * Gets the start node
         */
        StartEndBlockElement.prototype.getStartNode = function () {
            return this.startNode;
        };
        /**
         * Gets the end node
         */
        StartEndBlockElement.prototype.getEndNode = function () {
            return this.endNode;
        };
        /**
         * Checks equals of two blocks
         */
        StartEndBlockElement.prototype.equals = function (blockElement) {
            return (this.startNode == blockElement.getStartNode() &&
                this.endNode == blockElement.getEndNode());
        };
        /**
         * Checks if another block is after this current
         */
        StartEndBlockElement.prototype.isAfter = function (blockElement) {
            return (0, isNodeAfter_1.default)(this.getStartNode(), blockElement.getEndNode());
        };
        /**
         * Checks if an Html node is contained within the block
         */
        StartEndBlockElement.prototype.contains = function (node) {
            return ((0, contains_1.default)(this.startNode, node, true /*treatSameNodeAsContain*/) ||
                (0, contains_1.default)(this.endNode, node, true /*treatSameNodeAsContain*/) ||
                ((0, isNodeAfter_1.default)(node, this.startNode) && (0, isNodeAfter_1.default)(this.endNode, node)));
        };
        /**
         * Get the text content of this block element
         */
        StartEndBlockElement.prototype.getTextContent = function () {
            var range = (0, createRange_1.default)(this.getStartNode(), this.getEndNode());
            return range ? range.toString() : '';
        };
        return StartEndBlockElement;
    }());
    exports.default = StartEndBlockElement;
});
//# sourceMappingURL=StartEndBlockElement.js.map