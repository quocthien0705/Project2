{"version":3,"file":"getBlockElementAtNode.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts"],"names":[],"mappings":"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","sourcesContent":["import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport type { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitrary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(\r\n    rootNode: Node,\r\n    node: Node | null\r\n): BlockElement | null {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    const containerBlockNode = StartEndBlockElement.getBlockContext(node!);\r\n    if (!containerBlockNode) {\r\n        return null;\r\n    } else if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node!, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node!, containerBlockNode, true /*isTail*/);\r\n\r\n    if (!headNode || !tailNode) {\r\n        return null;\r\n    }\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancestor\r\n    const nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n\r\n    if (nodes.length === 0) {\r\n        return null;\r\n    }\r\n\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            const parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else if (parentNode && parentNode != rootNode) {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling: Node | null = node;\r\n        while (node.parentNode && !(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n"]}