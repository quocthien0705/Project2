{"version":3,"file":"StartEndBlockElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts"],"names":[],"mappings":"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","sourcesContent":["import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport createRange from '../selection/createRange';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\nimport type { BlockElement } from 'roosterjs-editor-types';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * @internal\r\n * This represents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) {}\r\n\r\n    static getBlockContext(node: Node): HTMLElement | null {\r\n        let currentNode: Node | null = node;\r\n        while (currentNode && !isBlockElement(currentNode)) {\r\n            currentNode = currentNode.parentNode;\r\n        }\r\n        return currentNode as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        const nodeContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        let nodes = nodeContext\r\n            ? collapseNodes(nodeContext, this.startNode, this.endNode, true /*canSplitParent*/)\r\n            : [];\r\n        const blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            const newNode = splitBalancedNodeRange(nodes);\r\n            if (newNode) {\r\n                nodes = [newNode];\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartNode(), this.getEndNode());\r\n        return range ? range.toString() : '';\r\n    }\r\n}\r\n"]}