{"version":3,"file":"NodeBlockElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts"],"names":[],"mappings":";;;IAIA;;;;OAIG;IACH;QACI,0BAAoB,OAAoB;YAApB,YAAO,GAAP,OAAO,CAAa;QAAG,CAAC;QAE5C;;;;WAIG;QACI,kDAAuB,GAA9B;YACI,OAAO,IAAI,CAAC,OAAO,CAAC;QACxB,CAAC;QAED;;;WAGG;QACI,uCAAY,GAAnB;YACI,OAAO,IAAI,CAAC,OAAO,CAAC;QACxB,CAAC;QAED;;;WAGG;QACI,qCAAU,GAAjB;YACI,OAAO,IAAI,CAAC,OAAO,CAAC;QACxB,CAAC;QAED;;WAEG;QACI,iCAAM,GAAb,UAAc,YAA0B;YACpC,oGAAoG;YACpG,OAAO,IAAI,CAAC,OAAO,IAAI,YAAY,CAAC,YAAY,EAAE,CAAC;QACvD,CAAC;QAED;;WAEG;QACI,kCAAO,GAAd,UAAe,YAA0B;YACrC,4EAA4E;YAC5E,OAAO,IAAA,qBAAW,EAAC,IAAI,CAAC,OAAO,EAAE,YAAY,CAAC,UAAU,EAAE,CAAC,CAAC;QAChE,CAAC;QAED;;WAEG;QACI,mCAAQ,GAAf,UAAgB,IAAU;YACtB,OAAO,IAAA,kBAAQ,EAAC,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,0BAA0B,CAAC,CAAC;QACzE,CAAC;QAED;;WAEG;QACI,yCAAc,GAArB;;YACI,OAAO,CAAA,MAAA,IAAI,CAAC,OAAO,0CAAE,WAAW,KAAI,EAAE,CAAC;QAC3C,CAAC;QACL,uBAAC;IAAD,CAAC,AAzDD,IAyDC","sourcesContent":["import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport type { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * This presents a content block that can be represented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) {}\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element?.textContent || '';\r\n    }\r\n}\r\n"]}