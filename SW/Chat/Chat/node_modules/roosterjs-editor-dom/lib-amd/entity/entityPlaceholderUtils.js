define(["require", "exports", "./getEntityFromElement", "./getEntitySelector", "../utils/safeInstanceOf"], function (require, exports, getEntityFromElement_1, getEntitySelector_1, safeInstanceOf_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.restoreContentWithEntityPlaceholder = exports.moveContentWithEntityPlaceholders = exports.createEntityPlaceholder = void 0;
    var EntityPlaceHolderTagName = 'ENTITY-PLACEHOLDER';
    /**
     * @deprecated
     * Create a placeholder comment node for entity
     * @param entity The entity to create placeholder from
     * @returns A placeholder comment node as
     */
    function createEntityPlaceholder(entity) {
        var placeholder = entity.wrapper.ownerDocument.createElement(EntityPlaceHolderTagName);
        placeholder.id = entity.id;
        return placeholder;
    }
    exports.createEntityPlaceholder = createEntityPlaceholder;
    /**
     * Move content from a container into a new Document fragment, and try keep entities to be reusable by creating placeholder
     * for them in the document fragment.
     * If an entity is directly under root container, the whole entity can be reused and no need to move it at all.
     * If an entity is not directly under root container, it is still reusable, but it may need some movement.
     * In any case, entities will be replaced with a placeholder in the target document fragment.
     * We will use an entity map (the "entities" parameter) to save the map from entity id to its wrapper element.
     * @param root The root element
     * @param entities A map from entity id to entity wrapper element
     * @returns A new document fragment contains all the content and entity placeholders
     */
    function moveContentWithEntityPlaceholders(root, entities) {
        var entitySelector = (0, getEntitySelector_1.default)();
        var fragment = root.ownerDocument.createDocumentFragment();
        var next = null;
        var _loop_1 = function (child) {
            var entity;
            var nodeToAppend = child;
            next = child.nextSibling;
            if ((0, safeInstanceOf_1.default)(child, 'HTMLElement')) {
                if ((entity = (0, getEntityFromElement_1.default)(child))) {
                    nodeToAppend = getPlaceholder(entity, entities);
                }
                else {
                    child.querySelectorAll(entitySelector).forEach(function (wrapper) {
                        var _a;
                        if ((entity = (0, getEntityFromElement_1.default)(wrapper))) {
                            var placeholder = getPlaceholder(entity, entities);
                            (_a = wrapper.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(placeholder, wrapper);
                        }
                    });
                }
            }
            fragment.appendChild(nodeToAppend);
        };
        for (var child = root.firstChild; child; child = next) {
            _loop_1(child);
        }
        fragment.normalize();
        return fragment;
    }
    exports.moveContentWithEntityPlaceholders = moveContentWithEntityPlaceholders;
    /**
     * Restore HTML content from a document fragment that may contain entity placeholders.
     * @param source Source document fragment that contains HTML content and entity placeholders
     * @param target Target container, usually to be editor root container
     * @param entities A map from entity id to entity wrapper, used for reusing existing DOM structure for entity
     * @param insertClonedNode When pass true, merge with a cloned copy of the nodes from source fragment rather than the nodes themselves @default false
     */
    function restoreContentWithEntityPlaceholder(source, target, entities, insertClonedNode) {
        var anchor = target.firstChild;
        var entitySelector = (0, getEntitySelector_1.default)();
        for (var current = source.firstChild; current;) {
            var next = current.nextSibling;
            var wrapper = tryGetWrapperFromEntityPlaceholder(entities, current);
            if (wrapper) {
                anchor = removeUntil(anchor, wrapper);
                if (anchor) {
                    anchor = anchor.nextSibling;
                }
                else {
                    target.appendChild(wrapper);
                }
            }
            else {
                var nodeToInsert = insertClonedNode ? current.cloneNode(true /*deep*/) : current;
                target.insertBefore(nodeToInsert, anchor);
                if ((0, safeInstanceOf_1.default)(nodeToInsert, 'HTMLElement')) {
                    nodeToInsert.querySelectorAll(entitySelector).forEach(function (placeholder) {
                        var _a;
                        var wrapper = tryGetWrapperFromEntityPlaceholder(entities, placeholder);
                        if (wrapper) {
                            (_a = placeholder.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(wrapper, placeholder);
                        }
                    });
                }
            }
            current = next;
        }
        removeUntil(anchor);
    }
    exports.restoreContentWithEntityPlaceholder = restoreContentWithEntityPlaceholder;
    function removeUntil(anchor, nodeToStop) {
        var _a;
        while (anchor && (!nodeToStop || anchor != nodeToStop)) {
            var nodeToRemove = anchor;
            anchor = anchor.nextSibling;
            (_a = nodeToRemove.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(nodeToRemove);
        }
        return anchor;
    }
    function tryGetWrapperFromEntityPlaceholder(entities, node) {
        var _a;
        var id = (0, safeInstanceOf_1.default)(node, 'HTMLElement') &&
            node.classList.contains("_Entity" /* ENTITY_INFO_NAME */) &&
            ((_a = (0, getEntityFromElement_1.default)(node)) === null || _a === void 0 ? void 0 : _a.id);
        var item = id ? entities === null || entities === void 0 ? void 0 : entities[id] : null;
        return !item
            ? null
            : (0, safeInstanceOf_1.default)(item, 'HTMLElement')
                ? item
                : (item === null || item === void 0 ? void 0 : item.canPersist)
                    ? item.element
                    : null;
    }
    function getPlaceholder(entity, entities) {
        entities[entity.id] = entity.wrapper;
        return entity.wrapper.cloneNode(true /*deep*/);
    }
});
//# sourceMappingURL=entityPlaceholderUtils.js.map