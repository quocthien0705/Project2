{"version":3,"file":"VListItem.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/list/VListItem.ts"],"names":[],"mappings":"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","sourcesContent":["import contains from '../utils/contains';\nimport getListTypeFromNode from './getListTypeFromNode';\nimport getStyles from '../style/getStyles';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport moveChildNodes from '../utils/moveChildNodes';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport setBulletListMarkers from './setBulletListMarkers';\nimport setListItemStyle from './setListItemStyle';\nimport setNumberingListMarkers from './setNumberingListMarkers';\nimport setStyles from '../style/setStyles';\nimport toArray from '../jsUtils/toArray';\nimport unwrap from '../utils/unwrap';\nimport wrap from '../utils/wrap';\nimport { createNumberDefinition, createObjectDefinition } from '../metadata/definitionCreators';\nimport { getMetadata, setMetadata } from '../metadata/metadata';\nimport {\n    BulletListType,\n    KnownCreateElementDataIndex,\n    ListType,\n    NumberingListType,\n} from 'roosterjs-editor-types';\nimport type {\n    CompatibleBulletListType,\n    CompatibleListType,\n    CompatibleNumberingListType,\n} from 'roosterjs-editor-types/lib/compatibleTypes';\n\nconst orderListStyles = [null, 'lower-alpha', 'lower-roman'];\nconst unorderedListStyles = ['disc', 'circle', 'square'];\n\nconst MARGIN_BASE = '0in 0in 0in 0.5in';\nconst NEGATIVE_MARGIN = '-.25in';\n\nconst stylesToInherit = ['font-size', 'font-family', 'color'];\nconst attrsToInherit = ['data-ogsc', 'data-ogsb', 'data-ogac', 'data-ogab'];\n\n/**\n * @internal\n * The definition for the number of BulletListType or NumberingListType\n */\nexport const ListStyleDefinitionMetadata = createObjectDefinition<ListStyleMetadata>(\n    {\n        orderedStyleType: createNumberDefinition(\n            true /** isOptional */,\n            undefined /** value **/,\n            NumberingListType.Min,\n            NumberingListType.Max\n        ),\n        unorderedStyleType: createNumberDefinition(\n            true /** isOptional */,\n            undefined /** value **/,\n            BulletListType.Min,\n            BulletListType.Max\n        ),\n    },\n    true /** isOptional */,\n    true /** allowNull */\n);\n\n/**\n * @internal\n * Represents the metadata of the style of a list element\n */\nexport interface ListStyleMetadata {\n    orderedStyleType?: NumberingListType | CompatibleNumberingListType;\n    unorderedStyleType?: BulletListType | CompatibleBulletListType;\n}\n\n/**\n * !!! Never directly create instance of this class. It should be created within VList class !!!\n *\n * Represent a list item.\n *\n * A list item is normally wrapped using a LI tag. But this class is only a logical item,\n * it can be a LI tag, or another other type of node which means it is actually not a list item.\n * That can happen after we do \"outdent\" on a 1-level list item, then it becomes not a list item.\n */\nexport default class VListItem {\n    private listTypes: (ListType | CompatibleListType)[];\n    private node: HTMLLIElement;\n    private dummy: boolean;\n    private newListStart: number | undefined = undefined;\n\n    /**\n     * Construct a new instance of VListItem class\n     * @param node The DOM node for this item\n     * @param listTypes An array represents list types of all parent and current level.\n     * Skip this parameter for a non-list item.\n     */\n    constructor(\n        node: Node,\n        ...listTypes: (\n            | ListType.Ordered\n            | ListType.Unordered\n            | CompatibleListType.Ordered\n            | CompatibleListType.Unordered\n        )[]\n    ) {\n        if (!node) {\n            throw new Error('node must not be null');\n        }\n\n        this.node = safeInstanceOf(node, 'HTMLLIElement')\n            ? node\n            : (wrap(node, KnownCreateElementDataIndex.BlockListItem) as HTMLLIElement);\n        const display = this.node.style.display;\n\n        this.dummy = display != 'list-item' && display != '';\n\n        // Always add a None list type in front of all other types to represent non-list scenario.\n        this.listTypes = [ListType.None, ...listTypes];\n    }\n\n    /**\n     * Get type of current list item\n     */\n    getListType(): ListType | CompatibleListType {\n        return this.listTypes[this.listTypes.length - 1];\n    }\n\n    /**\n     * Get the levels of this list item.\n     */\n    getLevel(): number {\n        return this.listTypes.length - 1;\n    }\n\n    /**\n     * Get DOM node of this list item\n     */\n    getNode(): HTMLLIElement {\n        return this.node;\n    }\n\n    /**\n     * Get the Start Number of the new List\n     */\n    getNewListStart(): number | undefined {\n        return this.newListStart;\n    }\n\n    /**\n     * Check if a given node is contained by this list item\n     * @param node The node to check\n     */\n    contains(node: Node): boolean {\n        return contains(this.node, node, true /*treatSameNodeAsContain*/);\n    }\n\n    /**\n     * Check if this item is a dummy item.\n     * A dummy item is also represented by LI tag, but it won't render a bullet (for Unordered list) or a number (for Ordered list)\n     * normally it has CSS style display set to a value other than \"list-item\"\n     */\n    isDummy() {\n        return this.dummy;\n    }\n\n    /**\n     * @deprecated Always return false\n     */\n    isOrphanItem(): boolean {\n        return false;\n    }\n\n    /**\n     * @deprecated\n     */\n    canMerge(item: VListItem): boolean {\n        if (!item?.isOrphanItem() || this.listTypes.length != item.listTypes.length) {\n            return false;\n        }\n\n        return this.listTypes.every((type, index) => item.listTypes[index] == type);\n    }\n\n    /**\n     * @deprecated\n     */\n    mergeItems(items: VListItem[]) {\n        const nodesToWrap = items?.map(item => item.node) || [];\n        const targetNodes = wrapIfNotBlockNode(\n            nodesToWrap,\n            true /*checkFirst*/,\n            false /*checkLast*/\n        );\n        targetNodes.forEach(node => this.node.appendChild(node));\n    }\n\n    /**\n     * Indent this item\n     * If this is not an list item, it will be no op\n     */\n    indent() {\n        if (this.node.style.marginLeft == NEGATIVE_MARGIN) {\n            this.node.style.margin = '';\n            this.node.style.marginLeft = '';\n            return;\n        }\n\n        const listType = this.getListType();\n        if (listType != ListType.None) {\n            this.listTypes.push(listType);\n        }\n    }\n\n    /**\n     * Outdent this item\n     * If this item is already not an list item, it will be no op\n     * @param preventItemRemoval Whether prevent the list item to be removed for the listItem by default false\n     */\n    outdent(preventItemRemoval: boolean = false) {\n        const expectedLength = preventItemRemoval ? 2 : 1;\n        if (this.listTypes.length > expectedLength) {\n            this.listTypes.pop();\n        }\n    }\n\n    /**\n     * Add negative margin to the List item\n     */\n    addNegativeMargins() {\n        this.node.style.margin = MARGIN_BASE;\n        this.node.style.marginLeft = NEGATIVE_MARGIN;\n    }\n\n    /**\n     * Change list type of this item\n     * @param targetType The target list type to change to\n     */\n    changeListType(targetType: ListType | CompatibleListType) {\n        if (targetType == ListType.None) {\n            this.listTypes = [targetType];\n        } else {\n            this.outdent();\n            this.listTypes.push(targetType);\n        }\n    }\n\n    /**\n     * Set whether the item is a dummy item\n     * @param isDummy Whether the item is a dummy item\n     */\n    setIsDummy(isDummy: boolean) {\n        this.dummy = isDummy;\n    }\n\n    /**\n     * Set the start Number of the new list\n     * @param isDummy Whether the item is a dummy item\n     */\n    setNewListStart(startNumber: number) {\n        this.newListStart = startNumber;\n    }\n\n    /**\n     * Apply the list style type\n     * @param rootList the vList that receives the style\n     * @param index the list item index\n     */\n    applyListStyle(rootList: HTMLOListElement | HTMLUListElement, index: number) {\n        const style = getMetadata<ListStyleMetadata>(rootList, ListStyleDefinitionMetadata);\n        // The list just need to be styled if it is at top level, so the listType length for this Vlist must be 2.\n        const isFirstLevel = this.listTypes.length < 3;\n        if (style) {\n            if (\n                isFirstLevel &&\n                this.listTypes[1] === ListType.Unordered &&\n                style.unorderedStyleType\n            ) {\n                setBulletListMarkers(this.node, style.unorderedStyleType);\n            } else if (\n                isFirstLevel &&\n                this.listTypes[1] === ListType.Ordered &&\n                style.orderedStyleType\n            ) {\n                setNumberingListMarkers(this.node, style.orderedStyleType, index);\n            } else {\n                this.node.style.removeProperty('list-style-type');\n            }\n        }\n    }\n\n    /**\n     * Write the change result back into DOM\n     * @param listStack current stack of list elements\n     * @param originalRoot Original list root element. It will be reused when write back if possible\n     * @param shouldReuseAllAncestorListElements Optional - defaults to false. If true, only make\n     *              sure the direct parent of this list matches the list types when writing back.\n     */\n    writeBack(\n        listStack: Node[],\n        originalRoot?: HTMLOListElement | HTMLUListElement,\n        shouldReuseAllAncestorListElements: boolean = false\n    ) {\n        let nextLevel = 1;\n\n        if (shouldReuseAllAncestorListElements) {\n            // Remove any un-needed lists from the stack.\n            if (listStack.length > this.listTypes.length) {\n                listStack.splice(this.listTypes.length);\n            }\n\n            // 1. If the listStack is the same length as the listTypes for this item, check\n            // if the last item needs to change, and remove it if needed. We can always re-use\n            // the other lists even if the type doesn't match - since the display is the same\n            // as long as the list immediately surrounding the item is correct.\n            const listStackEndIndex = listStack.length - 1;\n            if (\n                listStackEndIndex === this.listTypes.length - 1 && // they are the same length\n                getListTypeFromNode(listStack[listStackEndIndex]) !==\n                    this.listTypes[listStackEndIndex]\n            ) {\n                listStack.splice(listStackEndIndex);\n            }\n\n            nextLevel = listStack.length;\n        } else {\n            // 1. Determine list elements that we can reuse\n            // e.g.:\n            //    passed in listStack: Fragment > OL > UL > OL\n            //    local listTypes:     null     > OL > UL > UL > OL\n            //    then Fragment > OL > UL can be reused\n            for (; nextLevel < listStack.length; nextLevel++) {\n                if (getListTypeFromNode(listStack[nextLevel]) !== this.listTypes[nextLevel]) {\n                    listStack.splice(nextLevel);\n                    break;\n                }\n            }\n        }\n\n        // 2. Add new list elements\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then we need to create a UL and a OL tag\n        for (; nextLevel < this.listTypes.length; nextLevel++) {\n            const stackLength = listStack.length - 1;\n            const newList = createListElement(\n                listStack[0],\n                this.listTypes[nextLevel],\n                nextLevel,\n                originalRoot\n            );\n\n            listStack[stackLength].appendChild(newList);\n            listStack.push(newList);\n\n            //If the current node parent is in the same deep child index,\n            //apply the styles of the current parent list to the new list\n            if (this.getDeepChildIndex(originalRoot) == stackLength) {\n                const listStyleType = this.node.parentElement?.style.listStyleType;\n                if (\n                    listStyleType &&\n                    getTagOfNode(this.node.parentElement) === getTagOfNode(newList)\n                ) {\n                    newList.style.listStyleType = listStyleType;\n                }\n            }\n        }\n        // 3. Add current node into deepest list element\n        listStack[listStack.length - 1].appendChild(this.node);\n        this.node.style.setProperty('display', this.dummy ? 'block' : null);\n\n        // 4. Inherit styles of the child element to the li, so we are able to apply the styles to the ::marker\n        if (this.listTypes.length > 1) {\n            setListItemStyle(this.node, stylesToInherit, true /*isCssStyle*/);\n            setListItemStyle(this.node, attrsToInherit, false /*isCssStyle*/);\n        }\n\n        // 5. If this is not a list item now, need to unwrap the LI node and do proper handling\n        if (this.listTypes.length <= 1) {\n            // If original <LI> node has styles for font and color, we need to apply it to new parent\n            const isLi = getTagOfNode(this.node) == 'LI';\n            const stylesToApply = isLi\n                ? {\n                      'font-family': this.node.style.fontFamily,\n                      'font-size': this.node.style.fontSize,\n                      color: this.node.style.color,\n                  }\n                : undefined;\n\n            const childNodes = isLi ? getChildrenAndUnwrap(this.node) : [this.node];\n\n            if (stylesToApply) {\n                for (let i = 0; i < childNodes.length; i++) {\n                    if (safeInstanceOf(childNodes[i], 'Text')) {\n                        childNodes[i] = wrap(childNodes[i], 'span');\n                    }\n\n                    const node = childNodes[i];\n\n                    if (safeInstanceOf(node, 'HTMLElement')) {\n                        const styles = {\n                            ...stylesToApply,\n                            ...getStyles(node),\n                        };\n                        setStyles(node, styles);\n\n                        attrsToInherit.forEach(attr => {\n                            const attrValue = this.node.getAttribute(attr);\n\n                            if (attrValue) {\n                                node.setAttribute(attr, attrValue);\n                            }\n                        });\n                    }\n                }\n            }\n\n            wrapIfNotBlockNode(childNodes, true /*checkFirst*/, true /*checkLast*/);\n        }\n    }\n\n    /**\n     * Get the index of how deep is the current node parent list inside of the original root list.\n     * @example In the following structure this function would return 2\n     * ```html\n     *  <ol> <!-- original Root -->\n     *      <ol>\n     *          <ol>\n     *              <li></li> <!-- this.node  -->\n     *          </ol>\n     *      </ol>\n     *  </ol>\n     * ```\n     * @param originalRoot The root list\n     * @returns -1  if the node does not have parent element or if original root was not provided,\n     *              else, how deep is the parent element inside of the original root.\n     */\n    private getDeepChildIndex(originalRoot: HTMLOListElement | HTMLUListElement | undefined) {\n        let parentElement = this.node.parentElement;\n        if (originalRoot && parentElement) {\n            let deepIndex = 0;\n            while (parentElement && parentElement != originalRoot) {\n                deepIndex++;\n                parentElement = parentElement?.parentElement || null;\n            }\n            return deepIndex;\n        }\n        return -1;\n    }\n}\n\nfunction createListElement(\n    newRoot: Node,\n    listType: ListType | CompatibleListType,\n    nextLevel: number,\n    originalRoot?: HTMLOListElement | HTMLUListElement\n): HTMLOListElement | HTMLUListElement {\n    const doc = newRoot.ownerDocument!;\n    let result: HTMLOListElement | HTMLUListElement;\n\n    // Try to reuse the existing root element\n    // It can be reused when\n    // 1. Current list item is level 1 (top level), AND\n    // 2. Original root exists, AND\n    // 3. They have the same list type AND\n    // 4. The original root is not used yet\n    if (nextLevel == 1 && originalRoot && listType == getListTypeFromNode(originalRoot)) {\n        if (contains(newRoot, originalRoot)) {\n            // If it is already used, let's clone one and remove ID to avoid duplicating ID\n            result = originalRoot.cloneNode(false /*deep*/) as HTMLOListElement | HTMLUListElement;\n            (<HTMLOListElement>result).removeAttribute('id');\n        } else {\n            // Remove all child nodes, they will be added back later when write back other items\n            moveChildNodes(originalRoot);\n            result = originalRoot;\n        }\n    } else {\n        // Can't be reused, can't clone, let's create a new one\n        result = doc.createElement(listType == ListType.Ordered ? 'ol' : 'ul');\n    }\n\n    if (originalRoot?.style.marginTop == '0px' && originalRoot?.style.marginBottom == '0px') {\n        result.style.marginTop = '0px';\n        result.style.marginBottom = '0px';\n    }\n\n    // Always maintain the metadata saved in the list\n    if (originalRoot && nextLevel == 1 && listType != getListTypeFromNode(originalRoot)) {\n        const style = getMetadata<ListStyleMetadata>(originalRoot, ListStyleDefinitionMetadata);\n        if (style) {\n            setMetadata(result, style, ListStyleDefinitionMetadata);\n        }\n    }\n\n    if (listType == ListType.Ordered && nextLevel > 1) {\n        result.style.setProperty(\n            'list-style-type',\n            orderListStyles[(nextLevel - 1) % orderListStyles.length]\n        );\n    }\n\n    if (listType == ListType.Unordered && nextLevel > 1) {\n        result.style.setProperty(\n            'list-style-type',\n            unorderedListStyles[(nextLevel - 1) % unorderedListStyles.length]\n        );\n    }\n\n    return result;\n}\n\nfunction wrapIfNotBlockNode(nodes: Node[], checkFirst: boolean, checkLast: boolean): Node[] {\n    if (\n        nodes.length > 0 &&\n        (!checkFirst || !isBlockElement(nodes[0])) &&\n        (!checkLast || !isBlockElement(nodes[nodes.length]))\n    ) {\n        nodes = [wrap(nodes)];\n    }\n\n    return nodes;\n}\n\nfunction getChildrenAndUnwrap(node: Node): Node[] {\n    const result = toArray(node.childNodes);\n    unwrap(node);\n    return result;\n}\n"]}