{"version":3,"file":"VListChain.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/list/VListChain.ts"],"names":[],"mappings":"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","sourcesContent":["import arrayPush from '../jsUtils/arrayPush';\nimport getRootListNode from './getRootListNode';\nimport isNodeAfter from '../utils/isNodeAfter';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport queryElements from '../utils/queryElements';\nimport VList from './VList';\nimport { ListType } from 'roosterjs-editor-types';\nimport type { RegionBase } from 'roosterjs-editor-types';\n\nconst CHAIN_NAME_PREFIX = '__List_Chain_';\nconst CHAIN_DATASET_NAME = 'listchain';\nconst AFTER_CURSOR_DATASET_NAME = 'listchainafter';\nlet lastChainIndex = 0;\n\n/**\n * Represent a chain of list nodes.\n * A chain of lists is a virtual link of lists that have continuous numbers, when editor one of them,\n * all others should also be updated in order to main the list number to be continuous.\n */\nexport default class VListChain {\n    private lastNumber = 0;\n    private lastNumberBeforeCursor = 0;\n\n    /**\n     * Create an array of VListChain from current region in editor\n     * @param region The region to create VListChain from\n     * @param currentNode Optional current node, used for mark lists that are after this node\n     * @param nameGenerator Used by test code only\n     */\n    static createListChains(\n        region: RegionBase | RegionBase[],\n        currentNode?: Node,\n        nameGenerator?: () => string\n    ): VListChain[] {\n        const regions = Array.isArray(region) ? region : region ? [region] : [];\n        const result: VListChain[] = [];\n        regions.forEach(region => {\n            const chains: VListChain[] = [];\n            let lastList: HTMLOListElement;\n\n            queryElements(region.rootNode, 'ol', ol => {\n                const list = getRootListNode(region, 'ol', ol);\n\n                if (lastList != list) {\n                    const chain =\n                        chains.filter(c => c.canAppendToTail(list))[0] ||\n                        new VListChain(region, (nameGenerator || createListChainName)());\n                    const index = chains.indexOf(chain);\n                    const afterCurrentNode = !!currentNode && isNodeAfter(list, currentNode);\n\n                    if (!afterCurrentNode) {\n                        // Make sure current one is at the front if current block has not been met, so that\n                        // the first chain is always the nearest one from current node\n                        if (index >= 0) {\n                            chains.splice(index, 1);\n                        }\n\n                        chains.unshift(chain);\n                    } else if (index < 0) {\n                        chains.push(chain);\n                    }\n\n                    chain.append(list, afterCurrentNode);\n                    lastList = list;\n                }\n            });\n\n            arrayPush(result, chains);\n        });\n\n        return result;\n    }\n\n    /**\n     * Check if a list with the given start number can be appended next to the last list before cursor\n     * @param startNumber The start number of the new list\n     */\n    canAppendAtCursor(startNumber: number): boolean {\n        return startNumber > 1 && this.lastNumberBeforeCursor + 1 == startNumber;\n    }\n\n    /**\n     * Create a VList to wrap the block of the given node, and append to current chain\n     * @param container The container node to create list at\n     * @param startNumber Start number of the new list\n     */\n    createVListAtBlock(container: Node, startNumber: number): VList | null {\n        if (container && container.parentNode) {\n            const list = container.ownerDocument!.createElement('ol');\n\n            list.start = startNumber;\n            this.applyChainName(list);\n            container.parentNode.insertBefore(list, container);\n\n            const vList = new VList(list);\n\n            vList.appendItem(container, ListType.None);\n            return vList;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * After change the lists, commit the change to all lists in this chain to update the list number,\n     * and clear the temporary dataset values added to list node\n     * @param shouldReuseAllAncestorListElements Whether we can parent list item (OL/UL) even if its list type does not match the previous one. @default false\n     * @param disableListChain Whether we want to disable list chain functionality, so splitted list will always restart its number from 1 @default false\n     */\n    commit(shouldReuseAllAncestorListElements?: boolean, disableListChain?: boolean) {\n        const lists = this.getLists();\n        let lastNumber = 0;\n\n        for (let i = 0; i < lists.length; i++) {\n            const list = lists[i];\n\n            if (!disableListChain) {\n                //If there is a list chain sequence, ensure the list chain keep increasing correctly\n                if (list.start > 1) {\n                    list.start = list.start === lastNumber ? lastNumber + 1 : list.start;\n                } else {\n                    list.start = lastNumber + 1;\n                }\n            }\n\n            const vlist = new VList(list);\n            lastNumber = vlist.getLastItemNumber() || 0;\n\n            delete list.dataset[CHAIN_DATASET_NAME];\n            delete list.dataset[AFTER_CURSOR_DATASET_NAME];\n\n            vlist.writeBack(shouldReuseAllAncestorListElements);\n        }\n    }\n\n    /**\n     * Construct a new instance of VListChain class\n     * @param editor Editor object\n     */\n    private constructor(private region: RegionBase, private name: string) {}\n\n    /**\n     * Check if the given list node is can be appended into current list chain\n     * @param list The list node to check\n     */\n    private canAppendToTail(list: HTMLOListElement) {\n        return this.lastNumber + 1 == list.start;\n    }\n\n    /**\n     * Append the given list node into this VListChain\n     * @param list The list node to append\n     * @param isAfterCurrentNode Whether this list is after current node\n     */\n    private append(list: HTMLOListElement, isAfterCurrentNode: boolean) {\n        this.applyChainName(list);\n        this.lastNumber = new VList(list).getLastItemNumber() || 0;\n\n        if (isAfterCurrentNode) {\n            list.dataset[AFTER_CURSOR_DATASET_NAME] = 'true';\n        } else {\n            this.lastNumberBeforeCursor = this.lastNumber;\n        }\n    }\n\n    private applyChainName(list: HTMLOListElement) {\n        list.dataset[CHAIN_DATASET_NAME] = this.name;\n    }\n\n    private getLists() {\n        return queryElements(\n            this.region.rootNode,\n            `ol[data-${CHAIN_DATASET_NAME}=${this.name}]`\n        ).filter(node => isNodeInRegion(this.region, node)) as HTMLOListElement[];\n    }\n}\n\nfunction createListChainName() {\n    return CHAIN_NAME_PREFIX + lastChainIndex++;\n}\n"]}