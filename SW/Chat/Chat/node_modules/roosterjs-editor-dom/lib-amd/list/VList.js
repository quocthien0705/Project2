define(["require", "exports", "tslib", "../utils/changeElementTag", "./getListTypeFromNode", "../utils/getTagOfNode", "../utils/isBlockElement", "../utils/isNodeEmpty", "../selection/Position", "../utils/queryElements", "../utils/safeInstanceOf", "../utils/splitParentNode", "../jsUtils/toArray", "../utils/unwrap", "./VListItem", "../utils/wrap", "../metadata/metadata"], function (require, exports, tslib_1, changeElementTag_1, getListTypeFromNode_1, getTagOfNode_1, isBlockElement_1, isNodeEmpty_1, Position_1, queryElements_1, safeInstanceOf_1, splitParentNode_1, toArray_1, unwrap_1, VListItem_1, wrap_1, metadata_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Represent a bullet or a numbering list
     *
     * @example
     * A VList is a logical representation of list items, it contains an item array with node and list type stack.
     * e.g. We have a list like this
     * ```html
     * <ol>
     *   <li>item 1</li>
     *   <li>item 2</li>
     *   <ul>
     *     <li>item 2.1</li>
     *     <li>item 2.2</li>
     *   <ul>
     * </ol>
     * ```
     *
     * A VList of this list will be like this:
     * ```javascript
     * {
     *   rootList: (OL node),
     *   items: [{
     *       node: (LI node with 'item 1'),
     *       listTypes: [null, OL],
     *     }, {
     *       node: (LI node with 'item 2'),
     *       listTypes: [null, OL],
     *     }, {
     *       node: (LI node with 'item 2.1),
     *       listTypes: [null, OL, UL],
     *     }, {
     *       node: (LI node with 'item 2.2'),
     *       listTypes: [null, OL, UL],
     *     }
     *   ]
     * }
     * ```
     *
     * When we want to outdent item 2.1, we just need to remove the last "UL" from listTypes of item 2.1, then
     * the writeBack() function will handle everything related to DOM change
     */
    var VList = /** @class */ (function () {
        /**
         * Create a new instance of VList class
         * @param rootList The root list element, can be either OL or UL tag
         */
        function VList(rootList) {
            this.rootList = rootList;
            this.items = [];
            if (!rootList) {
                throw new Error('rootList must not be null');
            }
            // Before populate items, we need to normalize the list to make sure it is in a correct format
            // otherwise further action may mass thing up.
            //
            // There are two kinds of normalization to perform.
            // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node
            // Please see comment for VListItem.isOrphanItem() for more information about orphan node
            // e.g.:
            // ```HTML
            // <ol>
            //   <li>item 1</li>
            //   <div>item 2</div>
            // </ol>
            // ```
            // After this step, it should become:
            // ```html
            // <ol>
            //   <li>item 1
            //     <div>item 2</div>
            //   <li>
            // </ol>
            // ```
            moveChildNodesToLi(this.rootList);
            (0, queryElements_1.default)(this.rootList, 'ol,ul', moveChildNodesToLi);
            // 2. Move LI node embedded into another LI node out to directly under OL/UL node
            // Ideally browser we do this for us automatically when out the HTML into DOM. However after
            // step 1, it is possible that we move some LI node into another one. e.g:
            // ```HTML
            // <ol>
            //   <li>item 1</li>
            //   <div>
            //     item 1.1
            //     <li>item 3</li>
            //   </div>
            // </ol>
            // ```
            // See that the second LI tag is not directly under OL, so after step 1, this will become:
            // ```html
            // <ol>
            //   <li>item 1
            //     <div>
            //       item 1.1
            //       <li>item 2</li>
            //     </div>
            //   <li>
            // </ol>
            // ```
            // Now we have a LI tag embedded into another LI tag. So we need step 2 to move the inner LI tag out to be:
            // ```html
            // <ol>
            //   <li>item1
            //     <div>item 1.1</div>
            //   </li>
            //   <li><div>item2</div></li>
            // </ol>
            // ```
            (0, queryElements_1.default)(this.rootList, 'li', moveLiToList);
            this.populateItems(this.rootList);
        }
        /**
         * Check if this list contains the given node
         * @param node The node to check
         */
        VList.prototype.contains = function (node) {
            // We don't check if the node is contained by this.rootList here, because after some operation,
            // it is possible a node is logically contained by this list but the container list item hasn't
            // been put under this.rootList in DOM tree yet.
            return this.items.some(function (item) { return item.contains(node); });
        };
        /**
         * Get list number of the last item in this VList.
         * If there is no order list item, result will be undefined
         */
        VList.prototype.getLastItemNumber = function () {
            var start = this.getStart();
            return start === undefined
                ? start
                : start -
                    1 +
                    this.items.filter(function (item) {
                        return item.getListType() == 1 /* Ordered */ &&
                            item.getLevel() == 1 &&
                            !item.isDummy();
                    }).length;
        };
        /**
         * Write the result back into DOM tree
         * After that, this VList becomes unavailable because we set this.rootList to null
         *
         * @param shouldReuseAllAncestorListElements Optional - defaults to false.
         * @param disableListChain Whether we want to disable list chain functionality. @default false
         */
        VList.prototype.writeBack = function (shouldReuseAllAncestorListElements, disableListChain) {
            var _this = this;
            if (!this.rootList) {
                throw new Error('rootList must not be null');
            }
            var doc = this.rootList.ownerDocument;
            var listStack = [doc.createDocumentFragment()];
            var placeholder = doc.createTextNode('');
            var start = this.getStart() || 1;
            var lastList;
            // Use a placeholder to hold the position since the root list may be moved into document fragment later
            this.rootList.parentNode.replaceChild(placeholder, this.rootList);
            this.items.forEach(function (item) {
                var newListStart = item.getNewListStart();
                if (newListStart && newListStart != start) {
                    listStack.splice(1, listStack.length - 1);
                    start = newListStart;
                }
                item.writeBack(listStack, _this.rootList, shouldReuseAllAncestorListElements);
                var topList = listStack[1];
                item.applyListStyle(_this.rootList, start);
                if ((0, safeInstanceOf_1.default)(topList, 'HTMLOListElement')) {
                    if (lastList != topList) {
                        if (start == 1) {
                            topList.removeAttribute('start');
                        }
                        else {
                            topList.start = start;
                        }
                    }
                    if (item.getLevel() == 1 && !item.isDummy() && !disableListChain) {
                        start++;
                    }
                }
                lastList = topList;
            });
            // Restore the content to the position of placeholder
            placeholder.parentNode.replaceChild(listStack[0], placeholder);
        };
        /**
         * Sets the New List Start Property, that is going to be used to create a new List in the WriteBack function
         * @param separator The HTML element that indicates when to split the VList
         * @param startNumber The start number of the new List
         */
        VList.prototype.split = function (separator, startNumber) {
            if (!this.rootList) {
                throw new Error('rootList must not be null');
            }
            //Traverse the items of the VList, when the separator is found, set the New List Start Property
            for (var index = 0; index < this.items.length; index++) {
                if (this.items[index].getNode() == separator) {
                    this.items[index].setNewListStart(startNumber);
                    return;
                }
            }
        };
        VList.prototype.setIndentation = function (start, end, indentation, softOutdent, preventItemRemoval) {
            var _this = this;
            if (preventItemRemoval === void 0) { preventItemRemoval = false; }
            var shouldAddMargin = false;
            this.findListItems(start, end, function (item) {
                shouldAddMargin = shouldAddMargin || _this.items.indexOf(item) == 0;
                indentation == 1 /* Decrease */
                    ? softOutdent && !item.isDummy()
                        ? item.setIsDummy(true /*isDummy*/)
                        : item.outdent(preventItemRemoval)
                    : item.indent();
            });
            if (shouldAddMargin && preventItemRemoval) {
                for (var index = 0; index < this.items.length; index++) {
                    this.items[index].addNegativeMargins();
                }
            }
        };
        /**
         * Set alignment of the given range of this list
         * @param start Start position to operate from
         * @param end End position to operate to
         * @param alignment Align items left, center or right
         */
        VList.prototype.setAlignment = function (start, end, alignment) {
            this.rootList.style.display = 'flex';
            this.rootList.style.flexDirection = 'column';
            this.findListItems(start, end, function (item) {
                var align = 'start';
                if (alignment == 1 /* Center */) {
                    align = 'center';
                }
                else if (alignment == 2 /* Right */) {
                    align = 'end';
                }
                item.getNode().style.alignSelf = align;
            });
        };
        /**
         * Remove margins of a new list
         */
        VList.prototype.removeMargins = function () {
            if (!this.rootList.style.marginTop && !this.rootList.style.marginBottom) {
                this.rootList.style.marginTop = '0px';
                this.rootList.style.marginBottom = '0px';
            }
        };
        /**
         * Change list type of the given range of this list.
         * If some of the items are not real list item yet, this will make them to be list item with given type
         * If all items in the given range are already in the type to change to, this becomes an outdent operation
         * @param start Start position to operate from
         * @param end End position to operate to
         * @param targetType Target list type
         */
        VList.prototype.changeListType = function (start, end, targetType) {
            var needChangeType = false;
            this.findListItems(start, end, function (item) {
                needChangeType = needChangeType || item.getListType() != targetType;
            });
            this.findListItems(start, end, function (item) {
                return needChangeType ? item.changeListType(targetType) : item.outdent();
            });
        };
        /**
         * Change list style of the given range of this list.
         * If some of the items are not real list item yet, this will make them to be list item with given style
         * @param orderedStyle The style of ordered list
         * @param unorderedStyle The style of unordered list
         */
        VList.prototype.setListStyleType = function (orderedStyle, unorderedStyle) {
            var style = (0, metadata_1.getMetadata)(this.rootList, VListItem_1.ListStyleDefinitionMetadata);
            var styleMetadata = createListStyleMetadata(style, orderedStyle, unorderedStyle);
            (0, metadata_1.setMetadata)(this.rootList, styleMetadata, VListItem_1.ListStyleDefinitionMetadata);
        };
        /**
         * Append a new item to this VList
         * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped
         * @param type Type of this list item, can be ListType.None
         */
        VList.prototype.appendItem = function (node, type) {
            var nodeTag = (0, getTagOfNode_1.default)(node);
            // Change DIV tag to SPAN. Otherwise we cannot create new list item by Enter key in Safari
            if (nodeTag == 'DIV') {
                node = (0, changeElementTag_1.default)(node, 'LI');
            }
            else if (nodeTag != 'LI') {
                node = (0, wrap_1.default)(node, 'LI');
            }
            this.items.push(type == 0 /* None */
                ? new VListItem_1.default(node)
                : new VListItem_1.default(node, type));
        };
        /**
         * Merge the given VList into current VList.
         * - All list items will be removed from the given VList and added into this list.
         * - The root node of the given VList will be removed from DOM tree
         * - If there are orphan items in the given VList, they will be merged into the last item
         *   of this list if any.
         * @param list The vList to merge from
         */
        VList.prototype.mergeVList = function (list) {
            var _this = this;
            var _a;
            if (list && list != this) {
                list.items.forEach(function (item) { return _this.items.push(item); });
                list.items.splice(0, list.items.length);
                (_a = list.rootList.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(list.rootList);
            }
        };
        /**
         * Get the index of the List Item in the current List
         * If the root list is:
         * Ordered list, the listIndex start count is going to be the start property of the OL - 1,
         * @example For example if we want to find the index of Item 2 in the list below, the returned index is going to be 6
         *  * ```html
         * <ol start="5">
         *   <li>item 1</li>
         *   <li>item 2</li> <!-- Node to find -->
         *   <li>item 3</li>
         * </ol>
         * ```
         * Unordered list, the listIndex start count starts from 0
         * @example For example if we want to find the index of Item 2 in the list below, the returned index is going to be 2
         * ```html
         * <ul>
         *   <li>item 1</li>
         *   <li>item 2</li> <!-- Node to find -->
         *   <li>item 3</li>
         * </ul>
         * ```
         * @param input List item to find in the root list
         */
        VList.prototype.getListItemIndex = function (input) {
            if (this.items) {
                var listIndex = (this.getStart() || 1) - 1;
                for (var index = 0; index < this.items.length; index++) {
                    var child = this.items[index];
                    if (child.getLevel() == 1 && !child.isDummy()) {
                        listIndex++;
                    }
                    if (child.getNode() == input) {
                        return listIndex;
                    }
                }
            }
            return -1;
        };
        /**
         * Get the Start property of the root list of this VList
         * @returns Start number of the list
         */
        VList.prototype.getStart = function () {
            return (0, safeInstanceOf_1.default)(this.rootList, 'HTMLOListElement') ? this.rootList.start : undefined;
        };
        VList.prototype.findListItems = function (start, end, callback) {
            if (this.items.length == 0) {
                return [];
            }
            var listStartPos = new Position_1.default(this.items[0].getNode(), 0 /* Begin */);
            var listEndPos = new Position_1.default(this.items[this.items.length - 1].getNode(), -1 /* End */);
            var startIndex = listStartPos.isAfter(start) ? 0 : -1;
            var endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);
            this.items.forEach(function (item, index) {
                startIndex = item.contains(start.node) ? index : startIndex;
                endIndex = item.contains(end.node) ? index : endIndex;
            });
            startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;
            endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;
            var result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];
            if (callback) {
                result.forEach(callback);
            }
            return result;
        };
        VList.prototype.populateItems = function (list, listTypes) {
            var _this = this;
            if (listTypes === void 0) { listTypes = []; }
            var type = (0, getListTypeFromNode_1.default)(list);
            var items = (0, toArray_1.default)(list.childNodes);
            items.forEach(function (item) {
                var newListTypes = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(listTypes), false), [type], false);
                if ((0, getListTypeFromNode_1.isListElement)(item)) {
                    _this.populateItems(item, newListTypes);
                }
                else if (item.nodeType != 3 /* Text */ || (item.nodeValue || '').trim() != '') {
                    _this.items.push(new (VListItem_1.default.bind.apply(VListItem_1.default, (0, tslib_1.__spreadArray)([void 0, item], (0, tslib_1.__read)(newListTypes), false)))());
                }
            });
        };
        return VList;
    }());
    exports.default = VList;
    //Normalization
    // Step 1: Move all non-LI direct children under list into LI
    // e.g.
    // From: <ul><li>line 1</li>line 2</ul>
    // To:   <ul><li>line 1<div>line 2</div></li></ul>
    function moveChildNodesToLi(list) {
        var currentItem = null;
        (0, toArray_1.default)(list.childNodes).forEach(function (child) {
            if ((0, getTagOfNode_1.default)(child) == 'LI') {
                currentItem = child;
            }
            else if ((0, getListTypeFromNode_1.isListElement)(child)) {
                currentItem = null;
            }
            else if (currentItem && !(0, isNodeEmpty_1.default)(child, true /*trimContent*/)) {
                currentItem.appendChild((0, isBlockElement_1.default)(child) ? child : (0, wrap_1.default)(child));
            }
        });
    }
    // Step 2: Move nested LI up to under list directly
    // e.g.
    // From: <ul><li>line 1<li>line 2</li>line 3</li></ul>
    // To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>
    function moveLiToList(li) {
        while (!(0, getListTypeFromNode_1.isListElement)(li.parentNode)) {
            (0, splitParentNode_1.default)(li, true /*splitBefore*/);
            var furtherNodes = (0, toArray_1.default)(li.parentNode.childNodes).slice(1);
            if (furtherNodes.length > 0) {
                if (!(0, isBlockElement_1.default)(furtherNodes[0])) {
                    furtherNodes = [(0, wrap_1.default)(furtherNodes)];
                }
                furtherNodes.forEach(function (node) { return li.appendChild(node); });
            }
            (0, unwrap_1.default)(li.parentNode);
        }
    }
    function getValidValue() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        return values.filter(function (x) { return x !== undefined; })[0];
    }
    function createListStyleMetadata(style, orderedStyle, unorderedStyle) {
        return {
            orderedStyleType: getValidValue(orderedStyle, style === null || style === void 0 ? void 0 : style.orderedStyleType, 1 /* Decimal */),
            unorderedStyleType: getValidValue(unorderedStyle, style === null || style === void 0 ? void 0 : style.unorderedStyleType, 1 /* Disc */),
        };
    }
});
//# sourceMappingURL=VList.js.map