define(["require", "exports", "tslib", "../utils/contains", "./getListTypeFromNode", "../style/getStyles", "../utils/getTagOfNode", "../utils/isBlockElement", "../utils/moveChildNodes", "../utils/safeInstanceOf", "./setBulletListMarkers", "./setListItemStyle", "./setNumberingListMarkers", "../style/setStyles", "../jsUtils/toArray", "../utils/unwrap", "../utils/wrap", "../metadata/definitionCreators", "../metadata/metadata"], function (require, exports, tslib_1, contains_1, getListTypeFromNode_1, getStyles_1, getTagOfNode_1, isBlockElement_1, moveChildNodes_1, safeInstanceOf_1, setBulletListMarkers_1, setListItemStyle_1, setNumberingListMarkers_1, setStyles_1, toArray_1, unwrap_1, wrap_1, definitionCreators_1, metadata_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListStyleDefinitionMetadata = void 0;
    var orderListStyles = [null, 'lower-alpha', 'lower-roman'];
    var unorderedListStyles = ['disc', 'circle', 'square'];
    var MARGIN_BASE = '0in 0in 0in 0.5in';
    var NEGATIVE_MARGIN = '-.25in';
    var stylesToInherit = ['font-size', 'font-family', 'color'];
    var attrsToInherit = ['data-ogsc', 'data-ogsb', 'data-ogac', 'data-ogab'];
    /**
     * @internal
     * The definition for the number of BulletListType or NumberingListType
     */
    exports.ListStyleDefinitionMetadata = (0, definitionCreators_1.createObjectDefinition)({
        orderedStyleType: (0, definitionCreators_1.createNumberDefinition)(true /** isOptional */, undefined /** value **/, 1 /* Min */, 20 /* Max */),
        unorderedStyleType: (0, definitionCreators_1.createNumberDefinition)(true /** isOptional */, undefined /** value **/, 1 /* Min */, 9 /* Max */),
    }, true /** isOptional */, true /** allowNull */);
    /**
     * !!! Never directly create instance of this class. It should be created within VList class !!!
     *
     * Represent a list item.
     *
     * A list item is normally wrapped using a LI tag. But this class is only a logical item,
     * it can be a LI tag, or another other type of node which means it is actually not a list item.
     * That can happen after we do "outdent" on a 1-level list item, then it becomes not a list item.
     */
    var VListItem = /** @class */ (function () {
        /**
         * Construct a new instance of VListItem class
         * @param node The DOM node for this item
         * @param listTypes An array represents list types of all parent and current level.
         * Skip this parameter for a non-list item.
         */
        function VListItem(node) {
            var listTypes = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                listTypes[_i - 1] = arguments[_i];
            }
            this.newListStart = undefined;
            if (!node) {
                throw new Error('node must not be null');
            }
            this.node = (0, safeInstanceOf_1.default)(node, 'HTMLLIElement')
                ? node
                : (0, wrap_1.default)(node, 4 /* BlockListItem */);
            var display = this.node.style.display;
            this.dummy = display != 'list-item' && display != '';
            // Always add a None list type in front of all other types to represent non-list scenario.
            this.listTypes = (0, tslib_1.__spreadArray)([0 /* None */], (0, tslib_1.__read)(listTypes), false);
        }
        /**
         * Get type of current list item
         */
        VListItem.prototype.getListType = function () {
            return this.listTypes[this.listTypes.length - 1];
        };
        /**
         * Get the levels of this list item.
         */
        VListItem.prototype.getLevel = function () {
            return this.listTypes.length - 1;
        };
        /**
         * Get DOM node of this list item
         */
        VListItem.prototype.getNode = function () {
            return this.node;
        };
        /**
         * Get the Start Number of the new List
         */
        VListItem.prototype.getNewListStart = function () {
            return this.newListStart;
        };
        /**
         * Check if a given node is contained by this list item
         * @param node The node to check
         */
        VListItem.prototype.contains = function (node) {
            return (0, contains_1.default)(this.node, node, true /*treatSameNodeAsContain*/);
        };
        /**
         * Check if this item is a dummy item.
         * A dummy item is also represented by LI tag, but it won't render a bullet (for Unordered list) or a number (for Ordered list)
         * normally it has CSS style display set to a value other than "list-item"
         */
        VListItem.prototype.isDummy = function () {
            return this.dummy;
        };
        /**
         * @deprecated Always return false
         */
        VListItem.prototype.isOrphanItem = function () {
            return false;
        };
        /**
         * @deprecated
         */
        VListItem.prototype.canMerge = function (item) {
            if (!(item === null || item === void 0 ? void 0 : item.isOrphanItem()) || this.listTypes.length != item.listTypes.length) {
                return false;
            }
            return this.listTypes.every(function (type, index) { return item.listTypes[index] == type; });
        };
        /**
         * @deprecated
         */
        VListItem.prototype.mergeItems = function (items) {
            var _this = this;
            var nodesToWrap = (items === null || items === void 0 ? void 0 : items.map(function (item) { return item.node; })) || [];
            var targetNodes = wrapIfNotBlockNode(nodesToWrap, true /*checkFirst*/, false /*checkLast*/);
            targetNodes.forEach(function (node) { return _this.node.appendChild(node); });
        };
        /**
         * Indent this item
         * If this is not an list item, it will be no op
         */
        VListItem.prototype.indent = function () {
            if (this.node.style.marginLeft == NEGATIVE_MARGIN) {
                this.node.style.margin = '';
                this.node.style.marginLeft = '';
                return;
            }
            var listType = this.getListType();
            if (listType != 0 /* None */) {
                this.listTypes.push(listType);
            }
        };
        /**
         * Outdent this item
         * If this item is already not an list item, it will be no op
         * @param preventItemRemoval Whether prevent the list item to be removed for the listItem by default false
         */
        VListItem.prototype.outdent = function (preventItemRemoval) {
            if (preventItemRemoval === void 0) { preventItemRemoval = false; }
            var expectedLength = preventItemRemoval ? 2 : 1;
            if (this.listTypes.length > expectedLength) {
                this.listTypes.pop();
            }
        };
        /**
         * Add negative margin to the List item
         */
        VListItem.prototype.addNegativeMargins = function () {
            this.node.style.margin = MARGIN_BASE;
            this.node.style.marginLeft = NEGATIVE_MARGIN;
        };
        /**
         * Change list type of this item
         * @param targetType The target list type to change to
         */
        VListItem.prototype.changeListType = function (targetType) {
            if (targetType == 0 /* None */) {
                this.listTypes = [targetType];
            }
            else {
                this.outdent();
                this.listTypes.push(targetType);
            }
        };
        /**
         * Set whether the item is a dummy item
         * @param isDummy Whether the item is a dummy item
         */
        VListItem.prototype.setIsDummy = function (isDummy) {
            this.dummy = isDummy;
        };
        /**
         * Set the start Number of the new list
         * @param isDummy Whether the item is a dummy item
         */
        VListItem.prototype.setNewListStart = function (startNumber) {
            this.newListStart = startNumber;
        };
        /**
         * Apply the list style type
         * @param rootList the vList that receives the style
         * @param index the list item index
         */
        VListItem.prototype.applyListStyle = function (rootList, index) {
            var style = (0, metadata_1.getMetadata)(rootList, exports.ListStyleDefinitionMetadata);
            // The list just need to be styled if it is at top level, so the listType length for this Vlist must be 2.
            var isFirstLevel = this.listTypes.length < 3;
            if (style) {
                if (isFirstLevel &&
                    this.listTypes[1] === 2 /* Unordered */ &&
                    style.unorderedStyleType) {
                    (0, setBulletListMarkers_1.default)(this.node, style.unorderedStyleType);
                }
                else if (isFirstLevel &&
                    this.listTypes[1] === 1 /* Ordered */ &&
                    style.orderedStyleType) {
                    (0, setNumberingListMarkers_1.default)(this.node, style.orderedStyleType, index);
                }
                else {
                    this.node.style.removeProperty('list-style-type');
                }
            }
        };
        /**
         * Write the change result back into DOM
         * @param listStack current stack of list elements
         * @param originalRoot Original list root element. It will be reused when write back if possible
         * @param shouldReuseAllAncestorListElements Optional - defaults to false. If true, only make
         *              sure the direct parent of this list matches the list types when writing back.
         */
        VListItem.prototype.writeBack = function (listStack, originalRoot, shouldReuseAllAncestorListElements) {
            var _this = this;
            var _a;
            if (shouldReuseAllAncestorListElements === void 0) { shouldReuseAllAncestorListElements = false; }
            var nextLevel = 1;
            if (shouldReuseAllAncestorListElements) {
                // Remove any un-needed lists from the stack.
                if (listStack.length > this.listTypes.length) {
                    listStack.splice(this.listTypes.length);
                }
                // 1. If the listStack is the same length as the listTypes for this item, check
                // if the last item needs to change, and remove it if needed. We can always re-use
                // the other lists even if the type doesn't match - since the display is the same
                // as long as the list immediately surrounding the item is correct.
                var listStackEndIndex = listStack.length - 1;
                if (listStackEndIndex === this.listTypes.length - 1 && // they are the same length
                    (0, getListTypeFromNode_1.default)(listStack[listStackEndIndex]) !==
                        this.listTypes[listStackEndIndex]) {
                    listStack.splice(listStackEndIndex);
                }
                nextLevel = listStack.length;
            }
            else {
                // 1. Determine list elements that we can reuse
                // e.g.:
                //    passed in listStack: Fragment > OL > UL > OL
                //    local listTypes:     null     > OL > UL > UL > OL
                //    then Fragment > OL > UL can be reused
                for (; nextLevel < listStack.length; nextLevel++) {
                    if ((0, getListTypeFromNode_1.default)(listStack[nextLevel]) !== this.listTypes[nextLevel]) {
                        listStack.splice(nextLevel);
                        break;
                    }
                }
            }
            // 2. Add new list elements
            // e.g.:
            //    passed in listStack: Fragment > OL > UL
            //    local listTypes:     null     > OL > UL > UL > OL
            //    then we need to create a UL and a OL tag
            for (; nextLevel < this.listTypes.length; nextLevel++) {
                var stackLength = listStack.length - 1;
                var newList = createListElement(listStack[0], this.listTypes[nextLevel], nextLevel, originalRoot);
                listStack[stackLength].appendChild(newList);
                listStack.push(newList);
                //If the current node parent is in the same deep child index,
                //apply the styles of the current parent list to the new list
                if (this.getDeepChildIndex(originalRoot) == stackLength) {
                    var listStyleType = (_a = this.node.parentElement) === null || _a === void 0 ? void 0 : _a.style.listStyleType;
                    if (listStyleType &&
                        (0, getTagOfNode_1.default)(this.node.parentElement) === (0, getTagOfNode_1.default)(newList)) {
                        newList.style.listStyleType = listStyleType;
                    }
                }
            }
            // 3. Add current node into deepest list element
            listStack[listStack.length - 1].appendChild(this.node);
            this.node.style.setProperty('display', this.dummy ? 'block' : null);
            // 4. Inherit styles of the child element to the li, so we are able to apply the styles to the ::marker
            if (this.listTypes.length > 1) {
                (0, setListItemStyle_1.default)(this.node, stylesToInherit, true /*isCssStyle*/);
                (0, setListItemStyle_1.default)(this.node, attrsToInherit, false /*isCssStyle*/);
            }
            // 5. If this is not a list item now, need to unwrap the LI node and do proper handling
            if (this.listTypes.length <= 1) {
                // If original <LI> node has styles for font and color, we need to apply it to new parent
                var isLi = (0, getTagOfNode_1.default)(this.node) == 'LI';
                var stylesToApply = isLi
                    ? {
                        'font-family': this.node.style.fontFamily,
                        'font-size': this.node.style.fontSize,
                        color: this.node.style.color,
                    }
                    : undefined;
                var childNodes = isLi ? getChildrenAndUnwrap(this.node) : [this.node];
                if (stylesToApply) {
                    var _loop_1 = function (i) {
                        if ((0, safeInstanceOf_1.default)(childNodes[i], 'Text')) {
                            childNodes[i] = (0, wrap_1.default)(childNodes[i], 'span');
                        }
                        var node = childNodes[i];
                        if ((0, safeInstanceOf_1.default)(node, 'HTMLElement')) {
                            var styles = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, stylesToApply), (0, getStyles_1.default)(node));
                            (0, setStyles_1.default)(node, styles);
                            attrsToInherit.forEach(function (attr) {
                                var attrValue = _this.node.getAttribute(attr);
                                if (attrValue) {
                                    node.setAttribute(attr, attrValue);
                                }
                            });
                        }
                    };
                    for (var i = 0; i < childNodes.length; i++) {
                        _loop_1(i);
                    }
                }
                wrapIfNotBlockNode(childNodes, true /*checkFirst*/, true /*checkLast*/);
            }
        };
        /**
         * Get the index of how deep is the current node parent list inside of the original root list.
         * @example In the following structure this function would return 2
         * ```html
         *  <ol> <!-- original Root -->
         *      <ol>
         *          <ol>
         *              <li></li> <!-- this.node  -->
         *          </ol>
         *      </ol>
         *  </ol>
         * ```
         * @param originalRoot The root list
         * @returns -1  if the node does not have parent element or if original root was not provided,
         *              else, how deep is the parent element inside of the original root.
         */
        VListItem.prototype.getDeepChildIndex = function (originalRoot) {
            var parentElement = this.node.parentElement;
            if (originalRoot && parentElement) {
                var deepIndex = 0;
                while (parentElement && parentElement != originalRoot) {
                    deepIndex++;
                    parentElement = (parentElement === null || parentElement === void 0 ? void 0 : parentElement.parentElement) || null;
                }
                return deepIndex;
            }
            return -1;
        };
        return VListItem;
    }());
    exports.default = VListItem;
    function createListElement(newRoot, listType, nextLevel, originalRoot) {
        var doc = newRoot.ownerDocument;
        var result;
        // Try to reuse the existing root element
        // It can be reused when
        // 1. Current list item is level 1 (top level), AND
        // 2. Original root exists, AND
        // 3. They have the same list type AND
        // 4. The original root is not used yet
        if (nextLevel == 1 && originalRoot && listType == (0, getListTypeFromNode_1.default)(originalRoot)) {
            if ((0, contains_1.default)(newRoot, originalRoot)) {
                // If it is already used, let's clone one and remove ID to avoid duplicating ID
                result = originalRoot.cloneNode(false /*deep*/);
                result.removeAttribute('id');
            }
            else {
                // Remove all child nodes, they will be added back later when write back other items
                (0, moveChildNodes_1.default)(originalRoot);
                result = originalRoot;
            }
        }
        else {
            // Can't be reused, can't clone, let's create a new one
            result = doc.createElement(listType == 1 /* Ordered */ ? 'ol' : 'ul');
        }
        if ((originalRoot === null || originalRoot === void 0 ? void 0 : originalRoot.style.marginTop) == '0px' && (originalRoot === null || originalRoot === void 0 ? void 0 : originalRoot.style.marginBottom) == '0px') {
            result.style.marginTop = '0px';
            result.style.marginBottom = '0px';
        }
        // Always maintain the metadata saved in the list
        if (originalRoot && nextLevel == 1 && listType != (0, getListTypeFromNode_1.default)(originalRoot)) {
            var style = (0, metadata_1.getMetadata)(originalRoot, exports.ListStyleDefinitionMetadata);
            if (style) {
                (0, metadata_1.setMetadata)(result, style, exports.ListStyleDefinitionMetadata);
            }
        }
        if (listType == 1 /* Ordered */ && nextLevel > 1) {
            result.style.setProperty('list-style-type', orderListStyles[(nextLevel - 1) % orderListStyles.length]);
        }
        if (listType == 2 /* Unordered */ && nextLevel > 1) {
            result.style.setProperty('list-style-type', unorderedListStyles[(nextLevel - 1) % unorderedListStyles.length]);
        }
        return result;
    }
    function wrapIfNotBlockNode(nodes, checkFirst, checkLast) {
        if (nodes.length > 0 &&
            (!checkFirst || !(0, isBlockElement_1.default)(nodes[0])) &&
            (!checkLast || !(0, isBlockElement_1.default)(nodes[nodes.length]))) {
            nodes = [(0, wrap_1.default)(nodes)];
        }
        return nodes;
    }
    function getChildrenAndUnwrap(node) {
        var result = (0, toArray_1.default)(node.childNodes);
        (0, unwrap_1.default)(node);
        return result;
    }
});
//# sourceMappingURL=VListItem.js.map