define(["require", "exports", "../jsUtils/arrayPush", "./getRootListNode", "../utils/isNodeAfter", "../region/isNodeInRegion", "../utils/queryElements", "./VList"], function (require, exports, arrayPush_1, getRootListNode_1, isNodeAfter_1, isNodeInRegion_1, queryElements_1, VList_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CHAIN_NAME_PREFIX = '__List_Chain_';
    var CHAIN_DATASET_NAME = 'listchain';
    var AFTER_CURSOR_DATASET_NAME = 'listchainafter';
    var lastChainIndex = 0;
    /**
     * Represent a chain of list nodes.
     * A chain of lists is a virtual link of lists that have continuous numbers, when editor one of them,
     * all others should also be updated in order to main the list number to be continuous.
     */
    var VListChain = /** @class */ (function () {
        /**
         * Construct a new instance of VListChain class
         * @param editor Editor object
         */
        function VListChain(region, name) {
            this.region = region;
            this.name = name;
            this.lastNumber = 0;
            this.lastNumberBeforeCursor = 0;
        }
        /**
         * Create an array of VListChain from current region in editor
         * @param region The region to create VListChain from
         * @param currentNode Optional current node, used for mark lists that are after this node
         * @param nameGenerator Used by test code only
         */
        VListChain.createListChains = function (region, currentNode, nameGenerator) {
            var regions = Array.isArray(region) ? region : region ? [region] : [];
            var result = [];
            regions.forEach(function (region) {
                var chains = [];
                var lastList;
                (0, queryElements_1.default)(region.rootNode, 'ol', function (ol) {
                    var list = (0, getRootListNode_1.default)(region, 'ol', ol);
                    if (lastList != list) {
                        var chain = chains.filter(function (c) { return c.canAppendToTail(list); })[0] ||
                            new VListChain(region, (nameGenerator || createListChainName)());
                        var index = chains.indexOf(chain);
                        var afterCurrentNode = !!currentNode && (0, isNodeAfter_1.default)(list, currentNode);
                        if (!afterCurrentNode) {
                            // Make sure current one is at the front if current block has not been met, so that
                            // the first chain is always the nearest one from current node
                            if (index >= 0) {
                                chains.splice(index, 1);
                            }
                            chains.unshift(chain);
                        }
                        else if (index < 0) {
                            chains.push(chain);
                        }
                        chain.append(list, afterCurrentNode);
                        lastList = list;
                    }
                });
                (0, arrayPush_1.default)(result, chains);
            });
            return result;
        };
        /**
         * Check if a list with the given start number can be appended next to the last list before cursor
         * @param startNumber The start number of the new list
         */
        VListChain.prototype.canAppendAtCursor = function (startNumber) {
            return startNumber > 1 && this.lastNumberBeforeCursor + 1 == startNumber;
        };
        /**
         * Create a VList to wrap the block of the given node, and append to current chain
         * @param container The container node to create list at
         * @param startNumber Start number of the new list
         */
        VListChain.prototype.createVListAtBlock = function (container, startNumber) {
            if (container && container.parentNode) {
                var list = container.ownerDocument.createElement('ol');
                list.start = startNumber;
                this.applyChainName(list);
                container.parentNode.insertBefore(list, container);
                var vList = new VList_1.default(list);
                vList.appendItem(container, 0 /* None */);
                return vList;
            }
            else {
                return null;
            }
        };
        /**
         * After change the lists, commit the change to all lists in this chain to update the list number,
         * and clear the temporary dataset values added to list node
         * @param shouldReuseAllAncestorListElements Whether we can parent list item (OL/UL) even if its list type does not match the previous one. @default false
         * @param disableListChain Whether we want to disable list chain functionality, so splitted list will always restart its number from 1 @default false
         */
        VListChain.prototype.commit = function (shouldReuseAllAncestorListElements, disableListChain) {
            var lists = this.getLists();
            var lastNumber = 0;
            for (var i = 0; i < lists.length; i++) {
                var list = lists[i];
                if (!disableListChain) {
                    //If there is a list chain sequence, ensure the list chain keep increasing correctly
                    if (list.start > 1) {
                        list.start = list.start === lastNumber ? lastNumber + 1 : list.start;
                    }
                    else {
                        list.start = lastNumber + 1;
                    }
                }
                var vlist = new VList_1.default(list);
                lastNumber = vlist.getLastItemNumber() || 0;
                delete list.dataset[CHAIN_DATASET_NAME];
                delete list.dataset[AFTER_CURSOR_DATASET_NAME];
                vlist.writeBack(shouldReuseAllAncestorListElements);
            }
        };
        /**
         * Check if the given list node is can be appended into current list chain
         * @param list The list node to check
         */
        VListChain.prototype.canAppendToTail = function (list) {
            return this.lastNumber + 1 == list.start;
        };
        /**
         * Append the given list node into this VListChain
         * @param list The list node to append
         * @param isAfterCurrentNode Whether this list is after current node
         */
        VListChain.prototype.append = function (list, isAfterCurrentNode) {
            this.applyChainName(list);
            this.lastNumber = new VList_1.default(list).getLastItemNumber() || 0;
            if (isAfterCurrentNode) {
                list.dataset[AFTER_CURSOR_DATASET_NAME] = 'true';
            }
            else {
                this.lastNumberBeforeCursor = this.lastNumber;
            }
        };
        VListChain.prototype.applyChainName = function (list) {
            list.dataset[CHAIN_DATASET_NAME] = this.name;
        };
        VListChain.prototype.getLists = function () {
            var _this = this;
            return (0, queryElements_1.default)(this.region.rootNode, "ol[data-" + CHAIN_DATASET_NAME + "=" + this.name + "]").filter(function (node) { return (0, isNodeInRegion_1.default)(_this.region, node); });
        };
        return VListChain;
    }());
    exports.default = VListChain;
    function createListChainName() {
        return CHAIN_NAME_PREFIX + lastChainIndex++;
    }
});
//# sourceMappingURL=VListChain.js.map