{"version":3,"file":"getRegionsFromRange.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/region/getRegionsFromRange.ts"],"names":[],"mappings":"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","sourcesContent":["import contains from '../utils/contains';\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { QueryScope, RegionType } from 'roosterjs-editor-types';\nimport type { Region } from 'roosterjs-editor-types';\nimport type { CompatibleRegionType } from 'roosterjs-editor-types/lib/compatibleTypes';\n\ninterface RegionTypeData {\n    /**\n     * Tags that child elements will be skipped\n     */\n    skipTags: string[];\n\n    /**\n     * Selector of outer node of a region\n     */\n    outerSelector: string;\n\n    /**\n     * Selector of inner node of a region\n     */\n    innerSelector: string;\n}\n\nconst regionTypeData: Record<RegionType, RegionTypeData> = {\n    [RegionType.Table]: {\n        skipTags: ['TABLE'],\n        outerSelector: 'table',\n        innerSelector: 'td,th',\n    },\n};\n\n/**\n * Get regions impacted by the given range under the root node\n * @param root Root node to get regions from\n * @param range A selection range. Regions will be created according to this range. Each region will be\n * fully or partially covered by this range.\n * @param type Type of region. Currently we only support TABLE region.\n */\nexport default function getRegionsFromRange(\n    root: HTMLElement,\n    range: Range,\n    type: RegionType | CompatibleRegionType\n): Region[] {\n    let regions: Region[] = [];\n    if (root && range) {\n        const { innerSelector, skipTags } = regionTypeData[type];\n        const boundaryTree = buildBoundaryTree(root, range, type);\n        const start = findClosestElementAncestor(range.startContainer, root, innerSelector) || root;\n        const end = findClosestElementAncestor(range.endContainer, root, innerSelector) || root;\n        const creator = getRegionCreator(range, skipTags);\n        [regions] = iterateNodes(creator, boundaryTree, start, end);\n    }\n\n    return regions.filter(r => !!r);\n}\n\n/**\n * @internal export for test only\n */\nexport function getRegionCreator(\n    fullRange: Range,\n    skipTags: string[]\n): (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region | null {\n    const fullSelectionStart = Position.getStart(fullRange).normalize();\n    const fullSelectionEnd = Position.getEnd(fullRange).normalize();\n    return (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => {\n        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)\n            ? {\n                  rootNode,\n                  nodeBefore,\n                  nodeAfter,\n                  skipTags,\n                  fullSelectionStart,\n                  fullSelectionEnd,\n              }\n            : null;\n    };\n}\n\n/**\n * This is a internal data structure used for build regions.\n * We firstly split the selection by some boundaries, then we can build region from these boundaries.\n */\ninterface Boundary {\n    /**\n     * inner node of this boundary\n     */\n    innerNode: HTMLElement;\n\n    /**\n     * Children of this boundary\n     */\n    children: {\n        /**\n         * Outer node of a boundary child\n         */\n        outerNode: Node;\n\n        /**\n         * Child boundaries\n         */\n        boundaries: Boundary[];\n    }[];\n}\n\n/**\n * Step 1: Build boundary tree\n * @param root Root node of the whole scope, normally this will be the root of editable scope\n * @param range Existing selected full range\n * @param type Type of region to create\n */\nfunction buildBoundaryTree(\n    root: HTMLElement,\n    range: Range,\n    type: RegionType | CompatibleRegionType\n): Boundary {\n    const allBoundaries: Boundary[] = [{ innerNode: root, children: [] }];\n    const { outerSelector, innerSelector } = regionTypeData[type];\n    const inSelectionOuterNode = queryElements(\n        root,\n        outerSelector,\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll\n    // is in document order, which is what we expect. So we don't need to sort the result here.\n    queryElements(\n        root,\n        innerSelector,\n        thisInnerNode => {\n            const thisOuterNode = findClosestElementAncestor(thisInnerNode, root, outerSelector);\n            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {\n                const boundary: Boundary = { innerNode: thisInnerNode, children: [] };\n\n                for (let i = allBoundaries.length - 1; i >= 0; i--) {\n                    const { innerNode, children } = allBoundaries[i];\n                    if (contains(innerNode, thisOuterNode)) {\n                        let child = children.filter(c => c.outerNode == thisOuterNode)[0];\n\n                        if (!child) {\n                            child = { outerNode: thisOuterNode, boundaries: [] };\n                            children.push(child);\n                        }\n\n                        child.boundaries.push(boundary);\n                        break;\n                    }\n                }\n                allBoundaries.push(boundary);\n            }\n        },\n        QueryScope.OnSelection,\n        range\n    );\n\n    return allBoundaries[0];\n}\n\n/**\n * Step 2: Recursively iterate all boundaries and create regions\n * @param creator A region creator function to help create region\n * @param boundary Current root boundary\n * @param start A node where full range start from. This may not be the direct node container of range.startContainer.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param end A node where full range end from. This may not be the direct node container of range.endContainer.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param started Whether we have already hit the start node\n */\nfunction iterateNodes(\n    creator: (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region | null,\n    boundary: Boundary,\n    start: Node,\n    end: Node,\n    started?: boolean\n): [Region[], boolean, boolean] {\n    started = started || boundary.innerNode == start;\n    let ended = false;\n    const { children, innerNode } = boundary;\n    let regions: Region[] = [];\n\n    if (children.length == 0) {\n        const region = creator(innerNode);\n        if (region) {\n            regions.push(region);\n        }\n    } else {\n        // Need to run one more time to add region after all children\n        for (let i = 0; i <= children.length && !ended; i++) {\n            const { outerNode, boundaries } = children[i] || {};\n            const previousOuterNode = children[i - 1]?.outerNode;\n            if (started) {\n                const region = creator(innerNode, previousOuterNode, outerNode);\n                if (region) {\n                    regions.push(region);\n                }\n            }\n\n            boundaries?.forEach(child => {\n                let newRegions: Region[];\n                [newRegions, started, ended] = iterateNodes(creator, child, start, end, started);\n                regions = regions.concat(newRegions);\n            });\n        }\n    }\n\n    return [regions, started, ended || innerNode == end];\n}\n\n/**\n * Check if the given nodes combination is valid to create a region.\n * A combination is valid when:\n * 1. Root node is not null and is not empty. And\n * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And\n * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be\n * node between them.\n * @param root Root node of region\n * @param nodeBefore The boundary node before the region under root\n * @param nodeAfter The boundary node after the region under root\n * @param skipTags Tags to skip\n */\nfunction areNodesValid(\n    root: Node,\n    nodeBefore: Node | undefined,\n    nodeAfter: Node | undefined,\n    skipTags: string[]\n) {\n    if (!root) {\n        return false;\n    } else {\n        const firstNodeOfRegion = nodeBefore && getNextLeafSibling(root, nodeBefore, skipTags);\n        const lastNodeOfRegion = nodeAfter && getPreviousLeafSibling(root, nodeAfter, skipTags);\n        const firstNodeValid =\n            !nodeBefore || (contains(root, nodeBefore) && contains(root, firstNodeOfRegion));\n        const lastNodeValid =\n            !nodeAfter || (contains(root, nodeAfter) && contains(root, lastNodeOfRegion));\n        const bothValid =\n            !nodeBefore ||\n            !nodeAfter ||\n            (!contains(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&\n                !contains(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));\n        return firstNodeValid && lastNodeValid && bothValid;\n    }\n}\n"]}