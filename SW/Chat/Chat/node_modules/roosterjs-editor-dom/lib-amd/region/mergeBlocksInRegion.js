define(["require", "exports", "tslib", "../utils/changeElementTag", "../utils/contains", "../blockElements/getBlockElementAtNode", "../htmlSanitizer/getPredefinedCssForElement", "../style/getStyles", "./isNodeInRegion", "../utils/safeInstanceOf", "../style/setStyles", "../utils/collapseNodes"], function (require, exports, tslib_1, changeElementTag_1, contains_1, getBlockElementAtNode_1, getPredefinedCssForElement_1, getStyles_1, isNodeInRegion_1, safeInstanceOf_1, setStyles_1, collapseNodes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Merge a BlockElement of given node after another node
     * @param region Region to operate in
     * @param refNode The node to merge after
     * @param targetNode The node of target block element
     */
    function mergeBlocksInRegion(region, refNode, targetNode) {
        var _a, _b, _c;
        var block;
        if (!(0, isNodeInRegion_1.default)(region, refNode) ||
            !(0, isNodeInRegion_1.default)(region, targetNode) ||
            !(block = (0, getBlockElementAtNode_1.default)(region.rootNode, targetNode)) ||
            block.contains(refNode)) {
            return;
        }
        var blockRoot = block.collapseToSingleElement();
        var commonContainer = (0, collapseNodes_1.collapse)(region.rootNode, blockRoot, refNode, false /*isStart*/, true /*canSplitParent*/);
        // Copy styles of parent nodes into blockRoot
        for (var node = blockRoot; (0, contains_1.default)(commonContainer, node);) {
            var parent_1 = node.parentNode;
            if ((0, safeInstanceOf_1.default)(parent_1, 'HTMLElement')) {
                var styles = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, ((0, getPredefinedCssForElement_1.default)(parent_1) || {})), (0, getStyles_1.default)(parent_1)), (0, getStyles_1.default)(blockRoot));
                (0, setStyles_1.default)(blockRoot, styles);
            }
            node = parent_1;
        }
        var nodeToRemove = null;
        var nodeToMerge = blockRoot.childNodes.length == 1 && blockRoot.attributes.length == 0
            ? blockRoot.firstChild
            : (0, changeElementTag_1.default)(blockRoot, 'SPAN');
        // Remove empty node
        for (var node = nodeToMerge; (0, contains_1.default)(commonContainer, node) && ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes.length) == 1; node = node.parentNode) {
            // If the only child is the one which is about to be removed, this node should also be removed
            nodeToRemove = node.parentNode;
        }
        // Finally, merge blocks, and remove empty nodes
        (_b = refNode.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(nodeToMerge, refNode.nextSibling);
        (_c = nodeToRemove === null || nodeToRemove === void 0 ? void 0 : nodeToRemove.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(nodeToRemove);
    }
    exports.default = mergeBlocksInRegion;
});
//# sourceMappingURL=mergeBlocksInRegion.js.map