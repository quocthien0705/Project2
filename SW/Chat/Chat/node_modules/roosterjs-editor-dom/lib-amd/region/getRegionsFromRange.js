define(["require", "exports", "tslib", "../utils/contains", "../utils/findClosestElementAncestor", "../selection/Position", "../utils/queryElements", "../utils/getLeafSibling"], function (require, exports, tslib_1, contains_1, findClosestElementAncestor_1, Position_1, queryElements_1, getLeafSibling_1) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRegionCreator = void 0;
    var regionTypeData = (_a = {},
        _a[0 /* Table */] = {
            skipTags: ['TABLE'],
            outerSelector: 'table',
            innerSelector: 'td,th',
        },
        _a);
    /**
     * Get regions impacted by the given range under the root node
     * @param root Root node to get regions from
     * @param range A selection range. Regions will be created according to this range. Each region will be
     * fully or partially covered by this range.
     * @param type Type of region. Currently we only support TABLE region.
     */
    function getRegionsFromRange(root, range, type) {
        var _a;
        var regions = [];
        if (root && range) {
            var _b = regionTypeData[type], innerSelector = _b.innerSelector, skipTags = _b.skipTags;
            var boundaryTree = buildBoundaryTree(root, range, type);
            var start = (0, findClosestElementAncestor_1.default)(range.startContainer, root, innerSelector) || root;
            var end = (0, findClosestElementAncestor_1.default)(range.endContainer, root, innerSelector) || root;
            var creator = getRegionCreator(range, skipTags);
            _a = (0, tslib_1.__read)(iterateNodes(creator, boundaryTree, start, end), 1), regions = _a[0];
        }
        return regions.filter(function (r) { return !!r; });
    }
    exports.default = getRegionsFromRange;
    /**
     * @internal export for test only
     */
    function getRegionCreator(fullRange, skipTags) {
        var fullSelectionStart = Position_1.default.getStart(fullRange).normalize();
        var fullSelectionEnd = Position_1.default.getEnd(fullRange).normalize();
        return function (rootNode, nodeBefore, nodeAfter) {
            return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)
                ? {
                    rootNode: rootNode,
                    nodeBefore: nodeBefore,
                    nodeAfter: nodeAfter,
                    skipTags: skipTags,
                    fullSelectionStart: fullSelectionStart,
                    fullSelectionEnd: fullSelectionEnd,
                }
                : null;
        };
    }
    exports.getRegionCreator = getRegionCreator;
    /**
     * Step 1: Build boundary tree
     * @param root Root node of the whole scope, normally this will be the root of editable scope
     * @param range Existing selected full range
     * @param type Type of region to create
     */
    function buildBoundaryTree(root, range, type) {
        var allBoundaries = [{ innerNode: root, children: [] }];
        var _a = regionTypeData[type], outerSelector = _a.outerSelector, innerSelector = _a.innerSelector;
        var inSelectionOuterNode = (0, queryElements_1.default)(root, outerSelector, null /*callback*/, 2 /* InSelection */, range);
        // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll
        // is in document order, which is what we expect. So we don't need to sort the result here.
        (0, queryElements_1.default)(root, innerSelector, function (thisInnerNode) {
            var thisOuterNode = (0, findClosestElementAncestor_1.default)(thisInnerNode, root, outerSelector);
            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {
                var boundary = { innerNode: thisInnerNode, children: [] };
                for (var i = allBoundaries.length - 1; i >= 0; i--) {
                    var _a = allBoundaries[i], innerNode = _a.innerNode, children = _a.children;
                    if ((0, contains_1.default)(innerNode, thisOuterNode)) {
                        var child = children.filter(function (c) { return c.outerNode == thisOuterNode; })[0];
                        if (!child) {
                            child = { outerNode: thisOuterNode, boundaries: [] };
                            children.push(child);
                        }
                        child.boundaries.push(boundary);
                        break;
                    }
                }
                allBoundaries.push(boundary);
            }
        }, 1 /* OnSelection */, range);
        return allBoundaries[0];
    }
    /**
     * Step 2: Recursively iterate all boundaries and create regions
     * @param creator A region creator function to help create region
     * @param boundary Current root boundary
     * @param start A node where full range start from. This may not be the direct node container of range.startContainer.
     * It is the nearest ancestor which satisfies the InnerSelector of the given region type
     * @param end A node where full range end from. This may not be the direct node container of range.endContainer.
     * It is the nearest ancestor which satisfies the InnerSelector of the given region type
     * @param started Whether we have already hit the start node
     */
    function iterateNodes(creator, boundary, start, end, started) {
        var _a;
        started = started || boundary.innerNode == start;
        var ended = false;
        var children = boundary.children, innerNode = boundary.innerNode;
        var regions = [];
        if (children.length == 0) {
            var region = creator(innerNode);
            if (region) {
                regions.push(region);
            }
        }
        else {
            // Need to run one more time to add region after all children
            for (var i = 0; i <= children.length && !ended; i++) {
                var _b = children[i] || {}, outerNode = _b.outerNode, boundaries = _b.boundaries;
                var previousOuterNode = (_a = children[i - 1]) === null || _a === void 0 ? void 0 : _a.outerNode;
                if (started) {
                    var region = creator(innerNode, previousOuterNode, outerNode);
                    if (region) {
                        regions.push(region);
                    }
                }
                boundaries === null || boundaries === void 0 ? void 0 : boundaries.forEach(function (child) {
                    var _a;
                    var newRegions;
                    _a = (0, tslib_1.__read)(iterateNodes(creator, child, start, end, started), 3), newRegions = _a[0], started = _a[1], ended = _a[2];
                    regions = regions.concat(newRegions);
                });
            }
        }
        return [regions, started, ended || innerNode == end];
    }
    /**
     * Check if the given nodes combination is valid to create a region.
     * A combination is valid when:
     * 1. Root node is not null and is not empty. And
     * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And
     * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be
     * node between them.
     * @param root Root node of region
     * @param nodeBefore The boundary node before the region under root
     * @param nodeAfter The boundary node after the region under root
     * @param skipTags Tags to skip
     */
    function areNodesValid(root, nodeBefore, nodeAfter, skipTags) {
        if (!root) {
            return false;
        }
        else {
            var firstNodeOfRegion = nodeBefore && (0, getLeafSibling_1.getNextLeafSibling)(root, nodeBefore, skipTags);
            var lastNodeOfRegion = nodeAfter && (0, getLeafSibling_1.getPreviousLeafSibling)(root, nodeAfter, skipTags);
            var firstNodeValid = !nodeBefore || ((0, contains_1.default)(root, nodeBefore) && (0, contains_1.default)(root, firstNodeOfRegion));
            var lastNodeValid = !nodeAfter || ((0, contains_1.default)(root, nodeAfter) && (0, contains_1.default)(root, lastNodeOfRegion));
            var bothValid = !nodeBefore ||
                !nodeAfter ||
                (!(0, contains_1.default)(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&
                    !(0, contains_1.default)(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&
                    !(0, contains_1.default)(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&
                    !(0, contains_1.default)(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));
            return firstNodeValid && lastNodeValid && bothValid;
        }
    }
});
//# sourceMappingURL=getRegionsFromRange.js.map