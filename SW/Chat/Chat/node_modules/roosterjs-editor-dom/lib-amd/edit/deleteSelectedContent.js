define(["require", "exports", "tslib", "../jsUtils/arrayPush", "../region/collapseNodesInRegion", "../region/getRegionsFromRange", "../region/getSelectionRangeInRegion", "../region/mergeBlocksInRegion", "../selection/Position", "../utils/queryElements", "../utils/safeInstanceOf", "../utils/splitTextNode"], function (require, exports, tslib_1, arrayPush_1, collapseNodesInRegion_1, getRegionsFromRange_1, getSelectionRangeInRegion_1, mergeBlocksInRegion_1, Position_1, queryElements_1, safeInstanceOf_1, splitTextNode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Delete selected content, and return the new position to select
     * @param core The EditorCore object.
     * @param range The range to delete
     */
    function deleteSelectedContent(root, range) {
        var nodeBefore = null;
        // 1. TABLE and TR node in selected should be deleted. It is possible we don't detect them from step 2
        // since table cells will fall in to different regions
        var nodesToDelete = (0, queryElements_1.default)(root, 'table,tr', null /*callback*/, 2 /* InSelection */, range);
        // 2. Loop all selected regions, find out those nodes need to be deleted and merged.
        // We don't delete them directly here because delete node from one region may cause selection range
        // another region becomes invalid. So we delay the process of deletion.
        var regions = (0, getRegionsFromRange_1.default)(root, range, 0 /* Table */);
        var nodesPairToMerge = regions
            .map(function (region) {
            var regionRange = (0, getSelectionRangeInRegion_1.default)(region);
            if (!regionRange) {
                return null;
            }
            var startContainer = regionRange.startContainer, endContainer = regionRange.endContainer, startOffset = regionRange.startOffset, endOffset = regionRange.endOffset, commonAncestorContainer = regionRange.commonAncestorContainer;
            // Disallow merging of readonly elements
            if ((0, safeInstanceOf_1.default)(commonAncestorContainer, 'HTMLElement') &&
                !commonAncestorContainer.isContentEditable) {
                return null;
            }
            // Make sure there are node before and after the merging point.
            // This is required by mergeBlocksInRegion API.
            // This may create some empty text node as anchor
            var _a = (0, tslib_1.__read)(ensureBeforeAndAfter(endContainer, endOffset, false /*isStart*/), 2), beforeEnd = _a[0], afterEnd = _a[1];
            var _b = (0, tslib_1.__read)(ensureBeforeAndAfter(startContainer, startOffset, true /*isStart*/), 2), beforeStart = _b[0], afterStart = _b[1];
            nodeBefore = nodeBefore || beforeStart;
            // Find out all nodes to be deleted
            var nodes = (0, collapseNodesInRegion_1.default)(region, [afterStart, beforeEnd]);
            (0, arrayPush_1.default)(nodesToDelete, nodes);
            return { region: region, beforeStart: beforeStart, afterEnd: afterEnd };
        })
            .filter(function (x) { return !!x; });
        // 3. Delete all nodes that we found, whose parent is editable
        nodesToDelete.forEach(function (node) { var _a; return ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.isContentEditable) && node.parentElement.removeChild(node); });
        // 4. Merge lines for each region, so that after we don't see extra line breaks
        nodesPairToMerge.forEach(function (nodes) {
            if (nodes) {
                (0, mergeBlocksInRegion_1.default)(nodes.region, nodes.beforeStart, nodes.afterEnd);
            }
        });
        return nodeBefore && new Position_1.default(nodeBefore, -1 /* End */);
    }
    exports.default = deleteSelectedContent;
    function ensureBeforeAndAfter(node, offset, isStart) {
        var _a, _b;
        if ((0, safeInstanceOf_1.default)(node, 'Text')) {
            var newNode = (0, splitTextNode_1.default)(node, offset, isStart);
            return isStart ? [newNode, node] : [node, newNode];
        }
        else {
            var nodeBefore = node.childNodes[offset - 1];
            var nodeAfter = node.childNodes[offset];
            // Condition 1: node child nodes
            // ("I" means cursor; "o" means a DOM node, "[ ]" means a parent node)
            // [ I ]
            // need to use parent node instead to convert to condition 2
            if (!nodeBefore && !nodeAfter) {
                if (isStart) {
                    nodeAfter = node;
                    nodeBefore = nodeAfter.previousSibling;
                }
                else {
                    nodeBefore = node;
                    nodeAfter = nodeBefore.nextSibling;
                }
            }
            // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)
            // [ o I ]  or [ I o]
            // need to add empty text node to convert to condition 3
            if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {
                var emptyNode = node.ownerDocument.createTextNode('');
                (_b = (_a = (nodeBefore || nodeAfter)) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(emptyNode, nodeAfter);
                if (nodeBefore) {
                    nodeAfter = emptyNode;
                }
                else {
                    nodeBefore = emptyNode;
                }
            }
            // Condition 3: Both nodeBefore and nodeAfter are not null
            // [o I o]
            // return the nodes
            return [nodeBefore, nodeAfter];
        }
    }
});
//# sourceMappingURL=deleteSelectedContent.js.map