{"version":3,"file":"adjustInsertPosition.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/edit/adjustInsertPosition.ts"],"names":[],"mappings":";;;IAwBA,IAAM,qBAAqB,GAAG,yBAAyB,CAAC;IAExD,IAAM,WAAW,GAKM;QACnB,gCAAgC;QAChC,qCAAqC;QACrC,gCAAgC;QAChC,kCAAkC;QAClC,2CAA2C;QAC3C,sCAAsC;QACtC,4BAA4B;KAC/B,CAAC;IAEF;;OAEG;IACH,SAAS,gCAAgC,CACrC,IAAiB,EACjB,YAAkB,EAClB,QAAsB,EACtB,KAAY;;QAEZ,IAAM,YAAY,GAAG,IAAA,+BAAqB,EAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC;QAEhE,IAAI,YAAY,EAAE;YACd,6EAA6E;YAC7E,0GAA0G;YAC1G,IAAI,MAAM,GAAuB,IAAA,uBAAa,EAC1C,IAAI,EACJ,SAAS,EACT,IAAI,CAAC,mBAAmB,uBAExB,IAAA,qBAAW,EAAC,QAAQ,CAAC,CACxB,CAAC,MAAM,CAAC,UAAC,CAAc,IAAK,OAAA,YAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAzB,CAAyB,CAAC,CAAC,CAAC,CAAC,CAAC;YAE3D,wFAAwF;YACxF,IAAI,MAAM,IAAI,IAAA,qBAAW,EAAC,MAAM,CAAC,EAAE;gBAC/B,QAAQ,GAAG,IAAI,kBAAQ,CAAC,MAAM,kBAAsB,CAAC;gBACrD,UAAU,CAAC,MAAM,CAAC,CAAC;gBACnB,MAAM,GAAG,IAAI,CAAC;aACjB;YAED,wGAAwG;YACxG,uEAAuE;YACvE,IACI,MAAM;iBACN,MAAc,YAA6B,0CAAE,aAAa,CAAA;iBAC1D,MAAc,YAA6B,0CAAE,aAAa,CAAC,SAAS,CAAC,CAAA,EACvE;gBACE,IAAM,kBAAkB,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;gBAChD,IAAM,UAAU,GAAG,kBAAkB,CAAC,IAAI,CAAC,UAAW,CAAC;gBACvD,IAAM,QAAQ,GACV,kBAAkB,CAAC,IAAI,CAAC,QAAQ,gBAAiB;oBAC7C,CAAC,CAAC,IAAA,uBAAa,EACH,kBAAkB,CAAC,IAAI,EAC7B,kBAAkB,CAAC,MAAM,EACzB,KAAK,CAAC,mBAAmB,CAC5B;oBACH,CAAC,CAAC,kBAAkB,CAAC,OAAO;wBAC5B,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,WAAW;wBACrC,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC;gBAClC,IAAI,QAAQ,GAAgB,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;gBAClE,UAAU,CAAC,YAAY,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;gBAE5C,OAAO,QAAQ,IAAI,IAAA,kBAAQ,EAAC,MAAM,EAAE,QAAQ,CAAC,EAAE;oBAC3C,QAAQ,GAAG,IAAA,wCAAsB,EAAC,QAAQ,CAAC,CAAC;iBAC/C;gBAED,IAAI,QAAQ,EAAE;oBACV,QAAQ,GAAG,IAAI,kBAAQ,CAAC,QAAQ,kBAAsB,CAAC;oBACvD,UAAU,CAAC,QAAQ,CAAC,CAAC;iBACxB;aACJ;SACJ;QAED,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,SAAS,qCAAqC,CAC1C,IAAiB,EACjB,YAAkB,EAClB,QAAsB,EACtB,KAAY;QAEZ,IAAI,gBAAgB,GAAgB,YAAY,CAAC;QACjD,IAAI,UAAU,GAAY,KAAK,CAAC;QAEhC,IAAI,gBAAgB,CAAC,QAAQ,6BAA6B,EAAE;YACxD,UAAU,GAAG,IAAI,CAAC;YAClB,IAAM,SAAS,GAAG,IAAA,iBAAO,EAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC,MAAM,CACzD,UAAC,CAAY,IAAK,OAAA,IAAA,sBAAY,EAAC,CAAC,CAAC,IAAI,IAAI,EAAvB,CAAuB,CAC5C,CAAC;YACF,gBAAgB,GAAG,SAAS,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;SAClE;QAED,IAAI,GAAG,GAAG,IAAA,sBAAY,EAAC,gBAAgB,CAAC,CAAC;QACzC,IAAM,eAAe,GACjB,GAAG,IAAI,gBAAgB,IAAI,IAAA,sBAAY,EAAC,gBAAgB,CAAC,WAAW,CAAC,IAAI,IAAI,CAAC;QAClF,IAAM,QAAQ,GAAG,IAAA,oCAA0B,EAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QACvE,IAAM,QAAQ,GAAG,QAAQ,IAAI,IAAA,oCAA0B,EAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;QACjF,IAAM,MAAM,GAAG,IAAA,oCAA0B,EAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;QAExE,IAAI,GAAG,IAAI,IAAI,EAAE;YACb,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,IAAA,sBAAY,EAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;YAC/C,gBAAgB,GAAG,IAAA,cAAI,EAAC,gBAAiB,EAAE,GAAG,CAAC,CAAC;SACnD;QAED,IACI,CAAC,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC;YAC5B,gBAAgB;YAChB,IAAA,sBAAY,EAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,IAAI,EACnD;YACE,IAAM,sBAAsB,GACxB,CAAC,gBAAgB,CAAC,UAAW,CAAC,WAAW,IAAI,CAAC,eAAe,CAAC;YAElE,IAAI,eAAe,IAAI,gBAAgB,CAAC,UAAU,EAAE;gBAChD,UAAU,CAAC,gBAAgB,CAAC,WAAY,CAAC,CAAC;aAC7C;YAED,IAAI,sBAAsB,EAAE;gBACxB,IAAA,gBAAM,EAAC,gBAAgB,CAAC,UAAW,CAAC,CAAC;gBACrC,IAAA,gBAAM,EAAC,gBAAgB,CAAC,CAAC;aAC5B;iBAAM,IAAI,IAAA,sBAAY,EAAC,QAAQ,CAAC,IAAI,GAAG,EAAE;gBACtC,IAAA,gBAAM,EAAC,gBAAgB,CAAC,CAAC;gBACzB,QAAQ,GAAG,IAAI,kBAAQ,CACnB,QAAS,EACT,IAAA,iCAAuB,EAAC,QAAQ,EAAE,QAAS,CAAC;oBACxC,CAAC;oBACD,CAAC,eAAmB,CAC3B,CAAC;aACL;SACJ;QAED,IAAI,UAAU,IAAI,GAAG,IAAI,OAAO,IAAI,MAAM,EAAE;YACxC,IAAA,oBAAU,EACgB,MAAM,EACV,gBAAgB,EAClC,QAAQ,EACR,KAAK,CACR,CAAC;YACF,QAAQ,GAAG,IAAI,kBAAQ,CAAC,gBAAiB,EAAE,CAAC,CAAC,CAAC;YAC9C,IAAA,wBAAc,EAAC,YAAY,CAAC,CAAC;SAChC;QAED,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED;;OAEG;IAEH,SAAS,gCAAgC,CACrC,IAAiB,EACjB,YAAkB,EAClB,QAAsB,EACtB,KAAY;QAEZ,IAAI,IAAA,sBAAY,EAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,GAAG,EAAE;YACpC,6FAA6F;YAC7F,iDAAiD;YACjD,IAAM,GAAG,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;YACjC,IAAM,GAAG,GAAG,IAAA,0BAAgB,EAAc,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAChE,IAAI,GAAG,CAAC,IAAI,IAAI,GAAG,EAAE;gBACjB,QAAQ,GAAG,GAAG,CAAC;aAClB;SACJ;QAED,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED;;OAEG;IAEH,SAAS,kCAAkC,CACvC,IAAiB,EACjB,YAAkB,EAClB,QAAsB,EACtB,KAAY;QAEZ,IAAI,IAAA,2BAAiB,EAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;YAClC,QAAQ,GAAG,IAAI,kBAAQ,CACnB,QAAQ,CAAC,IAAI,EACb,QAAQ,CAAC,OAAO,CAAC,CAAC,gBAAoB,CAAC,gBAAoB,CAC9D,CAAC;SACL;QACD,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED;;OAEG;IAEH,SAAS,2CAA2C,CAChD,IAAiB,EACjB,YAAkB,EAClB,QAAsB,EACtB,KAAY;QAEZ,IAAI,KAAK,IAAI,KAAK,CAAC,SAAS,EAAE;YAC1B,IAAM,QAAQ,GAAG,IAAI,iCAAuB,CAAC,IAAI,EAAE,kBAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;YAC7E,IAAM,mBAAmB,GAAG,QAAQ,CAAC,sBAAsB,EAAE,CAAC;YAC9D,IAAM,kBAAkB,GAAG,QAAQ,CAAC,qBAAqB,EAAE,CAAC;YAC5D,IAAI,mBAAmB,YAAY,2BAAiB,EAAE;gBAClD,QAAQ,GAAG,IAAI,kBAAQ,CAAC,mBAAmB,CAAC,gBAAgB,EAAE,iBAAqB,CAAC;aACvF;iBAAM,IAAI,kBAAkB,YAAY,2BAAiB,EAAE;gBACxD,QAAQ,GAAG,IAAI,kBAAQ,CAAC,kBAAkB,CAAC,gBAAgB,EAAE,kBAAsB,CAAC;aACvF;SACJ;QACD,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,SAAS,sCAAsC,CAC3C,IAAiB,EACjB,YAAkB,EAClB,QAAsB,EACtB,KAAY;;QAEZ,IAAI,CAAC,CAAA,MAAA,QAAQ,CAAC,OAAO,0CAAE,iBAAiB,CAAA,EAAE;YACtC,IAAI,kBAAkB,SAAyB,CAAC;YAChD,IAAI,sBAAsB,GAAuB,IAAA,oCAA0B,EACvE,QAAQ,CAAC,IAAI,EACb,IAAI,EACJ,qBAAqB,CACxB,CAAC;YAEF,OAAO,sBAAsB,EAAE;gBAC3B,kBAAkB,GAAG,sBAAsB,CAAC;gBAC5C,sBAAsB,GAAG,CAAA,kBAAkB,aAAlB,kBAAkB,uBAAlB,kBAAkB,CAAE,aAAa;oBACtD,CAAC,CAAC,IAAA,oCAA0B,EACtB,kBAAkB,CAAC,aAAa,EAChC,IAAI,EACJ,qBAAqB,CACxB;oBACH,CAAC,CAAC,IAAI,CAAC;aACd;YAED,IAAI,kBAAkB,EAAE;gBACpB,QAAQ,GAAG,IAAI,kBAAQ,CAAC,kBAAkB,iBAAqB,CAAC;gBAChE,OAAO,sCAAsC,CAAC,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;aACtF;SACJ;QAED,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,SAAS,4BAA4B,CACjC,IAAiB,EACjB,YAAkB,EAClB,QAAsB,EACtB,KAAY;QAEZ,IACI,CAAC,YAAY,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC;YAChC,IAAA,sBAAY,EAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC;YACxD,IAAA,sBAAY,EAAC,YAAY,CAAC,IAAI,OAAO,EACvC;YACU,IAAA,OAAO,GAAK,QAAQ,QAAb,CAAc;YAE7B,IAAM,SAAS,GAAG,IAAI,kBAAQ,CAAC,OAAO,kBAAsB,CAAC;YAC7D,IAAM,eAAe,GAAG,IAAA,qBAAW,EAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;YACzD,IAAM,gBAAgB,GAAG,0BAAgB,CAAC,wBAAwB,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;YAE1F,IAAI,YAAY,GAAG,gBAAgB,IAAI,gBAAgB,CAAC,mBAAmB,CAAC;YAE5E,IAAI,YAAY,EAAE;gBACd,IAAI,gBAAgB,GAAwB,YAAY,CAAC;gBAEzD,OAAO,CAAC,gBAAgB,EAAE;oBACtB,gBAAgB,GAAG,gBAAgB,CAAC,mBAAmB,EAAE,CAAC;oBAC1D,IAAI,gBAAgB,EAAE;wBAClB,YAAY,GAAG,gBAAgB,CAAC;qBACnC;iBACJ;gBAED,IAAM,WAAW,GAAG,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,UAAU,EAAE,CAAC;gBAE/C,IAAI,WAAW,IAAI,IAAA,oCAA0B,EAAC,WAAW,EAAE,IAAI,EAAE,OAAO,CAAC,EAAE;oBACvE,IAAI,SAAS,GAAG,IAAA,qBAAW,EAAC,QAAQ,CAAC,CAAC;oBACtC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;oBACxC,IAAM,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;oBAClD,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;oBAEzB,SAAS,GAAG,IAAA,qBAAW,EAAC,EAAE,CAAC,CAAC;oBAC5B,QAAQ,GAAG,kBAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;iBACzC;aACJ;SACJ;QACD,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED;;;;;;;OAOG;IAEH,SAAwB,2BAA2B,CAC/C,IAAiB,EACjB,YAAkB,EAClB,QAAsB,EACtB,KAAY;QAEZ,WAAW,CAAC,OAAO,CAAC,UAAA,OAAO;YACvB,QAAQ,GAAG,OAAO,CAAC,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;QAC5D,CAAC,CAAC,CAAC;QACH,OAAO,QAAQ,CAAC;IACpB,CAAC;IAVD,8CAUC;IAED,SAAS,UAAU,CAAC,IAAU;;QAC1B,MAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,UAAU,0CAAE,WAAW,CAAC,IAAI,CAAC,CAAC;IACxC,CAAC","sourcesContent":["import changeElementTag from '../utils/changeElementTag';\nimport contains from '../utils/contains';\nimport ContentTraverser from '../contentTraverser/ContentTraverser';\nimport createRange from '../selection/createRange';\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isNodeEmpty from '../utils/isNodeEmpty';\nimport isPositionAtBeginningOf from '../selection/isPositionAtBeginningOf';\nimport isVoidHtmlElement from '../utils/isVoidHtmlElement';\nimport LinkInlineElement from '../inlineElements/LinkInlineElement';\nimport moveChildNodes from '../utils/moveChildNodes';\nimport pasteTable from '../table/pasteTable';\nimport Position from '../selection/Position';\nimport PositionContentSearcher from '../contentTraverser/PositionContentSearcher';\nimport queryElements from '../utils/queryElements';\nimport splitTextNode from '../utils/splitTextNode';\nimport toArray from '../jsUtils/toArray';\nimport unwrap from '../utils/unwrap';\nimport wrap from '../utils/wrap';\nimport { NodeType, PositionType, QueryScope } from 'roosterjs-editor-types';\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\nimport type { BlockElement, NodePosition } from 'roosterjs-editor-types';\n\nconst NOT_EDITABLE_SELECTOR = '[contenteditable=false]';\n\nconst adjustSteps: ((\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n) => NodePosition)[] = [\n    adjustInsertPositionForHyperLink,\n    adjustInsertPositionForStructuredNode,\n    adjustInsertPositionForParagraph,\n    adjustInsertPositionForVoidElement,\n    adjustInsertPositionForMoveCursorOutOfALink,\n    adjustInsertPositionForNotEditableNode,\n    adjustInsertPositionForTable,\n];\n\n/**\n * Adjust position for A tag don't be nested inside another A tag.\n */\nfunction adjustInsertPositionForHyperLink(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    const blockElement = getBlockElementAtNode(root, position.node);\n\n    if (blockElement) {\n        // Find the first <A> tag within current block which covers current selection\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\n        let anchor: HTMLElement | null = queryElements(\n            root,\n            'a[href]',\n            null /*forEachCallback*/,\n            QueryScope.OnSelection,\n            createRange(position)\n        ).filter((a: HTMLElement) => blockElement!.contains(a))[0];\n\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\n        if (anchor && isNodeEmpty(anchor)) {\n            position = new Position(anchor, PositionType.Before);\n            safeRemove(anchor);\n            anchor = null;\n        }\n\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\n        // otherwise we will have nested A tags which is a wrong HTML structure\n        if (\n            anchor &&\n            (<ParentNode>(nodeToInsert as HTMLElement))?.querySelector &&\n            (<ParentNode>(nodeToInsert as HTMLElement))?.querySelector('a[href]')\n        ) {\n            const normalizedPosition = position.normalize();\n            const parentNode = normalizedPosition.node.parentNode!;\n            const nextNode =\n                normalizedPosition.node.nodeType == NodeType.Text\n                    ? splitTextNode(\n                          <Text>normalizedPosition.node,\n                          normalizedPosition.offset,\n                          false /*returnFirstPart*/\n                      )\n                    : normalizedPosition.isAtEnd\n                    ? normalizedPosition.node.nextSibling\n                    : normalizedPosition.node;\n            let splitter: Node | null = root.ownerDocument.createTextNode('');\n            parentNode.insertBefore(splitter, nextNode);\n\n            while (splitter && contains(anchor, splitter)) {\n                splitter = splitBalancedNodeRange(splitter);\n            }\n\n            if (splitter) {\n                position = new Position(splitter, PositionType.Before);\n                safeRemove(splitter);\n            }\n        }\n    }\n\n    return position;\n}\n\n/**\n * Adjust position for a node don't be nested inside tags like BR, LI, TD.\n */\nfunction adjustInsertPositionForStructuredNode(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    let rootNodeToInsert: Node | null = nodeToInsert;\n    let isFragment: boolean = false;\n\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\n        isFragment = true;\n        const rootNodes = toArray(rootNodeToInsert.childNodes).filter(\n            (n: ChildNode) => getTagOfNode(n) != 'BR'\n        );\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\n    }\n\n    let tag = getTagOfNode(rootNodeToInsert);\n    const hasBrNextToRoot =\n        tag && rootNodeToInsert && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\n    const listItem = findClosestElementAncestor(position.node, root, 'LI');\n    const listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\n    const tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\n\n    if (tag == 'LI') {\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\n        rootNodeToInsert = wrap(rootNodeToInsert!, tag);\n    }\n\n    if (\n        (tag == 'OL' || tag == 'UL') &&\n        rootNodeToInsert &&\n        getTagOfNode(rootNodeToInsert.firstChild) == 'LI'\n    ) {\n        const shouldInsertListAsText =\n            !rootNodeToInsert.firstChild!.nextSibling && !hasBrNextToRoot;\n\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\n            safeRemove(rootNodeToInsert.nextSibling!);\n        }\n\n        if (shouldInsertListAsText) {\n            unwrap(rootNodeToInsert.firstChild!);\n            unwrap(rootNodeToInsert);\n        } else if (getTagOfNode(listNode) == tag) {\n            unwrap(rootNodeToInsert);\n            position = new Position(\n                listItem!,\n                isPositionAtBeginningOf(position, listItem!)\n                    ? PositionType.Before\n                    : PositionType.After\n            );\n        }\n    }\n\n    if (isFragment && tag == 'TABLE' && tdNode) {\n        pasteTable(\n            <HTMLTableCellElement>tdNode,\n            <HTMLTableElement>rootNodeToInsert,\n            position,\n            range\n        );\n        position = new Position(rootNodeToInsert!, 0);\n        moveChildNodes(nodeToInsert);\n    }\n\n    return position;\n}\n\n/**\n * Change P tag to DIV, when a new node when insert node.\n */\n\nfunction adjustInsertPositionForParagraph(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    if (getTagOfNode(position.node) == 'P') {\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\n        // Change P tag to DIV to make sure it works well\n        const pos = position.normalize();\n        const div = changeElementTag(<HTMLElement>position.node, 'div');\n        if (pos.node != div) {\n            position = pos;\n        }\n    }\n\n    return position;\n}\n\n/**\n * Adjust position for a node that can have children.\n */\n\nfunction adjustInsertPositionForVoidElement(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    if (isVoidHtmlElement(position.node)) {\n        position = new Position(\n            position.node,\n            position.isAtEnd ? PositionType.After : PositionType.Before\n        );\n    }\n    return position;\n}\n\n/**\n * Adjust the position cursor out of link when a new node is inserted.\n */\n\nfunction adjustInsertPositionForMoveCursorOutOfALink(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    if (range && range.collapsed) {\n        const searcher = new PositionContentSearcher(root, Position.getStart(range));\n        const inlineElementBefore = searcher.getInlineElementBefore();\n        const inlineElementAfter = searcher.getInlineElementAfter();\n        if (inlineElementBefore instanceof LinkInlineElement) {\n            position = new Position(inlineElementBefore.getContainerNode(), PositionType.After);\n        } else if (inlineElementAfter instanceof LinkInlineElement) {\n            position = new Position(inlineElementAfter.getContainerNode(), PositionType.Before);\n        }\n    }\n    return position;\n}\n\n/**\n * Adjust the position cursor out of a not contenteditable element.\n */\nfunction adjustInsertPositionForNotEditableNode(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    if (!position.element?.isContentEditable) {\n        let nonEditableElement: HTMLElement | undefined;\n        let lastNonEditableElement: HTMLElement | null = findClosestElementAncestor(\n            position.node,\n            root,\n            NOT_EDITABLE_SELECTOR\n        );\n\n        while (lastNonEditableElement) {\n            nonEditableElement = lastNonEditableElement;\n            lastNonEditableElement = nonEditableElement?.parentElement\n                ? findClosestElementAncestor(\n                      nonEditableElement.parentElement,\n                      root,\n                      NOT_EDITABLE_SELECTOR\n                  )\n                : null;\n        }\n\n        if (nonEditableElement) {\n            position = new Position(nonEditableElement, PositionType.After);\n            return adjustInsertPositionForNotEditableNode(root, nodeToInsert, position, range);\n        }\n    }\n\n    return position;\n}\n\n/**\n * Adjust the position of a table to be one line after another table.\n */\nfunction adjustInsertPositionForTable(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    if (\n        (nodeToInsert.childNodes.length == 1 &&\n            getTagOfNode(nodeToInsert.childNodes[0]) == 'TABLE') ||\n        getTagOfNode(nodeToInsert) == 'TABLE'\n    ) {\n        const { element } = position;\n\n        const posBefore = new Position(element, PositionType.Before);\n        const rangeToTraverse = createRange(posBefore, position);\n        const contentTraverser = ContentTraverser.createSelectionTraverser(root, rangeToTraverse);\n\n        let blockElement = contentTraverser && contentTraverser.currentBlockElement;\n\n        if (blockElement) {\n            let nextBlockElement: BlockElement | null = blockElement;\n\n            while (!nextBlockElement) {\n                nextBlockElement = contentTraverser.getNextBlockElement();\n                if (nextBlockElement) {\n                    blockElement = nextBlockElement;\n                }\n            }\n\n            const prevElement = blockElement?.getEndNode();\n\n            if (prevElement && findClosestElementAncestor(prevElement, root, 'TABLE')) {\n                let tempRange = createRange(position);\n                tempRange.collapse(false /* toStart */);\n                const br = root.ownerDocument.createElement('br');\n                tempRange.insertNode(br);\n\n                tempRange = createRange(br);\n                position = Position.getEnd(tempRange);\n            }\n        }\n    }\n    return position;\n}\n\n/**\n *\n * @param root the contentDiv of the ditor\n * @param nodeToInsert the node to be inserted\n * @param position the position of the node to be inserted\n * @param range the range current or cached range of the editor\n * @returns the adjusted position of the inserted node\n */\n\nexport default function adjustInsertPositionBySteps(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition,\n    range: Range\n): NodePosition {\n    adjustSteps.forEach(handler => {\n        position = handler(root, nodeToInsert, position, range);\n    });\n    return position;\n}\n\nfunction safeRemove(node: Node) {\n    node?.parentNode?.removeChild(node);\n}\n"]}