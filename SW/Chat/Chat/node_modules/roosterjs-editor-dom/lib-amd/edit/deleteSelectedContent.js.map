{"version":3,"file":"deleteSelectedContent.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/edit/deleteSelectedContent.ts"],"names":[],"mappings":"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","sourcesContent":["import arrayPush from '../jsUtils/arrayPush';\nimport collapseNodesInRegion from '../region/collapseNodesInRegion';\nimport getRegionsFromRange from '../region/getRegionsFromRange';\nimport getSelectionRangeInRegion from '../region/getSelectionRangeInRegion';\nimport mergeBlocksInRegion from '../region/mergeBlocksInRegion';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitTextNode from '../utils/splitTextNode';\nimport { PositionType, QueryScope, RegionType } from 'roosterjs-editor-types';\nimport type { NodePosition } from 'roosterjs-editor-types';\n\n/**\n * Delete selected content, and return the new position to select\n * @param core The EditorCore object.\n * @param range The range to delete\n */\nexport default function deleteSelectedContent(\n    root: HTMLElement,\n    range: Range\n): NodePosition | null {\n    let nodeBefore: Node | null = null;\n\n    // 1. TABLE and TR node in selected should be deleted. It is possible we don't detect them from step 2\n    // since table cells will fall in to different regions\n    const nodesToDelete: Node[] = queryElements(\n        root,\n        'table,tr',\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // 2. Loop all selected regions, find out those nodes need to be deleted and merged.\n    // We don't delete them directly here because delete node from one region may cause selection range\n    // another region becomes invalid. So we delay the process of deletion.\n    const regions = getRegionsFromRange(root, range, RegionType.Table);\n    const nodesPairToMerge = regions\n        .map(region => {\n            const regionRange = getSelectionRangeInRegion(region);\n            if (!regionRange) {\n                return null;\n            }\n\n            const {\n                startContainer,\n                endContainer,\n                startOffset,\n                endOffset,\n                commonAncestorContainer,\n            } = regionRange;\n\n            // Disallow merging of readonly elements\n            if (\n                safeInstanceOf(commonAncestorContainer, 'HTMLElement') &&\n                !commonAncestorContainer.isContentEditable\n            ) {\n                return null;\n            }\n\n            // Make sure there are node before and after the merging point.\n            // This is required by mergeBlocksInRegion API.\n            // This may create some empty text node as anchor\n            const [beforeEnd, afterEnd] = ensureBeforeAndAfter(\n                endContainer,\n                endOffset,\n                false /*isStart*/\n            );\n            const [beforeStart, afterStart] = ensureBeforeAndAfter(\n                startContainer,\n                startOffset,\n                true /*isStart*/\n            );\n            nodeBefore = nodeBefore || beforeStart;\n\n            // Find out all nodes to be deleted\n            const nodes = collapseNodesInRegion(region, [afterStart, beforeEnd]);\n            arrayPush(nodesToDelete, nodes);\n            return { region, beforeStart, afterEnd };\n        })\n        .filter(x => !!x);\n\n    // 3. Delete all nodes that we found, whose parent is editable\n    nodesToDelete.forEach(\n        node => node.parentElement?.isContentEditable && node.parentElement.removeChild(node)\n    );\n\n    // 4. Merge lines for each region, so that after we don't see extra line breaks\n    nodesPairToMerge.forEach(nodes => {\n        if (nodes) {\n            mergeBlocksInRegion(nodes.region, nodes.beforeStart, nodes.afterEnd);\n        }\n    });\n\n    return nodeBefore && new Position(nodeBefore, PositionType.End);\n}\n\nfunction ensureBeforeAndAfter(node: Node, offset: number, isStart: boolean) {\n    if (safeInstanceOf(node, 'Text')) {\n        const newNode = splitTextNode(node, offset, isStart);\n        return isStart ? [newNode, node] : [node, newNode];\n    } else {\n        let nodeBefore: Node | null = node.childNodes[offset - 1];\n        let nodeAfter: Node | null = node.childNodes[offset];\n\n        // Condition 1: node child nodes\n        // (\"I\" means cursor; \"o\" means a DOM node, \"[ ]\" means a parent node)\n        // [ I ]\n        // need to use parent node instead to convert to condition 2\n        if (!nodeBefore && !nodeAfter) {\n            if (isStart) {\n                nodeAfter = node;\n                nodeBefore = nodeAfter.previousSibling;\n            } else {\n                nodeBefore = node;\n                nodeAfter = nodeBefore.nextSibling;\n            }\n        }\n\n        // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)\n        // [ o I ]  or [ I o]\n        // need to add empty text node to convert to condition 3\n        if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {\n            const emptyNode = node.ownerDocument!.createTextNode('');\n            (nodeBefore || nodeAfter)?.parentNode?.insertBefore(emptyNode, nodeAfter);\n            if (nodeBefore) {\n                nodeAfter = emptyNode;\n            } else {\n                nodeBefore = emptyNode;\n            }\n        }\n\n        // Condition 3: Both nodeBefore and nodeAfter are not null\n        // [o I o]\n        // return the nodes\n        return [nodeBefore!, nodeAfter!];\n    }\n}\n"]}