define(["require", "exports", "tslib", "../utils/changeElementTag", "./getInheritableStyles", "../jsUtils/getObjectKeys", "./getPredefinedCssForElement", "../style/getStyles", "../utils/getTagOfNode", "../utils/safeInstanceOf", "../style/setStyles", "../jsUtils/toArray", "./cloneObject", "./processCssVariable", "./getAllowedValues"], function (require, exports, tslib_1, changeElementTag_1, getInheritableStyles_1, getObjectKeys_1, getPredefinedCssForElement_1, getStyles_1, getTagOfNode_1, safeInstanceOf_1, setStyles_1, toArray_1, cloneObject_1, processCssVariable_1, getAllowedValues_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * HTML sanitizer class provides two features:
     * 1. Convert global CSS to inline CSS
     * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes
     */
    var HtmlSanitizer = /** @class */ (function () {
        /**
         * Construct a new instance of HtmlSanitizer
         * @param options Options for HtmlSanitizer
         */
        function HtmlSanitizer(options) {
            options = options || {};
            this.elementCallbacks = (0, cloneObject_1.cloneObject)(options.elementCallbacks);
            this.styleCallbacks = (0, getAllowedValues_1.getStyleCallbacks)(options.cssStyleCallbacks);
            this.attributeCallbacks = (0, cloneObject_1.cloneObject)(options.attributeCallbacks);
            this.tagReplacements = (0, getAllowedValues_1.getTagReplacement)(options.additionalTagReplacements);
            this.allowedAttributes = (0, getAllowedValues_1.getAllowedAttributes)(options.additionalAllowedAttributes);
            this.allowedCssClassesRegex = (0, getAllowedValues_1.getAllowedCssClassesRegex)(options.additionalAllowedCssClasses);
            this.defaultStyleValues = (0, getAllowedValues_1.getDefaultStyleValues)(options.additionalDefaultStyleValues);
            this.additionalPredefinedCssForElement = options.additionalPredefinedCssForElement || null;
            this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];
            this.preserveHtmlComments = options.preserveHtmlComments || false;
            this.unknownTagReplacement = options.unknownTagReplacement || null;
        }
        /**
         * @deprecated Use new HtmlSanitizer().convertGlobalCssToInlineCss() instead
         * Convert global CSS to inline CSS if any
         * @param html HTML source
         * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS
         */
        HtmlSanitizer.convertInlineCss = function (html, additionalStyleNodes) {
            var sanitizer = new HtmlSanitizer({
                additionalGlobalStyleNodes: additionalStyleNodes,
            });
            return sanitizer.exec(html, true /*convertCssOnly*/);
        };
        /**
         * @deprecated Use new HtmlSanitizer().sanitize() instead
         * Sanitize HTML string, remove any unused HTML node/attribute/CSS.
         * @param html HTML source string
         * @param options Options used for this sanitizing process
         */
        HtmlSanitizer.sanitizeHtml = function (html, options) {
            options = options || {};
            var sanitizer = new HtmlSanitizer(options);
            var currentStyles = (0, safeInstanceOf_1.default)(options.currentElementOrStyle, 'HTMLElement')
                ? (0, getInheritableStyles_1.default)(options.currentElementOrStyle)
                : options.currentElementOrStyle;
            return sanitizer.exec(html, options.convertCssOnly, currentStyles);
        };
        /**
         * @deprecated Use HtmlSanitizer.convertGlobalCssToInlineCss() and HtmlSanitizer.sanitize() instead
         * Sanitize HTML string
         * This function will do the following work:
         * 1. Convert global CSS into inline CSS
         * 2. Remove dangerous HTML tags and attributes
         * 3. Remove useless CSS properties
         * @param html The input HTML
         * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing
         * @param currentStyles Current inheritable CSS styles
         */
        HtmlSanitizer.prototype.exec = function (html, convertCssOnly, currentStyles) {
            var parser = new DOMParser();
            var doc = parser.parseFromString(html || '', 'text/html');
            if (doc && doc.body && doc.body.firstChild) {
                this.convertGlobalCssToInlineCss(doc);
                if (!convertCssOnly) {
                    this.sanitize(doc.body, currentStyles);
                }
            }
            return (doc && doc.body && doc.body.innerHTML) || '';
        };
        /**
         * Splits CSS selectors, avoiding splits within parentheses
         * @param selectorText The CSS selector string
         * @return Array of trimmed selectors
         */
        HtmlSanitizer.prototype.splitSelectors = function (selectorText) {
            var regex = /(?![^(]*\)),/;
            return selectorText.split(regex).map(function (s) { return s.trim(); });
        };
        /**
         * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules
         * @param rootNode Root node to sanitize
         * @param currentStyles Current CSS styles. Inheritable styles in the given node which has
         * the same value with current styles will be ignored.
         */
        HtmlSanitizer.prototype.sanitize = function (rootNode, currentStyles) {
            if (!rootNode) {
                return '';
            }
            currentStyles = (0, cloneObject_1.cloneObject)(currentStyles, (0, getInheritableStyles_1.default)(null));
            this.processNode(rootNode, currentStyles, {});
        };
        /**
         * Convert global CSS into inline CSS
         * @param rootNode The HTML Document
         */
        HtmlSanitizer.prototype.convertGlobalCssToInlineCss = function (rootNode) {
            var e_1, _a;
            var styleNodes = (0, toArray_1.default)(rootNode.querySelectorAll('style'));
            var styleSheets = this.additionalGlobalStyleNodes
                .reverse()
                .map(function (node) { return node.sheet; })
                .concat(styleNodes.map(function (node) { return node.sheet; }).reverse())
                .filter(function (sheet) { return sheet; });
            try {
                for (var styleSheets_1 = (0, tslib_1.__values)(styleSheets), styleSheets_1_1 = styleSheets_1.next(); !styleSheets_1_1.done; styleSheets_1_1 = styleSheets_1.next()) {
                    var styleSheet = styleSheets_1_1.value;
                    var _loop_1 = function (j) {
                        var e_2, _b;
                        // Skip any none-style rule, i.e. @page
                        var styleRule = styleSheet.cssRules[j];
                        var text = styleRule && styleRule.style ? styleRule.style.cssText : null;
                        if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {
                            return "continue";
                        }
                        try {
                            // Make sure the selector is not empty
                            for (var _c = (e_2 = void 0, (0, tslib_1.__values)(this_1.splitSelectors(styleRule.selectorText))), _d = _c.next(); !_d.done; _d = _c.next()) {
                                var selector = _d.value;
                                if (!selector || !selector.trim()) {
                                    continue;
                                }
                                var nodes = (0, toArray_1.default)(rootNode.querySelectorAll(selector));
                                // Always put existing styles after so that they have higher priority
                                // Which means if both global style and inline style apply to the same element,
                                // inline style will have higher priority
                                nodes.forEach(function (node) {
                                    return node.setAttribute('style', text + (node.getAttribute('style') || ''));
                                });
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    };
                    var this_1 = this;
                    for (var j = styleSheet.cssRules.length - 1; j >= 0; j--) {
                        _loop_1(j);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (styleSheets_1_1 && !styleSheets_1_1.done && (_a = styleSheets_1.return)) _a.call(styleSheets_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            styleNodes.forEach(function (node) {
                if (node.parentNode) {
                    node.parentNode.removeChild(node);
                }
            });
        };
        HtmlSanitizer.prototype.processNode = function (node, currentStyle, context) {
            var _a;
            var nodeType = node.nodeType;
            var isElement = nodeType == 1 /* Element */;
            var isText = nodeType == 3 /* Text */;
            var isFragment = nodeType == 11 /* DocumentFragment */;
            var isComment = nodeType == 8 /* Comment */;
            var shouldKeep = false;
            if (isElement) {
                var tag = (0, getTagOfNode_1.default)(node);
                var callback = this.elementCallbacks[tag];
                var replacement = this.tagReplacements[tag.toLowerCase()];
                if (replacement === undefined) {
                    replacement = this.unknownTagReplacement;
                }
                if (callback) {
                    shouldKeep = callback(node, context);
                }
                else if (tag.indexOf(':') > 0) {
                    shouldKeep = true;
                }
                else if (tag == replacement || replacement == '*') {
                    shouldKeep = true;
                }
                else if (replacement && /^[a-zA-Z][\w\-]*$/.test(replacement)) {
                    node = (0, changeElementTag_1.default)(node, replacement);
                    shouldKeep = true;
                }
            }
            else if (isText) {
                var whiteSpace = currentStyle['white-space'];
                shouldKeep =
                    whiteSpace == 'pre' ||
                        whiteSpace == 'pre-line' ||
                        whiteSpace == 'pre-wrap' ||
                        !/^[\r\n]*$/g.test(node.nodeValue || '');
            }
            else if (isFragment) {
                shouldKeep = true;
            }
            else if (isComment) {
                shouldKeep = this.preserveHtmlComments;
            }
            else {
                shouldKeep = false;
            }
            if (!shouldKeep) {
                (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);
            }
            else if (isText &&
                (currentStyle['white-space'] == 'pre' || currentStyle['white-space'] == 'pre-wrap')) {
                node.nodeValue = (node.nodeValue || '')
                    .replace(/^ /gm, '\u00A0')
                    .replace(/ {2}/g, ' \u00A0');
            }
            else if (isElement || isFragment) {
                var thisStyle = (0, cloneObject_1.cloneObject)(currentStyle);
                var element = node;
                if (isElement) {
                    this.processAttributes(element, context);
                    this.preprocessCss(element, thisStyle);
                    this.processCss(element, thisStyle, context);
                }
                var child = element.firstChild;
                var next = void 0;
                for (; child; child = next) {
                    next = child.nextSibling;
                    this.processNode(child, thisStyle, context);
                }
            }
        };
        HtmlSanitizer.prototype.preprocessCss = function (element, thisStyle) {
            var predefinedStyles = (0, getPredefinedCssForElement_1.default)(element, this.additionalPredefinedCssForElement);
            if (predefinedStyles) {
                (0, getObjectKeys_1.default)(predefinedStyles).forEach(function (name) {
                    thisStyle[name] = predefinedStyles[name];
                });
            }
        };
        HtmlSanitizer.prototype.processCss = function (element, thisStyle, context) {
            var _this = this;
            var styles = (0, getStyles_1.default)(element);
            (0, getObjectKeys_1.default)(styles).forEach(function (name) {
                var value = styles[name];
                var callback = _this.styleCallbacks[name];
                var isInheritable = thisStyle[name] != undefined;
                var keep = true;
                if (keep && !!callback) {
                    keep = callback(value, element, thisStyle, context);
                }
                if (keep && (0, processCssVariable_1.isCssVariable)(value)) {
                    value = (0, processCssVariable_1.processCssVariable)(value);
                    keep = !!value;
                }
                keep =
                    keep &&
                        value != 'inherit' &&
                        value.indexOf('expression') < 0 &&
                        name.substr(0, 1) != '-' &&
                        _this.defaultStyleValues[name] != value &&
                        ((isInheritable && value != thisStyle[name]) ||
                            (!isInheritable && value != 'initial' && value != 'normal'));
                if (keep && isInheritable) {
                    thisStyle[name] = value;
                }
                if (keep) {
                    styles[name] = value;
                }
                else {
                    delete styles[name];
                }
            });
            (0, setStyles_1.default)(element, styles);
        };
        HtmlSanitizer.prototype.processAttributes = function (element, context) {
            for (var i = element.attributes.length - 1; i >= 0; i--) {
                var attribute = element.attributes[i];
                var name_1 = attribute.name.toLowerCase().trim();
                var value = attribute.value;
                var callback = this.attributeCallbacks[name_1];
                var newValue = callback
                    ? callback(value, element, context)
                    : this.allowedAttributes.indexOf(name_1) >= 0 || name_1.indexOf('data-') == 0
                        ? value
                        : null;
                if (name_1 == 'class' && this.allowedCssClassesRegex) {
                    newValue = this.processCssClass(value, newValue);
                }
                if (newValue === null ||
                    newValue === undefined ||
                    newValue.match(/s\n*c\n*r\n*i\n*p\n*t\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix
                ) {
                    element.removeAttribute(name_1);
                }
                else {
                    attribute.value = newValue;
                }
            }
        };
        HtmlSanitizer.prototype.processCssClass = function (originalValue, calculatedValue) {
            var _this = this;
            var originalClasses = originalValue ? originalValue.split(' ') : [];
            var calculatedClasses = calculatedValue ? calculatedValue.split(' ') : [];
            originalClasses.forEach(function (className) {
                var _a;
                if (((_a = _this.allowedCssClassesRegex) === null || _a === void 0 ? void 0 : _a.test(className)) &&
                    calculatedClasses.indexOf(className) < 0) {
                    calculatedClasses.push(className);
                }
            });
            return (calculatedClasses === null || calculatedClasses === void 0 ? void 0 : calculatedClasses.length) > 0 ? calculatedClasses.join(' ') : null;
        };
        return HtmlSanitizer;
    }());
    exports.default = HtmlSanitizer;
});
//# sourceMappingURL=HtmlSanitizer.js.map