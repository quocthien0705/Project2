{"version":3,"file":"EmptyInlineElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts"],"names":[],"mappings":";;;IAEA;;;;;OAKG;IACH;QACI,4BAAoB,QAAsB,EAAU,WAAyB;YAAzD,aAAQ,GAAR,QAAQ,CAAc;YAAU,gBAAW,GAAX,WAAW,CAAc;QAAG,CAAC;QAEjF;;WAEG;QACH,2CAAc,GAAd;YACI,OAAO,EAAE,CAAC;QACd,CAAC;QAED;;WAEG;QACH,6CAAgB,GAAhB;YACI,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;QAC9B,CAAC;QAED;;WAEG;QACH,2CAAc,GAAd;YACI,OAAO,IAAI,CAAC,WAAW,CAAC;QAC5B,CAAC;QAED;;WAEG;QACH,6CAAgB,GAAhB;YACI,OAAO,IAAI,CAAC,QAAQ,CAAC;QACzB,CAAC;QAED;;WAEG;QACH,2CAAc,GAAd;YACI,OAAO,IAAI,CAAC,QAAQ,CAAC;QACzB,CAAC;QAED;;WAEG;QACH,oCAAO,GAAP,UAAQ,aAA4B;YAChC,OAAO,aAAa,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC,CAAC;QAClF,CAAC;QAED;;WAEG;QACH,mDAAsB,GAAtB;YACI,OAAO,KAAK,CAAC;QACjB,CAAC;QAED;;WAEG;QACH,qCAAQ,GAAR,UAAS,QAAsB;YAC3B,OAAO,KAAK,CAAC;QACjB,CAAC;QAED;;WAEG;QACH,uCAAU,GAAV,UAAW,MAAqC,IAAS,CAAC;QAC9D,yBAAC;IAAD,CAAC,AA/DD,IA+DC","sourcesContent":["import type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n"]}