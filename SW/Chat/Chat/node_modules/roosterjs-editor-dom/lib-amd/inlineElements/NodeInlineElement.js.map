{"version":3,"file":"NodeInlineElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts"],"names":[],"mappings":";;;IAMA;;;;;OAKG;IACH;QACI,2BAAoB,aAAmB,EAAU,WAAyB;YAAtD,kBAAa,GAAb,aAAa,CAAM;YAAU,gBAAW,GAAX,WAAW,CAAc;QAAG,CAAC;QAE9E;;WAEG;QACI,0CAAc,GAArB;YACI,uFAAuF;YACvF,OAAO,CACH,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,gBAAiB;gBACzC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS;gBAC9B,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,IAAI,EAAE,CAC9C,CAAC;QACN,CAAC;QAED;;WAEG;QACI,4CAAgB,GAAvB;YACI,OAAO,IAAI,CAAC,aAAa,CAAC;QAC9B,CAAC;QAED,uBAAuB;QAChB,0CAAc,GAArB;YACI,OAAO,IAAI,CAAC,WAAW,CAAC;QAC5B,CAAC;QAED;;WAEG;QACI,4CAAgB,GAAvB;YACI,4DAA4D;YAC5D,yEAAyE;YACzE,OAAO,IAAI,kBAAQ,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC;QAC3D,CAAC;QAED;;WAEG;QACI,0CAAc,GAArB;YACI,4DAA4D;YAC5D,wEAAwE;YACxE,OAAO,IAAI,kBAAQ,CAAC,IAAI,CAAC,aAAa,eAAmB,CAAC,SAAS,EAAE,CAAC;QAC1E,CAAC;QAED;;WAEG;QACI,kDAAsB,GAA7B;YACI,OAAO,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,gBAAiB,CAAC;QAC9E,CAAC;QAED;;WAEG;QACI,mCAAO,GAAd,UAAe,aAA4B;YACvC,OAAO,aAAa,IAAI,IAAA,qBAAW,EAAC,IAAI,CAAC,aAAa,EAAE,aAAa,CAAC,gBAAgB,EAAE,CAAC,CAAC;QAC9F,CAAC;QAED;;WAEG;QACI,oCAAQ,GAAf,UAAgB,GAAiB;YAC7B,IAAM,KAAK,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACtC,IAAM,GAAG,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;YAClC,OAAO,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACzD,CAAC;QAED;;WAEG;QACI,sCAAU,GAAjB,UAAkB,MAA4D;YAC1E,IAAA,wBAAc,EAAC,IAAI,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;QAC/C,CAAC;QACL,wBAAC;IAAD,CAAC,AA1ED,IA0EC","sourcesContent":["import applyTextStyle from './applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport { NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be represented by a single html node.\r\n * This serves as base for most inline element as it contains most implementation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themselves for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return (\r\n            (this.containerNode.nodeType == NodeType.Text\r\n                ? this.containerNode.nodeValue\r\n                : this.containerNode.textContent) || ''\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        const start = this.getStartPosition();\r\n        const end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n"]}