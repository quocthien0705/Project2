{"version":3,"file":"PartialInlineElement.js","sourceRoot":"","sources":["../../../../packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts"],"names":[],"mappings":"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","sourcesContent":["import applyTextStyle from './applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\nimport { PositionType } from 'roosterjs-editor-types';\r\nimport type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start: NodePosition | null = null,\r\n        private end: NodePosition | null = null\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement | null {\r\n        return this.end ? new PartialInlineElement(this.inlineElement, this.end) : null;\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement | null {\r\n        return this.start\r\n            ? new PartialInlineElement(this.inlineElement, undefined, this.start)\r\n            : null;\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        const thisStart = this.getStartPosition();\r\n        const otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from: NodePosition | null = this.getStartPosition().normalize();\r\n        let to: NodePosition | null = this.getEndPosition().normalize();\r\n        const container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            const nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            const previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from || undefined, to || undefined);\r\n    }\r\n}\r\n"]}