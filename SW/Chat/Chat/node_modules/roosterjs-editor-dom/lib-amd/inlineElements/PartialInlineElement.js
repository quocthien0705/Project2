define(["require", "exports", "./applyTextStyle", "../selection/createRange", "../selection/Position", "../utils/getLeafSibling"], function (require, exports, applyTextStyle_1, createRange_1, Position_1, getLeafSibling_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is a special version of inline element that identifies a section of an inline element
     * We often have the need to cut an inline element in half and perform some operation only on half of an inline element
     * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element
     * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter
     * It also offers some special methods that others don't have, i.e. nextInlineElement etc.
     */
    var PartialInlineElement = /** @class */ (function () {
        function PartialInlineElement(inlineElement, start, end) {
            if (start === void 0) { start = null; }
            if (end === void 0) { end = null; }
            this.inlineElement = inlineElement;
            this.start = start;
            this.end = end;
        }
        /**
         * Get the full inline element that this partial inline decorates
         */
        PartialInlineElement.prototype.getDecoratedInline = function () {
            return this.inlineElement;
        };
        /**
         * Gets the container node
         */
        PartialInlineElement.prototype.getContainerNode = function () {
            return this.inlineElement.getContainerNode();
        };
        /**
         * Gets the parent block
         */
        PartialInlineElement.prototype.getParentBlock = function () {
            return this.inlineElement.getParentBlock();
        };
        /**
         * Gets the text content
         */
        PartialInlineElement.prototype.getTextContent = function () {
            var range = (0, createRange_1.default)(this.getStartPosition(), this.getEndPosition());
            return range.toString();
        };
        /**
         * Get start position of this inline element.
         */
        PartialInlineElement.prototype.getStartPosition = function () {
            return this.start || this.inlineElement.getStartPosition();
        };
        /**
         * Get end position of this inline element.
         */
        PartialInlineElement.prototype.getEndPosition = function () {
            return this.end || this.inlineElement.getEndPosition();
        };
        Object.defineProperty(PartialInlineElement.prototype, "nextInlineElement", {
            /**
             * Get next partial inline element if it is not at the end boundary yet
             */
            get: function () {
                return this.end ? new PartialInlineElement(this.inlineElement, this.end) : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PartialInlineElement.prototype, "previousInlineElement", {
            /**
             * Get previous partial inline element if it is not at the begin boundary yet
             */
            get: function () {
                return this.start
                    ? new PartialInlineElement(this.inlineElement, undefined, this.start)
                    : null;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Checks if it contains a position
         */
        PartialInlineElement.prototype.contains = function (pos) {
            return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);
        };
        /**
         * Checks if this inline element is a textual inline element
         */
        PartialInlineElement.prototype.isTextualInlineElement = function () {
            return this.inlineElement && this.inlineElement.isTextualInlineElement();
        };
        /**
         * Check if this inline element is after the other inline element
         */
        PartialInlineElement.prototype.isAfter = function (inlineElement) {
            var thisStart = this.getStartPosition();
            var otherEnd = inlineElement && inlineElement.getEndPosition();
            return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));
        };
        /**
         * apply style
         */
        PartialInlineElement.prototype.applyStyle = function (styler) {
            var from = this.getStartPosition().normalize();
            var to = this.getEndPosition().normalize();
            var container = this.getContainerNode();
            if (from.isAtEnd) {
                var nextNode = (0, getLeafSibling_1.getNextLeafSibling)(container, from.node);
                from = nextNode ? new Position_1.default(nextNode, 0 /* Begin */) : null;
            }
            if (to.offset == 0) {
                var previousNode = (0, getLeafSibling_1.getPreviousLeafSibling)(container, to.node);
                to = previousNode ? new Position_1.default(previousNode, -1 /* End */) : null;
            }
            (0, applyTextStyle_1.default)(container, styler, from || undefined, to || undefined);
        };
        return PartialInlineElement;
    }());
    exports.default = PartialInlineElement;
});
//# sourceMappingURL=PartialInlineElement.js.map