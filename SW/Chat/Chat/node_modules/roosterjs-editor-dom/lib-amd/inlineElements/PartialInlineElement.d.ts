import type { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';
/**
 * This is a special version of inline element that identifies a section of an inline element
 * We often have the need to cut an inline element in half and perform some operation only on half of an inline element
 * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element
 * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter
 * It also offers some special methods that others don't have, i.e. nextInlineElement etc.
 */
export default class PartialInlineElement implements InlineElement {
    private inlineElement;
    private start;
    private end;
    constructor(inlineElement: InlineElement, start?: NodePosition | null, end?: NodePosition | null);
    /**
     * Get the full inline element that this partial inline decorates
     */
    getDecoratedInline(): InlineElement;
    /**
     * Gets the container node
     */
    getContainerNode(): Node;
    /**
     * Gets the parent block
     */
    getParentBlock(): BlockElement;
    /**
     * Gets the text content
     */
    getTextContent(): string;
    /**
     * Get start position of this inline element.
     */
    getStartPosition(): NodePosition;
    /**
     * Get end position of this inline element.
     */
    getEndPosition(): NodePosition;
    /**
     * Get next partial inline element if it is not at the end boundary yet
     */
    get nextInlineElement(): PartialInlineElement | null;
    /**
     * Get previous partial inline element if it is not at the begin boundary yet
     */
    get previousInlineElement(): PartialInlineElement | null;
    /**
     * Checks if it contains a position
     */
    contains(pos: NodePosition): boolean;
    /**
     * Checks if this inline element is a textual inline element
     */
    isTextualInlineElement(): boolean;
    /**
     * Check if this inline element is after the other inline element
     */
    isAfter(inlineElement: InlineElement): boolean;
    /**
     * apply style
     */
    applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void;
}
