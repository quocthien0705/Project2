// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

import {
  TrouterMessage,
  MessageHandler,
  HandleMessageResult,
  LogProvider,
  ITelemetrySender,
  TelemetryEvent
} from "@skype/tstrouter";
import { AzureLogger } from "@azure/logger";
import {
  MessageReceivedPayload,
  MessageEditedPayload,
  MessageDeletedPayload,
  TypingIndicatorReceivedPayload,
  ReadReceiptReceivedPayload,
  ReadReceiptMessageBody,
  ChatThreadCreatedPayload,
  ChatThreadDeletedPayload,
  ChatThreadPropertiesUpdatedPayload,
  ParticipantsAddedPayload,
  ParticipantsRemovedPayload,
  ChatParticipantPayload
} from "./TrouterNotificationPayload";
import {
  ChatEventId,
  ChatMessageReceivedEvent,
  ChatMessageEditedEvent,
  ChatMessageDeletedEvent,
  ReadReceiptReceivedEvent,
  TypingIndicatorReceivedEvent,
  ChatThreadCreatedEvent,
  ChatThreadDeletedEvent,
  ChatThreadPropertiesUpdatedEvent,
  ParticipantsAddedEvent,
  ParticipantsRemovedEvent,
  ChatParticipant,
  ChatThreadProperties,
  ChatAttachment
} from "./events/chat";
import {
  CommunicationUserKind,
  PhoneNumberKind,
  MicrosoftTeamsUserKind,
  UnknownIdentifierKind
} from "./events/identifierModels";
import { CommunicationTokenCredential } from "./SignalingClient";
import { isNode } from "@azure/core-http";
import { CloudPrefix, CloudType, EudbCountries } from "./constants";

const eventIds = new Map<ChatEventId, number>([
  ["chatMessageReceived", 200],
  ["typingIndicatorReceived", 245],
  ["readReceiptReceived", 246],
  ["chatMessageEdited", 247],
  ["chatMessageDeleted", 248],
  ["chatThreadCreated", 257],
  ["chatThreadPropertiesUpdated", 258],
  ["chatThreadDeleted", 259],
  ["participantsAdded", 260],
  ["participantsRemoved", 261]
]);

const publicTeamsUserPrefix = "8:orgid:";
const dodTeamsUserPrefix = "8:dod:";
const gcchTeamsUserPrefix = "8:gcch:";
const teamsVisitorUserPrefix = "8:teamsvisitor:";
const phoneNumberPrefix = "4:";
const acsUserPrefix = "8:acs:";
const acsGcchUserPrefix = "8:gcch-acs:";
const acsDodUserPrefix = "8:dod-acs:";
const spoolUserPrefix = "8:spool:";

export const toMessageHandler = (
  event: ChatEventId,
  listener: (payload: any) => any,
  resourceEndpoint: string
): MessageHandler => {
  const eventId = eventIds.get(event);
  return {
    handleMessage(message: TrouterMessage): HandleMessageResult | undefined {
      let genericPayload = null;
      if (message?.rawBody) {
        genericPayload = JSON.parse(message.rawBody);
      }
      if (genericPayload === null || genericPayload.eventId !== eventId) {
        return undefined;
      }
      const eventPayload = toEventPayload(event, genericPayload, resourceEndpoint);
      if (eventPayload === null) {
        return undefined;
      }
      listener(eventPayload);
      return { isHandled: true, resultCode: 200 };
    }
  };
};

const toEventPayload = (event: ChatEventId, genericPayload: any, resourceEndpoint: string): any => {
  if (event === "chatMessageReceived") {
    const payload = genericPayload as MessageReceivedPayload;
    const eventPayload: ChatMessageReceivedEvent = {
      threadId: payload.groupId,
      sender: constructIdentifierKindFromMri(payload.senderId),
      senderDisplayName: payload.senderDisplayName,
      recipient: constructIdentifierKindFromMri(payload.recipientMri),
      id: payload.messageId,
      createdOn: new Date(payload.originalArrivalTime),
      version: payload.version,
      type: payload.messageType,
      message: payload.messageBody,
      metadata: (parseJsonString(payload.acsChatMessageMetadata) as Record<string, string>) || {},
      attachments: transformEndpoint(
        (parseJsonString(payload.attachments) as ChatAttachment[]) || [],
        resourceEndpoint
      )
    };
    return eventPayload;
  }

  if (event === "chatMessageEdited") {
    const payload = genericPayload as MessageEditedPayload;
    const eventPayload: ChatMessageEditedEvent = {
      threadId: payload.groupId,
      sender: constructIdentifierKindFromMri(payload.senderId),
      senderDisplayName: payload.senderDisplayName,
      recipient: constructIdentifierKindFromMri(payload.recipientMri),
      id: payload.messageId,
      createdOn: new Date(payload.originalArrivalTime),
      version: payload.version,
      message: payload.messageBody,
      editedOn: new Date(payload.edittime),
      type: payload.messageType,
      metadata: (parseJsonString(payload.acsChatMessageMetadata) as Record<string, string>) || {},
      attachments: transformEndpoint(
        (parseJsonString(payload.attachments) as ChatAttachment[]) || [],
        resourceEndpoint
      )
    };
    return eventPayload;
  }

  if (event === "chatMessageDeleted") {
    const payload = genericPayload as MessageDeletedPayload;
    const eventPayload: ChatMessageDeletedEvent = {
      threadId: payload.groupId,
      sender: constructIdentifierKindFromMri(payload.senderId),
      senderDisplayName: payload.senderDisplayName,
      recipient: constructIdentifierKindFromMri(payload.recipientMri),
      id: payload.messageId,
      createdOn: new Date(payload.originalArrivalTime),
      version: payload.version,
      deletedOn: new Date(payload.deletetime),
      type: payload.messageType
    };
    return eventPayload;
  }

  if (event === "typingIndicatorReceived") {
    const payload = genericPayload as TypingIndicatorReceivedPayload;
    const eventPayload: TypingIndicatorReceivedEvent = {
      threadId: payload.groupId,
      sender: constructIdentifierKindFromMri(payload.senderId),
      senderDisplayName: payload.senderDisplayName,
      recipient: constructIdentifierKindFromMri(payload.recipientMri),
      version: payload.version,
      receivedOn: new Date(payload.originalArrivalTime)
    };
    return eventPayload;
  }

  if (event === "readReceiptReceived") {
    const payload = genericPayload as ReadReceiptReceivedPayload;
    const readReceiptMessageBody = JSON.parse(payload.messageBody) as ReadReceiptMessageBody;
    const consumptionHorizon = readReceiptMessageBody.consumptionhorizon.split(";");
    const eventPayload: ReadReceiptReceivedEvent = {
      threadId: payload.groupId,
      sender: constructIdentifierKindFromMri(payload.senderId),
      senderDisplayName: "",
      recipient: constructIdentifierKindFromMri(payload.recipientMri),
      chatMessageId: payload.messageId,
      readOn: new Date(+consumptionHorizon[1])
    };
    return eventPayload;
  }

  if (event === "chatThreadCreated") {
    const payload = genericPayload as ChatThreadCreatedPayload;
    const createdByPayload = JSON.parse(unescape(payload.createdBy)) as ChatParticipantPayload;
    const membersPayload = JSON.parse(unescape(payload.members)) as ChatParticipantPayload[];
    const propertiesPayload = JSON.parse(unescape(payload.properties)) as ChatThreadProperties;
    const createdBy: ChatParticipant = {
      id: constructIdentifierKindFromMri(createdByPayload.participantId),
      displayName: createdByPayload.displayName
    };

    const chatParticipants: ChatParticipant[] = membersPayload.map((m) => {
      return {
        id: constructIdentifierKindFromMri(m.participantId),
        displayName: m.displayName
      };
    });
    const eventPayload: ChatThreadCreatedEvent = {
      threadId: payload.threadId,
      createdOn: new Date(payload.createTime),
      createdBy: createdBy,
      version: payload.version,
      participants: chatParticipants,
      properties: propertiesPayload
    };
    return eventPayload;
  }

  if (event === "chatThreadPropertiesUpdated") {
    const payload = genericPayload as ChatThreadPropertiesUpdatedPayload;
    const updatedByPayload = JSON.parse(unescape(payload.editedBy)) as ChatParticipantPayload;
    const propertiesPayload = JSON.parse(unescape(payload.properties)) as ChatThreadProperties;
    const updatedBy: ChatParticipant = {
      id: constructIdentifierKindFromMri(updatedByPayload.participantId),
      displayName: updatedByPayload.displayName
    };
    const eventPayload: ChatThreadPropertiesUpdatedEvent = {
      threadId: payload.threadId,
      updatedOn: new Date(payload.editTime),
      updatedBy: updatedBy,
      version: payload.version,
      properties: propertiesPayload
    };
    return eventPayload;
  }

  if (event === "chatThreadDeleted") {
    const payload = genericPayload as ChatThreadDeletedPayload;
    const deletedByPayload = JSON.parse(unescape(payload.deletedBy)) as ChatParticipantPayload;
    const deletedBy: ChatParticipant = {
      id: constructIdentifierKindFromMri(deletedByPayload.participantId),
      displayName: deletedByPayload.displayName
    };
    const eventPayload: ChatThreadDeletedEvent = {
      threadId: payload.threadId,
      deletedOn: new Date(payload.deleteTime),
      deletedBy: deletedBy,
      version: payload.version
    };
    return eventPayload;
  }

  if (event === "participantsAdded") {
    const payload = genericPayload as ParticipantsAddedPayload;
    const addedByPayload = JSON.parse(unescape(payload.addedBy)) as ChatParticipantPayload;
    const participantsAddedPayload = JSON.parse(
      unescape(payload.participantsAdded)
    ) as ChatParticipantPayload[];
    const addedBy: ChatParticipant = {
      id: constructIdentifierKindFromMri(addedByPayload.participantId),
      displayName: addedByPayload.displayName
    };

    const chatParticipants: ChatParticipant[] = participantsAddedPayload.map((m) => {
      return {
        id: constructIdentifierKindFromMri(m.participantId),
        displayName: m.displayName,
        shareHistoryTime: new Date(m.shareHistoryTime)
      };
    });
    const eventPayload: ParticipantsAddedEvent = {
      threadId: payload.threadId,
      addedOn: new Date(payload.time),
      addedBy: addedBy,
      version: payload.version,
      participantsAdded: chatParticipants
    };
    return eventPayload;
  }

  if (event === "participantsRemoved") {
    const payload = genericPayload as ParticipantsRemovedPayload;
    const removedByPayload = JSON.parse(unescape(payload.removedBy)) as ChatParticipantPayload;
    const participantsRemovedPayload = JSON.parse(
      unescape(payload.participantsRemoved)
    ) as ChatParticipantPayload[];
    const removedBy: ChatParticipant = {
      id: constructIdentifierKindFromMri(removedByPayload.participantId),
      displayName: removedByPayload.displayName
    };
    const chatParticipants: ChatParticipant[] = participantsRemovedPayload.map((m) => {
      return {
        id: constructIdentifierKindFromMri(m.participantId),
        displayName: m.displayName,
        shareHistoryTime: new Date(m.shareHistoryTime)
      };
    });
    const eventPayload: ParticipantsRemovedEvent = {
      threadId: payload.threadId,
      removedOn: new Date(payload.time),
      removedBy: removedBy,
      version: payload.version,
      participantsRemoved: chatParticipants
    };
    return eventPayload;
  }

  return null;
};

export const toLogProvider = (logger: AzureLogger): LogProvider => {
  return {
    log: (...message: any) => logger.info(message),
    warn: (...message: any[]) => logger.warning(message),
    error: (...message: any[]) => logger.error(message),
    debug: (...message: any[]) => logger.verbose(message),
    info: (...message: any[]) => logger.verbose(message)
  };
};

export const toTelemetrySender = (logger: AzureLogger): ITelemetrySender => {
  return {
    logEvent: (clientEvent: TelemetryEvent) => logger.info(clientEvent)
  };
};

const constructIdentifierKindFromMri = (
  mri: string
): CommunicationUserKind | PhoneNumberKind | MicrosoftTeamsUserKind | UnknownIdentifierKind => {
  if (mri.startsWith(publicTeamsUserPrefix)) {
    return {
      kind: "microsoftTeamsUser",
      rawId: mri,
      microsoftTeamsUserId: mri.substring(publicTeamsUserPrefix.length),
      isAnonymous: false,
      cloud: "public"
    };
  } else if (mri.startsWith(dodTeamsUserPrefix)) {
    return {
      kind: "microsoftTeamsUser",
      rawId: mri,
      microsoftTeamsUserId: mri.substring(dodTeamsUserPrefix.length),
      isAnonymous: false,
      cloud: "dod"
    };
  } else if (mri.startsWith(gcchTeamsUserPrefix)) {
    return {
      kind: "microsoftTeamsUser",
      rawId: mri,
      microsoftTeamsUserId: mri.substring(gcchTeamsUserPrefix.length),
      isAnonymous: false,
      cloud: "gcch"
    };
  } else if (mri.startsWith(teamsVisitorUserPrefix)) {
    return {
      kind: "microsoftTeamsUser",
      rawId: mri,
      microsoftTeamsUserId: mri.substring(teamsVisitorUserPrefix.length),
      isAnonymous: true
    };
  } else if (mri.startsWith(phoneNumberPrefix)) {
    return {
      kind: "phoneNumber",
      rawId: mri,
      phoneNumber: mri.substring(phoneNumberPrefix.length)
    };
  } else if (
    mri.startsWith(acsUserPrefix) ||
    mri.startsWith(acsGcchUserPrefix) ||
    mri.startsWith(acsDodUserPrefix) ||
    mri.startsWith(spoolUserPrefix)
  ) {
    return { kind: "communicationUser", communicationUserId: mri };
  } else {
    return { kind: "unknown", id: mri };
  }
};

const parseJsonString = (str: string): any => {
  if (
    str === undefined ||
    str === null ||
    str === "" ||
    str === "null" ||
    str === "{}" ||
    str === "[]"
  ) {
    return undefined;
  }
  return JSON.parse(str);
};

const createMediaUrlString = (urlString: string, resourceEndpoint: string): string => {
  let url: URL | undefined;
  try {
    url = new URL(urlString);
    const queryString = url.search;
  
    if (url.protocol === "http:" || url.protocol === "https:") {
      // If its already a full url, substitute the origin
      url = new URL(url.pathname, resourceEndpoint);
      url.search = queryString;
    }
  } catch (_) {
    // urlString is a likely a relative URL, so create a new one with the resourceEndpoint as base
    try {
      url = new URL(urlString, resourceEndpoint)
    } catch (_) {
      // If we get here, then the urlString passed in is likely incorrect, so just pass it along
      // As there's nothing we can do at this point.
      return urlString;
    }
  }
  return url.toString();
};

const isValidURL = (str: string): boolean => {
  let url;
  try {
    url = new URL(str);
  } catch (_) {
    return false;
  }
  return url.protocol === "http:" || url.protocol === "https:";
};

const transformEndpoint = (
  attachments: ChatAttachment[],
  resourceEndpoint: string
): ChatAttachment[] => {
  if (
    resourceEndpoint === undefined ||
    resourceEndpoint === null ||
    resourceEndpoint === "" ||
    !isValidURL(resourceEndpoint)
  ) {
    return attachments;
  }
  attachments
    .filter( (e) => e.attachmentType.toLowerCase() === "image".toLowerCase())
    .map((attachment) => {
      if (attachment.previewUrl) {
        attachment.previewUrl = createMediaUrlString(attachment.previewUrl, resourceEndpoint);
      }
      if (attachment.url) {
        attachment.url = createMediaUrlString(attachment.url, resourceEndpoint);
      }
    });
  return attachments;
};

export const base64decode = (encodedString: string): string =>
  !isNode ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();

const parseJWT = (token: string): any => {
  let [, payload] = token?.split(".");
  if (payload === undefined) {
    throw new Error("Invalid token");
  }
  payload = payload.replace(/-/g, "+").replace(/_/g, "/");
  return JSON.parse(decodeURIComponent(escape(base64decode(payload))));
};

export const parseTokenCredential = async (
  credential: CommunicationTokenCredential
): Promise<ParsedTokenCredential> => {
  const accessToken = await credential.getToken();
  const jwtToken = accessToken?.token;
  const parsedJwtToken = parseJWT(jwtToken);

  const identityMri = parsedJwtToken.skypeid;
  const acsResourceId = parsedJwtToken.resourceId;
  const cloudType = getCloudTypeFromSkypeId(identityMri);
  const resourceLocation = parsedJwtToken.resourceLocation || "";

  return { jwtToken, acsResourceId, identityMri, cloudType, resourceLocation };
};

export type ParsedTokenCredential = {
  // The original token
  jwtToken: string;
  // The ACS resource Id
  acsResourceId: string | undefined;
  // The MRI without the '8:'
  identityMri: string;
  // Public, Dod, GccHigh, Dod, AirGap08, or AirGap09
  cloudType: CloudType;
  // Resource location
  resourceLocation: string;
};

export function isEudbLocation(location: string): boolean {
  return !!location && !!EudbCountries.find((euLocation) => euLocation === location);
}

function getCloudTypeFromSkypeId(skypeId: string): CloudType {
  const cloudPrefix = skypeId.substring(0, skypeId.indexOf(":"));

  switch (cloudPrefix) {
    case CloudPrefix.OrgId:
    case CloudPrefix.Acs:
    case CloudPrefix.Spool: {
      return CloudType.Public;
    }

    case CloudPrefix.GccHigh:
    case CloudPrefix.GccHighAcs: {
      return CloudType.GccHigh;
    }

    case CloudPrefix.Dod:
    case CloudPrefix.DodAcs: {
      return CloudType.Dod;
    }

    default: {
      return CloudType.Public;
    }
  }
}
