'use strict';

var tslib = require('tslib');
var communicationCommon = require('@azure/communication-common');
var logger$1 = require('@azure/logger');
var coreTracing = require('@azure/core-tracing');
var uuid = require('uuid');
var coreClient = require('@azure/core-client');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The \@azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("communication-rooms");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Creates a span using the global tracer.
 * @internal
 */
const tracingClient$1 = coreTracing.createTracingClient({
    packageName: "Azure.Communication",
    namespace: "Microsoft.Communication",
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const tracingClient = coreTracing.createTracingClient({
    namespace: "Microsoft.Communication",
    packageName: "@azure/communication-rooms",
    packageVersion: "1.1.0-beta.1"
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const CreateRoomRequest = {
    type: {
        name: "Composite",
        className: "CreateRoomRequest",
        modelProperties: {
            validFrom: {
                serializedName: "validFrom",
                type: {
                    name: "DateTime"
                }
            },
            validUntil: {
                serializedName: "validUntil",
                type: {
                    name: "DateTime"
                }
            },
            pstnDialOutEnabled: {
                serializedName: "pstnDialOutEnabled",
                type: {
                    name: "Boolean"
                }
            },
            participants: {
                serializedName: "participants",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ParticipantProperties" }
                    }
                }
            }
        }
    }
};
const ParticipantProperties = {
    type: {
        name: "Composite",
        className: "ParticipantProperties",
        modelProperties: {
            role: {
                serializedName: "role",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Presenter", "Attendee", "Consumer"]
                }
            }
        }
    }
};
const RoomModel = {
    type: {
        name: "Composite",
        className: "RoomModel",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            validFrom: {
                serializedName: "validFrom",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            validUntil: {
                serializedName: "validUntil",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            pstnDialOutEnabled: {
                serializedName: "pstnDialOutEnabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CommunicationErrorResponse = {
    type: {
        name: "Composite",
        className: "CommunicationErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CommunicationError"
                }
            }
        }
    }
};
const CommunicationError = {
    type: {
        name: "Composite",
        className: "CommunicationError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CommunicationError"
                        }
                    }
                }
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "CommunicationError"
                }
            }
        }
    }
};
const RoomsCollection = {
    type: {
        name: "Composite",
        className: "RoomsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoomModel"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateRoomRequest = {
    type: {
        name: "Composite",
        className: "UpdateRoomRequest",
        modelProperties: {
            validFrom: {
                serializedName: "validFrom",
                type: {
                    name: "DateTime"
                }
            },
            validUntil: {
                serializedName: "validUntil",
                type: {
                    name: "DateTime"
                }
            },
            pstnDialOutEnabled: {
                serializedName: "pstnDialOutEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ParticipantsCollection = {
    type: {
        name: "Composite",
        className: "ParticipantsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoomParticipant"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoomParticipant = {
    type: {
        name: "Composite",
        className: "RoomParticipant",
        modelProperties: {
            rawId: {
                serializedName: "rawId",
                required: true,
                type: {
                    name: "String"
                }
            },
            role: {
                serializedName: "role",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Presenter", "Attendee", "Consumer"]
                }
            }
        }
    }
};
const UpdateParticipantsRequest = {
    type: {
        name: "Composite",
        className: "UpdateParticipantsRequest",
        modelProperties: {
            participants: {
                serializedName: "participants",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ParticipantProperties" }
                    }
                }
            }
        }
    }
};
const RoomsCreateExceptionHeaders = {
    type: {
        name: "Composite",
        className: "RoomsCreateExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoomsListExceptionHeaders = {
    type: {
        name: "Composite",
        className: "RoomsListExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoomsGetExceptionHeaders = {
    type: {
        name: "Composite",
        className: "RoomsGetExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoomsUpdateExceptionHeaders = {
    type: {
        name: "Composite",
        className: "RoomsUpdateExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoomsDeleteExceptionHeaders = {
    type: {
        name: "Composite",
        className: "RoomsDeleteExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoomsListNextExceptionHeaders = {
    type: {
        name: "Composite",
        className: "RoomsListNextExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParticipantsListExceptionHeaders = {
    type: {
        name: "Composite",
        className: "ParticipantsListExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParticipantsUpdateExceptionHeaders = {
    type: {
        name: "Composite",
        className: "ParticipantsUpdateExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParticipantsListNextExceptionHeaders = {
    type: {
        name: "Composite",
        className: "ParticipantsListNextExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CommunicationError: CommunicationError,
    CommunicationErrorResponse: CommunicationErrorResponse,
    CreateRoomRequest: CreateRoomRequest,
    ParticipantProperties: ParticipantProperties,
    ParticipantsCollection: ParticipantsCollection,
    ParticipantsListExceptionHeaders: ParticipantsListExceptionHeaders,
    ParticipantsListNextExceptionHeaders: ParticipantsListNextExceptionHeaders,
    ParticipantsUpdateExceptionHeaders: ParticipantsUpdateExceptionHeaders,
    RoomModel: RoomModel,
    RoomParticipant: RoomParticipant,
    RoomsCollection: RoomsCollection,
    RoomsCreateExceptionHeaders: RoomsCreateExceptionHeaders,
    RoomsDeleteExceptionHeaders: RoomsDeleteExceptionHeaders,
    RoomsGetExceptionHeaders: RoomsGetExceptionHeaders,
    RoomsListExceptionHeaders: RoomsListExceptionHeaders,
    RoomsListNextExceptionHeaders: RoomsListNextExceptionHeaders,
    RoomsUpdateExceptionHeaders: RoomsUpdateExceptionHeaders,
    UpdateParticipantsRequest: UpdateParticipantsRequest,
    UpdateRoomRequest: UpdateRoomRequest
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-10-30-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const repeatabilityRequestID = {
    parameterPath: ["options", "repeatabilityRequestID"],
    mapper: {
        serializedName: "Repeatability-Request-ID",
        type: {
            name: "Uuid"
        }
    }
};
const repeatabilityFirstSent = {
    parameterPath: ["options", "repeatabilityFirstSent"],
    mapper: {
        serializedName: "Repeatability-First-Sent",
        type: {
            name: "DateTimeRfc1123"
        }
    }
};
const roomId = {
    parameterPath: "roomId",
    mapper: {
        serializedName: "roomId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/merge-patch+json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Rooms operations. */
class RoomsImpl {
    /**
     * Initialize a new instance of the class Rooms class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new room.
     * @param options The options parameters.
     */
    async create(options) {
        return tracingClient.withSpan("RoomsRestClient.create", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ options }, createOperationSpec);
        });
    }
    /**
     * Retrieves all created rooms.
     * @param options The options parameters.
     */
    async list(options) {
        return tracingClient.withSpan("RoomsRestClient.list", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ options }, listOperationSpec$1);
        });
    }
    /**
     * Retrieves an existing room by id.
     * @param roomId The id of the room requested.
     * @param options The options parameters.
     */
    async get(roomId, options) {
        return tracingClient.withSpan("RoomsRestClient.get", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ roomId, options }, getOperationSpec);
        });
    }
    /**
     * Update a room with given changes.
     * @param roomId The id of the room requested.
     * @param options The options parameters.
     */
    async update(roomId, options) {
        return tracingClient.withSpan("RoomsRestClient.update", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ roomId, options }, updateOperationSpec$1);
        });
    }
    /**
     * Delete a room.
     * @param roomId The id of the room to be deleted.
     * @param options The options parameters.
     */
    async delete(roomId, options) {
        return tracingClient.withSpan("RoomsRestClient.delete", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ roomId, options }, deleteOperationSpec);
        });
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    async listNext(nextLink, options) {
        return tracingClient.withSpan("RoomsRestClient.listNext", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
        });
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/rooms",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: RoomModel
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
            headersMapper: RoomsCreateExceptionHeaders
        }
    },
    requestBody: {
        parameterPath: {
            validFrom: ["options", "validFrom"],
            validUntil: ["options", "validUntil"],
            pstnDialOutEnabled: ["options", "pstnDialOutEnabled"],
            participants: ["options", "participants"]
        },
        mapper: Object.assign(Object.assign({}, CreateRoomRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent
    ],
    mediaType: "json",
    serializer: serializer$1
};
const listOperationSpec$1 = {
    path: "/rooms",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoomsCollection
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
            headersMapper: RoomsListExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec = {
    path: "/rooms/{roomId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoomModel
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
            headersMapper: RoomsGetExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, roomId],
    headerParameters: [accept],
    serializer: serializer$1
};
const updateOperationSpec$1 = {
    path: "/rooms/{roomId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RoomModel
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
            headersMapper: RoomsUpdateExceptionHeaders
        }
    },
    requestBody: {
        parameterPath: {
            validFrom: ["options", "validFrom"],
            validUntil: ["options", "validUntil"],
            pstnDialOutEnabled: ["options", "pstnDialOutEnabled"]
        },
        mapper: Object.assign(Object.assign({}, UpdateRoomRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, roomId],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/rooms/{roomId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
            headersMapper: RoomsDeleteExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, roomId],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoomsCollection
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
            headersMapper: RoomsListNextExceptionHeaders
        }
    },
    urlParameters: [endpoint, nextLink],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Participants operations. */
class ParticipantsImpl {
    /**
     * Initialize a new instance of the class Participants class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get participants in a room.
     * @param roomId The id of the room to get participants from.
     * @param options The options parameters.
     */
    async list(roomId, options) {
        return tracingClient.withSpan("RoomsRestClient.list", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ roomId, options }, listOperationSpec);
        });
    }
    /**
     * Update participants in a room.
     * @param roomId The id of the room to update the participants in.
     * @param options The options parameters.
     */
    async update(roomId, options) {
        return tracingClient.withSpan("RoomsRestClient.update", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ roomId, options }, updateOperationSpec);
        });
    }
    /**
     * ListNext
     * @param roomId The id of the room to get participants from.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    async listNext(roomId, nextLink, options) {
        return tracingClient.withSpan("RoomsRestClient.listNext", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ roomId, nextLink, options }, listNextOperationSpec);
        });
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/rooms/{roomId}/participants",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ParticipantsCollection
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
            headersMapper: ParticipantsListExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, roomId],
    headerParameters: [accept],
    serializer
};
const updateOperationSpec = {
    path: "/rooms/{roomId}/participants",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
            headersMapper: ParticipantsUpdateExceptionHeaders
        }
    },
    requestBody: {
        parameterPath: { participants: ["options", "participants"] },
        mapper: Object.assign(Object.assign({}, UpdateParticipantsRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, roomId],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ParticipantsCollection
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
            headersMapper: ParticipantsListNextExceptionHeaders
        }
    },
    urlParameters: [endpoint, roomId, nextLink],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class RoomsRestClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the RoomsRestClient class.
     * @param endpoint The endpoint of the Azure Communication resource.
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-communication-rooms/1.1.0-beta.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2023-10-30-preview";
        this.rooms = new RoomsImpl(this);
        this.participants = new ParticipantsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const defaultRole = "Attendee";
/**
 * @internal
 * Mapping room participant customer model to room participant REST model.
 */
const mapToRoomParticipantRestModel = (roomParticipant) => {
    const { id, role } = roomParticipant;
    if (communicationCommon.getIdentifierKind(id).kind !== "communicationUser") {
        throwException("We currently only support CommunicationUsers");
    }
    return {
        rawId: communicationCommon.getIdentifierRawId(id),
        role: role || defaultRole,
    };
};
/**
 * @internal
 * Mapping room participant REST model to room participant customer model
 */
const mapToRoomParticipantSDKModel = (roomParticipant) => {
    const { rawId, role } = roomParticipant;
    return {
        id: communicationCommon.createIdentifierFromRawId(rawId),
        role: role || defaultRole,
    };
};
/**
 * @internal
 * Mapping room participant role to participants rawId.
 */
const mapRoomParticipantToRawId = (participants) => {
    participants = participants !== null && participants !== void 0 ? participants : [];
    const mappedParticipants = {};
    for (const participant of participants) {
        const mappedParticipant = mapToRoomParticipantRestModel(participant);
        mappedParticipants[mappedParticipant.rawId] = { role: mappedParticipant.role || defaultRole };
    }
    return mappedParticipants;
};
/**
 * @internal
 * Mapping communication identifier for removal.
 */
const mapRoomParticipantForRemoval = (ids) => {
    const mappedParticipants = {};
    for (const id of ids) {
        const rawId = communicationCommon.getIdentifierRawId(id);
        mappedParticipants[rawId] = null;
    }
    return mappedParticipants;
};
/**
 * @internal
 * Mapping room rest model to room customer model.
 */
const mapCommunicationRoomToSDKModel = (room) => {
    const { createdAt } = room, rest = tslib.__rest(room, ["createdAt"]);
    return Object.assign({ createdOn: createdAt }, rest);
};
function throwException(errorMessage) {
    throw new Error(errorMessage);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 * @internal
 */
function generateUuid() {
    return uuid.v4();
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Checks whether the type of a value is RoomsClientOptions or not.
 * @param options - The value being checked.
 */
const isRoomsClientOptions = (options) => !!options && !communicationCommon.isKeyCredential(options);
/**
 * The Rooms service client.
 */
class RoomsClient {
    constructor(connectionStringOrUrl, credentialOrOptions, maybeOptions = {}) {
        const { url, credential } = communicationCommon.parseClientArguments(connectionStringOrUrl, credentialOrOptions);
        const options = isRoomsClientOptions(credentialOrOptions) ? credentialOrOptions : maybeOptions;
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
            },
        });
        this.client = new RoomsRestClient(url, Object.assign({ endpoint: url }, internalPipelineOptions));
        const authPolicy = communicationCommon.createCommunicationAuthPolicy(credential);
        this.client.pipeline.addPolicy(authPolicy);
    }
    /**
     * Creates a new room asynchronously.
     * @param request - Request for creating a room.
     * @param options - Operation options.
     * @returns a RoomModel object with the values of the created room.
     */
    async createRoom(options = {}) {
        const repeatabilityRequestId = generateUuid();
        const repeatabilityFirstSent = new Date();
        return tracingClient$1.withSpan("RoomsClient-CreateRoom", options, async () => {
            const room = await this.client.rooms.create(Object.assign(Object.assign({}, options), { repeatabilityFirstSent: repeatabilityFirstSent, repeatabilityRequestID: repeatabilityRequestId, participants: mapRoomParticipantToRawId(options.participants) }));
            return mapCommunicationRoomToSDKModel(room);
        });
    }
    /**
     * Updates a room asynchronously.
     * @param roomId - ID of the room.
     * @param request - Request for updating a room.
     * @param options - Operational options.
     * @returns a RoomModel object with the values of the created room.
     */
    async updateRoom(roomId, options = {}) {
        return tracingClient$1.withSpan("RoomsClient-UpdateRoom", options, async () => {
            const room = await this.client.rooms.update(roomId, options);
            return mapCommunicationRoomToSDKModel(room);
        });
    }
    /**
     * Gets a room by id asynchronously.
     * @param roomId - ID of the room.
     * @param options - Operational options.
     * @returns a RoomModel object with the values of the created room.
     */
    async getRoom(roomId, options = {}) {
        return tracingClient$1.withSpan("RoomsClient-GetRoom", options, async (updatedOptions) => {
            const room = await this.client.rooms.get(roomId, updatedOptions);
            return mapCommunicationRoomToSDKModel(room);
        });
    }
    listRoomsPage(pageSettings, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listRoomsPage_1() {
            if (!pageSettings.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.rooms.list(options));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map((room) => mapCommunicationRoomToSDKModel(room)));
                }
            }
            while (pageSettings.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.rooms.listNext(pageSettings.continuationToken, options));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map((room) => mapCommunicationRoomToSDKModel(room)));
                }
                else {
                    break;
                }
            }
        });
    }
    listRoomsAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listRoomsAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listRoomsPage({}, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the list of rooms
     * @param options - Operational options
     */
    listRooms(options = {}) {
        const { span, updatedOptions } = tracingClient$1.startSpan("RoomsClient-ListRooms", options);
        try {
            const iter = this.listRoomsAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listRoomsPage(settings, updatedOptions);
                },
            };
        }
        catch (e) {
            span.setStatus({
                error: e,
                status: "error",
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes a room by id asynchronously.
     * @param roomId - ID of the room.
     * @param options - Operational options.
     */
    async deleteRoom(roomId, options = {}) {
        return tracingClient$1.withSpan("RoomsClient-DeleteRoom", options, async (updatedOptions) => {
            await this.client.rooms.delete(roomId, updatedOptions);
        });
    }
    listParticipantsPage(roomId, pageSettings, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listParticipantsPage_1() {
            if (!pageSettings.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.participants.list(roomId, options));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToRoomParticipantSDKModel, this));
                }
            }
            while (pageSettings.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.participants.listNext(roomId, pageSettings.continuationToken, options));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToRoomParticipantSDKModel, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listParticipantsAll(roomId, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listParticipantsAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listParticipantsPage(roomId, {}, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the participants of a room asynchronously.
     * @param roomId - ID of the room.
     * @param options - Operational options.
     * @returns a list of all the participants in the room.
     */
    listParticipants(roomId, options = {}) {
        const { span, updatedOptions } = tracingClient$1.startSpan("RoomsClient-GetParticipants", options);
        try {
            const iter = this.listParticipantsAll(roomId, updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listParticipantsPage(roomId, settings, updatedOptions);
                },
            };
        }
        catch (e) {
            span.setStatus({
                error: e,
                status: "error",
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates the Participants in a Room asynchronously.
     * Participant is added to room if they did not exist and updated if already in room.
     * @param roomId - ID of the room.
     * @param participants - List of participants to add or update.
     * @param options - Operational options.
     * @returns a list of all the participants in the room.
     */
    async addOrUpdateParticipants(roomId, participants, options = {}) {
        return tracingClient$1.withSpan("RoomsClient-AddOrUpdateParticipants", options, (updatedOptions) => {
            this.client.participants.update(roomId, Object.assign(Object.assign({}, updatedOptions), { participants: mapRoomParticipantToRawId(participants) }));
        });
    }
    /**
     * Removes Participants from a Room asynchronously.
     * @param roomId - ID of the room.
     * @param participantIdentifiers - List of participants' communication identifiers to remove from room.
     * @param options - Operational options.
     * @returns a list of all the participants in the room.
     */
    async removeParticipants(roomId, participantIdentifiers, options = {}) {
        return tracingClient$1.withSpan("RoomsClient-RemoveParticipants", options, (updatedOptions) => {
            this.client.participants.update(roomId, Object.assign(Object.assign({}, updatedOptions), { participants: mapRoomParticipantForRemoval(participantIdentifiers) }));
        });
    }
}

exports.RoomsClient = RoomsClient;
//# sourceMappingURL=index.js.map
