'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var communicationCommon = require('@azure/communication-common');
var logger$1 = require('@azure/logger');
var abortController = require('@azure/abort-controller');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreTracing = require('@azure/core-tracing');
var coreClient = require('@azure/core-client');
var events = require('events');
var uuid = require('uuid');
var communicationSignaling = require('@azure/communication-signaling');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const mapToCreateChatThreadOptionsRestModel = (options) => {
    const { participants, idempotencyToken } = options, rest = tslib.__rest(options, ["participants", "idempotencyToken"]);
    return Object.assign({ repeatabilityRequestId: idempotencyToken }, rest);
};
/**
 * @internal
 * Mapping chat participant customer model to chat participant REST model
 */
const mapToChatParticipantRestModel = (chatParticipant) => {
    const { id } = chatParticipant, rest = tslib.__rest(chatParticipant, ["id"]);
    return Object.assign(Object.assign({}, rest), { communicationIdentifier: communicationCommon.serializeCommunicationIdentifier(id) });
};
/**
 * @internal
 * Mapping add participants request to add chat participants request REST model
 */
const mapToAddChatParticipantsRequestRestModel = (addParticipantsRequest) => {
    var _a;
    return {
        participants: (_a = addParticipantsRequest.participants) === null || _a === void 0 ? void 0 : _a.map((participant) => mapToChatParticipantRestModel(participant)),
    };
};
/**
 * @internal
 * Mapping chat attachment SDK model to chat attachment REST model
 */
const mapToChatAttachmentRestModel = (chatAttachment) => {
    const { attachmentType } = chatAttachment, rest = tslib.__rest(chatAttachment, ["attachmentType"]);
    if (attachmentType === "unknown") {
        throw new Error("'unknown' attachmentType not supported");
    }
    return Object.assign(Object.assign({}, rest), { attachmentType: attachmentType });
};
/**
 * @internal
 * Mapping send message request and options to send chat message request REST model
 */
const mapToSendChatMessageRequestRestModel = (sendMessageRequest, sendMessageOptions) => {
    const { attachments } = sendMessageOptions, restOptions = tslib.__rest(sendMessageOptions, ["attachments"]);
    let request = Object.assign(Object.assign({}, sendMessageRequest), restOptions);
    if (attachments) {
        request = Object.assign(Object.assign({}, request), { attachments: attachments === null || attachments === void 0 ? void 0 : attachments.map((attachment) => mapToChatAttachmentRestModel(attachment)) });
    }
    return request;
};
/**
 * @internal
 * Mapping update message options to update chat message request REST model
 */
const mapToUpdateChatMessageRequestRestModel = (updateMessageOptions) => {
    const { attachments } = updateMessageOptions, restOptions = tslib.__rest(updateMessageOptions, ["attachments"]);
    let request = Object.assign({}, restOptions);
    if (attachments) {
        request = Object.assign(Object.assign({}, request), { attachments: attachments === null || attachments === void 0 ? void 0 : attachments.map((attachment) => mapToChatAttachmentRestModel(attachment)) });
    }
    return request;
};
/**
 * @internal
 * Mapping chat participant REST model to chat participant SDK model
 */
const mapToChatParticipantSdkModel = (chatParticipant) => {
    const { communicationIdentifier } = chatParticipant, rest = tslib.__rest(chatParticipant, ["communicationIdentifier"]);
    return Object.assign(Object.assign({}, rest), { id: communicationCommon.deserializeCommunicationIdentifier(communicationIdentifier) });
};
/**
 * @internal
 * Mapping chat attachment REST model to chat attachment SDK model
 */
const mapToChatAttachmentSdkModel = (chatAttachment) => {
    const { attachmentType } = chatAttachment, rest = tslib.__rest(chatAttachment, ["attachmentType"]);
    return Object.assign(Object.assign({}, rest), { attachmentType: attachmentType });
};
/**
 * @internal
 */
const mapToChatContentSdkModel = (content) => {
    const { participants, attachments, initiatorCommunicationIdentifier } = content, otherChatContents = tslib.__rest(content, ["participants", "attachments", "initiatorCommunicationIdentifier"]);
    let result = Object.assign({}, otherChatContents);
    if (initiatorCommunicationIdentifier) {
        const initiator = communicationCommon.deserializeCommunicationIdentifier(initiatorCommunicationIdentifier);
        result = Object.assign(Object.assign({}, result), { initiator });
    }
    if (participants) {
        result = Object.assign(Object.assign({}, result), { participants: participants === null || participants === void 0 ? void 0 : participants.map((participant) => mapToChatParticipantSdkModel(participant)) });
    }
    if (attachments) {
        result = Object.assign(Object.assign({}, result), { attachments: attachments === null || attachments === void 0 ? void 0 : attachments.map((attachment) => mapToChatAttachmentSdkModel(attachment)) });
    }
    return result;
};
/**
 * @internal
 * Mapping chat message REST model to chat message SDK model
 */
const mapToChatMessageSdkModel = (chatMessage) => {
    const { content, senderCommunicationIdentifier } = chatMessage, otherChatMessage = tslib.__rest(chatMessage, ["content", "senderCommunicationIdentifier"]);
    let result = Object.assign({}, otherChatMessage);
    if (content) {
        result = Object.assign(Object.assign({}, result), { content: mapToChatContentSdkModel(content) });
    }
    if (senderCommunicationIdentifier) {
        const sender = communicationCommon.deserializeCommunicationIdentifier(senderCommunicationIdentifier);
        result = Object.assign(Object.assign({}, result), { sender });
    }
    return result;
};
/**
 * @internal
 * Mapping chat retention policy REST model to chat retention policy SDK model
 */
const mapToRetentionPolicySdkModel = (retentionPolicy) => {
    if (retentionPolicy.kind === "threadCreationDate") {
        return retentionPolicy;
    }
    if (retentionPolicy.kind === "none") {
        return retentionPolicy;
    }
    else {
        throw new Error(`Retention Policy ${retentionPolicy.kind} is not supported`);
    }
};
/**
 * @internal
 * Mapping chat thread REST model to chat thread SDK model
 */
const mapToChatThreadPropertiesSdkModel = (chatThread) => {
    const { createdByCommunicationIdentifier, retentionPolicy } = chatThread, rest = tslib.__rest(chatThread, ["createdByCommunicationIdentifier", "retentionPolicy"]);
    let result = Object.assign({}, rest);
    if (createdByCommunicationIdentifier) {
        result = Object.assign(Object.assign({}, result), { createdBy: communicationCommon.deserializeCommunicationIdentifier(createdByCommunicationIdentifier) });
    }
    if (retentionPolicy) {
        result = Object.assign(Object.assign({}, result), { retentionPolicy: mapToRetentionPolicySdkModel(retentionPolicy) });
    }
    return result;
};
/**
 * @internal
 * Mapping chat thread REST model to chat thread SDK model
 */
const mapToCreateChatThreadResultSdkModel = (result) => {
    const { chatThread } = result, rest = tslib.__rest(result, ["chatThread"]);
    if (chatThread) {
        return Object.assign(Object.assign({}, rest), { chatThread: mapToChatThreadPropertiesSdkModel(chatThread) });
    }
    else {
        return Object.assign({}, rest);
    }
};
/**
 * @internal
 * Mapping read receipt REST model to read receipt SDK model
 */
const mapToReadReceiptSdkModel = (readReceipt) => {
    const { senderCommunicationIdentifier } = readReceipt, rest = tslib.__rest(readReceipt, ["senderCommunicationIdentifier"]);
    return Object.assign(Object.assign({}, rest), { sender: communicationCommon.deserializeCommunicationIdentifier(senderCommunicationIdentifier) });
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const tracingClient = coreTracing.createTracingClient({
    namespace: "Azure.Communication",
    packageName: "@azure/communication-chat",
    packageVersion: "1.6.0-beta.1",
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ChatMessageReadReceiptsCollection = {
    type: {
        name: "Composite",
        className: "ChatMessageReadReceiptsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatMessageReadReceipt",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ChatMessageReadReceipt = {
    type: {
        name: "Composite",
        className: "ChatMessageReadReceipt",
        modelProperties: {
            senderCommunicationIdentifier: {
                serializedName: "senderCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            chatMessageId: {
                serializedName: "chatMessageId",
                required: true,
                type: {
                    name: "String",
                },
            },
            readOn: {
                serializedName: "readOn",
                required: true,
                type: {
                    name: "DateTime",
                },
            },
        },
    },
};
const CommunicationIdentifierModel = {
    type: {
        name: "Composite",
        className: "CommunicationIdentifierModel",
        modelProperties: {
            kind: {
                serializedName: "kind",
                type: {
                    name: "String",
                },
            },
            rawId: {
                serializedName: "rawId",
                type: {
                    name: "String",
                },
            },
            communicationUser: {
                serializedName: "communicationUser",
                type: {
                    name: "Composite",
                    className: "CommunicationUserIdentifierModel",
                },
            },
            phoneNumber: {
                serializedName: "phoneNumber",
                type: {
                    name: "Composite",
                    className: "PhoneNumberIdentifierModel",
                },
            },
            microsoftTeamsUser: {
                serializedName: "microsoftTeamsUser",
                type: {
                    name: "Composite",
                    className: "MicrosoftTeamsUserIdentifierModel",
                },
            },
            microsoftTeamsApp: {
                serializedName: "microsoftTeamsApp",
                type: {
                    name: "Composite",
                    className: "MicrosoftTeamsAppIdentifierModel",
                },
            },
        },
    },
};
const CommunicationUserIdentifierModel = {
    type: {
        name: "Composite",
        className: "CommunicationUserIdentifierModel",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PhoneNumberIdentifierModel = {
    type: {
        name: "Composite",
        className: "PhoneNumberIdentifierModel",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MicrosoftTeamsUserIdentifierModel = {
    type: {
        name: "Composite",
        className: "MicrosoftTeamsUserIdentifierModel",
        modelProperties: {
            userId: {
                serializedName: "userId",
                required: true,
                type: {
                    name: "String",
                },
            },
            isAnonymous: {
                serializedName: "isAnonymous",
                type: {
                    name: "Boolean",
                },
            },
            cloud: {
                serializedName: "cloud",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MicrosoftTeamsAppIdentifierModel = {
    type: {
        name: "Composite",
        className: "MicrosoftTeamsAppIdentifierModel",
        modelProperties: {
            appId: {
                serializedName: "appId",
                required: true,
                type: {
                    name: "String",
                },
            },
            cloud: {
                serializedName: "cloud",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CommunicationErrorResponse = {
    type: {
        name: "Composite",
        className: "CommunicationErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ChatError",
                },
            },
        },
    },
};
const ChatError = {
    type: {
        name: "Composite",
        className: "ChatError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String",
                },
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatError",
                        },
                    },
                },
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ChatError",
                },
            },
        },
    },
};
const SendReadReceiptRequest = {
    type: {
        name: "Composite",
        className: "SendReadReceiptRequest",
        modelProperties: {
            chatMessageId: {
                serializedName: "chatMessageId",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SendChatMessageRequest = {
    type: {
        name: "Composite",
        className: "SendChatMessageRequest",
        modelProperties: {
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String",
                },
            },
            senderDisplayName: {
                serializedName: "senderDisplayName",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "text",
                        "html",
                        "topicUpdated",
                        "participantAdded",
                        "participantRemoved",
                    ],
                },
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            attachments: {
                serializedName: "attachments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatAttachment",
                        },
                    },
                },
            },
        },
    },
};
const ChatAttachment = {
    type: {
        name: "Composite",
        className: "ChatAttachment",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            },
            attachmentType: {
                serializedName: "attachmentType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["image", "file"],
                },
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String",
                },
            },
            previewUrl: {
                serializedName: "previewUrl",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SendChatMessageResult = {
    type: {
        name: "Composite",
        className: "SendChatMessageResult",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ChatMessagesCollection = {
    type: {
        name: "Composite",
        className: "ChatMessagesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatMessage",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ChatMessage = {
    type: {
        name: "Composite",
        className: "ChatMessage",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "text",
                        "html",
                        "topicUpdated",
                        "participantAdded",
                        "participantRemoved",
                    ],
                },
            },
            sequenceId: {
                serializedName: "sequenceId",
                required: true,
                type: {
                    name: "String",
                },
            },
            version: {
                serializedName: "version",
                required: true,
                type: {
                    name: "String",
                },
            },
            content: {
                serializedName: "content",
                type: {
                    name: "Composite",
                    className: "ChatMessageContent",
                },
            },
            senderDisplayName: {
                serializedName: "senderDisplayName",
                type: {
                    name: "String",
                },
            },
            createdOn: {
                serializedName: "createdOn",
                required: true,
                type: {
                    name: "DateTime",
                },
            },
            senderCommunicationIdentifier: {
                serializedName: "senderCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            deletedOn: {
                serializedName: "deletedOn",
                type: {
                    name: "DateTime",
                },
            },
            editedOn: {
                serializedName: "editedOn",
                type: {
                    name: "DateTime",
                },
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const ChatMessageContent = {
    type: {
        name: "Composite",
        className: "ChatMessageContent",
        modelProperties: {
            message: {
                serializedName: "message",
                type: {
                    name: "String",
                },
            },
            topic: {
                serializedName: "topic",
                type: {
                    name: "String",
                },
            },
            participants: {
                serializedName: "participants",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant",
                        },
                    },
                },
            },
            attachments: {
                serializedName: "attachments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatAttachment",
                        },
                    },
                },
            },
            initiatorCommunicationIdentifier: {
                serializedName: "initiatorCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
        },
    },
};
const ChatParticipant = {
    type: {
        name: "Composite",
        className: "ChatParticipant",
        modelProperties: {
            communicationIdentifier: {
                serializedName: "communicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String",
                },
            },
            shareHistoryTime: {
                serializedName: "shareHistoryTime",
                type: {
                    name: "DateTime",
                },
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const UpdateChatMessageRequest = {
    type: {
        name: "Composite",
        className: "UpdateChatMessageRequest",
        modelProperties: {
            content: {
                serializedName: "content",
                type: {
                    name: "String",
                },
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            attachments: {
                serializedName: "attachments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatAttachment",
                        },
                    },
                },
            },
        },
    },
};
const ChatParticipantsCollection = {
    type: {
        name: "Composite",
        className: "ChatParticipantsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AddChatParticipantsRequest = {
    type: {
        name: "Composite",
        className: "AddChatParticipantsRequest",
        modelProperties: {
            participants: {
                serializedName: "participants",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant",
                        },
                    },
                },
            },
        },
    },
};
const AddChatParticipantsResult = {
    type: {
        name: "Composite",
        className: "AddChatParticipantsResult",
        modelProperties: {
            invalidParticipants: {
                serializedName: "invalidParticipants",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatError",
                        },
                    },
                },
            },
        },
    },
};
const CreateChatThreadRequest = {
    type: {
        name: "Composite",
        className: "CreateChatThreadRequest",
        modelProperties: {
            topic: {
                serializedName: "topic",
                required: true,
                type: {
                    name: "String",
                },
            },
            participants: {
                serializedName: "participants",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant",
                        },
                    },
                },
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            retentionPolicy: {
                serializedName: "retentionPolicy",
                type: {
                    name: "Composite",
                    className: "ChatRetentionPolicy",
                },
            },
        },
    },
};
const ChatRetentionPolicy = {
    type: {
        name: "Composite",
        className: "ChatRetentionPolicy",
        uberParent: "ChatRetentionPolicy",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind",
        },
        modelProperties: {
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["threadCreationDate", "none"],
                },
            },
        },
    },
};
const CreateChatThreadResult = {
    type: {
        name: "Composite",
        className: "CreateChatThreadResult",
        modelProperties: {
            chatThread: {
                serializedName: "chatThread",
                type: {
                    name: "Composite",
                    className: "ChatThreadProperties",
                },
            },
            invalidParticipants: {
                serializedName: "invalidParticipants",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatError",
                        },
                    },
                },
            },
        },
    },
};
const ChatThreadProperties = {
    type: {
        name: "Composite",
        className: "ChatThreadProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            },
            topic: {
                serializedName: "topic",
                required: true,
                type: {
                    name: "String",
                },
            },
            createdOn: {
                serializedName: "createdOn",
                required: true,
                type: {
                    name: "DateTime",
                },
            },
            createdByCommunicationIdentifier: {
                serializedName: "createdByCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            deletedOn: {
                serializedName: "deletedOn",
                type: {
                    name: "DateTime",
                },
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            retentionPolicy: {
                serializedName: "retentionPolicy",
                type: {
                    name: "Composite",
                    className: "ChatRetentionPolicy",
                },
            },
        },
    },
};
const ChatThreadsItemCollection = {
    type: {
        name: "Composite",
        className: "ChatThreadsItemCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatThreadItem",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ChatThreadItem = {
    type: {
        name: "Composite",
        className: "ChatThreadItem",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            },
            topic: {
                serializedName: "topic",
                required: true,
                type: {
                    name: "String",
                },
            },
            deletedOn: {
                serializedName: "deletedOn",
                type: {
                    name: "DateTime",
                },
            },
            lastMessageReceivedOn: {
                serializedName: "lastMessageReceivedOn",
                readOnly: true,
                type: {
                    name: "DateTime",
                },
            },
        },
    },
};
const UpdateChatThreadRequest = {
    type: {
        name: "Composite",
        className: "UpdateChatThreadRequest",
        modelProperties: {
            topic: {
                serializedName: "topic",
                type: {
                    name: "String",
                },
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            retentionPolicy: {
                serializedName: "retentionPolicy",
                type: {
                    name: "Composite",
                    className: "ChatRetentionPolicy",
                },
            },
        },
    },
};
const SendTypingNotificationRequest = {
    type: {
        name: "Composite",
        className: "SendTypingNotificationRequest",
        modelProperties: {
            senderDisplayName: {
                serializedName: "senderDisplayName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const UploadChatImageResult = {
    type: {
        name: "Composite",
        className: "UploadChatImageResult",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            },
            attachmentType: {
                serializedName: "attachmentType",
                type: {
                    name: "Enum",
                    allowedValues: ["image", "file"],
                },
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel",
                },
            },
        },
    },
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String",
                },
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail",
                        },
                    },
                },
            },
        },
    },
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ThreadCreationDateRetentionPolicy = {
    serializedName: "threadCreationDate",
    type: {
        name: "Composite",
        className: "ThreadCreationDateRetentionPolicy",
        uberParent: "ChatRetentionPolicy",
        polymorphicDiscriminator: ChatRetentionPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ChatRetentionPolicy.type.modelProperties), { deleteThreadAfterDays: {
                serializedName: "deleteThreadAfterDays",
                required: true,
                type: {
                    name: "Number",
                },
            } }),
    },
};
const NoneRetentionPolicy = {
    serializedName: "none",
    type: {
        name: "Composite",
        className: "NoneRetentionPolicy",
        uberParent: "ChatRetentionPolicy",
        polymorphicDiscriminator: ChatRetentionPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, ChatRetentionPolicy.type.modelProperties),
    },
};
let discriminators = {
    ChatRetentionPolicy: ChatRetentionPolicy,
    "ChatRetentionPolicy.threadCreationDate": ThreadCreationDateRetentionPolicy,
    "ChatRetentionPolicy.none": NoneRetentionPolicy,
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AddChatParticipantsRequest: AddChatParticipantsRequest,
    AddChatParticipantsResult: AddChatParticipantsResult,
    ChatAttachment: ChatAttachment,
    ChatError: ChatError,
    ChatMessage: ChatMessage,
    ChatMessageContent: ChatMessageContent,
    ChatMessageReadReceipt: ChatMessageReadReceipt,
    ChatMessageReadReceiptsCollection: ChatMessageReadReceiptsCollection,
    ChatMessagesCollection: ChatMessagesCollection,
    ChatParticipant: ChatParticipant,
    ChatParticipantsCollection: ChatParticipantsCollection,
    ChatRetentionPolicy: ChatRetentionPolicy,
    ChatThreadItem: ChatThreadItem,
    ChatThreadProperties: ChatThreadProperties,
    ChatThreadsItemCollection: ChatThreadsItemCollection,
    CommunicationErrorResponse: CommunicationErrorResponse,
    CommunicationIdentifierModel: CommunicationIdentifierModel,
    CommunicationUserIdentifierModel: CommunicationUserIdentifierModel,
    CreateChatThreadRequest: CreateChatThreadRequest,
    CreateChatThreadResult: CreateChatThreadResult,
    ErrorDetail: ErrorDetail,
    ErrorModel: ErrorModel,
    ErrorResponse: ErrorResponse,
    MicrosoftTeamsAppIdentifierModel: MicrosoftTeamsAppIdentifierModel,
    MicrosoftTeamsUserIdentifierModel: MicrosoftTeamsUserIdentifierModel,
    NoneRetentionPolicy: NoneRetentionPolicy,
    PhoneNumberIdentifierModel: PhoneNumberIdentifierModel,
    SendChatMessageRequest: SendChatMessageRequest,
    SendChatMessageResult: SendChatMessageResult,
    SendReadReceiptRequest: SendReadReceiptRequest,
    SendTypingNotificationRequest: SendTypingNotificationRequest,
    ThreadCreationDateRetentionPolicy: ThreadCreationDateRetentionPolicy,
    UpdateChatMessageRequest: UpdateChatMessageRequest,
    UpdateChatThreadRequest: UpdateChatThreadRequest,
    UploadChatImageResult: UploadChatImageResult,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const chatThreadId = {
    parameterPath: "chatThreadId",
    mapper: {
        serializedName: "chatThreadId",
        required: true,
        type: {
            name: "String",
        },
    },
};
const maxPageSize = {
    parameterPath: ["options", "maxPageSize"],
    mapper: {
        serializedName: "maxPageSize",
        type: {
            name: "Number",
        },
    },
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        serializedName: "skip",
        type: {
            name: "Number",
        },
    },
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2024-03-15-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String",
        },
    },
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String",
        },
    },
};
const sendReadReceiptRequest = {
    parameterPath: "sendReadReceiptRequest",
    mapper: SendReadReceiptRequest,
};
const sendChatMessageRequest = {
    parameterPath: "sendChatMessageRequest",
    mapper: SendChatMessageRequest,
};
const startTime = {
    parameterPath: ["options", "startTime"],
    mapper: {
        serializedName: "startTime",
        type: {
            name: "DateTime",
        },
    },
};
const chatMessageId = {
    parameterPath: "chatMessageId",
    mapper: {
        serializedName: "chatMessageId",
        required: true,
        type: {
            name: "String",
        },
    },
};
const contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/merge-patch+json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String",
        },
    },
};
const updateChatMessageRequest = {
    parameterPath: "updateChatMessageRequest",
    mapper: UpdateChatMessageRequest,
};
const participantCommunicationIdentifier = {
    parameterPath: "participantCommunicationIdentifier",
    mapper: CommunicationIdentifierModel,
};
const addChatParticipantsRequest = {
    parameterPath: "addChatParticipantsRequest",
    mapper: AddChatParticipantsRequest,
};
const updateChatThreadRequest = {
    parameterPath: "updateChatThreadRequest",
    mapper: UpdateChatThreadRequest,
};
const sendTypingNotificationRequest = {
    parameterPath: ["options", "sendTypingNotificationRequest"],
    mapper: SendTypingNotificationRequest,
};
const contentType2 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/octet-stream",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String",
        },
    },
};
const chatImageFile = {
    parameterPath: "chatImageFile",
    mapper: {
        serializedName: "chatImageFile",
        required: true,
        type: {
            name: "Stream",
        },
    },
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const imageFilename = {
    parameterPath: ["options", "imageFilename"],
    mapper: {
        serializedName: "image-filename",
        type: {
            name: "String",
        },
    },
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, image/gif, image/jpeg, image/png, image/bmp, image/tiff",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const imageId = {
    parameterPath: "imageId",
    mapper: {
        serializedName: "imageId",
        required: true,
        type: {
            name: "String",
        },
    },
};
const imageViewType = {
    parameterPath: "imageViewType",
    mapper: {
        serializedName: "imageViewType",
        required: true,
        type: {
            name: "String",
        },
    },
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const createChatThreadRequest = {
    parameterPath: "createChatThreadRequest",
    mapper: CreateChatThreadRequest,
};
const repeatabilityRequestId = {
    parameterPath: ["options", "repeatabilityRequestId"],
    mapper: {
        serializedName: "repeatability-request-id",
        type: {
            name: "String",
        },
    },
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ChatThread operations. */
class ChatThreadImpl {
    /**
     * Initialize a new instance of the class ChatThread class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets chat message read receipts for a thread.
     * @param chatThreadId Thread id to get the chat message read receipts for.
     * @param options The options parameters.
     */
    async listChatReadReceipts(chatThreadId, options) {
        return tracingClient.withSpan("ChatApiClient.listChatReadReceipts", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, options }, listChatReadReceiptsOperationSpec);
        });
    }
    /**
     * Sends a read receipt event to a thread, on behalf of a user.
     * @param chatThreadId Thread id to send the read receipt event to.
     * @param sendReadReceiptRequest Read receipt details.
     * @param options The options parameters.
     */
    async sendChatReadReceipt(chatThreadId, sendReadReceiptRequest, options) {
        return tracingClient.withSpan("ChatApiClient.sendChatReadReceipt", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, sendReadReceiptRequest, options }, sendChatReadReceiptOperationSpec);
        });
    }
    /**
     * Sends a message to a thread.
     * @param chatThreadId The thread id to send the message to.
     * @param sendChatMessageRequest Details of the message to send.
     * @param options The options parameters.
     */
    async sendChatMessage(chatThreadId, sendChatMessageRequest, options) {
        return tracingClient.withSpan("ChatApiClient.sendChatMessage", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, sendChatMessageRequest, options }, sendChatMessageOperationSpec);
        });
    }
    /**
     * Gets a list of messages from a thread.
     * @param chatThreadId The thread id of the message.
     * @param options The options parameters.
     */
    async listChatMessages(chatThreadId, options) {
        return tracingClient.withSpan("ChatApiClient.listChatMessages", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, options }, listChatMessagesOperationSpec);
        });
    }
    /**
     * Gets a message by id.
     * @param chatThreadId The thread id to which the message was sent.
     * @param chatMessageId The message id.
     * @param options The options parameters.
     */
    async getChatMessage(chatThreadId, chatMessageId, options) {
        return tracingClient.withSpan("ChatApiClient.getChatMessage", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, chatMessageId, options }, getChatMessageOperationSpec);
        });
    }
    /**
     * Updates a message.
     * @param chatThreadId The thread id to which the message was sent.
     * @param chatMessageId The message id.
     * @param updateChatMessageRequest Details of the request to update the message.
     * @param options The options parameters.
     */
    async updateChatMessage(chatThreadId, chatMessageId, updateChatMessageRequest, options) {
        return tracingClient.withSpan("ChatApiClient.updateChatMessage", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, chatMessageId, updateChatMessageRequest, options }, updateChatMessageOperationSpec);
        });
    }
    /**
     * Deletes a message.
     * @param chatThreadId The thread id to which the message was sent.
     * @param chatMessageId The message id.
     * @param options The options parameters.
     */
    async deleteChatMessage(chatThreadId, chatMessageId, options) {
        return tracingClient.withSpan("ChatApiClient.deleteChatMessage", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, chatMessageId, options }, deleteChatMessageOperationSpec);
        });
    }
    /**
     * Gets the participants of a thread.
     * @param chatThreadId Thread id to get participants for.
     * @param options The options parameters.
     */
    async listChatParticipants(chatThreadId, options) {
        return tracingClient.withSpan("ChatApiClient.listChatParticipants", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, options }, listChatParticipantsOperationSpec);
        });
    }
    /**
     * Remove a participant from a thread.
     * @param chatThreadId Thread id to remove the participant from.
     * @param participantCommunicationIdentifier Id of the thread participant to remove from the thread.
     * @param options The options parameters.
     */
    async removeChatParticipant(chatThreadId, participantCommunicationIdentifier, options) {
        return tracingClient.withSpan("ChatApiClient.removeChatParticipant", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, participantCommunicationIdentifier, options }, removeChatParticipantOperationSpec);
        });
    }
    /**
     * Adds thread participants to a thread. If participants already exist, no change occurs.
     * @param chatThreadId Id of the thread to add participants to.
     * @param addChatParticipantsRequest Thread participants to be added to the thread.
     * @param options The options parameters.
     */
    async addChatParticipants(chatThreadId, addChatParticipantsRequest, options) {
        return tracingClient.withSpan("ChatApiClient.addChatParticipants", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, addChatParticipantsRequest, options }, addChatParticipantsOperationSpec);
        });
    }
    /**
     * Updates a thread's properties.
     * @param chatThreadId The id of the thread to update.
     * @param updateChatThreadRequest Request payload for updating a chat thread.
     * @param options The options parameters.
     */
    async updateChatThreadProperties(chatThreadId, updateChatThreadRequest, options) {
        return tracingClient.withSpan("ChatApiClient.updateChatThreadProperties", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, updateChatThreadRequest, options }, updateChatThreadPropertiesOperationSpec);
        });
    }
    /**
     * Gets a chat thread's properties.
     * @param chatThreadId Id of the thread.
     * @param options The options parameters.
     */
    async getChatThreadProperties(chatThreadId, options) {
        return tracingClient.withSpan("ChatApiClient.getChatThreadProperties", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, options }, getChatThreadPropertiesOperationSpec);
        });
    }
    /**
     * Posts a typing event to a thread, on behalf of a user.
     * @param chatThreadId Id of the thread.
     * @param options The options parameters.
     */
    async sendTypingNotification(chatThreadId, options) {
        return tracingClient.withSpan("ChatApiClient.sendTypingNotification", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, options }, sendTypingNotificationOperationSpec);
        });
    }
    /**
     * Upload an image in a thread, on behalf of a user.
     * @param chatThreadId Thread id where the uploaded image belongs to. (Teams meeting only)
     * @param chatImageFile Image binary data, allowed image formats: jpeg, png, gif, heic, webp
     * @param options The options parameters.
     */
    async uploadChatImage(chatThreadId, chatImageFile, options) {
        return tracingClient.withSpan("ChatApiClient.uploadChatImage", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, chatImageFile, options }, uploadChatImageOperationSpec);
        });
    }
    /**
     * Get an image by view type.
     * @param chatThreadId The thread id to which the message was sent.
     * @param imageId The image id.
     * @param imageViewType The view type of image.
     * @param options The options parameters.
     */
    async getChatImage(chatThreadId, imageId, imageViewType, options) {
        return tracingClient.withSpan("ChatApiClient.getChatImage", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, imageId, imageViewType, options }, getChatImageOperationSpec);
        });
    }
    /**
     * Deletes a image.
     * @param chatThreadId The thread id to which the message was sent.
     * @param imageId The image id.
     * @param options The options parameters.
     */
    async deleteChatImage(chatThreadId, imageId, options) {
        return tracingClient.withSpan("ChatApiClient.deleteChatImage", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, imageId, options }, deleteChatImageOperationSpec);
        });
    }
    /**
     * ListChatReadReceiptsNext
     * @param chatThreadId Thread id to get the chat message read receipts for.
     * @param nextLink The nextLink from the previous successful call to the ListChatReadReceipts method.
     * @param options The options parameters.
     */
    async listChatReadReceiptsNext(chatThreadId, nextLink, options) {
        return tracingClient.withSpan("ChatApiClient.listChatReadReceiptsNext", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, nextLink, options }, listChatReadReceiptsNextOperationSpec);
        });
    }
    /**
     * ListChatMessagesNext
     * @param chatThreadId The thread id of the message.
     * @param nextLink The nextLink from the previous successful call to the ListChatMessages method.
     * @param options The options parameters.
     */
    async listChatMessagesNext(chatThreadId, nextLink, options) {
        return tracingClient.withSpan("ChatApiClient.listChatMessagesNext", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, nextLink, options }, listChatMessagesNextOperationSpec);
        });
    }
    /**
     * ListChatParticipantsNext
     * @param chatThreadId Thread id to get participants for.
     * @param nextLink The nextLink from the previous successful call to the ListChatParticipants method.
     * @param options The options parameters.
     */
    async listChatParticipantsNext(chatThreadId, nextLink, options) {
        return tracingClient.withSpan("ChatApiClient.listChatParticipantsNext", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, nextLink, options }, listChatParticipantsNextOperationSpec);
        });
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listChatReadReceiptsOperationSpec = {
    path: "/chat/threads/{chatThreadId}/readReceipts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatMessageReadReceiptsCollection,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    queryParameters: [
        maxPageSize,
        skip,
        apiVersion,
    ],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer: serializer$1,
};
const sendChatReadReceiptOperationSpec = {
    path: "/chat/threads/{chatThreadId}/readReceipts",
    httpMethod: "POST",
    responses: {
        200: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    requestBody: sendReadReceiptRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1,
};
const sendChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SendChatMessageResult,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    requestBody: sendChatMessageRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1,
};
const listChatMessagesOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatMessagesCollection,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    queryParameters: [
        maxPageSize,
        apiVersion,
        startTime,
    ],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer: serializer$1,
};
const getChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatMessage,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        chatThreadId,
        chatMessageId,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const updateChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
    httpMethod: "PATCH",
    responses: {
        204: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    requestBody: updateChatMessageRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        chatThreadId,
        chatMessageId,
    ],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer: serializer$1,
};
const deleteChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        chatThreadId,
        chatMessageId,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const listChatParticipantsOperationSpec = {
    path: "/chat/threads/{chatThreadId}/participants",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatParticipantsCollection,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    queryParameters: [
        maxPageSize,
        skip,
        apiVersion,
    ],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer: serializer$1,
};
const removeChatParticipantOperationSpec = {
    path: "/chat/threads/{chatThreadId}/participants/:remove",
    httpMethod: "POST",
    responses: {
        204: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    requestBody: participantCommunicationIdentifier,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1,
};
const addChatParticipantsOperationSpec = {
    path: "/chat/threads/{chatThreadId}/participants/:add",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: AddChatParticipantsResult,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    requestBody: addChatParticipantsRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1,
};
const updateChatThreadPropertiesOperationSpec = {
    path: "/chat/threads/{chatThreadId}",
    httpMethod: "PATCH",
    responses: {
        204: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    requestBody: updateChatThreadRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer: serializer$1,
};
const getChatThreadPropertiesOperationSpec = {
    path: "/chat/threads/{chatThreadId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatThreadProperties,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer: serializer$1,
};
const sendTypingNotificationOperationSpec = {
    path: "/chat/threads/{chatThreadId}/typing",
    httpMethod: "POST",
    responses: {
        200: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    requestBody: sendTypingNotificationRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1,
};
const uploadChatImageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/images",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: UploadChatImageResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: chatImageFile,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [
        contentType2,
        accept1,
        imageFilename,
    ],
    mediaType: "binary",
    serializer: serializer$1,
};
const getChatImageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/images/{imageId}/view/{imageViewType}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        chatThreadId,
        imageId,
        imageViewType,
    ],
    headerParameters: [accept2],
    serializer: serializer$1,
};
const deleteChatImageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/images/{imageId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        chatThreadId,
        imageId,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const listChatReadReceiptsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatMessageReadReceiptsCollection,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    urlParameters: [
        endpoint,
        chatThreadId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const listChatMessagesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatMessagesCollection,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    urlParameters: [
        endpoint,
        chatThreadId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const listChatParticipantsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatParticipantsCollection,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    urlParameters: [
        endpoint,
        chatThreadId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Chat operations. */
class ChatImpl {
    /**
     * Initialize a new instance of the class Chat class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a chat thread.
     * @param createChatThreadRequest Request payload for creating a chat thread.
     * @param options The options parameters.
     */
    async createChatThread(createChatThreadRequest, options) {
        return tracingClient.withSpan("ChatApiClient.createChatThread", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ createChatThreadRequest, options }, createChatThreadOperationSpec);
        });
    }
    /**
     * Gets the list of chat threads of a user.
     * @param options The options parameters.
     */
    async listChatThreads(options) {
        return tracingClient.withSpan("ChatApiClient.listChatThreads", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ options }, listChatThreadsOperationSpec);
        });
    }
    /**
     * Deletes a thread.
     * @param chatThreadId Id of the thread to be deleted.
     * @param options The options parameters.
     */
    async deleteChatThread(chatThreadId, options) {
        return tracingClient.withSpan("ChatApiClient.deleteChatThread", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ chatThreadId, options }, deleteChatThreadOperationSpec);
        });
    }
    /**
     * ListChatThreadsNext
     * @param nextLink The nextLink from the previous successful call to the ListChatThreads method.
     * @param options The options parameters.
     */
    async listChatThreadsNext(nextLink, options) {
        return tracingClient.withSpan("ChatApiClient.listChatThreadsNext", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ nextLink, options }, listChatThreadsNextOperationSpec);
        });
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createChatThreadOperationSpec = {
    path: "/chat/threads",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: CreateChatThreadResult,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    requestBody: createChatThreadRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [
        accept,
        contentType,
        repeatabilityRequestId,
    ],
    mediaType: "json",
    serializer,
};
const listChatThreadsOperationSpec = {
    path: "/chat/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatThreadsItemCollection,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    queryParameters: [
        maxPageSize,
        apiVersion,
        startTime,
    ],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer,
};
const deleteChatThreadOperationSpec = {
    path: "/chat/threads/{chatThreadId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer,
};
const listChatThreadsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatThreadsItemCollection,
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true,
        },
    },
    urlParameters: [endpoint, nextLink],
    headerParameters: [accept],
    serializer,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ChatApiClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ChatApiClient class.
     * @param endpoint The endpoint of the Azure Communication resource.
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
        };
        const packageDetails = `azsdk-js-communication-chat/1.6.0-beta.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix,
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2024-03-15-preview";
        this.chatThread = new ChatThreadImpl(this);
        this.chat = new ChatImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            },
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const logger = logger$1.createClientLogger("communication-chat");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Temporary workaround with local copy of XhrHttpClient
function isNodeReadableStream(body) {
    return body && typeof body.pipe === "function";
}
/**
 * Checks if the body is a Blob or Blob-like
 * @internal
 */
function isBlob(body) {
    // File objects count as a type of Blob, so we want to use instanceof explicitly
    return (typeof Blob === "function" || typeof Blob === "object") && body instanceof Blob;
}
/**
 * Checks if the body is a ReadableStream supported by browsers
 * @internal
 */
function isReadableStream(body) {
    return Boolean(body &&
        typeof body.getReader === "function" &&
        typeof body.tee === "function");
}
/**
 * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.
 * @internal
 */
class XhrHttpClient {
    /**
     * Makes a request over an underlying transport layer and returns the response.
     * @param request - The request to be made.
     */
    async sendRequest(request) {
        var _a;
        const url = new URL(request.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) {
            throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        }
        const xhr = new XMLHttpRequest();
        if (request.proxySettings) {
            throw new Error("HTTP proxy is not supported in browser environment");
        }
        const abortSignal = request.abortSignal;
        if (abortSignal) {
            if (abortSignal.aborted) {
                throw new abortController.AbortError("The operation was aborted.");
            }
            const listener = () => {
                xhr.abort();
            };
            abortSignal.addEventListener("abort", listener);
            xhr.addEventListener("readystatechange", () => {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    abortSignal.removeEventListener("abort", listener);
                }
            });
        }
        addProgressListener(xhr.upload, request.onUploadProgress);
        addProgressListener(xhr, request.onDownloadProgress);
        xhr.open(request.method, request.url);
        xhr.timeout = request.timeout;
        xhr.withCredentials = request.withCredentials;
        for (const [name, value] of request.headers) {
            xhr.setRequestHeader(name, value);
        }
        xhr.responseType = ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.size) ? "blob" : "text";
        const body = typeof request.body === "function" ? request.body() : request.body;
        if (isNodeReadableStream(body) || isReadableStream(body)) {
            throw new Error("Streams are not supported by xhrHttpClient.");
        }
        xhr.send(body === undefined ? null : body);
        if (xhr.responseType === "blob") {
            return new Promise((resolve, reject) => {
                handleBlobResponse(xhr, request, resolve, reject);
                rejectOnTerminalEvent(request, xhr, reject);
            });
        }
        else {
            return new Promise(function (resolve, reject) {
                xhr.addEventListener("load", () => resolve({
                    request,
                    status: xhr.status,
                    headers: parseHeaders(xhr),
                    bodyAsText: xhr.responseText,
                }));
                rejectOnTerminalEvent(request, xhr, reject);
            });
        }
    }
}
function handleBlobResponse(xhr, request, res, rej) {
    xhr.addEventListener("readystatechange", () => {
        var _a, _b;
        // Resolve as soon as headers are loaded
        if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
            if (
            // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
            ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) ||
                ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(xhr.status))) {
                const blobBody = new Promise((resolve, reject) => {
                    xhr.addEventListener("load", () => {
                        resolve(xhr.response);
                    });
                    rejectOnTerminalEvent(request, xhr, reject);
                });
                res({
                    request,
                    status: xhr.status,
                    headers: parseHeaders(xhr),
                    blobBody,
                });
            }
            else {
                xhr.addEventListener("load", () => {
                    // xhr.response is of Blob type if the request is sent with xhr.responseType === "blob"
                    // but the status code is not one of the stream response status codes,
                    // so treat it as text and convert from Blob to text
                    if (xhr.response) {
                        xhr.response
                            .text()
                            .then((text) => {
                            res({
                                request: request,
                                status: xhr.status,
                                headers: parseHeaders(xhr),
                                bodyAsText: text,
                            });
                            return;
                        })
                            .catch((e) => {
                            rej(e);
                        });
                    }
                    else {
                        res({
                            request,
                            status: xhr.status,
                            headers: parseHeaders(xhr),
                        });
                    }
                });
            }
        }
    });
}
function addProgressListener(xhr, listener) {
    if (listener) {
        xhr.addEventListener("progress", (rawEvent) => listener({
            loadedBytes: rawEvent.loaded,
        }));
    }
}
function parseHeaders(xhr) {
    const responseHeaders = coreRestPipeline.createHttpHeaders();
    const headerLines = xhr
        .getAllResponseHeaders()
        .trim()
        .split(/[\r\n]+/);
    for (const line of headerLines) {
        const index = line.indexOf(":");
        const headerName = line.slice(0, index);
        const headerValue = line.slice(index + 2);
        responseHeaders.set(headerName, headerValue);
    }
    return responseHeaders;
}
function rejectOnTerminalEvent(request, xhr, reject) {
    xhr.addEventListener("error", () => reject(new coreRestPipeline.RestError(`Failed to send request to ${request.url}`, {
        code: coreRestPipeline.RestError.REQUEST_SEND_ERROR,
        request,
    })));
    const abortError = new abortController.AbortError("The operation was aborted.");
    xhr.addEventListener("abort", () => reject(abortError));
    xhr.addEventListener("timeout", () => reject(abortError));
}
/**
 * Create a new HttpClient instance for the browser environment.
 * @internal
 */
function createXhrHttpClient() {
    return new XhrHttpClient();
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Creates a new CommunicationTokenCredentialPolicy factory.
 *
 * @param credential - The CommunicationTokenCredential implementation that can supply the user credential.
 */
const createCommunicationTokenCredentialPolicy = (credential) => {
    const policyOptions = {
        credential: {
            getToken: (_scopes, options) => credential.getToken({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }),
        },
        scopes: [],
    };
    return coreRestPipeline.bearerTokenAuthenticationPolicy(policyOptions);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const minimumTypingIntervalInMilliSeconds = 8000;
/**
 * The client to do chat operations
 */
class ChatThreadClient {
    constructor(endpoint, threadId, credential, options = {}) {
        this.endpoint = endpoint;
        this.timeOfLastTypingRequest = undefined;
        this.threadId = threadId;
        this.tokenCredential = credential;
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
            },
        });
        this.client = new ChatApiClient(this.endpoint, Object.assign({ endpoint: this.endpoint }, internalPipelineOptions));
        const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);
        this.client.pipeline.addPolicy(authPolicy);
        if (typeof XMLHttpRequest !== "undefined") {
            this.xhrClient = new ChatApiClient(this.endpoint, Object.assign(Object.assign({ endpoint: this.endpoint }, internalPipelineOptions), { httpClient: createXhrHttpClient() }));
            this.xhrClient.pipeline.addPolicy(authPolicy);
        }
    }
    /**
     * Gets a chat thread.
     * Returns the chat thread.
     * @param options -  Operation options.
     */
    getProperties(options = {}) {
        return tracingClient.withSpan("ChatClient-GetProperties", options, async (updatedOptions) => {
            const result = await this.client.chatThread.getChatThreadProperties(this.threadId, updatedOptions);
            return mapToChatThreadPropertiesSdkModel(result);
        });
    }
    /**
     * Updates a thread's topic.
     * @param topic - The topic needs to be updated to.
     * @param options - Operation options.
     */
    updateTopic(topic, options = {}) {
        return tracingClient.withSpan("ChatThreadClient-UpdateTopic", options, async (updatedOptions) => {
            await this.client.chatThread.updateChatThreadProperties(this.threadId, { topic: topic }, updatedOptions);
        });
    }
    /**
     * Updates a thread's properties.
     * @param options - Operation options.
     */
    updateProperties(options = {}) {
        return tracingClient.withSpan("ChatThreadClient-UpdateProperties", options, async (updatedOptions) => {
            await this.client.chatThread.updateChatThreadProperties(this.threadId, options, updatedOptions);
        });
    }
    /**
     * Sends a chat message to a thread identified by threadId.
     * Returns the id of the created message.
     * @param request - Request for sending a message.
     * @param options - Operation options.
     */
    sendMessage(request, options = {}) {
        return tracingClient.withSpan("ChatThreadClient-SendMessage", options, async (updatedOptions) => {
            // reset typing notification clock
            this.timeOfLastTypingRequest = undefined;
            const result = await this.client.chatThread.sendChatMessage(this.threadId, mapToSendChatMessageRequestRestModel(request, options), updatedOptions);
            return result;
        });
    }
    /**
     * Gets a chat message identified by messageId.
     * Returns the specific message.
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */
    getMessage(messageId, options = {}) {
        return tracingClient.withSpan("ChatThreadClient-GetMessage", options, async (updatedOptions) => {
            const result = await this.client.chatThread.getChatMessage(this.threadId, messageId, updatedOptions);
            return mapToChatMessageSdkModel(result);
        });
    }
    listMessagesPage(pageSettings_1) {
        return tslib.__asyncGenerator(this, arguments, function* listMessagesPage_1(pageSettings, options = {}) {
            if (!pageSettings.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatMessages(this.threadId, options));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));
                }
            }
            while (pageSettings.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatMessagesNext(this.threadId, pageSettings.continuationToken, options));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listMessagesAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listMessagesAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMessagesPage({}, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of message from a thread identified by threadId.
     * Returns the list of the messages.
     * @param options - Get messages options.
     */
    listMessages(options = {}) {
        const { span, updatedOptions } = tracingClient.startSpan("ChatThreadClient-ListMessages", options);
        try {
            const iter = this.listMessagesAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listMessagesPage(settings, updatedOptions);
                },
            };
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes a message identified by threadId and messageId
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */
    deleteMessage(messageId, options = {}) {
        return tracingClient.withSpan("ChatThreadClient-DeleteMessage", options, async (updatedOptions) => {
            await this.client.chatThread.deleteChatMessage(this.threadId, messageId, updatedOptions);
        });
    }
    /**
     * Updates a message identified by threadId and messageId
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */
    async updateMessage(messageId, options = {}) {
        return tracingClient.withSpan("ChatThreadClient-UpdateMessage", options, async (updatedOptions) => {
            await this.client.chatThread.updateChatMessage(this.threadId, messageId, mapToUpdateChatMessageRequestRestModel(options), updatedOptions);
        });
    }
    /**
     * Adds the details of chat participants belonging to the thread identified by threadId.
     * @param request - Thread participants' details to add in the thread roster
     * @param options - Operation options.
     */
    async addParticipants(request, options = {}) {
        return tracingClient.withSpan("ChatThreadClient-AddParticipants", options, async (updatedOptions) => {
            const result = await this.client.chatThread.addChatParticipants(this.threadId, mapToAddChatParticipantsRequestRestModel(request), updatedOptions);
            return result;
        });
    }
    listParticipantsPage(continuationState_1) {
        return tslib.__asyncGenerator(this, arguments, function* listParticipantsPage_1(continuationState, options = {}) {
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatParticipants(this.threadId, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatParticipantsNext(this.threadId, continuationState.continuationToken, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listParticipantsAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listParticipantsAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listParticipantsPage({}, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the participants of the thread identified by threadId.
     * Returns the lists of the participants.
     * @param options - Operation options.
     */
    listParticipants(options = {}) {
        const { span, updatedOptions } = tracingClient.startSpan("ChatThreadClient-ListParticipants", options);
        try {
            const iter = this.listParticipantsAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listParticipantsPage(settings, updatedOptions);
                },
            };
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes participant from the thread identified by threadId.
     * @param participant - Thread participant to remove from the thread roster
     * @param options - Operation options.
     */
    async removeParticipant(participant, options = {}) {
        return tracingClient.withSpan("ChatThreadClient-RemoveParticipant", options, async (updatedOptions) => {
            await this.client.chatThread.removeChatParticipant(this.threadId, communicationCommon.serializeCommunicationIdentifier(participant), updatedOptions);
        });
    }
    /**
     * Sends a typing notification to the thread.
     * Doesn't attempt to send if the time since last notification is smaller than the minimum typing interval
     * @param options - - Operation options
     * @returns True if the typing message notification could be sent, otherwise false.
     */
    async sendTypingNotification(options = {}) {
        return tracingClient.withSpan("ChatThreadClient-SendTypingNotification", options, async (updatedOptions) => {
            const dateNow = new Date();
            const { senderDisplayName } = updatedOptions, restOptions = tslib.__rest(updatedOptions, ["senderDisplayName"]);
            if (this.canPostTypingNotification(dateNow)) {
                this.timeOfLastTypingRequest = dateNow;
                await this.client.chatThread.sendTypingNotification(this.threadId, Object.assign({ sendTypingNotificationRequest: { senderDisplayName: senderDisplayName } }, restOptions));
                return true;
            }
            logger.info(`Typing Notification NOT Send. [thread_id=${this.threadId}]`);
            return false;
        });
    }
    /**
     * Sends a read receipt to the thread identified by threadId.
     * @param request - Request for sending a read receipt
     * @param options - Operation options.
     */
    async sendReadReceipt(request, options = {}) {
        return tracingClient.withSpan("ChatThreadClient-SendReadReceipt", options, async (updatedOptions) => {
            await this.client.chatThread.sendChatReadReceipt(this.threadId, request, updatedOptions);
        });
    }
    listReadReceiptsPage(continuationState_1) {
        return tslib.__asyncGenerator(this, arguments, function* listReadReceiptsPage_1(continuationState, options = {}) {
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatReadReceipts(this.threadId, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatReadReceiptsNext(this.threadId, continuationState.continuationToken, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listReadReceiptsAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listReadReceiptsAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listReadReceiptsPage({}, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets a list of read receipt from a thread identified by threadId.
     * Returns the list of the messages.
     * @param options - Get messages options.
     */
    listReadReceipts(options = {}) {
        const { span, updatedOptions } = tracingClient.startSpan("ChatThreadClient-ListChatReadReceipts", options);
        try {
            const iter = this.listReadReceiptsAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listReadReceiptsPage(settings, updatedOptions);
                },
            };
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    canPostTypingNotification(dateNow) {
        if (this.timeOfLastTypingRequest) {
            const timeSinceLastRequestInMilliSeconds = dateNow.getTime() - this.timeOfLastTypingRequest.getTime();
            if (timeSinceLastRequestInMilliSeconds < minimumTypingIntervalInMilliSeconds) {
                logger.info(`Typing interval check failed. [last_request=${this.timeOfLastTypingRequest}]`);
                return false;
            }
        }
        return true;
    }
    async uploadImage(image, imageFilename, imageBytesLengthOrOptions, options = {}) {
        let uploadImageOptions = {};
        if (imageBytesLengthOrOptions !== undefined) {
            if (typeof imageBytesLengthOrOptions === "number") {
                uploadImageOptions = Object.assign(Object.assign({}, options), { imageBytesLength: imageBytesLengthOrOptions });
            }
            else {
                uploadImageOptions = Object.assign(Object.assign({}, options), imageBytesLengthOrOptions);
            }
        }
        return tracingClient.withSpan("ChatThreadClient-UploadImage", uploadImageOptions, async (updatedOptions) => {
            let result;
            if (this.xhrClient && // is browser
                ((!this.supportsReadableStream() && isReadableStream(image)) || // is readable stream but no support, need to convert
                    !isReadableStream(image))) {
                // use xhrClient if (to support onUploadProgress)
                // - is readable stream but no support => convert to ArrayBuffer (so will have content-length)
                // - is not readable stream
                result = await this.xhrClient.chatThread.uploadChatImage(this.threadId, isReadableStream(image) ? await this.getArrayBufferFromReadableStream(image) : image, Object.assign({ imageFilename }, updatedOptions));
            }
            else {
                // backend (node fetch client) or readable readable stream
                // Backend (no browser) need to convert Blob/ReadableStream to ArrayBuffer
                let chatImageFile = image;
                if (isBlob(image)) {
                    chatImageFile = await this.getArrayBufferFromBlob(image);
                }
                else if (isReadableStream(image)) {
                    chatImageFile = await this.getArrayBufferFromReadableStream(image);
                }
                result = await this.client.chatThread.uploadChatImage(this.threadId, chatImageFile, Object.assign({ imageFilename }, updatedOptions));
            }
            return result;
        });
    }
    /**
     * Deletes an image identified by threadId and imageId
     * @param imageId - The image id of the image.
     * @param options - Operation options.
     */
    deleteImage(imageId, options = {}) {
        return tracingClient.withSpan("ChatThreadClient-DeleteImage", options, async (updatedOptions) => {
            await this.client.chatThread.deleteChatImage(this.threadId, imageId, updatedOptions);
        });
    }
    supportsReadableStream() {
        let duplexAccessed = false;
        const hasContentType = new Request("", {
            body: new ReadableStream(),
            method: "POST",
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            get duplex() {
                duplexAccessed = true;
                return "half";
            },
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
    }
    async getArrayBufferFromReadableStream(body) {
        const arrayBuffer = await new Response(body).arrayBuffer();
        return new Uint8Array(arrayBuffer);
    }
    async getArrayBufferFromBlob(body) {
        return new Uint8Array(await body.arrayBuffer());
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 * @internal
 */
function generateUuid() {
    return uuid.v4();
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const getSignalingClient = (credential, logger, options) => {
    var _a, _b, _c;
    if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
        // In React Native
        return new communicationSignaling.CommunicationSignalingClient(credential, logger, {
            environment: (_a = options === null || options === void 0 ? void 0 : options.environment) !== null && _a !== void 0 ? _a : undefined,
            resourceEndpoint: (_b = options === null || options === void 0 ? void 0 : options.resourceEndpoint) !== null && _b !== void 0 ? _b : undefined,
            gatewayApiVersion: (_c = options === null || options === void 0 ? void 0 : options.gatewayApiVersion) !== null && _c !== void 0 ? _c : undefined,
        });
    }
    // In node js
    return undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/// <reference lib="esnext.asynciterable" />
/**
 * The client to do chat operations
 */
class ChatClient {
    /**
     * Creates an instance of the ChatClient for a given resource and user.
     *
     * @param endpoint - The url of the Communication Services resource.
     * @param credential - The token credential. Use AzureCommunicationTokenCredential from \@azure/communication-common to create a credential.
     * @param options - Additional client options.
     */
    constructor(endpoint, credential, options = {}) {
        this.endpoint = endpoint;
        this.signalingClient = undefined;
        this.emitter = new events.EventEmitter();
        this.isRealtimeNotificationsStarted = false;
        this.tokenCredential = credential;
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
            },
        });
        this.client = new ChatApiClient(this.endpoint, Object.assign({ endpoint: this.endpoint }, internalPipelineOptions));
        const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);
        this.client.pipeline.addPolicy(authPolicy);
        this.clientOptions = Object.assign({}, options);
        this.clientOptions.signalingClientOptions = Object.assign(Object.assign({}, this.clientOptions.signalingClientOptions), { resourceEndpoint: this.endpoint, gatewayApiVersion: this.client.apiVersion });
        this.signalingClient = getSignalingClient(credential, logger, this.clientOptions.signalingClientOptions);
    }
    /**
     * Returns ChatThreadClient with the specific thread id.
     * @param threadId - Thread ID for the ChatThreadClient
     */
    getChatThreadClient(threadId) {
        return new ChatThreadClient(this.endpoint, threadId, this.tokenCredential, this.clientOptions);
    }
    /**
     * Creates a chat thread.
     * Returns thread client with the id of the created thread.
     * @param request - Request for creating a chat thread.
     * @param options - Operation options.
     */
    async createChatThread(request, options = {}) {
        return tracingClient.withSpan("ChatClient-CreateChatThread", options, async (updatedOptions) => {
            var _a, _b;
            // We generate an UUID if the user does not provide an idempotencyToken value
            updatedOptions.idempotencyToken = (_a = updatedOptions.idempotencyToken) !== null && _a !== void 0 ? _a : generateUuid();
            const updatedRestModelOptions = mapToCreateChatThreadOptionsRestModel(updatedOptions);
            const result = await this.client.chat.createChatThread({
                topic: request.topic,
                participants: (_b = options.participants) === null || _b === void 0 ? void 0 : _b.map((participant) => mapToChatParticipantRestModel(participant)),
                metadata: options.metadata,
                retentionPolicy: options.retentionPolicy,
            }, updatedRestModelOptions);
            return mapToCreateChatThreadResultSdkModel(result);
        });
    }
    listChatThreadsPage(continuationState_1) {
        return tslib.__asyncGenerator(this, arguments, function* listChatThreadsPage_1(continuationState, options = {}) {
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chat.listChatThreads(options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value);
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chat.listChatThreadsNext(continuationState.continuationToken, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value);
                }
                else {
                    break;
                }
            }
        });
    }
    listChatThreadsAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listChatThreadsAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listChatThreadsPage({}, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the list of chat threads of a user.
     * @param options - List chat threads options.
     */
    listChatThreads(options = {}) {
        const { span, updatedOptions } = tracingClient.startSpan("ChatClient-ListChatThreads", options);
        try {
            const iter = this.listChatThreadsAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listChatThreadsPage(settings, updatedOptions);
                },
            };
        }
        catch (e) {
            span.setStatus({
                error: e,
                status: "error",
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes a chat thread.
     * @param threadId - The ID of the thread to delete.
     * @param options -  Operation options.
     */
    async deleteChatThread(threadId, options = {}) {
        return tracingClient.withSpan("ChatClient-DeleteChatThread", options, async (updatedOptions) => {
            await this.client.chat.deleteChatThread(threadId, updatedOptions);
        });
    }
    /**
     * Start receiving realtime notifications.
     * Call this function before subscribing to any event.
     */
    async startRealtimeNotifications() {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are not supported in node js.");
        }
        if (this.isRealtimeNotificationsStarted) {
            return;
        }
        this.isRealtimeNotificationsStarted = true;
        await this.signalingClient.start();
        this.subscribeToSignalingEvents();
    }
    /**
     * Stop receiving realtime notifications.
     * This function would unsubscribe to all events.
     */
    async stopRealtimeNotifications() {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are not supported in node js.");
        }
        this.isRealtimeNotificationsStarted = false;
        await this.signalingClient.stop();
        this.emitter.removeAllListeners();
    }
    on(event, listener) {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are only supported in the browser.");
        }
        if (!this.isRealtimeNotificationsStarted &&
            event !== "realTimeNotificationConnected" &&
            event !== "realTimeNotificationDisconnected") {
            throw new Error("You must call startRealtimeNotifications before you can subscribe to events.");
        }
        this.emitter.on(event, listener);
    }
    off(event, listener) {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are only supported in the browser.");
        }
        this.emitter.removeListener(event, listener);
    }
    subscribeToSignalingEvents() {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are only supported in the browser.");
        }
        this.signalingClient.on("connectionChanged", (payload) => {
            if (payload === 2 /* ConnectionState.Connected */) {
                this.emitter.emit("realTimeNotificationConnected");
            }
            else if (payload === 3 /* ConnectionState.Disconnected */) {
                this.emitter.emit("realTimeNotificationDisconnected");
            }
        });
        this.signalingClient.on("chatMessageReceived", (payload) => {
            this.emitter.emit("chatMessageReceived", payload);
        });
        this.signalingClient.on("chatMessageEdited", (payload) => {
            this.emitter.emit("chatMessageEdited", payload);
        });
        this.signalingClient.on("chatMessageDeleted", (payload) => {
            this.emitter.emit("chatMessageDeleted", payload);
        });
        this.signalingClient.on("typingIndicatorReceived", (payload) => {
            this.emitter.emit("typingIndicatorReceived", payload);
        });
        this.signalingClient.on("readReceiptReceived", (payload) => {
            this.emitter.emit("readReceiptReceived", payload);
        });
        this.signalingClient.on("chatThreadCreated", (payload) => {
            this.emitter.emit("chatThreadCreated", payload);
        });
        this.signalingClient.on("chatThreadDeleted", (payload) => {
            this.emitter.emit("chatThreadDeleted", payload);
        });
        this.signalingClient.on("chatThreadPropertiesUpdated", (payload) => {
            this.emitter.emit("chatThreadPropertiesUpdated", payload);
        });
        this.signalingClient.on("participantsAdded", (payload) => {
            this.emitter.emit("participantsAdded", payload);
        });
        this.signalingClient.on("participantsRemoved", (payload) => {
            this.emitter.emit("participantsRemoved", payload);
        });
    }
}

exports.ChatClient = ChatClient;
exports.ChatThreadClient = ChatThreadClient;
//# sourceMappingURL=index.js.map
